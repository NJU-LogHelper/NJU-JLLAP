93: Andrew Wang, info, MethodDeclaration, LOG.info("Testing read-after-write with FS implementation: {}", fs);
102: Jason Lowe, debug, CatchClause, LOG.debug("Cannot parse cookie header: " + header, iae);
153: Jason Lowe, trace, MethodDeclaration, LOG.trace("Setting token value to {} ({})", authCookie, oldCookie);
396: Xiao Chen, trace, IfStmt, LOG.trace("Setting token value to null ({}), resp={}", token, respCode);
392: Xiao Chen, trace, IfStmt, LOG.trace("Setting token value to null ({}), resp={}", token, respCode);
193: Arpit Agarwal, debug, IfStmt, LOG.debug("JDK performed authentication on our behalf.");
206: Arpit Agarwal, debug, IfStmt, LOG.debug("Using fallback authenticator sequence.");
203: Arpit Agarwal, debug, IfStmt, LOG.debug("Performing our own SPNEGO sequence.");
235: Arpit Agarwal, debug, CatchClause, LOG.debug("Unable to wrap exception of type {}, it has " + "no (String) constructor.", exceptionClass, e);
300: Eli Collins, debug, IfStmt, LOG.debug("No subject in context, logging in");
308: Eli Collins, debug, IfStmt, LOG.debug("Using subject: " + subject);
240: Haohui Mai, info, IfStmt, LOG.info("Unable to initialize FileSignerSecretProvider, " + "falling back to use random secrets.");
608: Jason Lowe, warn, IfStmt, LOG.warn("Authentication exception: " + ex.getMessage());
606: Jason Lowe, debug, IfStmt, LOG.debug("Authentication exception: " + ex.getMessage(), ex);
525: Alejandro Abdelnur, warn, CatchClause, LOG.warn("AuthenticationToken ignored: " + ex.getMessage());
520: Xiao Chen, debug, IfStmt, LOG.debug("Got token {} from httpRequest {}", token, getRequestURL(httpRequest));
596: Xiao Chen, debug, IfStmt, LOG.debug("managementOperation returned false for request {}." + " token: {}", getRequestURL(httpRequest), token);
533: Xiao Chen, debug, IfStmt, LOG.debug("Request [{}] triggering authentication. handler: {}", getRequestURL(httpRequest), authHandler.getClass());
552: Benoy Antony, debug, IfStmt, LOG.debug("Request [{}] user [{}] authenticated", getRequestURL(httpRequest), token.getUserName());
176: Owen O'Malley, warn, CatchClause, LOG.warn("Unable to parse the JWT token", pe);
172: Owen O'Malley, warn, IfStmt, LOG.warn("jwtToken failed validation: " + jwtToken.serialize());
170: Owen O'Malley, info, IfStmt, LOG.info("USERNAME: " + userName);
183: Owen O'Malley, info, IfStmt, LOG.info("token validation failed - sending redirect to: " + loginURL);
179: Owen O'Malley, debug, IfStmt, LOG.debug("Issuing AuthenticationToken for user.");
159: Owen O'Malley, info, IfStmt, LOG.info("sending redirect to: " + loginURL);
203: Owen O'Malley, info, IfStmt, LOG.info(cookieName + " cookie has been found and is being processed");
249: Owen O'Malley, warn, IfStmt, LOG.warn("Signature could not be verified");
253: Owen O'Malley, warn, IfStmt, LOG.warn("Audience validation failed.");
257: Owen O'Malley, info, IfStmt, LOG.info("Expiration validation failed.");
275: Owen O'Malley, debug, IfStmt, LOG.debug("JWT token is in a SIGNED state");
277: Owen O'Malley, debug, IfStmt, LOG.debug("JWT token signature is not null");
287: Owen O'Malley, Error, CatchClause, LOG.warn("Error while validating signature", je);
284: Owen O'Malley, warn, IfStmt, LOG.warn("JWT signature verification failed.");
282: Owen O'Malley, debug, IfStmt, LOG.debug("JWT token has been successfully verified");
328: Owen O'Malley, warn, CatchClause, LOG.warn("Unable to parse the JWT token.", pe);
318: Owen O'Malley, debug, IfStmt, LOG.debug("JWT token audience has been successfully validated");
324: Owen O'Malley, warn, IfStmt, LOG.warn("JWT audience validation failed.");
353: Owen O'Malley, warn, CatchClause, LOG.warn("JWT expiration date validation failed.", pe);
350: Owen O'Malley, warn, IfStmt, LOG.warn("JWT expiration date validation failed.");
346: Owen O'Malley, debug, IfStmt, LOG.debug("JWT token expiration date has been " + "successfully validated");
158: Daryn Sharp, info, ForeachStmt, LOG.info("Using keytab {}, for principal {}", keytab, krbPrincipal);
274: Xiaoyu Yao, warn, IfStmt, LOG.warn("'" + KerberosAuthenticator.AUTHORIZATION + "' does not start with '" + KerberosAuthenticator.NEGOTIATE + "' :  {}", authorization);
272: Xiaoyu Yao, trace, IfStmt, LOG.trace("SPNEGO starting for url: {}", request.getRequestURL());
319: Xiaoyu Yao, trace, TryStmt, LOG.trace("SPNEGO initiated with server principal [{}]", serverPrincipal);
346: Xiaoyu Yao, trace, IfStmt, LOG.trace("SPNEGO completed for client principal [{}]", clientPrincipal);
339: Xiaoyu Yao, trace, IfStmt, LOG.trace("SPNEGO in progress");
187: Benoy Antony, warn, IfStmt, logger.warn("'" + HttpConstants.AUTHORIZATION_HEADER + "' does not start with '" + HttpConstants.BASIC + "' :  {}", authorization);
185: Benoy Antony, trace, IfStmt, logger.trace("Basic auth starting");
276: Benoy Antony, debug, TryStmt, logger.debug("Authentication successful for {}", userDN);
304: Benoy Antony, debug, TryStmt, logger.debug("Authentication successful for {}", userDN);
113: Benoy Antony, info, ForeachStmt, logger.info("{} : {}", prop.getKey(), prop.getValue());
142: Benoy Antony, info, MethodDeclaration, logger.info("Successfully initialized MultiSchemeAuthenticationHandler");
162: Benoy Antony, error, CatchClause, logger.error("Failed to initialize authentication handler " + authHandlerClassName, ex);
149: Benoy Antony, debug, TryStmt, logger.debug("Initializing Authentication handler of type " + authHandlerClassName);
157: Benoy Antony, info, TryStmt, logger.info("Successfully initialized Authentication handler of type " + authHandlerClassName);
195: Benoy Antony, trace, IfStmt, logger.trace("Token generated with type {}", token.getType());
91: Zhe Zhang, debug, CatchClause, LOG.debug("resetting default realm failed, " + "current default realm will still be used.", ke);
127: Allen Wittenauer, debug, CatchClause, LOG.debug("Kerberos krb5 configuration not found, setting default realm to empty");
327: Steve Loughran, info, IfStmt, LOG.info("Non-simple name {} after auth_to_local rule {}", result, this);
401: Steve Loughran, info, MethodDeclaration, LOG.info("No auth_to_local rules applied to {}", this);
122: Alejandro Abdelnur, debug, IfStmt, LOG.debug("rolling secret");
199: Alejandro Abdelnur, info, CatchClause, LOG.info("The secret znode already exists, retrieving data");
197: Alejandro Abdelnur, info, TryStmt, LOG.info("Creating secret znode");
260: Alejandro Abdelnur, debug, CatchClause, LOG.debug("Unable to push to znode; another server already did it");
262: Andrew Wang, error, CatchClause, LOG.error("An unexpected exception occurred pushing data to ZooKeeper", ex);
341: Alejandro Abdelnur, error, CatchClause, LOG.error("An unexpected exception occurred while pulling data from" + "ZooKeeper", ex);
377: Alejandro Abdelnur, info, IfStmt, LOG.info("Connecting to ZooKeeper without authentication");
368: Alejandro Abdelnur, info, IfStmt, LOG.info("Connecting to ZooKeeper with SASL/Kerberos" + "and using 'sasl' ACLs");
61: Aaron Myers, debug, TryStmt, LOG.debug(xResponse.getResponseInfo().toString());
57: Aaron Myers, debug, TryStmt, LOG.debug(xRequest.getResquestInfo().toString());
727: Jonathan Eagles, Warn, IfStmt, logDeprecation(keyInfo.getWarningMessage(name));
752: Mahadev Konar, debug, MethodDeclaration, LOG.debug("Handling deprecation for all properties in config...");
757: Mahadev Konar, debug, ForeachStmt, LOG.debug("Handling deprecation for " + (String) item);
773: Owen O'Malley, warn, IfStmt, LOG.warn("DEPRECATED: hadoop-site.xml found in the classpath. " + "Usage of hadoop-site.xml is deprecated. Instead use core-site.xml, " + "mapred-site.xml and hdfs-site.xml to override properties of " + "core-default.xml, mapred-default.xml and hdfs-default.xml " + "respectively");
856: John Zhuge, debug, IfStmt, LOG.debug("Reloading " + REGISTRY.keySet().size() + " existing configurations");
1147: Arun Suresh, warn, CatchClause, LOG.warn("Unexpected SecurityException in Configuration", se);
1394: Chris Douglas, info, MethodDeclaration, LOG_DEPRECATION.info(message);
1400: John Zhuge, Info, IfStmt, LOG_DEPRECATION.info(keyInfo.getWarningMessage(name, source));
1936: Thomas White, warn, CatchClause, LOG.warn("Regular expression '" + valString + "' for property '" + name + "' not valid. Using default", pse);
2696: Owen O'Malley, warn, MethodDeclaration, LOG.warn("Could not make " + path + " in local directories from " + dirsProp);
2700: Owen O'Malley, warn, ForStmt, LOG.warn(dirsProp + "[" + index + "]=" + dirs[index]);
2755: Owen O'Malley, info, IfStmt, LOG.info("found resource " + name + " at " + url);
2752: Owen O'Malley, info, IfStmt, LOG.info(name + " not found");
2779: Owen O'Malley, info, IfStmt, LOG.info("found resource " + name + " at " + url);
2776: Owen O'Malley, info, IfStmt, LOG.info(name + " not found");
2887: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("parsing URL " + url);
2906: Jason Darrell Lowe, debug, IfStmt, LOG.debug("parsing input stream " + is);
3174: Akira Ajisaka, error, CatchClause, LOG.error("error parsing conf " + name, e);
3177: Akira Ajisaka, error, CatchClause, LOG.error("error parsing conf " + name, e);
2960: Jason Darrell Lowe, debug, IfStmt, LOG.debug("parsing File " + file);
3202: Anu Engineer, Error, CatchClause, LOG.trace("Error adding tags in configuration", ex);
3233: Anu Engineer, trace, CatchClause, LOG.trace("Tag '{}' for property:{} Source:{}", tagStr, confName, Arrays.toString(confSource.toArray()), ex);
3276: Andrew Wang, warn, IfStmt, LOG.warn(name + ":an attempt to override final parameter: " + attr + ";  Ignoring.");
49: Xiao Chen, info, MethodDeclaration, log.info("Got {} = '{}'", name, redactor.redact(name, value));
59: Xiao Chen, info, MethodDeclaration, log.info("Got {} = '{}' (default '{}')", name, redactor.redact(name, value), redactor.redact(name, defaultValue));
70: Xiao Chen, info, MethodDeclaration, log.info("Got {} = '{}' (default '{}')", name, value, defaultValue);
80: Xiao Chen, info, MethodDeclaration, log.info("Got {} = '{}' (default '{}')", name, value, defaultValue);
90: Xiao Chen, info, MethodDeclaration, log.info("Got {} = '{}' (default '{}')", name, value, defaultValue);
100: Xiao Chen, info, MethodDeclaration, log.info("Got {} = '{}' (default '{}')", name, value, defaultValue);
109: Xiao Chen, info, MethodDeclaration, log.info("Set {} to '{}'{}", name, redactor.redact(name, value), source == null ? "" : " from " + source);
115: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Starting reconfiguration task.");
128: Colin Patrick Mccabe, info, IfStmt, LOG.info(String.format("Property %s is not configurable: old value: %s, new value: %s", change.prop, oldValRedacted, newValRedacted));
135: Colin Patrick Mccabe, info, ForeachStmt, LOG.info("Change property: " + change.prop + " from \"" + ((change.oldVal == null) ? "<default>" : oldValRedacted) + "\" to \"" + ((change.newVal == null) ? "<default>" : newValRedacted) + "\".");
169: Colin Patrick Mccabe, error, IfStmt, LOG.warn(errorMessage);
174: Colin Patrick Mccabe, error, IfStmt, LOG.warn(errorMessage);
223: Dhruba Borthakur, info, IfStmt, LOG.info("changing property " + property + " to " + newVal);
64: Dhruba Borthakur, info, MethodDeclaration, LOG.info("servlet path: " + req.getServletPath());
65: Dhruba Borthakur, info, MethodDeclaration, LOG.info("getting attribute: " + CONF_SERVLET_RECONFIGURABLE_PREFIX + req.getServletPath());
184: Dhruba Borthakur, info, IfStmt, LOG.info("property " + param + " unchanged");
202: Dhruba Borthakur, info, MethodDeclaration, LOG.info("GET");
217: Dhruba Borthakur, info, MethodDeclaration, LOG.info("POST");
82: Andrew Wang, debug, CatchClause, PerformanceAdvisory.LOG.debug("Crypto codec {} is not available.", klass.getName());
77: Andrew Wang, debug, IfStmt, PerformanceAdvisory.LOG.debug("Crypto codec {} doesn't meet the cipher suite {}.", klass.getName(), cipherSuite.getName());
72: Andrew Wang, debug, IfStmt, PerformanceAdvisory.LOG.debug("Using crypto codec {}.", klass.getName());
119: Andrew Wang, debug, IfStmt, PerformanceAdvisory.LOG.debug("No crypto codec classes with cipher suite configured.");
129: Andrew Wang, debug, CatchClause, PerformanceAdvisory.LOG.debug("Class {} is not a CryptoCodec.", c);
131: Andrew Wang, debug, CatchClause, PerformanceAdvisory.LOG.debug("Crypto codec {} not found.", c);
72: Yi Liu, warn, CatchClause, LOG.warn(e.getMessage());
68: Colin McCabe, info, CatchClause, LOG.info("Unable to use " + klass.getName() + ".  Falling back to " + "Java SecureRandom.", e);
65: Uma Maheswara Rao G, debug, IfStmt, LOG.debug("Using " + klass.getName() + " as random number generator.");
93: Colin McCabe, debug, CatchClause, LOG.debug("Failed to load OpenSSL Cipher.", t);
86: Colin Patrick Mccabe, debug, IfStmt, PerformanceAdvisory.LOG.debug("Build does not support openssl");
206: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug(String.format("KeyStore loaded successfully from '%s' since '%s'" + "was corrupted !!", backupPath, path));
195: Alejandro Abdelnur, debug, TryStmt, LOG.debug("KeyStore loaded successfully !!");
245: Alejandro Abdelnur, debug, IfStmt, LOG.debug("KeyStore initialized anew successfully !!");
259: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug(String.format("KeyStore loaded successfully from '%s'!!", pathToLoad));
586: Andrew Wang, debug, MethodDeclaration, LOG.debug("Could not flush Keystore.." + "attempting to reset to previous state !!");
595: Andrew Wang, debug, CatchClause, LOG.debug("Could not reset Keystore to previous state", e);
593: Andrew Wang, debug, TryStmt, LOG.debug("KeyStore resetting to previously flushed state !!");
345: Xiaoyu Yao, info, ConstructorDeclaration, LOG.info("KMSClientProvider for KMS url: {} delegation token service: {}" + " created.", kmsUrl, dtService);
424: Andrew Wang, warn, IfStmt, LOG.warn("Failed to connect to {}:{}", url.getHost(), url.getPort());
476: Xiao Chen, debug, IfStmt, LOG.debug("Response={}({}), resetting authToken", conn.getResponseCode(), conn.getResponseMessage());
875: Andrew Wang, debug, TryStmt, LOG.debug("Renewing delegation token {} with url:{}, as:{}", token, url, doAsUser);
907: Andrew Wang, debug, MethodDeclaration, LOG.debug("Cancelling delegation token {} with url:{}, as:{}", dToken, url, doAsUser);
999: Xiao Chen, info, IfStmt, LOG.info("New token created: ({})", token);
1033: Xiao Chen, debug, IfStmt, LOG.debug("Not creating legacy token because copyLegacyToken={}, " + "token={}", copyLegacyToken, token);
1046: Xiao Chen, info, MethodDeclaration, LOG.info("Copied token to legacy kind: {}", legacyToken);
1068: Xiao Chen, debug, MethodDeclaration, LOG.debug("Searching service {} found token {}", dtService, token);
1081: Xiao Chen, debug, MethodDeclaration, LOG.debug("Selected delegation token {} using service:{}", token, fallBackServiceText);
56: Xiao Chen, debug, MethodDeclaration, LOG.debug("Renewing delegation token {}", token);
76: Xiao Chen, debug, MethodDeclaration, LOG.debug("Canceling delegation token {}", token);
131: Xiao Chen, warn, CatchClause, LOG.warn("KMS provider at [{}] threw an IOException: ", provider.getKMSUrl(), ioe);
148: Xiao Chen, warn, IfStmt, LOG.warn("Aborting since the Request has failed with all KMS" + " providers(depending on {}={} setting and numProviders={})" + " in the group OR the exception is not recoverable", CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, getConf().getInt(CommonConfigurationKeysPublic.KMS_CLIENT_FAILOVER_MAX_RETRIES_KEY, providers.length), providers.length);
232: Andrew Wang, Error, CatchClause, LOG.error("Error warming up keys for provider with url" + "[" + provider.getKMSUrl() + "]", ioe);
480: Andrew Wang, Error, CatchClause, LOG.error("Error closing provider with url" + "[" + provider.getKMSUrl() + "]");
493: Andrew Wang, Error, CatchClause, LOG.error("Error flushing provider with url" + "[" + provider.getKMSUrl() + "]");
60: Colin McCabe, error, CatchClause, LOG.error("Failed to load Openssl SecureRandom", t);
71: Colin Patrick Mccabe, debug, IfStmt, PerformanceAdvisory.LOG.debug("Build does not support openssl, " + "falling back to Java SecureRandom.");
183: Arpit Agarwal, warn, CatchClause, LOG.warn("Thread Interrupted waiting to refresh disk information: " + e.getMessage());
165: Kihwal Lee, warn, IfStmt, LOG.warn("Problem opening checksum file: " + file + ".  Ignoring exception: ", e);
149: Suresh Srinivas, warn, CatchClause, LOG.warn("Problem opening checksum file: " + file + ".  Ignoring exception: ", e);
207: Kihwal Lee, warn, CatchClause, LOG.warn("Failed to reset renewer");
226: Kihwal Lee, error, IfStmt, fs.LOG.error("does not have a token for renewal");
243: Kihwal Lee, error, CatchClause, LOG.error("Interrupted while canceling token for " + fs.getUri() + "filesystem");
246: Akira Ajisaka, debug, IfStmt, LOG.debug("Exception in removeRenewAction: ", ie);
265: Thomas White, warn, CatchClause, action.weakFs.get().LOG.warn("Failed to renew token, action=" + action, ie);
55: Arpit Agarwal, warn, CatchClause, LOG.warn("Could not get disk usage information for path {}", getDirPath(), ioe);
236: Jitendra Nath Pandey, error, CatchClause, LOG.error("Exception in getCurrentUser: ", e);
291: Tsz-wo Sze, warn, CatchClause, LOG.warn("Ignoring failure to deleteOnExit for path " + path);
344: Akira Ajisaka, error, CatchClause, LOG.error(ex.toString());
458: Akira Ajisaka, error, CatchClause, LOG.error(ex.toString());
417: Mingliang Liu, warn, IfStmt, LOGGER.warn("\"" + name + "\" is a deprecated filesystem name." + " Use \"hdfs://" + name + "/\" instead.");
413: Mingliang Liu, warn, IfStmt, LOGGER.warn("\"local\" is a deprecated filesystem name." + " Use \"file:///\" instead.");
473: Mingliang Liu, debug, IfStmt, LOGGER.debug("Bypassing cache to create filesystem {}", uri);
1715: Mingliang Liu, info, CatchClause, LOGGER.info("Ignoring failure to deleteOnExit for path {}", path);
3241: Mingliang Liu, warn, CatchClause, LOGGER.warn("Cannot get all trash roots", e);
3260: Mingliang Liu, debug, MethodDeclaration, LOGGER.debug("Loading filesystems");
3282: Chris Nauroth, warn, CatchClause, LOG.warn("Cannot load filesystem: " + ee);
3286: Chris Nauroth, warn, WhileStmt, LOG.warn(cause.toString());
3290: Chris Nauroth, debug, CatchClause, LOG.debug("Stack Trace", ee);
3277: Mingliang Liu, warn, CatchClause, LOGGER.warn("Cannot load: {} from {}", fs, ClassUtil.findContainingJar(fs.getClass()));
3279: Mingliang Liu, info, CatchClause, LOGGER.info("Full exception loading: {}", fs, e);
3272: Mingliang Liu, debug, IfStmt, LOGGER.debug("{}:// = {} from {}", fs.getScheme(), fs.getClass(), ClassUtil.findContainingJar(fs.getClass()));
3315: Mingliang Liu, debug, MethodDeclaration, LOGGER.debug("Looking for FS supporting {}", scheme);
3323: Mingliang Liu, debug, IfStmt, LOGGER.debug("No configuration: skipping check for fs.{}.impl", scheme);
3319: Mingliang Liu, debug, IfStmt, LOGGER.debug("looking for configuration option {}", property);
3329: Mingliang Liu, debug, IfStmt, LOGGER.debug("Filesystem {} defined in configuration option", scheme);
3326: Mingliang Liu, debug, IfStmt, LOGGER.debug("Looking in service filesystems for implementation class");
3335: Mingliang Liu, debug, MethodDeclaration, LOGGER.debug("FS for {} is {}", scheme, clazz);
3489: Mingliang Liu, info, CatchClause, LOGGER.info("FileSystem.Cache.closeAll() threw an exception:\n" + e);
3809: Mingliang Liu, warn, CatchClause, LOGGER.warn("Cleaner thread interrupted, will stop", ie);
3812: Mingliang Liu, warn, CatchClause, LOGGER.warn("Exception in the cleaner thread but it will" + " continue to run", th);
220: Robert Joseph Evans, warn, IfStmt, LOG.warn("null file argument.");
229: Robert Joseph Evans, warn, IfStmt, LOG.warn("Failed to delete file or dir [" + f.getAbsolutePath() + "]: it still exists.");
640: Jason Lowe, warn, IfStmt, LOG.warn("Could not set last modfied time for {} file(s)", numOfFailedLastModifiedSet);
733: Jason Lowe, debug, CatchClause, LOG.debug(e.getMessage());
724: Jason Lowe, debug, WhileStmt, LOG.debug(line);
756: Jason Lowe, debug, CatchClause, LOG.debug(e.getMessage());
747: Jason Lowe, debug, WhileStmt, LOG.debug(line);
1053: Suresh Srinivas, warn, IfStmt, LOG.warn("Command '" + StringUtils.join(" ", cmd) + "' failed " + returnVal + " with: " + ec.getMessage());
1048: Suresh Srinivas, warn, IfStmt, LOG.warn("Fail to create symbolic links on Windows. " + "The default security settings in Windows disallow non-elevated " + "administrators and all non-administrators from creating symbolic links. " + "This behavior can be changed in the Local Security Policy management console");
1059: Suresh Srinivas, Error, IfStmt, LOG.debug("Error while create symlink " + linkname + " to " + target + "." + " Exception: " + StringUtils.stringifyException(e));
1100: Allen Wittenauer, Error, IfStmt, LOG.debug("Error while changing permission : " + filename + " Exception: " + StringUtils.stringifyException(e));
1606: Robert Kanter, debug, IfStmt, LOG.debug("Could not compare file-systems. Unknown host: ", ue);
309: Owen O'Malley, info, CatchClause, LOG.info("Found checksum error: b[" + off + ", " + (off + read) + "]=" + StringUtils.byteToHexString(b, off, off + read), ce);
345: Todd Lipcon, Error, CatchClause, LOG.debug("Error", e);
105: Tsz-wo Sze, Error, CatchClause, LOG.debug("Error changing permissions of " + item, e);
185: Tsz-wo Sze, Error, CatchClause, LOG.debug("Error changing ownership of " + item, e);
58: Haohui Mai, debug, TryStmt, LOG.debug("Connecting to {}", url);
89: Haohui Mai, debug, MethodDeclaration, LOG.debug("Creating handler for protocol {}", protocol);
95: Haohui Mai, debug, TryStmt, LOG.debug("Found implementation of {}: {}", protocol, impl);
107: Haohui Mai, debug, IfStmt, LOG.debug("Unknown protocol {}, delegating to default implementation", protocol);
103: Haohui Mai, debug, IfStmt, LOG.debug("Using handler for protocol {}", protocol);
146: Colin Patrick Mccabe, Error, CatchClause, LOG.warn("Error trying to create an instance of " + getKlass(), e);
148: Colin Patrick Mccabe, Error, CatchClause, LOG.warn("Error trying to create " + getKlass(), e);
150: Colin Patrick Mccabe, Error, CatchClause, LOG.warn("Error trying to create " + getKlass(), e);
152: Colin Patrick Mccabe, warn, CatchClause, LOG.warn("Doesn't look like the class " + getKlass() + " have the needed constructor", e);
1188: Suresh Srinivas, warn, CatchClause, LOG.warn("Encountered exception ", ioe);
325: Junping Du, warn, CatchClause, LOG.warn("Failed to create " + dirStrings[i] + ": " + ie.getMessage() + "\n", ie);
322: Junping Du, warn, IfStmt, LOG.warn("Failed to create " + dirStrings[i]);
319: Junping Du, warn, CatchClause, LOG.warn(dirStrings[i] + " is not writable\n", de);
354: Arun Murthy, warn, CatchClause, LOG.warn("Disk Error Exception: ", d);
142: Steve Loughran, Error, CatchClause, LOG.warn("Error moving bad file " + p, e);
127: Owen O'Malley, warn, TryStmt, LOG.warn("Moving bad file " + f + " to " + badFile);
131: Owen O'Malley, warn, IfStmt, LOG.warn("Ignoring failure of renameTo");
139: Owen O'Malley, warn, IfStmt, LOG.warn("Ignoring failure of renameTo");
370: cnauroth, debug, IfStmt, LOG.debug("Falling through to a copy of " + src + " to " + dst);
391: Akira Ajisaka, debug, IfStmt, LOG.debug("Deleting empty destination and renaming " + src + " to " + dst);
513: Colin Patrick Mccabe, debug, IfStmt, LOG.debug(String.format("NativeIO.createDirectoryWithMode error, path = %s, mode = %o", p2f, permission.toShort()), e);
712: Chris Douglas, debug, CatchClause, LOG.debug("Native call failed", ex);
50: Xiao Chen, debug, IfStmt, LOG.debug(in.getClass().getName() + ":" + " does not implement StreamCapabilities" + " and the unbuffer capability");
152: Arpit Agarwal, warn, CatchClause, LOG.warn("Can't create trash directory: " + baseTrashPath, e);
148: Arpit Agarwal, warn, IfStmt, LOG.warn("Can't create(mkdir) trash directory: " + baseTrashPath);
168: Eric Yang, info, TryStmt, LOG.info("Moved: '" + path + "' to trash at: " + trashPath);
188: Xiaoyu Yao, info, ForeachStmt, LOG.info("TrashPolicyDefault#createCheckpoint for trashRoot: " + trashRoot.getPath());
198: Xiaoyu Yao, info, ForeachStmt, LOG.info("TrashPolicyDefault#deleteCheckpoint for trashRoot: " + trashRoot.getPath());
228: Eli Collins, info, IfStmt, LOG.info("The configured checkpoint interval is " + (emptierInterval / MSECS_PER_MINUTE) + " minutes." + " Using an interval of " + (deletionInterval / MSECS_PER_MINUTE) + " minutes that is used for deletion instead");
235: Vinayakumar B, info, ConstructorDeclaration, LOG.info("Namenode trash configuration: Deletion interval = " + (deletionInterval / MSECS_PER_MINUTE) + " minutes, Emptier interval = " + (emptierInterval / MSECS_PER_MINUTE) + " minutes.");
275: Suresh Srinivas, warn, CatchClause, LOG.warn("RuntimeException during Trash.Emptier.run(): ", e);
269: Xiaoyu Yao, warn, CatchClause, LOG.warn("Trash caught: " + e + ". Skipping " + trashRoot.getPath() + ".");
281: Suresh Srinivas, warn, CatchClause, LOG.warn("Trash cannot close FileSystem: ", e);
313: Xiaoyu Yao, info, TryStmt, LOG.info("Created trash checkpoint: " + checkpoint.toUri().getPath());
325: Xiaoyu Yao, info, MethodDeclaration, LOG.info("TrashPolicyDefault#deleteCheckpoint for trashRoot: " + trashRoot);
347: Xiaoyu Yao, warn, CatchClause, LOG.warn("Unexpected item in trash: " + dir + ". Ignoring.");
355: Xiaoyu Yao, warn, IfStmt, LOG.warn("Couldn't delete checkpoint: " + dir + " Ignoring.");
353: Xiaoyu Yao, info, IfStmt, LOG.info("Deleted trash checkpoint: " + dir);
187: Wei-Chiu Chuang, warn, IfStmt, LOG.warn("Cannot parse the value for " + FS_FTP_TRANSFER_MODE + ": " + mode + ". Using default.");
219: Wei-Chiu Chuang, warn, IfStmt, LOG.warn("Cannot parse the value for " + FS_FTP_DATA_CONNECTION_MODE + ": " + mode + ". Using default.");
239: Owen O'Malley, warn, IfStmt, LOG.warn("Logout failed while disconnecting, error code - " + client.getReplyCode());
322: Suresh Srinivas, error, CatchClause, LOG.warn(error);
91: Chris Douglas, info, MethodDeclaration, LOG.info("Inside shutdown, con2infoMap size=" + con2infoMap.size());
104: Chris Douglas, Error, CatchClause, LOG.error("Error encountered while closing connection to " + info.getHost(), ioe);
468: Tsz-wo Sze, error, IfStmt, LOG.debug(errorMessage);
300: Chris Douglas, debug, IfStmt, LOG.debug("Exceptions occurred: " + ioe);
420: Chris Douglas, info, CatchClause, LOG.info("Failed to set timestamp: " + nodes[i] + " " + nflyPath);
687: Chris Douglas, info, CatchClause, LOG.info(f + ": Failed to open at " + rNode.getFs().getUri());
300: Todd Lipcon, info, IfStmt, LOG.info("Already in election. Not re-connecting.");
308: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Attempting active election for " + this);
345: Todd Lipcon, debug, ForStmt, LOG.debug("Ensuring existence of " + prefixPath);
363: Todd Lipcon, info, MethodDeclaration, LOG.info("Successfully created " + znodeWorkingDir + " in ZK.");
378: Todd Lipcon, info, TryStmt, LOG.info("Recursively deleting " + znodeWorkingDir + " from ZK...");
391: Todd Lipcon, info, MethodDeclaration, LOG.info("Successfully deleted " + znodeWorkingDir + " from ZK.");
409: Todd Lipcon, info, MethodDeclaration, LOG.info("Yielding from election");
465: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("CreateNode result: " + rc + " for path: " + path + " connectionState: " + zkConnectionState + "  for " + this);
497: Suresh Srinivas, error, MethodDeclaration, LOG.debug(errorMessage);
510: Todd Lipcon, warn, IfStmt, LOG.warn("Lock acquisition failed because session was lost");
501: Suresh Srinivas, debug, IfStmt, LOG.debug("Retrying createNode createRetryCount: " + createRetryCount);
530: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("StatNode result: " + rc + " for path: " + path + " connectionState: " + zkConnectionState + " for " + this);
560: Suresh Srinivas, error, MethodDeclaration, LOG.debug(errorMessage);
572: Todd Lipcon, warn, IfStmt, LOG.warn("Lock monitoring failed because session was lost");
598: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Watcher event type: " + eventType + " with state:" + event.getState() + " for path:" + event.getPath() + " connectionState: " + zkConnectionState + " for " + this);
608: Todd Lipcon, info, SwitchStmt, LOG.info("Session connected.");
619: Todd Lipcon, info, SwitchStmt, LOG.info("Session disconnected. Entering neutral mode...");
634: Todd Lipcon, info, SwitchStmt, LOG.info("Successfully authenticated to ZooKeeper using SASL.");
662: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Unexpected node event: " + eventType + " for path: " + path);
716: Akira Ajisaka, error, MethodDeclaration, LOG.error(errorMessage);
724: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Monitoring active leader for " + this);
746: Todd Lipcon, info, MethodDeclaration, LOG.info("Trying to re-establish ZK session");
764: Todd Lipcon, info, IfStmt, LOG.info("Not joining election since service has not yet been " + "reported as healthy.");
822: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Establishing zookeeper connection for " + this);
828: Akira Ajisaka, warn, CatchClause, LOG.warn(e.toString());
831: Akira Ajisaka, warn, CatchClause, LOG.warn(e.toString());
852: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Created new connection for " + this);
862: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Terminating ZK connection for " + this);
870: Akira Ajisaka, warn, CatchClause, LOG.warn(e.toString());
897: Todd Lipcon, warn, CatchClause, LOG.warn("Exception handling the winning of election", e);
891: Steve Loughran, debug, TryStmt, LOG.debug("Becoming active for {}", this);
912: Steve Loughran, info, MethodDeclaration, LOG.info("Writing znode {} to indicate that the local " + "node is the most recent active...", zkBreadCrumbPath);
932: Todd Lipcon, info, MethodDeclaration, LOG.info("Deleting bread-crumb of active node...");
950: Steve Loughran, warn, CatchClause, LOG.warn("Unable to delete our own bread-crumb of being active at {}." + ". Expecting to be fenced by the next active.", zkBreadCrumbPath, e);
964: Todd Lipcon, info, MethodDeclaration, LOG.info("Checking for any old active which needs to be fenced...");
974: Todd Lipcon, info, IfStmt, LOG.info("No old node to fence");
985: Steve Loughran, info, MethodDeclaration, LOG.info("Old node exists: {}", StringUtils.byteToHexString(data));
987: Todd Lipcon, info, IfStmt, LOG.info("But old node has our own data, so don't need to fence it.");
996: Steve Loughran, debug, IfStmt, LOG.debug("Becoming standby for {}", this);
1004: Steve Loughran, debug, IfStmt, LOG.debug("Entering neutral mode for {}", this);
1017: Vinayakumar B, info, IfStmt, LOG.info("Ignore duplicate monitor lock-node request.");
1121: Steve Loughran, warn, IfStmt, LOG.warn("Ignoring stale result from old client with sessionId {}", String.format("0x%08x", ((ZooKeeper) ctx).getSessionId()));
1159: Steve Loughran, error, IfStmt, LOG.error("Connection timed out: couldn't connect to ZooKeeper in " + "{} milliseconds", connectionTimeoutMs);
1183: Vinayakumar B, debug, IfStmt, LOG.debug("Event received with stale zk");
126: Steve Loughran, error, CatchClause, LOG.error(msg, e);
142: Steve Loughran, warn, IfStmt, LOG.warn("Service is not ready to become active, but forcing: {}", notReadyReason);
175: Steve Loughran, warn, CatchClause, LOG.warn("Unable to gracefully make {} standby ({})", svc, sfe.getMessage());
178: Steve Loughran, warn, CatchClause, LOG.warn("Unable to gracefully make {} standby (unable to connect)", svc, ioe);
230: Steve Loughran, error, CatchClause, LOG.error("Unable to make {} active ({}). Failing back.", toSvc, sfe.getMessage());
235: Steve Loughran, error, CatchClause, LOG.error("Unable to make {} active (unable to connect). Failing back.", toSvc, ioe);
255: Akira Ajisaka, error, CatchClause, LOG.error(msg);
244: Todd Lipcon, warn, IfStmt, LOG.warn("Proceeding with manual HA state management even though\n" + "automatic failover is enabled for " + target);
401: Todd Lipcon, debug, IfStmt, LOG.debug("Operation failed", ioe);
452: Akira Ajisaka, error, IfStmt, LOG.error("Aborted");
151: Todd Lipcon, info, MethodDeclaration, LOG.info("Stopping HealthMonitor thread");
183: Todd Lipcon, warn, CatchClause, LOG.warn("Could not connect to local service at " + targetToMonitor + ": " + e.getMessage());
210: Steve Loughran, warn, IfStmt, LOG.warn("Transport-level exception trying to monitor health of {}", targetToMonitor, t);
207: Steve Loughran, warn, IfStmt, LOG.warn("Service health check failed for {}", targetToMonitor, t);
248: Steve Loughran, info, IfStmt, LOG.info("Entering state {}", newState);
285: Akira Ajisaka, error, MethodDeclaration, LOG.error("Health monitor failed", e);
92: Eli Collins, info, MethodDeclaration, LOG.info("====== Beginning Service Fencing Process... ======");
95: Todd Lipcon, info, ForeachStmt, LOG.info("Trying method " + (++i) + "/" + methods.size() + ": " + method);
103: Todd Lipcon, error, CatchClause, LOG.error("Fencing method " + method + " misconfigured", e);
106: Todd Lipcon, error, CatchClause, LOG.error("Fencing method " + method + " failed with an unexpected error.", t);
99: Todd Lipcon, info, IfStmt, LOG.info("====== Fencing successful by method " + method + " ======");
109: Todd Lipcon, warn, ForeachStmt, LOG.warn("Fencing method " + method + " was unsuccessful.");
112: Eli Collins, error, MethodDeclaration, LOG.error("Unable to fence service by any configured method.");
50: Chris Douglas, info, MethodDeclaration, LOG.info("The parameter for the PowerShell fencer is " + argStr);
64: Chris Douglas, error, IfStmt, LOG.error("Cannot build PowerShell script");
69: Chris Douglas, info, MethodDeclaration, LOG.info("Executing " + ps1script);
76: Chris Douglas, warn, CatchClause, LOG.warn("Unable to execute " + ps1script, e);
96: Chris Douglas, warn, CatchClause, LOG.warn("Interrupted while waiting for fencing command: " + ps1script);
112: Chris Douglas, info, MethodDeclaration, LOG.info("Building PowerShell script to kill " + processName + " at " + host);
143: Chris Douglas, error, CatchClause, LOG.error("Cannot create PowerShell script", ioe);
149: Chris Douglas, error, CatchClause, LOG.error("Cannot close PowerShell script", ioe);
137: Chris Douglas, info, TryStmt, LOG.info("PowerShell command: " + cmd);
93: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to execute " + cmd, e);
98: Todd Lipcon, info, MethodDeclaration, LOG.info("Launched fencing command '" + cmd + "' with " + ((pid != null) ? ("pid " + pid) : "unknown pid"));
123: Todd Lipcon, warn, CatchClause, LOG.warn("Interrupted while waiting for fencing command: " + cmd);
169: Todd Lipcon, trace, CatchClause, LOG.trace("Unable to determine pid for " + p, t);
164: Todd Lipcon, trace, IfStmt, LOG.trace("Unable to determine pid for " + p + " since it is not a UNIXProcess");
92: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to create SSH session", e);
96: Todd Lipcon, info, MethodDeclaration, LOG.info("Connecting to " + host + "...");
101: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to connect to " + host + " as user " + args.user, e);
105: Todd Lipcon, info, MethodDeclaration, LOG.info("Connected to " + host);
110: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to achieve fencing on remote host", e);
165: Todd Lipcon, warn, CatchClause, LOG.warn("Interrupted while trying to fence via ssh", e);
168: Todd Lipcon, warn, CatchClause, LOG.warn("Unknown failure while trying to fence via ssh", e);
134: Eli Collins, info, TryStmt, LOG.info("Looking for process running on port " + port);
156: Eli Collins, info, IfStmt, LOG.info("Verified that the service is down.");
153: Eli Collins, warn, IfStmt, LOG.warn("Unable to fence - it is running but we cannot kill it");
138: Todd Lipcon, info, IfStmt, LOG.info("Successfully killed process that was " + "listening on port " + port);
162: Todd Lipcon, info, TryStmt, LOG.info("rc: " + rc);
179: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Running cmd: " + cmd);
210: Todd Lipcon, warn, CatchClause, LOG.warn("Couldn't disconnect ssh channel", t);
297: Todd Lipcon, debug, SwitchStmt, LOG.debug(message);
300: Todd Lipcon, info, SwitchStmt, LOG.info(message);
303: Todd Lipcon, warn, SwitchStmt, LOG.warn(message);
307: Akira Ajisaka, error, SwitchStmt, LOG.error(message);
59: Todd Lipcon, warn, CatchClause, ShellCommandFencer.LOG.warn(logPrefix + ": Unable to pump output from " + type, t);
88: Todd Lipcon, warn, IfStmt, log.warn(logPrefix + ": " + line);
86: Todd Lipcon, info, IfStmt, log.info(logPrefix + ": " + line);
164: Akira Ajisaka, error, IfStmt, LOG.error("Automatic failover is not enabled for " + localTarget + "." + " Please ensure that automatic failover is enabled in the " + "configuration before running the ZK failover controller.");
196: Akira Ajisaka, error, CatchClause, LOG.error("Unable to start failover controller. Unable to connect " + "to ZooKeeper quorum at " + zkQuorum + ". Please check the " + "configured value for " + ZK_QUORUM_KEY + " and ensure that " + "ZooKeeper is running.", ke);
223: Arpit Agarwal, error, CatchClause, LOG.error("The failover controller encounters runtime error", e);
228: Akira Ajisaka, error, IfStmt, LOG.error("Unable to start failover controller. " + "Parent znode does not exist.\n" + "Run with -formatZK flag to initialize ZooKeeper.");
237: Akira Ajisaka, error, CatchClause, LOG.error("Fencing is not configured for " + localTarget + ".\n" + "You must configure a fencing method before using automatic " + "failover.", e);
249: Arpit Agarwal, error, CatchClause, LOG.error("The failover controller encounters runtime error: ", e);
281: Todd Lipcon, error, CatchClause, LOG.error("Unable to clear zk parent znode", e);
303: Todd Lipcon, debug, CatchClause, LOG.debug("Failed to confirm", e);
379: Akira Ajisaka, Fatal, MethodDeclaration, LOG.error("Fatal error occurred:" + err);
385: Todd Lipcon, info, MethodDeclaration, LOG.info("Trying to make " + localTarget + " active...");
398: Akira Ajisaka, error, CatchClause, LOG.error(msg, t);
392: Todd Lipcon, info, TryStmt, LOG.info(msg);
479: Todd Lipcon, warn, MethodDeclaration, LOG.warn(timeoutMillis + "ms timeout elapsed waiting for an attempt " + "to become active");
489: Todd Lipcon, info, MethodDeclaration, LOG.info("ZK Election indicated that " + localTarget + " should become standby");
497: Todd Lipcon, error, CatchClause, LOG.error("Couldn't transition " + localTarget + " to standby state", e);
494: Todd Lipcon, info, TryStmt, LOG.info("Successfully transitioned " + localTarget + " to standby state");
518: Todd Lipcon, info, MethodDeclaration, LOG.info("Should fence: " + target);
532: Todd Lipcon, error, CatchClause, LOG.error("Couldn't fence old active " + target, e);
577: Todd Lipcon, info, SynchronizedStmt, LOG.info("Requested by " + UserGroupInformation.getCurrentUser() + " at " + Server.getRemoteAddress() + " to cede active role.");
584: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to transition local node to standby: " + ioe.getLocalizedMessage());
586: Todd Lipcon, warn, CatchClause, LOG.warn("Quitting election but indicating that fencing is " + "necessary");
582: Todd Lipcon, info, TryStmt, LOG.info("Successfully ensured local node is in standby mode");
653: Todd Lipcon, info, IfStmt, LOG.info("Local node " + localTarget + " is already active. " + "No need to failover. Returning success.");
705: Todd Lipcon, info, IfStmt, LOG.info("Successfully became active. " + attempt.status);
723: Aaron T. Myers, info, MethodDeclaration, LOG.info("Asking " + remote + " to cede its active state for " + timeout + "ms");
784: Todd Lipcon, info, IfStmt, LOG.info("Would have joined master election, but this node is " + "prohibited from doing so for " + TimeUnit.NANOSECONDS.toMillis(remainingDelay) + " more ms");
801: Todd Lipcon, info, SwitchStmt, LOG.info("Ensuring that " + localTarget + " does not " + "participate in active master election");
809: Todd Lipcon, info, SwitchStmt, LOG.info("Quitting master election for " + localTarget + " and marking that fencing is necessary");
854: Uma Maheswara Rao G, debug, IfStmt, LOG.debug("rechecking for electability from bad state");
893: Todd Lipcon, info, MethodDeclaration, LOG.info("Local service " + localTarget + " entered state: " + newState);
95: Todd Lipcon, warn, SwitchStmt, LOG.warn("Unknown request source: " + proto.getReqSource());
97: Jonathan Turner Eagles, warn, IfStmt, LOG.warn("Jetty request log can only be enabled using Log4j");
76: Akira Ajisaka, warn, CatchClause, LOG.warn("Http request log for {} could not be created", loggerName);
81: Akira Ajisaka, info, IfStmt, LOG.info("Http request log for {} is not defined", loggerName);
93: Akira Ajisaka, warn, IfStmt, LOG.warn("Jetty request log for {} was of the wrong class", loggerName);
504: Wei-Chiu Chuang, info, IfStmt, LOG.info("Excluded Cipher List:" + excludeCiphers);
595: Arun Murthy, info, ForeachStmt, LOG.info("adding path spec: " + path);
787: Tsz-wo Sze, info, MethodDeclaration, LOG.info("addJerseyResourcePackage: packageName=" + packageName + ", pathSpec=" + pathSpec);
850: Robert Kanter, debug, IfStmt, LOG.debug("Found existing " + servletMappings[i].getServletName() + " servlet at path " + pathSpec + "; will replace mapping" + " with " + holder.getName() + " servlet");
864: Robert Kanter, info, IfStmt, LOG.info("Adding Kerberos (SPNEGO) filter to " + name);
899: Billie Rinaldi, debug, IfStmt, LOG.debug("Found existing " + servletMappings[i].getServletName() + " servlet at path " + pathSpec + "; will replace mapping" + " with " + sh.getName() + " servlet");
941: Haohui Mai, info, MethodDeclaration, LOG.info("Added filter " + name + " (class=" + classname + ") to context " + webAppContext.getDisplayName());
951: Owen O'Malley, info, IfStmt, LOG.info("Added filter " + name + " (class=" + classname + ") to context " + ctx.getDisplayName());
968: Matthew Foley, info, MethodDeclaration, LOG.info("Added global filter '" + name + "' (class=" + classname + ")");
1050: Anu Engineer, info, IfStmt, LOG.info("Web server is in development mode. Resources " + "will be read from the source tree.");
1136: Robert Joseph Evans, info, CatchClause, LOG.info("HttpServer.start() threw a non Bind IOException", ex);
1139: Robert Joseph Evans, info, CatchClause, LOG.info("HttpServer.start() threw a MultiException", ex);
1185: Junping Du, info, MethodDeclaration, LOG.info("Jetty bound to port " + listener.getLocalPort());
1267: Andrew Wang, debug, MethodDeclaration, LOG.debug("opening listeners: {}", listeners);
1292: Jing Zhao, Error, CatchClause, LOG.error("Error while stopping listener for webapp" + webAppContext.getDisplayName(), e);
1306: Eric Yang, Error, CatchClause, LOG.error("Error while stopping web app context for webapp " + webAppContext.getDisplayName(), e);
1314: Eric Yang, Error, CatchClause, LOG.error("Error while stopping web server for webapp " + webAppContext.getDisplayName(), e);
249: Owen O'Malley, warn, CatchClause, LOG.warn("Can't open BloomFilter: " + ioe + " - fallback to MapFile.");
79: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("Lexicographical comparer selected for " + "byte aligned system architecture");
98: Colin Patrick Mccabe, trace, IfStmt, LOG.trace(t.getMessage());
99: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("Lexicographical comparer selected");
92: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("Unsafe comparer selected for " + "byte unaligned system architecture");
261: Owen O'Malley, debug, IfStmt, log.debug("Exception in closing " + c, e);
283: Akira Ajisaka, debug, IfStmt, logger.debug("Exception in closing {}", c, e);
324: Harsh J, debug, CatchClause, LOG.debug("Ignoring exception while closing socket", ignored);
504: Steve Loughran, warn, CatchClause, LOG.warn("Unable to wrap exception of type " + clazz + ": it has no (String) constructor", e);
511: Owen O'Malley, warn, CatchClause, LOG.warn("Unexpected EOF reading " + index + " at entry #" + count + ".  Ignoring.");
154: Todd Lipcon, trace, IfStmt, LOG.trace("submit readahead: " + req);
216: Todd Lipcon, warn, CatchClause, LOG.warn("Failed readahead on " + identifier, ioe);
1140: Vinayakumar B, info, IfStmt, LOG.info("MetaData Option is ignored during append");
2326: Owen O'Malley, debug, IfStmt, LOG.debug(val + " is a zero-length value");
2311: Owen O'Malley, info, IfStmt, LOG.info("available bytes: " + valIn.available());
2365: Owen O'Malley, debug, IfStmt, LOG.debug(val + " is a zero-length value");
2350: Owen O'Malley, info, IfStmt, LOG.info("available bytes: " + valIn.available());
2700: Owen O'Malley, warn, IfStmt, LOG.warn("Bad checksum at " + getPosition() + ". Skipping entries.");
2926: Tsz-wo Sze, debug, IfStmt, LOG.debug("running sort pass");
3026: Tsz-wo Sze, debug, IfStmt, LOG.debug("flushing segment " + segments);
3315: Tsz-wo Sze, debug, IfStmt, LOG.debug("running merge pass");
3553: Tsz-wo Sze, debug, IfStmt, LOG.debug("writing intermediate results to " + outputFile);
89: Owen O'Malley, warn, IfStmt, LOG.warn("truncating long string: " + string.length() + " chars, starting with " + string.substring(0, 20));
327: Owen O'Malley, warn, IfStmt, LOG.warn("truncating long string: " + s.length() + " chars, starting with " + s.substring(0, 20));
157: Tsz-wo Sze, debug, IfStmt, LOG.debug("Got recycled compressor");
153: Eli Collins, info, IfStmt, LOG.info("Got brand-new compressor [" + codec.getDefaultExtension() + "]");
187: Tsz-wo Sze, debug, IfStmt, LOG.debug("Got recycled decompressor");
184: Eli Collins, info, IfStmt, LOG.info("Got brand-new decompressor [" + codec.getDefaultExtension() + "]");
119: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Reinit compressor with new compression configuration");
64: Jason Darrell Lowe, warn, CatchClause, LOG.warn("Failed to load/initialize native-bzip2 library " + libname + ", will use pure-Java version");
61: Jason Darrell Lowe, info, TryStmt, LOG.info("Successfully loaded & initialized native-bzip2 library " + libname);
54: Jason Darrell Lowe, info, IfStmt, LOG.info("Using pure-Java version of bzip2 library");
63: Todd Lipcon, error, IfStmt, LOG.error("Cannot load " + Lz4Compressor.class.getName() + " without native hadoop library!");
60: Todd Lipcon, warn, CatchClause, LOG.warn(t.toString());
57: Todd Lipcon, error, IfStmt, LOG.error("Cannot load " + Lz4Compressor.class.getName() + " without native hadoop library!");
54: Todd Lipcon, warn, CatchClause, LOG.warn(t.toString());
60: Eli Collins, error, CatchClause, LOG.error("failed to load SnappyCompressor", t);
57: Eli Collins, error, CatchClause, LOG.error("failed to load SnappyDecompressor", t);
77: Christopher Douglas, warn, CatchClause, LOG.warn(strategy + " not supported by BuiltInZlibDeflater.");
81: Tsz-wo Sze, debug, IfStmt, LOG.debug("Reinit compressor with new compression configuration");
295: Tsz-wo Sze, debug, IfStmt, LOG.debug("Reinit compressor with new compression configuration");
61: Owen O'Malley, warn, IfStmt, LOG.warn("Failed to load/initialize native-zlib library");
59: Owen O'Malley, info, IfStmt, LOG.info("Successfully loaded & initialized native-zlib library");
65: Jason Lowe, Error, CatchClause, LOG.warn("Error loading zstandard native libraries: " + t);
117: Jason Lowe, debug, MethodDeclaration, LOG.debug("Reinit compressor with new compression configuration");
57: Jason Lowe, Error, CatchClause, LOG.warn("Error loading zstandard native libraries: " + t);
91: Wei-Chiu Chuang, error, IfStmt, LOG.error("Coder {} cannot be registered because its coder name " + "{} has conflict with {}", coderFactory.getClass().getName(), coderFactory.getCoderName(), coder.getClass().getName());
106: Wei-Chiu Chuang, debug, IfStmt, LOG.debug("Codec registered: codec = {}, coder = {}", coderFactory.getCodecName(), coderFactory.getCoderName());
84: Wei-Chiu Chuang, debug, IfStmt, LOG.debug("Codec registered: codec = {}, coder = {}", coderFactory.getCodecName(), coderFactory.getCoderName());
182: Wei-Chiu Chuang, debug, IfStmt, LOG.debug("Failed to create raw erasure encoder " + rawCoderName + ", fallback to next codec if possible", e);
204: Wei-Chiu Chuang, debug, IfStmt, LOG.debug("Failed to create raw erasure decoder " + rawCoderName + ", fallback to next codec if possible", e);
49: Colin Patrick Mccabe, error, CatchClause, LOG.error("Loading ISA-L failed", t);
55: Wei-Chiu Chuang, warn, IfStmt, LOG.warn("ISA-L support is not available in your platform... " + "using builtin-java codec where applicable");
78: Kai Zheng, debug, MethodDeclaration, PerformanceAdvisory.LOG.debug("convertToByteBufferState is invoked, " + "not efficiently. Please use direct ByteBuffer inputs/outputs");
75: Kai Zheng, debug, MethodDeclaration, PerformanceAdvisory.LOG.debug("convertToByteBufferState is invoked, " + "not efficiently. Please use direct ByteBuffer inputs/outputs");
94: Christopher Douglas, info, TryStmt, LOG.info("Trying to load Lzo codec class: " + clazz);
288: Tsz-wo Sze, debug, IfStmt, LOG.debug("Got a compressor: " + compressor.hashCode());
305: Tsz-wo Sze, debug, IfStmt, LOG.debug("Return a compressor: " + compressor.hashCode());
322: Tsz-wo Sze, debug, IfStmt, LOG.debug("Got a decompressor: " + decompressor.hashCode());
340: Tsz-wo Sze, debug, IfStmt, LOG.debug("Returned a decompressor: " + decompressor.hashCode());
165: Colin McCabe, info, MethodDeclaration, LOG.info("mlocking " + identifier);
196: Suresh Srinivas, debug, TryStmt, LOG.debug("Initialized cache for IDs to User/Group mapping with a " + " cache timeout of " + cacheTimeout / 1000 + " seconds.");
242: Suresh Srinivas, warn, IfStmt, LOG.warn(String.format("NativeIO.chmod error (%d): %s", nioe.getErrorCode(), nioe.getMessage()));
425: Chris Nauroth, warn, IfStmt, LOG.warn(String.format("NativeIO.getFstat error (%d): %s", nioe.getErrorCode(), nioe.getMessage()));
445: Chris Douglas, warn, IfStmt, LOG.warn(errMessage);
458: Chris Douglas, warn, CatchClause, LOG.warn("NativeIO.getStat error ({}): {} -- file path: {}", nioe.getErrorCode(), nioe.getMessage(), path);
477: Suresh Srinivas, debug, IfStmt, LOG.debug("Got " + type + " " + name + " for ID " + id + " from the native implementation");
723: Colin McCabe, warn, CatchClause, LOG.warn("Unable to get operating system page size.  Guessing 4096.", e);
770: Suresh Srinivas, info, IfStmt, LOG.info("Got UserName " + user + " for UID " + uid + " from the native implementation");
861: Suresh Srinivas, info, IfStmt, LOG.info("Initialized cache for UID to User mapping with a cache" + " timeout of " + cacheTimeout / 1000 + " seconds.");
114: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("add " + call);
174: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Starting AsyncCallQueue.Processor " + daemon);
188: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Killing " + d);
242: Tsz-Wo Nicholas Sze, debug, MethodDeclaration, LOG.debug("#{}: {}", getCallId(), r.getState());
265: Tsz-Wo Nicholas Sze, trace, MethodDeclaration, LOG.trace("#{} processRetryInfo: waitTime={}", getCallId(), waitTime);
275: Tsz-Wo Nicholas Sze, debug, MethodDeclaration, LOG.debug("{}.invoke {}", getClass().getSimpleName(), this);
279: Tsz-Wo Nicholas Sze, trace, IfStmt, LOG.trace("#{} invoke: lowerLayerAsyncGet.isDone()? {}", getCallId(), isDone);
292: Tsz-Wo Nicholas Sze, trace, MethodDeclaration, LOG.trace("#{} invoke: ASYNC_INVOKED", getCallId());
303: Tsz-Wo Nicholas Sze, trace, IfStmt, LOG.trace("#{} invoke: initAsyncCall", getCallId());
60: Arpit Gupta, debug, IfStmt, LOG.debug("retryCount == " + retryCount + ". It's time to normally process the response");
55: Arpit Gupta, debug, IfStmt, LOG.debug("Drop the response. Current retryCount == " + retryCount);
98: Tsz-Wo Nicholas Sze, trace, IfStmt, LOG.trace(toString(), e);
126: Tsz-Wo Nicholas Sze, trace, MethodDeclaration, LOG.trace("#{} processRetryInfo: retryInfo={}, waitTime={}", callId, retryInfo, waitTime);
134: Junping Du, debug, IfStmt, LOG.debug("Interrupted while waiting to retry", e);
220: Tsz-Wo Nicholas Sze, warn, IfStmt, LOG.warn("A failover has occurred since the start of call #" + callId + " " + proxyInfo.getString(method.getName()));
379: Jason Lowe, debug, IfStmt, LOG.debug("Exception while invoking call #" + callId + " " + proxyDescriptor.getProxyInfo().getString(method.getName()) + ". Not retrying because " + retryInfo.action.reason, e);
413: Jing Zhao, debug, IfStmt, LOG.debug(b.toString(), ex);
411: Junping Du, info, IfStmt, LOG.info(b.toString());
443: Tsz-wo Sze, warn, IfStmt, LOG.warn("Illegal value: there is no element in \"" + s + "\".");
447: Tsz-wo Sze, warn, IfStmt, LOG.warn("Illegal value: the number of elements in \"" + s + "\" is " + elements.length + " but an even number of elements is expected.");
485: Tsz-wo Sze, warn, CatchClause, LOG.warn("Failed to parse \"" + s + "\", which is the index " + i + " element in \"" + originalString + "\"", nfe);
491: Tsz-wo Sze, warn, IfStmt, LOG.warn("The value " + n + " <= 0: it is parsed from the string \"" + s + "\" which is the index " + i + " element in \"" + originalString + "\"");
75: Steve Loughran, debug, MethodDeclaration, LOG.debug("multipleLinearRandomRetry = {}", multipleLinearRandomRetry);
125: Steve Loughran, debug, MethodDeclaration, LOG.debug("RETRY {}) policy={}", retries, p.getClass().getSimpleName(), e);
75: Tanping Wang, warn, CatchClause, LOG.warn("Serialization class not found: ", e);
84: Konstantin V Shvachko, info, ConstructorDeclaration, LOG.info("Using callQueue: " + backingClass + " queueCapacity: " + maxQueueSize + " scheduler: " + schedulerClass);
320: Xiaoyu Yao, warn, IfStmt, LOG.warn(ns + "." + FairCallQueue.IPC_CALLQUEUE_PRIORITY_LEVELS_KEY + " is deprecated. Please use " + ns + "." + CommonConfigurationKeys.IPC_SCHEDULER_PRIORITY_LEVELS_KEY + ".");
359: Arpit Agarwal, info, MethodDeclaration, LOG.info("Old Queue: " + stringRepr(oldQ) + ", " + "Replacement: " + stringRepr(newQ));
198: Tsuyoshi Ozawa, warn, CatchClause, LOG.warn("Interrupted while waiting for clientExecutor" + " to stop");
484: Eli Collins, debug, IfStmt, LOG.debug("The ping interval is " + this.pingInterval + " ms.");
630: Suresh Srinivas, warn, IfStmt, LOG.warn("Address change detected. Old: " + server.toString() + " New: " + currentAddr.toString());
680: Steve Loughran, debug, IfStmt, LOG.debug("Binding {} to {}", principal, localAddr);
751: Devaraj Das, warn, IfStmt, LOG.warn("Exception encountered while connecting to " + "the server : " + ex);
747: cnauroth, warn, IfStmt, LOG.warn(msg, ex);
728: Tsz-wo Sze, debug, IfStmt, LOG.debug("Exception encountered while connecting to " + "the server : " + ex);
780: Owen O'Malley, debug, IfStmt, LOG.debug("Connecting to " + server);
822: Arpit Agarwal, debug, IfStmt, LOG.debug("Negotiated QOP is :" + remoteId.saslQop);
875: Devaraj Das, warn, CatchClause, LOG.warn("Not able to close a socket", e);
905: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Retrying connect to server: " + server + ". Already tried " + curRetries + " time(s); maxRetries=" + maxRetries);
922: Junping Du, debug, IfStmt, LOG.debug("Failed to connect to server: " + server + ": " + action.reason, ioe);
931: Steve Loughran, warn, IfStmt, LOG.warn("Interrupted while trying for connection");
941: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Retrying connect to server: " + server + ". Already tried " + curRetries + " time(s); retry policy is " + connectionRetryPolicy);
1057: Owen O'Malley, debug, BlockStmt, LOG.debug(getName() + ": starting, having connections " + connections.size());
1075: Owen O'Malley, debug, BlockStmt, LOG.debug(getName() + ": stopped, remaining connections " + connections.size());
1120: John Zhuge, debug, IfStmt, LOG.debug(getName() + " sending #" + call.id + " " + call.rpcRequest);
1174: Sanjay Radia, debug, BlockStmt, LOG.debug(getName() + " got value #" + callId);
1195: Sanjay Radia, warn, IfStmt, LOG.warn("Detailed error code not set by server on rpc error");
1221: Owen O'Malley, error, IfStmt, LOG.error("The connection is not in the closed state");
1247: Owen O'Malley, debug, IfStmt, LOG.debug("closing ipc connection to " + server + ": " + closeException.getMessage(), closeException);
1237: Owen O'Malley, warn, IfStmt, LOG.warn("A connection is closed for no cause and calls are not empty");
1256: Owen O'Malley, debug, BlockStmt, LOG.debug(getName() + ": closed");
1284: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("{} set to true. Will bind client sockets to wildcard " + "address.", CommonConfigurationKeys.IPC_CLIENT_BIND_WILDCARD_ADDR_KEY);
1316: Owen O'Malley, debug, IfStmt, LOG.debug("Stopping client");
1402: Tsz-Wo Nicholas Sze, warn, CatchClause, LOG.warn("interrupted waiting to send rpc request to server", e);
63: Aaron Myers, debug, IfStmt, Client.LOG.debug("getting client out of cache: " + client);
97: Aaron Myers, debug, IfStmt, Client.LOG.debug("stopping client from cache: " + client);
103: Aaron Myers, debug, IfStmt, Client.LOG.debug("removing client from cache: " + client);
110: Aaron Myers, debug, IfStmt, Client.LOG.debug("stopping actual client because no more references remain: " + client);
251: Arpit Agarwal, info, IfStmt, LOG.info("IdentityProvider not specified, " + "defaulting to UserIdentityProvider");
267: Xiaoyu Yao, warn, IfStmt, LOG.warn(IPC_FCQ_DECAYSCHEDULER_FACTOR_KEY + " is deprecated. Please use " + IPC_SCHEDULER_DECAYSCHEDULER_FACTOR_KEY + ".");
288: Xiaoyu Yao, warn, IfStmt, LOG.warn((IPC_FCQ_DECAYSCHEDULER_PERIOD_KEY + " is deprecated. Please use " + IPC_SCHEDULER_DECAYSCHEDULER_PERIOD_KEY));
310: Xiaoyu Yao, warn, IfStmt, LOG.warn(IPC_FCQ_DECAYSCHEDULER_THRESHOLDS_KEY + " is deprecated. Please use " + IPC_DECAYSCHEDULER_THRESHOLDS_KEY);
431: Xiaoyu Yao, error, CatchClause, LOG.error("decayCurrentCounts exception: " + ExceptionUtils.getFullStackTrace(ex));
543: Xiaoyu Yao, warn, CatchClause, LOG.warn("Caught InterruptedException, returning low priority level");
544: Xiaoyu Yao, debug, CatchClause, LOG.debug("Fallback priority for: {} with priority: {}", identity, numLevels - 1);
531: Xiaoyu Yao, debug, IfStmt, LOG.debug("Cache priority for: {} with priority: {}", identity, priority);
539: Xiaoyu Yao, debug, TryStmt, LOG.debug("compute priority for " + identity + " priority " + priority);
574: Xiaoyu Yao, debug, IfStmt, LOG.debug("Current Caller: {}  Priority: {} ", obj.getUserGroupInformation().getUserName(), obj.getPriorityLevel());
578: Xiaoyu Yao, debug, ForStmt, LOG.debug("Queue: {} responseTime: {} backoffThreshold: {}", i, responseTimes[i], backOffResponseTimeThresholds[i]);
601: Xiaoyu Yao, debug, IfStmt, LOG.debug("addResponseTime for call: {}  priority: {} queueTime: {} " + "processingTime: {} ", name, priorityLevel, queueTime, processingTime);
629: Xiaoyu Yao, debug, IfStmt, LOG.debug("updateAverageResponseTime queue: {} Average: {} Count: {}", i, averageResponseTime, responseTimeCount);
838: Xiaoyu Yao, warn, CatchClause, LOG.warn("Exception thrown while metric collection. Exception : " + e.getMessage());
91: Konstantin V Shvachko, info, ConstructorDeclaration, LOG.info("FairCallQueue is in use with " + numQueues + " queues with total capacity of " + capacity);
219: Todd Lipcon, trace, IfStmt, LOG.trace(Thread.currentThread().getId() + ": Call -> " + remoteId + ": " + method.getName() + " {" + TextFormat.shortDebugString((Message) args[1]) + "}");
234: Todd Lipcon, trace, IfStmt, LOG.trace(Thread.currentThread().getId() + ": Exception <- " + remoteId + ": " + method.getName() + " {" + e + "}");
249: Todd Lipcon, debug, IfStmt, LOG.debug("Call: " + method.getName() + " took " + callTime + "ms");
287: Todd Lipcon, trace, IfStmt, LOG.trace(Thread.currentThread().getId() + ": Response <- " + remoteId + ": " + method.getName() + " {" + TextFormat.shortDebugString(returnMessage) + "}");
499: Sanjay Radia, info, BlockStmt, LOG.info("Call: connectionProtocolName=" + connectionProtocolName + ", method=" + methodName);
510: Sanjay Radia, warn, IfStmt, LOG.warn(msg);
550: Jing Zhao, debug, IfStmt, LOG.debug(msg);
118: Arpit Agarwal, info, TryStmt, LOG.info(handlerName(handler) + " responds to '" + identifier + "', says: '" + response.getMessage() + "', returns " + response.getReturnCode());
267: Jing Zhao, trace, IfStmt, LOG.trace("Adding Rpc request clientId " + newEntry.clientIdMsb + newEntry.clientIdLsb + " callId " + newEntry.callId + " to retryCache");
132: Sanjay Radia, warn, IfStmt, LOG.warn("Interface " + childInterface + " ignored because it does not extend VersionedProtocol");
407: Owen O'Malley, info, CatchClause, LOG.info("Server at " + addr + " not available yet, Zzzzz...");
410: Owen O'Malley, info, CatchClause, LOG.info("Problem connecting to server: " + addr);
413: Thomas White, info, CatchClause, LOG.info("No route to host for server: " + addr);
682: Suresh Srinivas, error, CatchClause, LOG.error("Closing proxy or invocation handler caused exception", e);
684: Uma Maheswara Rao G, error, CatchClause, LOG.error("RPC.stopProxy called on non proxy: class=" + proxy.getClass().getName(), e);
920: Sanjay Radia, warn, CatchClause, LOG.warn("Protocol " + protocolClass + " NOT registered as cannot get protocol version ");
929: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("RpcKind = " + rpcKind + " Protocol Name = " + protocolName + " version=" + version + " ProtocolImpl=" + protocolImpl.getClass().getName() + " protocolClass=" + protocolClass.getName());
970: Harsh J, debug, IfStmt, LOG.debug("Size of protoMap for " + rpcKind + " =" + getProtocolImplMap(rpcKind).size());
280: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("rpcKind=" + rpcKind + ", rpcRequestWrapperClass=" + rpcRequestWrapperClass + ", rpcInvoker=" + rpcInvoker);
499: Xiaoyu Yao, warn, IfStmt, LOG.warn("Slow RPC : " + methodName + " took " + processingTime + " milliseconds to process from client " + client);
869: Kihwal Lee, info, IfStmt, Server.LOG.info(Thread.currentThread().getName() + ": skipped " + this);
888: Jian He, debug, IfStmt, LOG.debug("Deferring response for callId: " + this.callId);
1074: Jing Zhao, info, MethodDeclaration, LOG.info("Starting " + Thread.currentThread().getName());
1081: Jing Zhao, Error, CatchClause, LOG.error("Error closing read selector in " + Thread.currentThread().getName(), ioe);
1118: Jing Zhao, info, IfStmt, LOG.info(Thread.currentThread().getName() + " unexpectedly interrupted", e);
1121: Todd Lipcon, Error, CatchClause, LOG.error("Error in Reader", ex);
1123: Akira Ajisaka, error, CatchClause, LOG.error("Bug in read selector!", re);
1153: Jing Zhao, info, MethodDeclaration, LOG.info(Thread.currentThread().getName() + ": starting");
1185: Jing Zhao, info, MethodDeclaration, LOG.info("Stopping " + Thread.currentThread().getName());
1251: Jing Zhao, info, CatchClause, LOG.info(Thread.currentThread().getName() + ": readAndProcess caught InterruptedException", ieo);
1281: Jing Zhao, info, CatchClause, LOG.info(Thread.currentThread().getName() + ":Exception in closing listener socket. " + e);
1314: Jing Zhao, info, MethodDeclaration, LOG.info(Thread.currentThread().getName() + ": starting");
1319: Jing Zhao, info, TryStmt, LOG.info("Stopping " + Thread.currentThread().getName());
1323: Jing Zhao, error, CatchClause, LOG.error("Couldn't close write selector in " + Thread.currentThread().getName(), ioe);
1395: Todd Lipcon, warn, CatchClause, LOG.warn("Exception in Responder", e);
1349: Kihwal Lee, info, IfStmt, LOG.info(Thread.currentThread().getName() + ": connection aborted from " + call.connection);
1353: Jing Zhao, info, CatchClause, LOG.info(Thread.currentThread().getName() + ": doAsyncWrite threw exception " + e);
1366: Tsz-wo Sze, debug, IfStmt, LOG.debug("Checking for old call responses.");
1419: Owen O'Malley, warn, CatchClause, LOG.warn("Exception while changing ops : " + e);
1523: Jing Zhao, warn, IfStmt, LOG.warn(Thread.currentThread().getName() + ", call " + call + ": output error");
1468: Jing Zhao, debug, IfStmt, LOG.debug(Thread.currentThread().getName() + ": responding to " + call);
1515: Jing Zhao, debug, IfStmt, LOG.debug(Thread.currentThread().getName() + ": responding to " + call + " Wrote partial " + numBytes + " bytes.");
1487: Jing Zhao, debug, IfStmt, LOG.debug(Thread.currentThread().getName() + ": responding to " + call + " Wrote " + numBytes + " bytes.");
1680: Owen O'Malley, warn, CatchClause, LOG.warn("Connection: unable to set socket send buffer size to " + socketSendBufferSize);
1829: Yongjun Zhang, debug, IfStmt, LOG.debug(StringUtils.stringifyException(e));
1833: Jing Zhao, warn, CatchClause, AUDITLOG.warn(AUTH_FAILED_FOR + this.toString() + ":" + attemptingUser + " (" + e.getLocalizedMessage() + ") with true cause: (" + tce.getLocalizedMessage() + ")");
1841: Suresh Srinivas, debug, IfStmt, LOG.debug("SASL server context established. Negotiated QoP is " + saslServer.getNegotiatedProperty(Sasl.QOP));
1846: Suresh Srinivas, debug, IfStmt, LOG.debug("SASL server successfully authenticated client: " + user);
1849: Eli Collins, info, IfStmt, AUDITLOG.info(AUTH_SUCCESSFUL_FOR + user);
1952: Tsz-wo Sze, debug, IfStmt, LOG.debug("Have read input token of size " + saslToken.length + " for processing by saslServer.evaluateResponse()");
1969: Daryn Sharp, debug, IfStmt, LOG.debug("Will send " + state + " token of size " + ((replyToken != null) ? replyToken.length : null) + " from saslServer.");
2017: Colin McCabe, error, IfStmt, LOG.warn(error);
2011: Colin McCabe, error, IfStmt, LOG.warn(error);
2076: Devaraj Das, warn, IfStmt, LOG.warn("Incorrect header or version mismatch from " + hostAddress + ":" + remotePort + " got version " + version + " expected version " + CURRENT_VERSION);
2290: Jitendra Nath Pandey, debug, IfStmt, LOG.debug("Have read input token of size " + inBuf.length + " for processing by saslServer.unwrap()");
2372: Kihwal Lee, debug, IfStmt, LOG.debug(Thread.currentThread().getName() + ": processOneRpc from client " + this + " threw exception [" + rse + "]");
2355: Daryn Sharp, debug, IfStmt, LOG.debug(" got #" + callId);
2436: Sanjay Radia, warn, IfStmt, LOG.warn("Unknown rpc kind " + header.getRpcKind() + " from client " + getHostAddress());
2449: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to read call parameters for client " + getHostAddress() + "on connection protocol " + this.protocolName + " for rpcKind " + header.getRpcKind(), t);
2534: Daryn Sharp, debug, IfStmt, LOG.debug("Received ping message");
2562: Daryn Sharp, info, CatchClause, LOG.info("Connection from " + this + " for protocol " + connectionContext.getProtocol() + " is unauthorized for user " + user);
2558: Sanjay Radia, debug, IfStmt, LOG.debug("Successfully authorized " + connectionContext);
2619: Aaron Myers, debug, CatchClause, LOG.debug("Ignoring socket shutdown exception", e);
2663: Jing Zhao, debug, MethodDeclaration, LOG.debug(Thread.currentThread().getName() + ": starting");
2688: Jing Zhao, info, IfStmt, LOG.info(Thread.currentThread().getName() + " unexpectedly interrupted", e);
2695: Jing Zhao, info, CatchClause, LOG.info(Thread.currentThread().getName() + " caught an exception", e);
2670: Jing Zhao, debug, IfStmt, LOG.debug(Thread.currentThread().getName() + ": " + call + " for RpcKind " + call.rpcKind);
2705: Jing Zhao, debug, MethodDeclaration, LOG.debug(Thread.currentThread().getName() + ": exiting");
2726: Arpit Agarwal, info, IfStmt, logger.info(logMsg, e);
2719: Arpit Agarwal, info, IfStmt, logger.info(logMsg + ": " + e);
2877: Robert Joseph Evans, debug, IfStmt, LOG.debug(AuthenticationMethod.TOKEN + " authentication enabled for secret manager");
2884: Robert Joseph Evans, debug, MethodDeclaration, LOG.debug("Server accepts auth methods:" + authMethods);
2923: Todd Lipcon, Error, CatchClause, LOG.warn("Error serializing call response for call " + call, t);
2950: Kihwal Lee, warn, IfStmt, LOG.warn("Large response size " + response.length + " for call " + call.toString());
3042: Devaraj Das, debug, BlockStmt, LOG.debug("Adding saslServer wrapped token of size " + token.length + " as call response.");
3082: Owen O'Malley, info, MethodDeclaration, LOG.info("Stopping server on " + port);
3427: Daryn Sharp, debug, IfStmt, LOG.debug("Server connection from " + connection + "; # active connections: " + size() + "; # queued calls: " + callQueue.size());
3438: Daryn Sharp, debug, IfStmt, LOG.debug(Thread.currentThread().getName() + ": disconnecting client " + connection + ". Number of active connections: " + size());
3503: Daryn Sharp, debug, IfStmt, LOG.debug(Thread.currentThread().getName() + ": task running");
78: Arpit Agarwal, info, ConstructorDeclaration, LOG.info("WeightedRoundRobinMultiplexer is being used.");
255: Kai Zheng, debug, IfStmt, LOG.debug("Call: " + method.getName() + " " + callTime);
446: Kai Zheng, info, MethodDeclaration, LOG.info(value);
536: Kai Zheng, error, IfStmt, LOG.error("Unexpected throwable object ", e);
550: Kai Zheng, debug, IfStmt, LOG.debug(msg);
46: Jing Zhao, debug, IfStmt, LOG.debug("Initialized " + registry);
48: Akira Ajisaka, debug, ConstructorDeclaration, LOG.debug(registry.info().toString());
84: Andrew Wang, debug, ConstructorDeclaration, LOG.debug("Initialized " + registry);
220: Christopher Douglas, error, CatchClause, LOG.error("Caught an exception while processing JMX request", e);
223: Christopher Douglas, error, CatchClause, LOG.error("Caught an exception while processing JMX request", e);
232: Christopher Douglas, debug, MethodDeclaration, LOG.debug("Listing beans for " + qry);
345: Aaron Myers, error, IfStmt, LOG.error("getting attribute " + attName + " of " + oname + " threw an exception", e);
343: Aaron Myers, debug, IfStmt, LOG.debug("getting attribute " + attName + " of " + oname + " threw an exception", e);
125: Xiaoyu Yao, warn, CatchClause, LOG.warn("Failed to dump to Json.", e);
109: Akira Ajisaka, debug, MethodDeclaration, MetricsSystemImpl.LOG.debug(attrs.toString());
131: BELUGA BEHR, debug, IfStmt, LOG.debug("Could not locate file {}", fname, e);
121: BELUGA BEHR, info, TryStmt, LOG.info("Loaded properties from {}", fname);
123: BELUGA BEHR, debug, IfStmt, LOG.debug("Properties: {}", toString(cf));
126: BELUGA BEHR, debug, TryStmt, LOG.debug("Metrics Config: {}", mc);
137: BELUGA BEHR, warn, MethodDeclaration, LOG.warn("Cannot locate configuration: tried " + Joiner.on(",").join(fileNames));
191: BELUGA BEHR, debug, IfStmt, LOG.debug("poking parent '" + getParent().getClass().getSimpleName() + "' for key: " + key);
197: BELUGA BEHR, debug, MethodDeclaration, LOG.debug("Returning '{}' for key: {}", value, key);
220: BELUGA BEHR, debug, MethodDeclaration, LOG.debug("Class name for prefix {} is {}", prefix, clsName);
243: BELUGA BEHR, debug, ForeachStmt, LOG.debug("Parsing URL for {}", jar);
250: BELUGA BEHR, debug, IfStmt, LOG.debug("Using plugin jars: {}", Iterables.toString(jars));
98: Eric Yang, debug, IfStmt, LOG.debug("enqueue, logicalTime=" + logicalTimeMs);
115: Suresh Srinivas, warn, IfStmt, LOG.warn(name + " has a full queue and can't consume the given metrics.");
120: Suresh Srinivas, warn, IfStmt, LOG.warn(name + " couldn't fulfill an immediate putMetrics request in time." + " Abandoning.");
141: Arun Murthy, info, CatchClause, LOG.info(name + " thread interrupted.");
157: Arun Murthy, error, IfStmt, LOG.error("Got sink exception and over retry limit, " + "suppressing further error messages", e);
147: Arun Murthy, error, IfStmt, LOG.error("Got sink exception, retry in " + awhile + "ms", e);
152: Arun Murthy, info, CatchClause, LOG.info(name + " thread interrupted while waiting for retry", e2);
181: Arun Murthy, debug, IfStmt, LOG.debug("Pushing record " + entry.name() + "." + record.context() + "." + record.name() + " to " + name);
199: Arun Murthy, debug, MethodDeclaration, LOG.debug("Done");
204: Arun Murthy, info, MethodDeclaration, LOG.info("Sink " + name + " started");
216: Arun Murthy, warn, CatchClause, LOG.warn("Stop interrupted", e);
114: Matthew Foley, debug, IfStmt, LOG.debug(attribute + ": " + a);
135: Matthew Foley, debug, IfStmt, LOG.debug(key + ": " + attr);
202: Arun Murthy, Error, CatchClause, LOG.error("Error getting metrics from source " + name, e);
218: Arun Murthy, warn, IfStmt, LOG.warn("MBean " + name + " already initialized!");
219: Arun Murthy, trace, IfStmt, LOG.debug("Stacktrace: ", new Throwable());
223: Arun Murthy, debug, MethodDeclaration, LOG.debug("MBean for source " + name + " registered.");
245: Arun Murthy, debug, MethodDeclaration, LOG.debug("Updating info cache...");
247: Arun Murthy, debug, MethodDeclaration, LOG.debug("Done");
252: Arun Murthy, debug, MethodDeclaration, LOG.debug("Updating attr cache...");
266: Arun Murthy, debug, MethodDeclaration, LOG.debug("Done. # tags & metrics=" + numMetrics);
151: Arun Murthy, warn, IfStmt, LOG.warn(this.prefix + " metrics system already initialized!");
158: Arun Murthy, info, IfStmt, LOG.info(this.prefix + " metrics system started (again)");
168: Arun Murthy, trace, CatchClause, LOG.debug("Stacktrace: ", e);
172: Arun Murthy, info, SwitchStmt, LOG.info(prefix + " metrics system started in standby mode");
182: Arun Murthy, warn, IfStmt, LOG.warn(prefix + " metrics system already started!", new MetricsException("Illegal start"));
191: Arun Murthy, info, MethodDeclaration, LOG.info(prefix + " metrics system started");
199: Arun Murthy, warn, IfStmt, LOG.warn(prefix + " metrics system not yet started!", new MetricsException("Illegal stop"));
205: Arun Murthy, info, IfStmt, LOG.info(prefix + " metrics system stopped (again)");
210: Arun Murthy, info, MethodDeclaration, LOG.info("Stopping " + prefix + " metrics system...");
216: Arun Murthy, info, MethodDeclaration, LOG.info(prefix + " metrics system stopped.");
231: Arun Murthy, debug, MethodDeclaration, LOG.debug(finalName + ", " + finalDesc);
269: Eli Collins, debug, MethodDeclaration, LOG.debug("Registered source " + name);
274: Arun Murthy, debug, MethodDeclaration, LOG.debug(name + ", " + description);
276: Arun Murthy, warn, IfStmt, LOG.warn("Sink " + name + " already exists!");
301: Arun Murthy, info, MethodDeclaration, LOG.info("Registered sink " + name);
323: cnauroth, warn, CatchClause, LOG.warn("Caught exception in callback " + method.getName(), e);
358: Arun Murthy, warn, IfStmt, LOG.warn(prefix + " metrics system timer already started!");
370: Jonathan Eagles, Error, CatchClause, LOG.warn("Error invoking metrics timer", e);
374: Brahma Reddy Battula, info, MethodDeclaration, LOG.info("Scheduled Metric snapshot period at " + (period / 1000) + " second(s).");
422: Arun Murthy, debug, MethodDeclaration, LOG.debug("Snapshotted source " + sa.name());
449: Arun Murthy, warn, IfStmt, LOG.warn(prefix + " metrics system timer already stopped!");
459: Eli Collins, debug, ForeachStmt, LOG.debug("Stopping metrics source " + entry.getKey() + ": class=" + sa.source().getClass());
470: Eli Collins, debug, ForeachStmt, LOG.debug("Stopping metrics sink " + entry.getKey() + ": class=" + sa.sink().getClass());
508: Arun Murthy, Error, CatchClause, LOG.warn("Error creating sink '" + sinkName + "'", e);
551: Arun Murthy, Error, CatchClause, LOG.error("Error getting localhost name. Using 'localhost'...", e);
587: Arun Murthy, debug, MethodDeclaration, LOG.debug("refCount=" + refCount);
589: Todd Lipcon, debug, IfStmt, LOG.debug("Redundant shutdown", new Throwable());
596: Arun Murthy, Error, CatchClause, LOG.warn("Error stopping the metrics system", e);
607: Arun Murthy, info, MethodDeclaration, LOG.info(prefix + " metrics system shutdown complete.");
627: Arun Murthy, debug, MethodDeclaration, LOG.debug("from system property: " + System.getProperty(MS_INIT_MODE_KEY));
628: Arun Murthy, debug, MethodDeclaration, LOG.debug("from environment variable: " + System.getenv(MS_INIT_MODE_KEY));
50: Akira Ajisaka, info, IfStmt, LOG.info("Metrics intern cache overflow at {} for {}", size(), e);
70: Akira Ajisaka, info, IfStmt, LOG.info("Metrics intern cache overflow at {} for {}", size(), e);
81: Arun Murthy, Error, CatchClause, LOG.error("Error invoking method " + method.getName(), ex);
117: Arun Murthy, Error, CatchClause, LOG.error("Error invoking method " + method.getName(), ex);
133: Arun Murthy, Error, CatchClause, LOG.error("Error invoking method " + method.getName(), ex);
110: Arun Murthy, Error, CatchClause, LOG.warn("Error accessing field " + field, e);
143: Arun Murthy, Error, CatchClause, LOG.warn("Error accessing field " + field + " annotated with" + annotation, e);
43: Arun Murthy, debug, IfStmt, LOG.debug("field " + field + " with annotation " + annotation);
93: Arun Murthy, debug, IfStmt, LOG.debug("method " + method + " with annotation " + annotation);
64: Arun Murthy, debug, ForeachStmt, LOG.debug(name);
67: Arun Murthy, Error, CatchClause, LOG.error("Error creating rate metrics for " + method.getName(), e);
75: Zhe Zhang, debug, ForeachStmt, LOG.debug(name);
101: Ravi Prakash, Error, CatchClause, LOG.warn("Error sending metrics to Graphite", e);
115: Ravi Prakash, Error, CatchClause, LOG.warn("Error flushing metrics to Graphite", e);
160: Ravi Prakash, error, IfStmt, LOG.error("Too many connection failures, would not try to connect again.");
153: Steve Loughran, Error, CatchClause, LOG.warn("Error sending metrics to StatsD", e);
201: Steve Loughran, debug, MethodDeclaration, LOG.debug("Sending metric: {}", msg);
117: Luke Lu, debug, MethodDeclaration, LOG.debug("Initializing the GangliaSink for Ganglia metrics.");
130: Akira Ajisaka, error, CatchClause, LOG.error(uhe.toString());
158: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
151: cnauroth, info, IfStmt, LOG.info("Enabling multicast for Ganglia with TTL " + multicastTtl);
183: Luke Lu, error, IfStmt, LOG.error("Invalid propertylist for " + gtype.name());
231: Luke Lu, warn, IfStmt, LOG.warn("Metric name " + name + ", value " + value + " has no type.");
228: Luke Lu, warn, IfStmt, LOG.warn("Metric name " + name + " was emitted with a null value.");
225: Luke Lu, warn, IfStmt, LOG.warn("Metric was emitted with no name.");
236: Luke Lu, debug, IfStmt, LOG.debug("Emitting metric " + name + ", type " + type + ", value " + value + ", slope " + gSlope.name() + " from hostname " + getHostName());
59: Luke Lu, warn, IfStmt, LOG.warn("Metric name " + name + ", value " + value + " has no type.");
56: Luke Lu, warn, IfStmt, LOG.warn("Metric name " + name + " was emitted with a null value.");
53: Luke Lu, warn, IfStmt, LOG.warn("Metric was emitted with no name.");
64: Luke Lu, debug, IfStmt, LOG.debug("Emitting metric " + name + ", type " + type + ", value " + value + ", slope " + gSlope.name() + " from hostname " + getHostName());
105: Uma Maheswara Rao G, warn, IfStmt, LOG.warn("Failed to register MBean \"" + name + "\": Instance already exists.");
103: Uma Maheswara Rao G, trace, IfStmt, LOG.trace("Failed to register MBean \"" + name + "\"", iaee);
109: Uma Maheswara Rao G, warn, CatchClause, LOG.warn("Failed to register MBean \"" + name + "\"", e);
99: Uma Maheswara Rao G, debug, TryStmt, LOG.debug("Registered " + name);
136: Arun Murthy, debug, MethodDeclaration, LOG.debug("Unregistering " + mbeanName);
139: Arun Murthy, trace, IfStmt, LOG.debug("Stacktrace: ", new Throwable());
145: Arun Murthy, Error, CatchClause, LOG.warn("Error unregistering " + mbeanName, e);
165: Arun Murthy, Error, CatchClause, LOG.warn("Error creating MBean object name: " + nameStr, e);
58: Arun Murthy, warn, IfStmt, LOG.warn("Metrics cache overflow at " + size() + " for " + eldest);
182: Steve Loughran, warn, CatchClause, LOG.warn("I/O error finding interface {}", strInterface, e);
267: Steve Loughran, warn, IfStmt, LOG.warn("Unable to determine hostname for interface {}", strInterface);
285: Steve Loughran, warn, CatchClause, LOG.warn("Unable to determine local hostname -falling back to '{}'", LOCALHOST, e);
308: Steve Loughran, warn, CatchClause, LOG.warn("Unable to determine address of the host " + "-falling back to '{}' address", LOCALHOST, e);
314: Steve Loughran, error, CatchClause, LOG.error("Unable to determine local loopback address of '{}' " + "-this system's network configuration is unsupported", LOCALHOST, e);
433: Steve Loughran, warn, CatchClause, LOG.warn("I/O error finding interface {}: {}", strInterface, e.getMessage());
545: Thomas White, info, IfStmt, LOG.info("Detected a loopback TCP socket, disconnecting it");
834: Arpit Agarwal, warn, CatchClause, LOG.warn("Unable to wrap exception of type {}: it has no (String) " + "constructor", clazz, e);
917: Eli Collins, error, CatchClause, LOG.error("Unable to get host interfaces", e);
132: Andrew Wang, Error, IfStmt, LOG.error("Error: can't add leaf node {} at depth {} to topology:{}\n", NodeBase.getPath(node), newDepth, this);
145: Owen O'Malley, info, IfStmt, LOG.info("Adding a new node: " + NodeBase.getPath(node));
155: Andrew Wang, debug, TryStmt, LOG.debug("NetworkTopology became:\n{}", this);
219: Owen O'Malley, info, MethodDeclaration, LOG.info("Removing a node: " + NodeBase.getPath(node));
228: Andrew Wang, debug, TryStmt, LOG.debug("NetworkTopology became:\n{}", this);
331: Sangjin Lee, warn, IfStmt, LOG.warn("One of the nodes is a null pointer");
358: Owen O'Malley, warn, IfStmt, LOG.warn("The cluster does not contain node: " + NodeBase.getPath(node1));
362: Owen O'Malley, warn, IfStmt, LOG.warn("The cluster does not contain node: " + NodeBase.getPath(node2));
382: Sangjin Lee, warn, IfStmt, LOG.warn("One of the nodes is a null pointer");
526: Xiao Chen, debug, IfStmt, LOG.debug("Failed to find datanode (scope=\"{}\" excludedScope=\"{}\")." + " numOfDatanodes={}", scope, excludedScope, numOfDatanodes);
538: Ming Ma, debug, MethodDeclaration, LOG.debug("Choosing random from {} available nodes on node {}," + " scope={}, excludedScope={}, excludeNodes={}. numOfDatanodes={}.", availableNodes, innerNode, scope, excludedScope, excludedNodes, numOfDatanodes);
547: Xiao Chen, debug, MethodDeclaration, LOG.debug("chooseRandom returning {}", ret);
597: Xiao Chen, debug, MethodDeclaration, LOG.debug("nthValidToReturn is {}", nthValidToReturn);
602: Xiao Chen, debug, IfStmt, LOG.debug("Chosen node {} from first random", ret);
617: Xiao Chen, debug, IfStmt, LOG.debug("Node {} is excluded, continuing.", ret);
622: Xiao Chen, error, IfStmt, LOG.error("BUG: Found lastValidNode {} but not nth valid node. " + "parentNode={}, excludedScopeNode={}, excludedNodes={}, " + "totalInScopeNodes={}, availableNodes={}, nthValidToReturn={}.", lastValidNode, parentNode, excludedScopeNode, excludedNodes, totalInScopeNodes, availableNodes, nthValidToReturn);
210: Tsz-wo Sze, info, IfStmt, LOG.info("Adding a new node: " + NodeBase.getPath(node));
217: Tsz-wo Sze, debug, IfStmt, LOG.debug("NetworkTopology became:\n" + this.toString());
235: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Removing a node: " + NodeBase.getPath(node));
249: Tsz-wo Sze, debug, IfStmt, LOG.debug("NetworkTopology became:\n" + this.toString());
198: Steve Loughran, error, IfStmt, LOG.error("Script " + scriptName + " returned " + Integer.toString(m.size()) + " values when " + Integer.toString(names.size()) + " were expected.");
229: Steve Loughran, warn, IfStmt, LOG.warn("Invalid value " + Integer.toString(maxArgs) + " for " + SCRIPT_ARG_COUNT_KEY + "; must be >= " + Integer.toString(MIN_ALLOWABLE_ARGS));
254: Steve Loughran, warn, CatchClause, LOG.warn("Exception running " + s, e);
295: Tanping Wang, warn, CatchClause, LOG.warn("Unexpected exception while closing selector : ", e);
367: Tanping Wang, info, CatchClause, LOG.info("Unexpected Exception while clearing selector : ", e);
96: Aaron Myers, warn, IfStmt, LOG.warn(NET_TOPOLOGY_TABLE_MAPPING_FILE_KEY + " not configured. ");
118: Aaron Myers, warn, CatchClause, LOG.warn(filename + " cannot be read.", e);
112: Thomas White, warn, IfStmt, LOG.warn("Line does not have two columns. Ignoring. " + line);
129: Aaron Myers, warn, IfStmt, LOG.warn("Failed to read topology table. " + NetworkTopology.DEFAULT_RACK + " will be used for all nodes.");
150: Aaron Myers, error, IfStmt, LOG.error("Failed to reload the topology table.  The cached " + "mappings will not be cleared.");
362: Todd Lipcon, error, CatchClause, LOG.error("shutdown error: ", e);
468: Akira Ajisaka, warn, CatchClause, LOG.warn(t.toString());
462: Akira Ajisaka, warn, CatchClause, LOG.warn(t.toString());
124: Colin McCabe, trace, IfStmt, LOG.trace(this + ": NotificationHandler: setting closed to " + "true for " + sock.fd);
108: Colin McCabe, trace, IfStmt, LOG.trace(this + ": NotificationHandler: doing a read on " + sock.fd);
113: Colin McCabe, trace, IfStmt, LOG.trace(this + ": NotificationHandler: got EOF on " + sock.fd);
118: Colin McCabe, trace, IfStmt, LOG.trace(this + ": NotificationHandler: read succeeded on " + sock.fd);
255: cnauroth, error, MethodDeclaration, LOG.error(thread + " terminating on unexpected exception", t);
272: Colin McCabe, debug, IfStmt, LOG.debug(this + ": closing");
371: Colin McCabe, error, IfStmt, LOG.error(this + ": error writing to notificationSockets[0]", e);
389: Colin McCabe, trace, IfStmt, LOG.trace(this + ": " + caller + " starting sendCallback for fd " + fd);
419: Colin McCabe, trace, IfStmt, LOG.trace(this + ": " + caller + ": sendCallback not " + "closing fd " + fd);
398: Colin McCabe, trace, IfStmt, LOG.trace(this + ": " + caller + ": closing fd " + fd + " at the request of the handler.");
403: Colin McCabe, trace, IfStmt, LOG.trace(this + ": " + caller + " : sendCallback processed fd " + fd + " in toRemove.");
447: Colin McCabe, debug, IfStmt, LOG.debug(this + ": starting with interruptCheckPeriodMs = " + interruptCheckPeriodMs);
506: Colin McCabe, info, CatchClause, LOG.info(toString() + " terminating on InterruptedException");
508: Colin Patrick Mccabe, error, CatchClause, LOG.error(toString() + " terminating on exception", e);
472: Colin McCabe, trace, IfStmt, LOG.trace(this + ": adding fd " + sock.fd);
491: Colin McCabe, debug, IfStmt, LOG.debug(toString() + " thread terminating.");
557: Colin McCabe, trace, IfStmt, LOG.trace(this + ": adding notificationSocket " + notificationSockets[1].fd + ", connected to " + notificationSockets[0].fd);
77: Wei-Chiu Chuang, warn, CatchClause, LOG.warn("Unable to get groups for user {} via {} because: {}", user, provider.getClass().getSimpleName(), e.toString());
79: Wei-Chiu Chuang, trace, CatchClause, LOG.debug("Stacktrace: ", e);
132: Brandon Li, error, IfStmt, LOG.error("The mapping provider, " + name + " does not have a valid class");
120: Devaraj Das, warn, IfStmt, LOG.warn("Null token ignored for " + alias);
150: Boris Shkolnik, debug, BlockStmt, LOG.debug("Group mapping impl=" + impl.getClass().getName() + "; cacheTimeout=" + cacheTimeout + "; warningDeltaMs=" + warningDeltaMs);
389: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("Potential performance problem: getGroups(user=" + user + ") " + "took " + deltaMs + " milliseconds.");
401: Boris Shkolnik, info, MethodDeclaration, LOG.info("clearing userToGroupsMap cache");
405: Boris Shkolnik, Error, CatchClause, LOG.warn("Error refreshing groups cache", e);
422: Boris Shkolnik, Error, CatchClause, LOG.warn("Error caching groups", e);
446: Tsz-wo Sze, debug, IfStmt, LOG.debug(" Creating new Groups object");
49: Jonathan Eagles, info, IfStmt, LOG.info("CORS filter not enabled. Please set " + key + " to 'true' to enable it");
50: Suresh Srinivas, debug, InitializerDeclaration, LOG.debug("Using JniBasedUnixGroupsMapping for Group resolution");
73: Colin McCabe, error, MethodDeclaration, LOG.error("error looking up the name of group " + groupId + ": " + error);
85: Suresh Srinivas, Error, IfStmt, LOG.info("Error getting groups for " + user + ": " + e.getMessage());
83: Suresh Srinivas, Error, IfStmt, LOG.debug("Error getting groups for " + user, e);
41: Colin Patrick Mccabe, debug, IfStmt, PerformanceAdvisory.LOG.debug("Falling back to shell based");
45: Robert Joseph Evans, debug, IfStmt, LOG.debug("Group mapping impl=" + impl.getClass().getName());
55: Suresh Srinivas, debug, InitializerDeclaration, LOG.debug("Using JniBasedUnixGroupsNetgroupMapping for Netgroup resolution");
121: Suresh Srinivas, Error, IfStmt, LOG.info("Error getting users for netgroup " + netgroup + ": " + e.getMessage());
119: Suresh Srinivas, Error, IfStmt, LOG.debug("Error getting users for netgroup " + netgroup, e);
40: Robert Joseph Evans, info, IfStmt, LOG.info("Falling back to shell based");
44: Robert Joseph Evans, debug, IfStmt, LOG.debug("Group mapping impl=" + impl.getClass().getName());
219: cnauroth, info, WhileStmt, LOG.info("Loading resource {}", resource);
371: cnauroth, warn, IfStmt, LOG.warn("The default cluster security is insecure");
368: cnauroth, warn, IfStmt, LOG.warn("Security is not enabled for the Hadoop cluster");
505: cnauroth, debug, IfStmt, LOG.debug(cause.toString(), cause);
651: cnauroth, debug, CatchClause, LOG.debug("Failed to reset UGI: {}", e, e);
1065: cnauroth, error, CatchClause, LOG.error(e.toString());
1068: cnauroth, error, CatchClause, LOG.error(e.toString(), e);
290: Tsz-Wo Nicholas Sze, warn, CatchClause, LOG.warn("Failed to get groups for user " + user + " (retry=" + retry + ") by " + e);
292: Tsz-Wo Nicholas Sze, TRACE, CatchClause, LOG.trace("TRACE", e);
437: Jitendra Pandey, debug, IfStmt, LOG.debug("doGetGroups(" + user + ") returned no groups because the " + "user is not found.");
466: Kai Zheng, info, CatchClause, LOG.info("Failed to get groups from the first lookup. Initiating " + "the second LDAP query using the user's DN.", e);
474: Jitendra Pandey, debug, IfStmt, LOG.debug("doGetGroups(" + user + ") returned " + groups);
528: Jitendra Pandey, debug, MethodDeclaration, LOG.debug("Ldap group query string: " + filter.toString());
627: Mingliang Liu, debug, IfStmt, LOG.debug("Usersearch baseDN: " + userbaseDN);
633: Mingliang Liu, debug, IfStmt, LOG.debug("Groupsearch baseDN: " + userbaseDN);
703: Konstantin V Shvachko, warn, CatchClause, LOG.warn("Exception while trying to get password for alias {}: {}", alias, ioe);
724: Wei-Chiu Chuang, warn, CatchClause, LOG.warn("Exception while trying to get password for alias " + alias + ": ", ioe);
181: Chris Nauroth, warn, CatchClause, LOG.warn("Credential Provider URI is invalid." + provider);
170: Chris Nauroth, debug, IfStmt, LOG.debug("Filesystem based provider" + " excluded from provider path due to recursive dependency: " + provider);
62: Arpit Agarwal, warn, CatchClause, LOG.warn("Invalid {} configured: '{}'. Using default value: '{}'", CONVERSION_RULE_KEY, value, CONVERSION_RULE_DEFAULT);
100: Devaraj Das, debug, BlockStmt, LOG.debug("Actual length is " + length);
177: Daryn Sharp, debug, IfStmt, LOG.debug("Use " + selectedAuthType.getMethod() + " authentication for protocol " + protocol.getSimpleName());
221: Steve Loughran, debug, IfStmt, LOG.debug("tokens aren't supported for this protocol" + " or user doesn't have one");
231: Steve Loughran, debug, IfStmt, LOG.debug("client isn't using kerberos");
236: Steve Loughran, debug, IfStmt, LOG.debug("protocol doesn't use kerberos");
240: Daryn Sharp, debug, IfStmt, LOG.debug("RPC Server's Kerberos principal name for protocol=" + protocol.getCanonicalName() + " is " + serverPrincipal);
251: Daryn Sharp, debug, IfStmt, LOG.debug("Creating SASL " + mechanism + "(" + method + ") " + " client to authenticate to service at " + saslServerName);
268: Steve Loughran, debug, MethodDeclaration, LOG.debug("Get token info proto:" + protocol + " info:" + tokenInfo);
293: Steve Loughran, debug, MethodDeclaration, LOG.debug("Get kerberos info proto:" + protocol + " info:" + krbInfo);
323: Aaron Myers, debug, IfStmt, LOG.debug("getting serverKey: " + serverKey + " conf value: " + conf.get(serverKey) + " principal: " + confPrincipal);
451: Daryn Sharp, debug, IfStmt, LOG.debug("Sending sasl message " + message);
588: Jitendra Nath Pandey, debug, MethodDeclaration, LOG.debug("reading next wrapped RPC packet");
609: Jitendra Nath Pandey, debug, IfStmt, LOG.debug("unwrapping token of length:" + token.length);
628: Jitendra Nath Pandey, debug, IfStmt, LOG.debug("wrapping token of length:" + len);
678: Devaraj Das, debug, BlockStmt, LOG.debug("SASL client callback: setting username: " + userName);
683: Devaraj Das, debug, BlockStmt, LOG.debug("SASL client callback: setting userPassword");
688: Devaraj Das, debug, BlockStmt, LOG.debug("SASL client callback: setting realm: " + rc.getDefaultText());
111: Daryn Sharp, debug, BlockStmt, LOG.debug("Kerberos principal name is " + fullName);
175: Daryn Sharp, debug, IfStmt, LOG.debug("Created SASL server with mechanism = " + mechanism);
310: Devaraj Das, debug, IfStmt, LOG.debug("SASL server DIGEST-MD5 callback: setting password " + "for client: " + tokenIdentifier.getUser());
328: Devaraj Das, debug, IfStmt, LOG.debug("SASL server DIGEST-MD5 callback: setting " + "canonicalized client ID: " + username);
363: Devaraj Das, debug, BlockStmt, LOG.debug("SASL server GSSAPI callback: setting " + "canonicalized client ID: " + authzid);
92: Robert Kanter, info, MethodDeclaration, LOG.info("Updating Configuration");
122: Robert Kanter, debug, IfStmt, LOG.debug("Setting " + CommonConfigurationKeys.HADOOP_SECURITY_TOKEN_SERVICE_USE_IP + " to " + flag);
430: Suresh Srinivas, warn, IfStmt, LOG.warn("Failed to get token for service " + service);
427: Mahadev Konar, debug, IfStmt, LOG.debug("Acquired token " + token);
476: Akira Ajisaka, error, CatchClause, LOG.error("Exception while getting login user", e);
541: Steve Loughran, trace, IfStmt, LOG.trace("Name lookup for " + hostname + " took " + elapsedMs + " ms.");
538: Steve Loughran, warn, IfStmt, LOG.warn("Slow name lookup for " + hostname + ". Took " + elapsedMs + " ms.");
743: Yufei Gu, error, CatchClause, LOG.error("Couldn't read Auth based on {}", configKey);
113: Brandon Li, info, IfStmt, LOG.info("User configured user account update time is less" + " than 1 minute. Use 1 minute instead.");
166: Brandon Li, info, IfStmt, LOG.info("Update cache now");
170: Brandon Li, error, CatchClause, LOG.error("Can't update the maps. Will use the old ones," + " which can potentially cause problem.", e);
188: Brandon Li, warn, MethodDeclaration, LOG.warn("\n" + header + String.format("new entry (%d, %s), existing entry: (%d, %s).%n%s%n%s", key, value, ekey, evalue, "The new entry is to be ignored for the following reason.", DUPLICATE_NAME_ID_DEBUG_INFO));
261: Brandon Li, error, CatchClause, LOG.error("Can't update " + mapName + " map");
268: Brandon Li, error, CatchClause, LOG.error("Can't close BufferedReader of command result", e1);
233: Brandon Li, debug, WhileStmt, LOG.debug("add to " + mapName + "map:" + nameId[0] + " id:" + nameId[1]);
258: Brandon Li, debug, TryStmt, LOG.debug("Updated " + mapName + " map size: " + map.size());
278: Brandon Li, error, IfStmt, LOG.error("Platform is not supported:" + OS + ". Can't update user map and group map and" + " 'nobody' will be used for any user and group.");
309: Brandon Li, info, IfStmt, LOG.info(init ? "Using " : "Reloading " + "'" + staticMappingFile + "' for static UID/GID mapping...");
599: Andrew Wang, warn, IfStmt, LOG.warn("Could not parse line '" + line + "'. Lines should be of " + "the form '[uid|gid] [remote id] [local id]'. Blank lines and " + "everything following a '#' on a line will be ignored.");
661: Brandon Li, warn, IfStmt, LOG.warn("Can't find user name for uid " + uid + ". Use default user name " + unknown);
679: Brandon Li, warn, IfStmt, LOG.warn("Can't find group name for gid " + gid + ". Use default group name " + unknown);
695: Brandon Li, info, CatchClause, LOG.info("Can't map user " + user + ". Use its string hashcode:" + uid);
708: Brandon Li, info, CatchClause, LOG.info("Can't map group " + group + ". Use its string hashcode:" + gid);
173: Miklos Szegedi, warn, IfStmt, LOG.warn("Unable to return groups for user '{}' as shell group lookup " + "command '{}' ran longer than the configured timeout limit of " + "{} seconds.", user, Joiner.on(' ').join(executor.getExecString()), timeout);
210: Miklos Szegedi, warn, CatchClause, LOG.warn("unable to return groups for user {}", user, pge);
297: Harsh J, warn, IfStmt, LOG.warn("Some group names for '{}' are not resolvable. {}", userName, errMessage);
141: Boris Shkolnik, error, CatchClause, LOG.warn("error getting users for netgroup " + netgroup, e);
186: Alejandro Abdelnur, debug, IfStmt, LOG.debug("hadoop login commit");
191: Alejandro Abdelnur, debug, IfStmt, LOG.debug("using existing subject:" + subject.getPrincipals());
198: Alejandro Abdelnur, debug, IfStmt, LOG.debug("using kerberos user:" + user);
214: Alejandro Abdelnur, debug, IfStmt, LOG.debug("using local user:" + user);
220: Steve Loughran, debug, IfStmt, LOG.debug("Using user: \"" + user + "\" with name " + user.getName());
234: Steve Loughran, debug, IfStmt, LOG.debug("User entry: \"" + userEntry.toString() + "\"");
240: Owen O'Malley, error, MethodDeclaration, LOG.error("Can't find user in " + subject);
253: Alejandro Abdelnur, debug, IfStmt, LOG.debug("hadoop login");
261: Alejandro Abdelnur, debug, IfStmt, LOG.debug("hadoop logout");
453: Devaraj Das, error, CatchClause, LOG.error("Unable to find JAAS classes:" + e.getMessage());
757: Kihwal Lee, debug, CatchClause, LOG.debug("failure to load login credentials", ioe);
730: Allen Wittenauer, info, IfStmt, LOG.info("tokenFile(" + tokenFileName + ") does not exist");
742: cnauroth, debug, IfStmt, LOG.debug("Reading credentials from location set in {}: {}", HADOOP_TOKEN_FILE_LOCATION, source.getCanonicalPath());
753: cnauroth, debug, IfStmt, LOG.debug("Loaded {} tokens", cred.numberOfTokens());
761: Robert Joseph Evans, debug, IfStmt, LOG.debug("UGI loginUser:" + loginUser);
885: Kai Zheng, warn, CatchClause, LOG.warn("Terminating renewal thread");
890: Xiao Chen, warn, CatchClause, LOG.warn("Exception encountered while running the renewal " + "command for {}. (TGT end time:{}, renewalFailures: {}," + "renewalFailuresTotal: {})", getUserName(), tgtEndTime, metrics.renewalFailures, metrics.renewalFailuresTotal, ie);
906: Xiao Chen, error, CatchClause, LOG.error("Exception when calculating next tgt renewal time", e);
912: Xiao Chen, error, IfStmt, LOG.error("TGT is expired. Aborting renew thread for {}.", getUserName());
863: Kai Zheng, debug, IfStmt, LOG.debug("Current time is " + now);
864: Kai Zheng, debug, IfStmt, LOG.debug("Next refresh is " + nextRefresh);
871: Wei-Chiu Chuang, debug, IfStmt, LOG.debug("Renewed ticket. kinit output: {}", output);
876: Kai Zheng, warn, IfStmt, LOG.warn("No TGT after renewal. Aborting renew thread for " + getUserName());
962: Kihwal Lee, info, MethodDeclaration, LOG.info("Login successful for user " + user + " using keytab file " + path);
989: Xiaoyu Yao, debug, IfStmt, LOG.debug("Initiating logout for " + getUserName());
1000: Kihwal Lee, info, MethodDeclaration, LOG.info("Logout successful for user " + getUserName() + " using keytab file " + keytabFile);
1029: Steve Loughran, warn, IfStmt, LOG.warn("The first kerberos ticket is not TGT" + "(the server principal is {}), remove and destroy it.", ticket.getServer());
1037: Steve Loughran, warn, CatchClause, LOG.warn("destroy ticket failed", e);
1026: Jitendra Pandey, warn, IfStmt, LOG.warn("Ticket is already destroyed, remove it.");
1045: Steve Loughran, Warn, MethodDeclaration, LOG.warn("Warning, no kerberos ticket found while attempting to renew ticket");
1125: Tsz-wo Sze, debug, IfStmt, LOG.debug("Initiating logout for " + getUserName());
1136: Tsz-wo Sze, debug, IfStmt, LOG.debug("Initiating re-login for " + getUserName());
1174: Devaraj Das, warn, IfStmt, LOG.warn("Not attempting to re-login since the last re-login was " + "attempted less than " + (kerberosMinSecondsBeforeRelogin / 1000) + " seconds before. Last Login=" + user.getLastLogin());
1544: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Failed to get groups for user " + getShortUserName() + " by " + ie);
1546: Tsz-Wo Nicholas Sze, TRACE, IfStmt, LOG.trace("TRACE", ie);
1687: Tsz-wo Sze, debug, IfStmt, LOG.debug("PrivilegedActionException as:" + this + " cause:" + cause);
1710: Alejandro Abdelnur, debug, IfStmt, LOG.debug("PrivilegedAction as:" + this + " from:" + where);
1724: Xiaoyu Yao, debug, IfStmt, log.debug(caption + " UGI: " + ugi);
1726: Xiaoyu Yao, debug, ForeachStmt, log.debug("+token:" + token);
165: Andrew Wang, debug, IfStmt, LOG.debug("backing jks path initialized to " + path);
284: Andrew Wang, debug, IfStmt, LOG.debug("Keystore hasn't changed, returning.");
287: Andrew Wang, debug, TryStmt, LOG.debug("Writing out keystore.");
69: Andrew Wang, debug, IfStmt, LOG.debug("using '" + file + "' for output stream.");
130: Andrew Wang, debug, IfStmt, LOG.debug("initialized local file as '" + file + "'.");
142: Andrew Wang, debug, IfStmt, LOG.debug("the local file does not exist.");
132: Andrew Wang, debug, IfStmt, LOG.debug("the local file exists and is size " + file.length());
135: Andrew Wang, trace, IfStmt, LOG.trace("we can read the local file.");
138: Andrew Wang, trace, IfStmt, LOG.trace("we can write the local file.");
154: Andrew Wang, debug, IfStmt, LOG.debug("Resetting permissions to '" + permissions + "'");
123: Harsh J, warn, IfStmt, AUDITLOG.warn(AUTHZ_FAILED_FOR + user + " for protocol=" + protocol + cause);
132: Benoy Antony, warn, IfStmt, AUDITLOG.warn(AUTHZ_FAILED_FOR + " for protocol=" + protocol + " from host = " + hostAddress);
138: Eli Collins, info, MethodDeclaration, AUDITLOG.info(AUTHZ_SUCCESSFUL_FOR + user + " for protocol=" + protocol);
113: Jonathan Eagles, debug, IfStmt, LOG.debug("Header origin is null. Returning");
120: Jonathan Eagles, debug, IfStmt, LOG.debug("Header origins '" + originsList + "' not allowed. Returning");
129: Jonathan Eagles, debug, IfStmt, LOG.debug("Access control method '" + accessControlRequestMethod + "' not allowed. Returning");
139: Jonathan Eagles, debug, IfStmt, LOG.debug("Access control headers '" + accessControlRequestHeaders + "' not allowed. Returning");
146: Jonathan Eagles, debug, IfStmt, LOG.debug("Completed cross origin filter checks. Populating " + "HttpServletResponse");
174: Zhijie Shen, info, MethodDeclaration, LOG.info("Allowed Methods: " + getAllowedMethodsHeader());
185: Zhijie Shen, info, MethodDeclaration, LOG.info("Allowed Headers: " + getAllowedHeadersHeader());
197: Zhijie Shen, info, MethodDeclaration, LOG.info("Allowed Origins: " + StringUtils.join(allowedOrigins, ','));
198: Zhijie Shen, info, MethodDeclaration, LOG.info("Allow All Origins: " + allowAllOrigins);
203: Allen Wittenauer, warn, ForeachStmt, LOG.warn("Allowed Origin pattern '" + discouragedAllowedOrigin + "' is discouraged, use the 'regex:' prefix and use a Java regular expression instead.");
212: Zhijie Shen, info, MethodDeclaration, LOG.info("Max Age: " + maxAge);
89: cnauroth, info, MethodDeclaration, LOG.info("Adding cross-site request forgery (CSRF) protection, " + "headerName = {}, methodsToIgnore = {}, browserUserAgents = {}", headerName, methodsToIgnore, browserUserAgents);
170: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug(mode.toString() + " KeyStore: " + keystoreLocation);
180: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug(mode.toString() + " Loaded KeyStore: " + keystoreLocation);
230: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("The property '" + locationProperty + "' has not been set, " + "no TrustStore will be loaded");
216: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug(mode.toString() + " TrustStore: " + truststoreLocation);
225: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug(mode.toString() + " Loaded TrustStore: " + truststoreLocation);
246: Alejandro Abdelnur, warn, CatchClause, LOG.warn("Exception while trying to get password for alias " + alias + ": " + ioe.getMessage());
173: Alejandro Abdelnur, debug, TryStmt, LOG.debug("Loaded truststore '" + file + "'");
203: Jitendra Pandey, ERROR, CatchClause, LOG.warn(RELOAD_ERROR_MESSAGE + ex.toString(), ex);
145: John Zhuge, debug, IfStmt, LOG.debug("will exclude cipher suites: {}", StringUtils.join(",", excludeCiphers));
259: Zhe ZHang, debug, IfStmt, LOG.debug("Disabling cipher suite {}.", cipherName);
357: Xiaoyu Yao, error, CatchClause, LOG.error("Host check error {}", e);
367: Xiaoyu Yao, trace, IfStmt, LOG.trace("Hosts:{}, CNs:{} subjectAlts:{}, ie6:{}, " + "strictWithSubDomains{}", Arrays.toString(hosts), Arrays.toString(cns), Arrays.toString(subjectAlts), ie6, strictWithSubDomains);
182: Ravi Prakash, error, IfStmt, LOG.error(message);
194: Ravi Prakash, error, IfStmt, LOG.error(message);
200: Ravi Prakash, info, IfStmt, LOG.info("Add token with service " + alias);
267: Ravi Prakash, info, IfStmt, LOG.info("Canceled " + token.getKind() + ":" + token.getService());
291: Ravi Prakash, info, IfStmt, LOG.info("Renewed" + token.getKind() + ":" + token.getService() + " until " + formatDate(result));
99: Ravi Prakash, warn, IfStmt, LOG.warn("-principal and -keytab not both specified!  " + "Kerberos login not attempted.");
168: Ravi Prakash, error, IfStmt, LOG.error("Must provide a filename to all commands.");
152: Ravi Prakash, error, IfStmt, LOG.error("-format must be '" + DtFileOperations.FORMAT_JAVA + "' or '" + DtFileOperations.FORMAT_PB + "' not '" + format + "'");
224: Ravi Prakash, error, IfStmt, LOG.error("Only provide -service with http/https URL.");
228: Ravi Prakash, error, IfStmt, LOG.error("Must provide -service with http/https URL.");
232: Ravi Prakash, error, IfStmt, LOG.error("URL does not contain a service specification: " + url);
258: Allen Wittenauer, error, IfStmt, LOG.error("must pass -service field with dtutil edit command");
262: Allen Wittenauer, error, IfStmt, LOG.error("must pass -alias field with dtutil edit command");
311: Ravi Prakash, error, IfStmt, LOG.error("-alias flag is not optional for remove or cancel");
341: Ravi Prakash, error, IfStmt, LOG.error("-alias flag is not optional for renew");
156: Andrew Wang, debug, IfStmt, LOG.debug("Cannot find class for token kind " + kind);
265: Wei-Chiu Chuang, debug, IfStmt, LOG.debug("Cloned private token " + this + " from " + publicToken);
470: Jitendra Nath Pandey, warn, MethodDeclaration, LOG.warn("No TokenRenewer defined for token kind " + this.kind);
320: Yongjun Zhang, warn, IfStmt, LOG.warn("No KEY found for persisted identifier " + formatTokenId(identifier));
343: Owen O'Malley, info, MethodDeclaration, LOG.info("Updating the current master key for generating delegation tokens");
403: Yongjun Zhang, info, MethodDeclaration, LOG.info("Creating password for identifier: " + formatTokenId(identifier) + ", currentKey: " + currentKey.getKeyId());
411: Yongjun Zhang, error, CatchClause, LOG.error("Could not store token " + formatTokenId(identifier) + "!!", ioe);
491: Yongjun Zhang, info, MethodDeclaration, LOG.info("Token renewal for identifier: " + formatTokenId(id) + "; total currentTokens " + currentTokens.size());
550: Yongjun Zhang, info, MethodDeclaration, LOG.info("Token cancellation requested for identifier: " + formatTokenId(id));
638: Xiao Chen, info, ForeachStmt, LOG.info("Removing expired token " + formatTokenId(ident));
645: Owen O'Malley, debug, BlockStmt, LOG.debug("Stopping expired delegation token remover thread");
675: Owen O'Malley, info, MethodDeclaration, LOG.info("Starting expired delegation token remover thread, " + "tokenRemoverScanInterval=" + tokenRemoverScanInterval / (60 * 1000) + " min(s)");
700: Arpit Agarwal, error, CatchClause, LOG.error("ExpiredTokenRemover thread received unexpected exception", t);
686: Tanping Wang, error, CatchClause, LOG.error("Master key updating failed: ", e);
696: Arpit Agarwal, error, CatchClause, LOG.error("ExpiredTokenRemover received " + ie);
181: Alejandro Abdelnur, info, IfStmt, LOG.info("Connecting to ZooKeeper without authentication");
172: Alejandro Abdelnur, info, IfStmt, LOG.info("Connecting to ZooKeeper with SASL/Kerberos" + "and using 'sasl' ACLs");
409: Xiao Chen, info, MethodDeclaration, LOG.info("Starting to load {} cache.", cacheName);
426: Xiao Chen, info, CatchClause, LOG.info("Ignoring node {} because it failed to load.", child.getPath());
428: Xiao Chen, debug, CatchClause, LOG.debug("Failure exception:", e);
433: Xiao Chen, warn, IfStmt, LOG.warn("Ignored {} nodes while loading {} cache.", count, cacheName);
435: Xiao Chen, info, MethodDeclaration, LOG.info("Loaded {} cache.", cacheName);
502: Aaron T. Myers, error, CatchClause, LOG.error("Could not stop Delegation Token Cache", e);
509: Aaron T. Myers, error, CatchClause, LOG.error("Could not stop Delegation Token Counter", e);
516: Aaron T. Myers, error, CatchClause, LOG.error("Could not stop Key Id Counter", e);
523: Aaron T. Myers, error, CatchClause, LOG.error("Could not stop KeyCache", e);
530: Alejandro Abdelnur, error, CatchClause, LOG.error("Could not stop Curator Framework", e);
538: Aaron T. Myers, error, IfStmt, LOG.error("Forcing Listener threadPool to shutdown !!");
552: Alejandro Abdelnur, debug, CatchClause, LOG.debug(nodePath + " znode already exists !!");
579: Aaron T. Myers, debug, CatchClause, LOG.debug("Thread interrupted while performing token counter increment", e);
607: Aaron T. Myers, debug, CatchClause, LOG.debug("Thread interrupted while performing keyId increment", e);
627: Alejandro Abdelnur, Error, CatchClause, LOG.error("Error retrieving key [" + keyId + "] from ZK", e);
647: Alejandro Abdelnur, error, CatchClause, LOG.error("No node in path [" + nodePath + "]");
666: Alejandro Abdelnur, Error, CatchClause, LOG.error("Error retrieving tokenInfo [" + ident.getSequenceNumber() + "] from ZK", e);
688: Xiao Chen, Error, CatchClause, LOG.error("Error retrieving tokenInfo [" + ident.getSequenceNumber() + "] from ZK", e);
722: Karthik Kambatla, error, IfStmt, LOG.error("No node in path [" + nodePath + "]");
748: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Storing ZKDTSMDelegationKey_" + key.getKeyId());
768: Alejandro Abdelnur, debug, CatchClause, LOG.debug(nodeCreatePath + " znode already exists !!");
763: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Updating non existent Key path [" + nodeCreatePath + "].. Adding new !!");
756: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Key with path [" + nodeCreatePath + "] already exists.. Updating !!");
782: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Removing ZKDTSMDelegationKey_" + key.getKeyId());
801: Alejandro Abdelnur, debug, CatchClause, LOG.debug(nodeRemovePath + " znode could not be removed!!");
798: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Attempted to delete a non-existing znode " + nodeRemovePath);
826: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Attempted to update a non-existing znode " + nodeRemovePath);
841: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Removing ZKDTSMDelegationToken_" + ident.getSequenceNumber());
858: Karthik Kambatla, debug, IfStmt, LOG.debug("Attempted to remove a non-existing znode " + nodeRemovePath);
892: Karthik Kambatla, debug, IfStmt, LOG.debug((isUpdate ? "Updating " : "Storing ") + "ZKDTSMDelegationToken_" + ident.getSequenceNumber());
291: Xiao Chen, debug, MethodDeclaration, LOG.debug("Connecting to url {} with token {} as {}", url, token, doAs);
299: Xiao Chen, debug, IfStmt, LOG.debug("Token not set, looking for delegation token. Creds:{}", creds.getAllTokens());
350: Xiao Chen, debug, MethodDeclaration, LOG.debug("Selected delegation token {} using service:{}", dToken, service);
272: Xiao Chen, warn, IfStmt, LOG.warn("Authentication exception: " + ex.getMessage());
270: Xiao Chen, debug, IfStmt, LOG.debug("Authentication exception: " + ex.getMessage(), ex);
227: Xiao Chen, trace, MethodDeclaration, LOG.trace("Processing operation for req=({}), token: {}", request.getRequestURL(), token);
241: Xiao Chen, trace, IfStmt, LOG.trace("Got token: {}.", token);
411: Xiao Chen, debug, IfStmt, LOG.debug("Falling back to {} (req={})", authHandler.getClass(), request.getRequestURL());
393: Xiao Chen, debug, IfStmt, LOG.debug("Authenticating with dt param: {}", delegationParam);
125: Xiao Chen, trace, IfStmt, LOG.trace("Delegation token found: {}", ((DelegationTokenAuthenticatedURL.Token) token).getDelegationToken());
133: Xiao Chen, trace, IfStmt, LOG.trace("hasDt={}, queryStr={}", hasDt, queryStr);
154: Xiao Chen, debug, IfStmt, LOG.debug("Authenticated from delegation token. url={}, token={}", url, token);
145: Arpit Agarwal, debug, TryStmt, LOG.debug("No delegation token found for url={}, token={}, " + "authenticating with {}", url, token, authenticator.getClass());
169: Xiaoyu Yao, debug, MethodDeclaration, LOG.debug("Creating token with ugi:{}, renewer:{}, service:{}.", ugi, renewer, service != null ? service : "");
194: Andrew Wang, debug, MethodDeclaration, LOG.debug("Renewing token:{} with renewer:{}.", token, renewer);
202: Andrew Wang, debug, MethodDeclaration, LOG.debug("Cancelling token:{} with canceler:{}.", token, canceler);
197: Steve Loughran, debug, IfStmt, LOG.debug("Service {} is started", getName());
236: Steve Loughran, debug, IfStmt, LOG.debug("Ignoring re-entrant call to stop()");
257: Steve Loughran, debug, MethodDeclaration, LOG.debug("noteFailure {}" + exception);
267: Steve Loughran, info, IfStmt, LOG.info("Service {} failed in state {}", getName(), failureState, exception);
313: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Config has been overridden during init");
413: Steve Loughran, warn, CatchClause, LOG.warn("Exception while notifying listeners of {}", this, e);
443: Steve Loughran, debug, IfStmt, LOG.debug("Service: {} entered state {}", getName(), getServiceState());
74: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Adding service " + service.getName());
105: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug(getName() + ": initing services, size=" + services.size());
116: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug(getName() + ": starting services, size=" + services.size());
130: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug(getName() + ": stopping services, size=" + numOfServicesToStop);
152: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Stopping service #" + i + ": " + service);
44: Vinod Kumar Vavilapalli, Debug, ConstructorDeclaration, log.isDebugEnabled();
61: Vinod Kumar Vavilapalli, info, MethodDeclaration, log.info("Entry to state " + service.getServiceState() + " for " + service.getName());
84: Steve Loughran, warn, CatchClause, log.warn("When stopping the service " + service.getName(), e);
104: Steve Loughran, warn, CatchClause, log.warn("When stopping the service {}", service.getName(), e);
61: Junping Du, debug, IfStmt, LOG.debug("Service {} passed in {} arguments:", getName(), args.size());
63: Junping Du, debug, ForeachStmt, LOG.debug(arg);
92: Junping Du, error, TryStmt, LOG.error("Thread {} threw an error: {}. Shutting down", thread.toString(), exception, exception);
86: Junping Du, error, IfStmt, LOG.error("Thread {} threw an error during shutdown: {}.", thread.toString(), exception, exception);
106: Junping Du, warn, MethodDeclaration, LOG.warn(message);
109: Junping Du, warn, IfStmt, LOG.warn(message);
131: Junping Du, warn, IfStmt, LOG.warn("Service did not shut down in time");
129: Junping Du, info, MethodDeclaration, LOG.info("Interrupted: {}", data);
287: Junping Du, debug, IfStmt, LOG.debug(startupShutdownMessage(serviceName, args));
288: Junping Du, debug, IfStmt, LOG.debug(argumentString);
331: Junping Du, debug, MethodDeclaration, LOG.debug("Exception raised", exitException);
428: Junping Du, debug, CatchClause, LOG.debug("Failed to load {} because it is not on the classpath", classname);
435: Junping Du, info, CatchClause, LOG.info("Failed to create {}", classname, e);
547: Junping Du, debug, MethodDeclaration, LOG.debug("Launched service {}", name);
552: Junping Du, debug, IfStmt, LOG.debug("Service {} implements LaunchableService", name);
555: Junping Du, warn, IfStmt, LOG.warn("LaunchableService {}" + " initialized in constructor before CLI arguments passed in", name);
581: Junping Du, debug, TryStmt, LOG.debug("Service {} execution returned exit code {}", name, exitCode);
629: Junping Du, debug, CatchClause, LOG.debug("No empty constructor {}", noEmptyConstructor, noEmptyConstructor);
722: Junping Du, warn, CatchClause, LOG.warn("{}", e, e);
735: Junping Du, error, MethodDeclaration, LOG.error("Uncaught exception in thread {} -exiting", thread, exception);
771: Junping Du, warn, IfStmt, LOG.warn(text);
790: Junping Du, error, IfStmt, LOG.error(text, thrown);
878: Junping Du, debug, MethodDeclaration, LOG.debug("Command line: {}", argString);
891: Junping Du, debug, TryStmt, LOG.debug("Remaining arguments {}", remainingArgs);
901: Junping Du, debug, ForeachStmt, LOG.debug("Configuration files {}", file);
909: Junping Du, debug, IfStmt, LOG.debug("Configuration classes {}", classnameList);
948: Junping Du, debug, ForeachStmt, LOG.debug("Conf file {}", file.getAbsolutePath());
73: Junping Du, info, CatchClause, LOG.info("Failed to unregister shutdown hook: {}", e, e);
107: Junping Du, Error, CatchClause, LOG.info("Error stopping {}", service.getName(), t);
176: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Set service principal: {}", servicePrincipal);
76: Colin Patrick Mccabe, info, CatchClause, LOG.info("Failed to add SpanReceiver " + info.getClassName() + " with configuration " + configStringBuilder.toString(), e);
81: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Successfully added SpanReceiver " + info.getClassName() + " with configuration " + configStringBuilder.toString());
93: Colin Patrick Mccabe, info, IfStmt, LOG.info("Successfully removed SpanReceiver " + spanReceiverId + " with class " + receiver.getClass().getName());
98: Ming Ma, info, ConstructorDeclaration, LOG.info("classpath: " + Arrays.toString(urls));
99: Jason Darrell Lowe, info, ConstructorDeclaration, LOG.info("system classes: " + this.systemClasses);
136: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Remove leading / off " + name);
148: Jason Darrell Lowe, debug, IfStmt, LOG.debug("getResource(" + name + ")=" + url);
165: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Loading class: " + name);
182: Akira Ajisaka, debug, IfStmt, LOG.debug(e.toString());
178: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Loaded class: " + name + " ");
191: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Loaded class from parent: " + name + " ");
113: Dhruba Borthakur, info, MethodDeclaration, LOG.info("Shutting down all AsyncDiskService threads...");
138: Dhruba Borthakur, warn, IfStmt, LOG.warn("AsyncDiskService awaitTermination timeout.");
142: Dhruba Borthakur, info, MethodDeclaration, LOG.info("All AsyncDiskService threads are terminated.");
151: Dhruba Borthakur, info, MethodDeclaration, LOG.info("Shutting down all AsyncDiskService threads immediately...");
143: Lei Xu, error, MethodDeclaration, LOG.error("Could not submit task to executor {}", executor.toString());
87: Xiao Chen, debug, ConstructorDeclaration, LOG.debug("crcPolynomial=0x{}, precomputedMonomialForHint=0x{}, " + "bytesPerCrcHint={}, stripeLength={}", Integer.toString(crcPolynomial, 16), Integer.toString(precomputedMonomialForHint, 16), bytesPerCrcHint, stripeLength);
101: Steve Loughran, error, CatchClause, LOG.error("CRC32C creation failed, switching to PureJavaCrc32C", e);
209: Junping Du, debug, IfStmt, LOG.debug("Exiting with status {}: {}", status, msg, ee);
210: Junping Du, info, IfStmt, LOG.info("Exiting with status {}: {}", status, msg);
213: Junping Du, error, IfStmt, LOG.error("Terminate called", ee);
235: Junping Du, debug, IfStmt, LOG.debug("Halt with status {}: {}", status, msg, ee);
236: Junping Du, info, IfStmt, LOG.info("Halt with status {}: {}", status, msg, msg);
242: Junping Du, error, IfStmt, LOG.error("Halt called", ee);
111: Akira Ajisaka, error, CatchClause, LOG.error(ioe.toString());
107: Arpit Agarwal, debug, IfStmt, LOG.debug("Missing ip list file : " + fileName);
101: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Loaded IP list of size = " + lines.size() + " from file = " + fileName);
349: Tsz-wo Sze, debug, IfStmt, LOG.debug("setting conf tokensFile: " + fileName);
377: Thomas White, warn, IfStmt, LOG.warn("The libjars file " + tmp + " is not on the local " + "filesystem. It will not be added to the local classpath.");
498: Sangjin Lee, warn, IfStmt, LOG.warn(path + " does not have jars in it. It will be ignored.");
575: Owen O'Malley, warn, CatchClause, LOG.warn("options parsing failed: " + e.getMessage());
100: Tsz-Wo Nicholas Sze, info, IfStmt, LOG.info("Adding a node \"" + nodes[i] + "\" to the list of " + type + " hosts from " + filename);
175: Akira Ajisaka, error, CatchClause, LOG.error("error parsing " + filename, e);
169: Junping Du, info, ForeachStmt, LOG.info("Adding a node \"" + host + "\" to the list of " + type + " hosts from " + filename);
189: Jian He, info, MethodDeclaration, LOG.info("Refreshing hosts (include/exclude) list");
211: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Refreshing hosts (include/exclude) list");
282: Owen O'Malley, info, MethodDeclaration, LOG.info("Setting the includes file to " + includesFile);
290: Owen O'Malley, info, MethodDeclaration, LOG.info("Setting the excludes file to " + excludesFile);
299: Rohith Sharma K S, info, MethodDeclaration, LOG.info("Setting the includes file to " + includesFile);
300: Rohith Sharma K S, info, MethodDeclaration, LOG.info("Setting the excludes file to " + excludesFile);
143: Chris Douglas, warn, MethodDeclaration, logger.warn(String.format("Lock held time above threshold: " + "lock identifier: %s " + "lockHeldTimeMs=%d ms. Suppressed %d lock warnings. " + "The stack trace is: %s", name, lockHeldTime, suppressed, StringUtils.getStackTrace(Thread.currentThread())));
118: Steve Loughran, error, CatchClause, LOG.error("Exception while parsing json : {}\n{}", e, json, e);
155: Steve Loughran, error, CatchClause, LOG.error("Exception while parsing json file {}", jsonFile, e);
190: Steve Loughran, error, CatchClause, LOG.error("Exception while parsing json resource {}", resource, e);
188: Lei Xu, info, MethodDeclaration, LOG.info("Starting JVM pause monitor");
205: Colin McCabe, info, IfStmt, LOG.info(formatMessage(extraSleepTime, gcTimesAfterSleep, gcTimesBeforeSleep));
201: Colin McCabe, warn, IfStmt, LOG.warn(formatMessage(extraSleepTime, gcTimesAfterSleep, gcTimesBeforeSleep));
61: Andrew Wang, debug, MethodDeclaration, LOG.debug("Creating key provider with config key {}", configKeyName);
70: Xiao Chen, info, IfStmt, LOG.info("KeyProvider is created with uri: {}. This should happen only " + "in tests.", providerUriStr);
227: Xiao Chen, debug, MethodDeclaration, LOG.debug("Creating key provider from token service value {}. ", tokenServiceValue);
232: Xiao Chen, info, IfStmt, LOG.info("KeyProvider is created with uri: {}. This should happen only " + "in tests.", tokenServiceValue);
90: Harsh J, debug, IfStmt, LOG.debug("recommended=" + recommended_length + ", actual=" + actual);
395: Suresh Srinivas, info, MethodDeclaration, LOG.info("Computing capacity for map " + mapName);
396: Suresh Srinivas, info, MethodDeclaration, LOG.info("VM type       = " + vmBit + "-bit");
397: Suresh Srinivas, info, MethodDeclaration, LOG.info(percentage + "% max memory " + StringUtils.TraditionalBinaryPrefix.long2String(maxMemory, "B", 1) + " = " + StringUtils.TraditionalBinaryPrefix.long2String((long) percentMemory, "B", 1));
402: Suresh Srinivas, info, MethodDeclaration, LOG.info("capacity      = 2^" + exponent + " = " + c + " entries");
51: Andrew Wang, info, IfStmt, LOGGER.info(msg);
49: Andrew Wang, info, IfStmt, LOG.info(msg);
59: Andrew Wang, warn, IfStmt, LOGGER.warn(msg, t);
57: Andrew Wang, warn, IfStmt, LOG.warn(msg, t);
67: Andrew Wang, debug, IfStmt, LOGGER.debug("", t);
65: Andrew Wang, debug, IfStmt, LOG.debug(t);
75: Andrew Wang, error, IfStmt, LOGGER.error(msg);
73: Andrew Wang, error, IfStmt, LOG.error(msg);
112: Arpit Agarwal, warn, CatchClause, LOG.warn("Invalid CIDR syntax : " + hostEntry);
44: Tsz-wo Sze, debug, IfStmt, LOG.debug("Trying to load the custom-built native-hadoop library...");
53: Aaron Myers, debug, IfStmt, LOG.debug("Failed to load native-hadoop with error: " + t);
54: Aaron Myers, debug, IfStmt, LOG.debug("java.library.path=" + System.getProperty("java.library.path"));
48: Eli Collins, debug, TryStmt, LOG.debug("Loaded the native-hadoop library");
60: Owen O'Malley, warn, IfStmt, LOG.warn("Unable to load native-hadoop library for your platform... " + "using builtin-java classes where applicable");
135: Steve Loughran, debug, CatchClause, LOG.debug("No Winutils: ", e);
117: Todd Lipcon, warn, CatchClause, LOG.warn("Caught exception : " + e.getMessage());
319: Allen Wittenauer, info, MethodDeclaration, LOG.info("health status being set as " + output);
326: Allen Wittenauer, info, MethodDeclaration, LOG.info("health status being set as " + output);
101: Owen O'Malley, warn, IfStmt, LOG.warn("Sum of weightages can not be more than 1.0; But sum = " + sum);
185: Jason Lowe, debug, IfStmt, LOG.debug("Illegal progress value found, progress is " + "Float.POSITIVE_INFINITY. Progress will be changed to 1");
180: Jason Lowe, debug, IfStmt, LOG.debug("Illegal progress value found, progress is larger than 1." + " Progress will be changed to 1");
175: Jason Lowe, debug, IfStmt, LOG.debug("Illegal progress value found, progress is less than 0." + " Progress will be changed to 0");
170: Jason Lowe, debug, IfStmt, LOG.debug("Illegal progress value found, progress is " + "Float.NEGATIVE_INFINITY. Progress will be changed to 0");
165: Jason Lowe, debug, IfStmt, LOG.debug("Illegal progress value found, progress is Float.NaN. " + "Progress will be changed to 0");
225: Steve Loughran, info, TryStmt, log.info(buffer.toString(Charset.defaultCharset().name()));
254: Haohui Mai, info, TryStmt, log.info(buffer.toString(Charset.defaultCharset().name()));
132: Jason Lowe, warn, IfStmt, LOG.warn("Could not set last modfied time for {} file(s)", numOfFailedLastModifiedSet);
199: Arpit Agarwal, warn, IfStmt, LOG.warn("Could not set last modfied time for {} file(s)", numOfFailedLastModifiedSet);
521: Steve Loughran, debug, IfStmt, LOG.debug("Failed to detect a valid hadoop home directory", ioe);
694: Steve Loughran, warn, CatchClause, LOG.warn("Did not find {}: {}", WINUTILS_EXE, e);
696: Steve Loughran, debug, CatchClause, LOG.debug("Failed to find " + WINUTILS_EXE, e);
770: Jason Lowe, warn, CatchClause, LOG.warn("Interrupted, unable to determine if bash is supported", iioe);
773: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Bash is not supported by the OS", ioe);
776: Steve Loughran, info, CatchClause, LOG.info("Bash execution is not allowed by the JVM " + "security manager.Considering it not supported.");
804: Steve Loughran, debug, CatchClause, LOG.debug("setsid is not available on this machine. So not using it.");
807: Steve Loughran, debug, CatchClause, LOG.debug("setsid is not allowed to run by the JVM " + "security manager. So not using it.");
822: Steve Loughran, debug, IfStmt, LOG.debug("setsid exited with exit code " + (shexec != null ? shexec.getExitCode() : "(null executor)"));
979: Harsh J, Error, IfStmt, LOG.debug("Error reading the error stream due to shell " + "command timeout", ioe);
977: Harsh J, Error, IfStmt, LOG.warn("Error reading the error stream", ioe);
989: Andrew Wang, error, CatchClause, LOG.error("Caught " + oe + ". One possible reason is that ulimit" + " setting of 'max user processes' is too low. If so, do" + " 'ulimit -u <largerNum>' and try again.");
1033: Owen O'Malley, Error, CatchClause, LOG.warn("Error while closing the input stream", ioe);
1045: Owen O'Malley, Error, CatchClause, LOG.warn("Error while closing the error stream", ioe);
1060: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Interrupted while joining on: " + t, ie);
97: Vinayakumar B, warn, CatchClause, LOG.warn("Failed to add the ShutdownHook", ex);
71: Xiaoyu Yao, warn, CatchClause, LOG.warn("ShutdownHook '" + entry.getHook().getClass().getSimpleName() + "' timeout, " + ex.toString(), ex);
74: Xiaoyu Yao, warn, CatchClause, LOG.warn("ShutdownHook '" + entry.getHook().getClass().getSimpleName() + "' failed, " + ex.toString(), ex);
87: Xiaoyu Yao, error, CatchClause, LOG.error("ShutdownHookManger interrupted while waiting for " + "termination.", ex);
82: Xiaoyu Yao, error, IfStmt, LOG.error("ShutdownHookManger shutdown forcefully.");
85: Xiaoyu Yao, debug, TryStmt, LOG.debug("ShutdownHookManger complete shutdown.");
67: Sanford Ryza, warn, CatchClause, LOG.warn("Interrupted while shutting down thread - " + thread.getName());
60: Aaron Myers, error, MethodDeclaration, LOG.error("RECEIVED SIGNAL " + signal.getNumber() + ": SIG" + signal.getName());
91: Aaron Myers, debug, CatchClause, LOG.debug(e);
95: Aaron Myers, info, MethodDeclaration, LOG.info(bld.toString());
714: Junping Du, info, MethodDeclaration, LOG.info(createStartupShutdownMessage(classname, hostname, args));
720: Aaron Myers, warn, CatchClause, LOG.warn("failed to register any UNIX signal loggers: ", t);
727: Alejandro Abdelnur, info, MethodDeclaration, LOG.info(toStartupShutdownString("SHUTDOWN_MSG: ", new String[] { "Shutting down " + classname + " at " + hostname }));
238: Karthik Kambatla, warn, CatchClause, LOG.warn("Couldn't read " + procfsMemFile + "; can't determine memory settings");
273: Karthik Kambatla, Error, CatchClause, LOG.warn("Error reading the stream " + io);
284: Karthik Kambatla, Error, CatchClause, LOG.warn("Error closing the stream " + fReader);
281: Karthik Kambatla, Error, CatchClause, LOG.warn("Error closing the stream " + in);
309: Karthik Kambatla, warn, CatchClause, LOG.warn("Couldn't read " + procfsCpuFile + "; can't determine cpu info");
339: Karthik Kambatla, Error, CatchClause, LOG.warn("Error reading the stream " + io);
350: Karthik Kambatla, Error, CatchClause, LOG.warn("Error closing the stream " + fReader);
347: Karthik Kambatla, Error, CatchClause, LOG.warn("Error closing the stream " + in);
389: Karthik Kambatla, Error, CatchClause, LOG.warn("Error reading the stream " + io);
400: Karthik Kambatla, Error, CatchClause, LOG.warn("Error closing the stream " + fReader);
397: Karthik Kambatla, Error, CatchClause, LOG.warn("Error closing the stream " + in);
444: Chris Douglas, Error, CatchClause, LOG.warn("Error reading the stream " + io);
455: Chris Douglas, Error, CatchClause, LOG.warn("Error closing the stream " + fReader);
452: Chris Douglas, Error, CatchClause, LOG.warn("Error closing the stream " + in);
514: Chris Douglas, Error, CatchClause, LOG.warn("Error reading the stream " + procfsDisksFile, e);
520: Chris Douglas, Error, CatchClause, LOG.warn("Error closing the stream " + procfsDisksFile, e);
561: Chris Douglas, Error, CatchClause, LOG.warn("Error reading the stream " + procfsDiskSectorFile, e);
568: Chris Douglas, Error, CatchClause, LOG.warn("Error closing the stream " + procfsDiskSectorFile, e);
89: Karthik Kambatla, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
137: Steve Loughran, warn, IfStmt, LOG.warn("Wrong output from sysInfo: " + sysInfoStr);
133: Steve Loughran, warn, IfStmt, LOG.warn("Expected split length of sysInfo to be " + sysInfoSplitCount + ". Got " + sysInfo.length);
130: Steve Loughran, Error, CatchClause, LOG.warn("Error parsing sysInfo", nfe);
47: Aaron Myers, warn, CatchClause, LOG.warn("interrupted while sleeping", ie);
50: Akira Ajisaka, warn, CatchClause, LoggerFactory.getLogger(getClass()).warn("Could not read '" + versionInfoFile + "', " + ex.toString(), ex);
171: Suresh Srinivas, debug, MethodDeclaration, LOG.debug("version: " + getVersion());
47: Tsz-Wo Nicholas Sze, TRACE, CatchClause, LOG.trace("TRACE", te);
50: Tsz-Wo Nicholas Sze, TRACE, CatchClause, LOG.trace("TRACE", e);
37: Varun Vasudev, debug, IfStmt, LOG.debug("afterExecute in thread: " + Thread.currentThread().getName() + ", runnable type: " + r.getClass().getName());
50: Naganarasimha, warn, CatchClause, LOG.warn("Execution exception when running task in " + Thread.currentThread().getName());
55: Varun Vasudev, warn, CatchClause, LOG.warn("Thread (" + Thread.currentThread() + ") interrupted: ", ie);
63: Varun Vasudev, warn, IfStmt, LOG.warn("Caught exception in thread " + Thread.currentThread().getName() + ": ", t);
121: Mukul Kumar Singh, Error, CatchClause, logger.error("Error during shutdown: ", e);
116: Mukul Kumar Singh, Error, CatchClause, logger.error("Error attempting to shutdown.", e);
113: Mukul Kumar Singh, error, IfStmt, logger.error("Unable to shutdown properly.");
61: Varun Vasudev, debug, IfStmt, LOG.debug("beforeExecute in thread: " + Thread.currentThread().getName() + ", runnable type: " + r.getClass().getName());
82: Varun Vasudev, debug, IfStmt, LOG.debug("beforeExecute in thread: " + Thread.currentThread().getName() + ", runnable type: " + r.getClass().getName());
230: Robert Kanter, error, CatchClause, log.error("Could not get children for path: " + path, e);
93: Subru Krishnan, error, CatchClause, LOG.error("Couldn't read ACLs based on {}", CommonConfigurationKeys.ZK_ACL);
83: Andrew Wang, info, CatchClause, LOG.info("Exception while reading test config file {}:", testConfigFile, e);
146: Konstantin Boudnik, info, MethodDeclaration, LOG.info("Detailed results:");
147: Konstantin Boudnik, info, MethodDeclaration, LOG.info("----------------------------------\n");
156: Konstantin Boudnik, info, IfStmt, LOG.info("-------------------------------------------");
157: Konstantin Boudnik, info, IfStmt, LOG.info("                    Test ID: [" + (i + 1) + "]");
158: Konstantin Boudnik, info, IfStmt, LOG.info("           Test Description: [" + td.getTestDesc() + "]");
159: Konstantin Boudnik, info, IfStmt, LOG.info("");
163: Konstantin Boudnik, info, ForeachStmt, LOG.info("              Test Commands: [" + expandCommand(cmd.getCmd()) + "]");
167: Konstantin Boudnik, info, IfStmt, LOG.info("");
170: Konstantin Boudnik, info, ForeachStmt, LOG.info("           Cleanup Commands: [" + expandCommand(cmd.getCmd()) + "]");
174: Konstantin Boudnik, info, IfStmt, LOG.info("");
178: Konstantin Boudnik, info, ForeachStmt, LOG.info("                 Comparator: [" + cd.getComparatorType() + "]");
180: Konstantin Boudnik, info, ForeachStmt, LOG.info("         Comparision result:   [" + (resultBoolean ? "pass" : "fail") + "]");
182: Konstantin Boudnik, info, ForeachStmt, LOG.info("            Expected output:   [" + expandCommand(cd.getExpectedOutput()) + "]");
184: Konstantin Boudnik, info, ForeachStmt, LOG.info("              Actual output:   [" + cd.getActualOutput() + "]");
187: Konstantin Boudnik, info, IfStmt, LOG.info("");
191: Konstantin Boudnik, info, MethodDeclaration, LOG.info("Summary results:");
192: Konstantin Boudnik, info, MethodDeclaration, LOG.info("----------------------------------\n");
212: Konstantin Boudnik, info, MethodDeclaration, LOG.info("               Testing mode: " + testMode);
213: Konstantin Boudnik, info, MethodDeclaration, LOG.info("");
214: Konstantin Boudnik, info, MethodDeclaration, LOG.info("             Overall result: " + (overallResults ? "+++ PASS +++" : "--- FAIL ---"));
222: Konstantin Boudnik, info, IfStmt, LOG.info("               # Tests pass: " + totalPass + " (" + (100 * totalPass / (totalPass + totalFail)) + "%)");
224: Konstantin Boudnik, info, IfStmt, LOG.info("               # Tests fail: " + totalFail + " (" + (100 * totalFail / (totalPass + totalFail)) + "%)");
217: Konstantin Boudnik, info, IfStmt, LOG.info("               # Tests pass: " + 0);
218: Konstantin Boudnik, info, IfStmt, LOG.info("               # Tests fail: " + 0);
228: Konstantin Boudnik, info, MethodDeclaration, LOG.info("         # Validations done: " + totalComparators + " (each test may do multiple validations)");
231: Konstantin Boudnik, info, MethodDeclaration, LOG.info("");
232: Konstantin Boudnik, info, MethodDeclaration, LOG.info("Failing tests:");
233: Konstantin Boudnik, info, MethodDeclaration, LOG.info("--------------");
239: Konstantin Boudnik, info, IfStmt, LOG.info((i + 1) + ": " + testsFromConfigFile.get(i).getTestDesc());
245: Konstantin Boudnik, info, IfStmt, LOG.info("NONE");
249: Konstantin Boudnik, info, MethodDeclaration, LOG.info("");
250: Konstantin Boudnik, info, MethodDeclaration, LOG.info("Passing tests:");
251: Konstantin Boudnik, info, MethodDeclaration, LOG.info("--------------");
255: Konstantin Boudnik, info, IfStmt, LOG.info((i + 1) + ": " + testsFromConfigFile.get(i).getTestDesc());
261: Konstantin Boudnik, info, IfStmt, LOG.info("NONE");
295: Konstantin Boudnik, Error, CatchClause, LOG.info("Error in instantiating the comparator" + e);
314: Konstantin Boudnik, info, MethodDeclaration, LOG.info("TestAll");
203: Mingliang Liu, debug, ForeachStmt, LOG_CONFIG.debug("Field: {}", f);
227: Mingliang Liu, debug, ForeachStmt, LOG_CONFIG.debug("  Value: {}", value);
253: Mingliang Liu, debug, IfStmt, LOG_CONFIG.debug("  Passes Regex: false");
256: Mingliang Liu, debug, ForeachStmt, LOG_CONFIG.debug("  Passes Regex: true");
262: Mingliang Liu, ERROR, IfStmt, LOG_CONFIG.debug("ERROR: Already found key for property " + value);
292: Mingliang Liu, debug, IfStmt, LOG_XML.debug("  Skipping Full Key: {}", key);
297: Mingliang Liu, debug, IfStmt, LOG_XML.debug("  Skipping Prefix Key: " + key);
306: Mingliang Liu, debug, IfStmt, LOG_XML.debug("  XML Key,Valid Value: " + key);
302: Mingliang Liu, debug, IfStmt, LOG_XML.debug("  XML Key,Null Value: " + key);
388: Mingliang Liu, error, CatchClause, LOG.error("{}", f, iaException);
384: Mingliang Liu, debug, IfStmt, LOG.debug("Config variable {} has unknown type {}", f.getName(), f.getType().getName());
425: Mingliang Liu, debug, MethodDeclaration, LOG_CONFIG.debug("Reading configuration classes\n");
434: Mingliang Liu, debug, MethodDeclaration, LOG_CONFIG.debug("\n=====\n");
437: Mingliang Liu, debug, MethodDeclaration, LOG_XML.debug("Reading XML property files\n");
439: Mingliang Liu, debug, MethodDeclaration, LOG_XML.debug("\n=====\n");
442: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Reading Config property files for defaults\n");
449: Mingliang Liu, debug, MethodDeclaration, LOG.debug("\n=====\n");
473: Mingliang Liu, info, ForeachStmt, LOG.info(c.toString());
475: Mingliang Liu, info, MethodDeclaration, LOG.info("({} member variables)\n", configurationMemberVariables.size());
485: Mingliang Liu, Error, MethodDeclaration, LOG.error(xmlErrorMsg.toString());
487: Mingliang Liu, info, IfStmt, LOG.info("  (None)");
491: Mingliang Liu, info, MethodDeclaration, LOG.info("\n=====\n");
507: Mingliang Liu, info, LambdaExpr, LOG.info("  {}", s);
524: Mingliang Liu, info, MethodDeclaration, LOG.info("File {} ({} properties)", xmlFilename, xmlKeyValueMap.size());
532: Mingliang Liu, Error, MethodDeclaration, LOG.info(configErrorMsg.toString());
534: Mingliang Liu, info, IfStmt, LOG.info("  (None)");
538: Mingliang Liu, info, MethodDeclaration, LOG.info("\n=====\n");
620: Mingliang Liu, info, MethodDeclaration, LOG.info("{} has {} properties that do not match the default Config value", xmlFilename, mismatchingXmlConfig.size());
628: Mingliang Liu, info, LambdaExpr, LOG.info("XML Property: {}", key);
629: Mingliang Liu, info, LambdaExpr, LOG.info("XML Value:    {}", value);
632: Mingliang Liu, info, LambdaExpr, LOG.info("Config Name:  {}", key);
633: Mingliang Liu, info, LambdaExpr, LOG.info("Config Value: {}", value);
635: Mingliang Liu, info, ForeachStmt, LOG.info("");
623: Mingliang Liu, info, IfStmt, LOG.info("  (None)");
638: Mingliang Liu, info, MethodDeclaration, LOG.info("\n");
650: Mingliang Liu, info, IfStmt, configPropertiesWithNoDefaultConfig.forEach(c -> LOG.info(" {}", c));
648: Mingliang Liu, info, IfStmt, LOG.info("  (None)");
652: Mingliang Liu, info, MethodDeclaration, LOG.info("\n");
663: Mingliang Liu, info, IfStmt, xmlPropertiesWithEmptyValue.forEach(p -> LOG.info("  {}", p));
661: Mingliang Liu, info, IfStmt, LOG.info("  (None)");
665: Mingliang Liu, info, MethodDeclaration, LOG.info("\n");
668: Mingliang Liu, info, MethodDeclaration, LOG.info("{} has {} properties which match a corresponding Config variable", xmlFilename, xmlPropertiesMatchingConfigDefault.size());
674: Mingliang Liu, info, MethodCallExpr, LOG.info("  {} / {}", key, value);
673: Mingliang Liu, info, IfStmt, xmlPropertiesMatchingConfigDefault.forEach((key, value) -> LOG.info("  {} / {}", key, value));
671: Mingliang Liu, info, IfStmt, LOG.info("  (None)");
676: Mingliang Liu, info, MethodDeclaration, LOG.info("\n=====\n");
688: Mingliang Liu, info, ForeachStmt, LOG.info("Checking if any of the default values whose name " + "contains string \"{}\" collide.", filter);
710: Mingliang Liu, info, ForeachStmt, LOG.info("Checked {} default values for collision.", valuesChecked);
78: Yi Liu, info, MethodDeclaration, LOG.info("Generated " + count + " records");
76: Alejandro Abdelnur, warn, IfStmt, LOG.warn("Skipping test since openSSL library not loaded");
95: Alejandro Abdelnur, warn, IfStmt, LOG.warn("Skipping test since openSSL library not loaded");
120: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("Created a Codec object of type: " + encCodecClass);
133: Colin McCabe, info, MethodDeclaration, LOG.info("Generated " + count + " records");
142: Colin McCabe, info, MethodDeclaration, LOG.info("Finished encrypting data");
151: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("Created a Codec object of type: " + decCodecClass);
225: Colin McCabe, info, MethodDeclaration, LOG.info("SUCCESS! Completed checking " + count + " records");
162: Walter Su, info, IfStmt, LOG.info("Current ValueQueue size is " + size);
94: Xiao Chen, info, TryStmt, LOG.info("Got tokens: {}", tokens);
96: Xiao Chen, info, TryStmt, LOG.info("uri:" + uriString);
121: Xiao Chen, info, TryStmt, LOG.info("Got tokens: {}", tokens);
156: Jason Lowe, warn, MethodDeclaration, LOG.warn("not all references have been cleaned up; still " + allDataSize.get() + " references left");
158: Jason Lowe, warn, MethodDeclaration, LOG.warn("triggering another GC");
119: Mingliang Liu, info, IfStmt, LOG.info("Deleting test root path {}", testRoot);
123: Mingliang Liu, Error, CatchClause, LOG.error("Error when deleting test root path " + testRoot, e);
129: Mingliang Liu, Error, CatchClause, LOG.error("Error when deleting localFsRootPath " + localFsRootPath, e);
94: Mingliang Liu, Error, CatchClause, LOG.error("Error deleting test dir: " + p, e);
91: Mingliang Liu, info, TryStmt, LOG.info("Deleting " + p);
114: Mingliang Liu, info, MethodDeclaration, LOG.info("Resolving {} -> {}", pathString, p);
632: Steve Loughran, info, IfStmt, LOG.info("Skipping test");
723: Steve Loughran, info, MethodDeclaration, LOG.info("testRenameChildDirForbidden");
956: Suresh Srinivas, warn, IfStmt, LOG.warn(message);
975: Suresh Srinivas, warn, ForStmt, LOG.warn(line);
800: Robert Kanter, info, CatchClause, Log.getLog().info("XXX", e);
39: Jason Lowe, info, CatchClause, LOG.info("Expected exception: ", ufse);
70: Eli Collins, info, MethodDeclaration, LOG.info("Writing FileStatuses to a ByteArrayOutputStream");
78: Eli Collins, info, MethodDeclaration, LOG.info("Creating ByteArrayInputStream object");
83: Eli Collins, info, MethodDeclaration, LOG.info("Testing if read objects are equal to written ones");
86: Colin Patrick Mccabe, info, WhileStmt, LOG.info("{}: FileSystem.Statistics={}, FileSystemStorageStatistics={}", longStat.getName(), expectedStat, longStat.getValue());
97: Colin Patrick Mccabe, info, ForeachStmt, LOG.info("{}: FileSystem.Statistics={}, FileSystemStorageStatistics={}", key, expectedStat, storageStat);
441: Sharad Agarwal, info, MethodDeclaration, LOG.info("Running test to verify failure of fullyDelete()");
481: Sharad Agarwal, info, MethodDeclaration, LOG.info("Trying to delete myFile " + getAbsolutePath());
491: Sharad Agarwal, info, IfStmt, LOG.info("Cannot delete " + getAbsolutePath());
489: Sharad Agarwal, info, IfStmt, LOG.info("Deleted " + getAbsolutePath() + " successfully");
520: Sharad Agarwal, info, MethodDeclaration, LOG.info("Running test to verify failure of fullyDeleteContents()");
1065: Suresh Srinivas, warn, CatchClause, LOG.warn("exception closing jarFile: " + classPathJar, e);
162: Haohui Mai, error, CatchClause, LOG.error("FilterFileSystem MUST implement " + m);
153: Haohui Mai, error, TryStmt, LOG.error("FilterFileSystem MUST NOT implement " + m);
59: Dhruba Borthakur, info, CatchClause, LOG.info("Testing " + m);
64: Dhruba Borthakur, error, CatchClause, LOG.error("FilterFileSystem doesn't implement " + m);
57: Dhruba Borthakur, info, TryStmt, LOG.info("Skipping " + m);
85: Andrew Wang, info, MethodDeclaration, LOG.info("exit " + exitCode + " - " + StringUtils.join(" ", args));
381: Boris Shkolnik, info, TryStmt, LOG.info("result=" + results);
60: Andrew Wang, info, MethodDeclaration, LOG.info("exit " + exitCode + " - " + StringUtils.join(" ", args));
367: Suresh Srinivas, error, CatchClause, LOG.error("HarFileSystem MUST implement " + m);
358: Suresh Srinivas, error, TryStmt, LOG.error("HarFileSystem MUST not implement " + m);
195: Steve Loughran, info, TryStmt, LOGGER.info("{}: {}", filename, getPermission(localfs, f));
207: Steve Loughran, info, IfStmt, LOGGER.info("Not testing changing the group since user " + "belongs to only one group.");
231: Steve Loughran, info, MethodDeclaration, LOGGER.info("Current umask is {}", conf.get(CommonConfigurationKeys.FS_PERMISSIONS_UMASK_KEY));
122: Chris Douglas, info, MethodDeclaration, LOG.info("owner: {}, group: {}, permission: {}, isSticky: {}", fsNIO.getOwner(), fsNIO.getGroup(), fsNIO.getPermission(), fsNIO.getPermission().getStickyBit());
80: Steve Loughran, info, IfStmt, LOG.info("skipping tests as FS name is not defined in " + getFilesystemConfKey());
121: Steve Loughran, error, IfStmt, getLog().error("dest dir {}", destDirLS);
78: Steve Loughran, info, MethodDeclaration, LOG.info("rm -r / of empty dir result is {}", deleted);
117: Steve Loughran, info, MethodDeclaration, LOG.info("rm / of empty dir result is {}", deleted);
155: Steve Loughran, info, MethodDeclaration, LOG.info("rm -rf / result is {}", deleted);
135: Steve Loughran, debug, MethodDeclaration, getLog().debug("Stream is of type " + instream.getClass().getCanonicalName());
186: Steve Loughran, warn, TryStmt, LOG.warn("Seek to -1 returned a position of " + p);
366: Steve Loughran, error, CatchClause, LOG.error(sb.toString());
485: Chris Nauroth, info, TryStmt, LOG.info("Filesystem short-circuits 0-byte reads");
504: Chris Nauroth, info, TryStmt, LOG.info("Filesystem short-circuits 0-byte reads");
60: Steve Loughran, debug, IfStmt, LOG.debug("Not loaded: {}", ContractOptions.CONTRACT_OPTIONS_RESOURCE);
58: Steve Loughran, debug, IfStmt, LOG.debug("Loaded authentication keys from {}", ContractOptions.CONTRACT_OPTIONS_RESOURCE);
175: Chris Nauroth, debug, MethodDeclaration, LOG.debug("== Setup ==");
184: Steve Loughran, info, MethodDeclaration, LOG.info("Test filesystem = {} implemented by {}", fsURI, fileSystem);
194: Chris Nauroth, debug, MethodDeclaration, LOG.debug("== Setup complete ==");
203: Chris Nauroth, debug, MethodDeclaration, LOG.debug("== Teardown ==");
205: Chris Nauroth, debug, MethodDeclaration, LOG.debug("== Teardown complete ==");
255: Steve Loughran, info, MethodDeclaration, LOG.info(text);
275: Steve Loughran, warn, MethodDeclaration, LOG.warn("The expected exception {}  was not the exception class" + " raised on {}: {}", action, e.getClass(), expectedException, e);
284: Steve Loughran, debug, MethodDeclaration, getLog().debug("expected :{}", e, e);
369: Steve Loughran, error, MethodDeclaration, getLog().error("src dir " + ContractTestUtils.ls(fs, src.getParent()));
285: Steve Loughran, warn, IfStmt, LOG.warn(message);
304: Steve Loughran, warn, ForStmt, LOG.warn(line);
376: Steve Loughran, Error, CatchClause, LOG.error("Error deleting in " + action + " - " + path + ": " + e, e);
484: Steve Loughran, debug, IfStmt, LOG.debug("==============  " + action + " =============");
496: Steve Loughran, warn, MethodDeclaration, LOG.warn("Downgrading test " + message, failure);
517: Steve Loughran, info, MethodDeclaration, LOG.info("Skipping: {}", message);
933: Steve Loughran, error, CatchClause, LOG.error("{}: not found {}; parent listing is:\n{}", message, path, ls(fileSystem, path.getParent()));
1204: Chris Nauroth, info, MethodDeclaration, LOG.info("Bandwidth = {}  MB/S", timer.bandwidthDescription(bytes));
1384: Chris Nauroth, info, ForeachStmt, LOG.info("{}{}", status.getPath(), status.isDirectory() ? "*" : "");
1690: Chris Nauroth, info, MethodDeclaration, LOG.info("Duration of {}: {} nS", String.format(format, args), toHuman(d));
265: Giridharan Kesavan, debug, BlockStmt, LOG.debug("Thread " + this.id + " moving to index " + i);
377: Brandon Li, error, CatchClause, LOG.error("Got error when checking if file exists:" + flagFile, e);
379: Brandon Li, info, MethodDeclaration, LOG.info("Flag file was created. Stopping the test.");
436: Brandon Li, debug, IfStmt, LOG.debug("Moving to index " + currentIndex + ": r = " + readProbs[currentIndex] + ", w = " + writeProbs + " for duration " + durations[currentIndex]);
447: Tsz-wo Sze, debug, IfStmt, LOG.debug("Done with testing.  Waiting for threads to finish.");
553: Brandon Li, info, IfStmt, LOG.info("got flagFile:" + flagFile);
66: Chris Douglas, info, MethodDeclaration, LOG.info("Starting testNflyWriteSimple");
104: Chris Douglas, info, MethodDeclaration, LOG.info("Starting testNflyInvalidMinReplication");
162: Andrew Wang, info, ForeachStmt, LOG.info("MountPoint: " + mountPoint.getMountedOnPath() + " => " + mountPoint.getTargetFileSystemURIs()[0]);
1246: Andrew Wang, info, CatchClause, LOG.info("Expected exception: " + e);
1256: Andrew Wang, info, CatchClause, LOG.info("Expected exception: " + e);
1265: Andrew Wang, info, CatchClause, LOG.info("Expected exception: " + e);
87: Robert Kanter, info, MethodDeclaration, Log.getLog().info("Working dir is: " + fsView.getWorkingDirectory());
121: Robert Kanter, info, IfStmt, Log.getLog().info("Added link for home dir " + homeDir + "->" + linkTarget);
126: Robert Kanter, info, MethodDeclaration, Log.getLog().info("Home dir base for viewfs" + homeDirRoot);
141: Robert Kanter, info, MethodDeclaration, Log.getLog().info("Added link for " + info + " " + firstComponent + "->" + linkTarget);
85: Robert Kanter, info, MethodDeclaration, Log.getLog().info("Working dir is: " + fc.getWorkingDirectory());
110: Robert Kanter, info, IfStmt, Log.getLog().info("Added link for home dir " + homeDir + "->" + linkTarget);
115: Robert Kanter, info, MethodDeclaration, Log.getLog().info("Home dir base for viewfs" + homeDirRoot);
131: Robert Kanter, info, MethodDeclaration, Log.getLog().info("Added link for " + info + " " + firstComponent + "->" + linkTarget);
64: Todd Lipcon, info, IfStmt, LOG.info("Cur data: no node");
56: Todd Lipcon, info, IfStmt, LOG.info("Cur data: " + StringUtils.byteToHexString(data));
185: Todd Lipcon, error, IfStmt, LOG.error("allClients never setup");
234: Todd Lipcon, info, MethodDeclaration, LOG.info("connecting to " + host + " " + port);
274: Todd Lipcon, info, CatchClause, LOG.info("server " + hp + " not up " + e);
365: Todd Lipcon, Error, CatchClause, LOG.warn("Error closing logs ", ie);
404: Todd Lipcon, info, MethodDeclaration, LOG.info("Client test setup finished");
419: Todd Lipcon, info, MethodDeclaration, LOG.info("STARTING server");
424: Todd Lipcon, info, MethodDeclaration, LOG.info("STOPPING server");
443: Todd Lipcon, warn, CatchClause, LOG.warn("ignoring interrupt", e);
452: Todd Lipcon, info, MethodDeclaration, LOG.info("tearDown starting");
295: Todd Lipcon, info, MethodDeclaration, LOG.info("tryFence(" + target + ")");
301: Todd Lipcon, info, IfStmt, LOG.info("Injected failure to fence");
120: Todd Lipcon, info, MethodDeclaration, LOG.info("Waiting for svc0 to enter active state");
125: Aaron T. Myers, info, ForStmt, LOG.info("Adding svc" + i);
243: Todd Lipcon, info, MethodDeclaration, LOG.info("Expiring svc " + idx + "'s zookeeper session " + session);
93: Todd Lipcon, info, MethodDeclaration, LOG.info("starting test with parentDir:" + PARENT_DIR);
175: Todd Lipcon, info, MethodDeclaration, LOG.info("========================== Expiring session");
187: Todd Lipcon, info, MethodDeclaration, LOG.info("========================== Quitting election");
218: Todd Lipcon, info, MethodDeclaration, LOG.info("========================== Expiring standby's session");
229: Todd Lipcon, info, MethodDeclaration, LOG.info("========================== Quitting election");
103: Todd Lipcon, info, MethodDeclaration, LOG.info("Running: HAAdmin " + Joiner.on(" ").join(args));
107: Suresh Srinivas, info, MethodDeclaration, LOG.info("Err_output:\n" + errOutput + "\nOutput:\n" + output);
69: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting health monitor");
72: Todd Lipcon, info, MethodDeclaration, LOG.info("Waiting for HEALTHY signal");
83: Todd Lipcon, info, MethodDeclaration, LOG.info("Mocking bad health check, waiting for UNHEALTHY");
87: Todd Lipcon, info, MethodDeclaration, LOG.info("Returning to healthy state, waiting for HEALTHY");
91: Todd Lipcon, info, MethodDeclaration, LOG.info("Returning an IOException, as if node went down");
102: Todd Lipcon, info, MethodDeclaration, LOG.info("Returning to healthy state, waiting for HEALTHY");
117: Todd Lipcon, info, MethodDeclaration, LOG.info("Mocking RTE in health monitor, waiting for FAILED");
139: Todd Lipcon, info, MethodDeclaration, LOG.info("Mocking bad health check, waiting for UNHEALTHY");
117: Todd Lipcon, info, MethodDeclaration, Mockito.verify(ShellCommandFencer.LOG).info(Mockito.endsWith("echo hello: hello"));
128: Todd Lipcon, warn, MethodDeclaration, Mockito.verify(ShellCommandFencer.LOG).warn(Mockito.endsWith("echo hello>&2: hello"));
144: Suresh Srinivas, info, IfStmt, Mockito.verify(ShellCommandFencer.LOG).info(Mockito.endsWith("echo %in...ng_tests%: yessir"));
140: Suresh Srinivas, info, IfStmt, Mockito.verify(ShellCommandFencer.LOG).info(Mockito.endsWith("echo $in...ing_tests: yessir"));
161: Suresh Srinivas, info, IfStmt, Mockito.verify(ShellCommandFencer.LOG).info(Mockito.endsWith("echo %ta...get_port%: dummyhost 1234"));
157: Suresh Srinivas, info, IfStmt, Mockito.verify(ShellCommandFencer.LOG).info(Mockito.endsWith("echo $ta...rget_port: dummyhost 1234"));
92: Tsuyoshi Ozawa, warn, CatchClause, LOG.warn("When stopping the cluster", e);
229: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("Faking svc0 unhealthy, should failover to svc1");
232: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("Waiting for svc0 to enter initializing state");
236: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("Allowing svc0 to be healthy again, making svc1 unreachable " + "and fail to gracefully go to standby");
257: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("Faking svc0 to change the state, should failover to svc1");
274: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("======= Running test cases second time to test " + "re-establishment =========");
308: Tsuyoshi Ozawa, info, TryStmt, LOG.info("Allowing svc0's elector to re-establish its connection");
300: Tsuyoshi Ozawa, info, TryStmt, LOG.info("Expired svc0's ZK session. Waiting a second to give svc1" + " a chance to take the lock, if it is ever going to.");
324: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("Making svc1 fail to become active");
327: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("Faking svc0 unhealthy, should NOT successfully " + "failover to svc1");
340: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("Faking svc0 healthy again, should go back to svc0");
366: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("====== Stopping ZK server");
370: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("====== Waiting for services to enter NEUTRAL mode");
376: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("====== Checking that the services didn't change HA state");
380: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("====== Restarting server");
551: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("====== Failing over by session expiration");
556: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("====== Restarting server");
78: Todd Lipcon, info, WhileStmt, LOG.info("Failing over via expiration from " + from + " to " + to);
104: Todd Lipcon, info, IfStmt, LOG.info(String.format("Expiring session %x for svc %d", sessId, targetIdx));
153: Todd Lipcon, info, IfStmt, LOG.info("Throwing an exception for svc " + svcIdx);
153: Robert Kanter, info, MethodDeclaration, Log.getLog().info(header);
175: Robert Kanter, info, MethodDeclaration, Log.getLog().info(header);
67: Giridharan Kesavan, info, MethodDeclaration, LOG.info("filtering " + uri);
86: Giridharan Kesavan, warn, MethodDeclaration, LOG.warn("access " + urlstring);
100: Giridharan Kesavan, warn, CatchClause, LOG.warn("urlstring=" + urlstring, ioe);
139: Giridharan Kesavan, info, MethodDeclaration, LOG.info("RECORDS = " + RECORDS);
157: Matthew Foley, info, MethodDeclaration, LOG.info("HTTP server started: " + baseUrl);
524: Tsz-wo Sze, info, MethodDeclaration, LOG.info("BEGIN testJersey()");
527: Tsz-wo Sze, info, MethodDeclaration, LOG.info("m=" + m);
530: Tsz-wo Sze, info, MethodDeclaration, LOG.info("END testJersey()");
48: Robert Kanter, info, MethodDeclaration, LOG.info("HTTP server started: " + baseUrl);
62: Akira Ajisaka, debug, CatchClause, LOG.debug("Expected exception " + expected, expected);
67: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("filtering " + uri);
86: Vinod Kumar Vavilapalli, warn, MethodDeclaration, LOG.warn("access " + urlstring);
101: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("urlstring=" + urlstring, ioe);
143: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("RECORDS = " + RECORDS);
67: Giridharan Kesavan, info, MethodDeclaration, LOG.info("filtering " + uri);
85: Giridharan Kesavan, warn, MethodDeclaration, LOG.warn("access " + urlstring);
99: Giridharan Kesavan, warn, CatchClause, LOG.warn("urlstring=" + urlstring, ioe);
121: Jing Zhao, info, MethodDeclaration, LOG.info("HTTP server started: " + baseUrl);
183: Zhe Zhang, info, CatchClause, LOG.info("No Ciphers in common, expected succesful test result.", ex);
206: Zhe Zhang, info, TryStmt, LOG.info("Atleast one additional enabled cipher than excluded ciphers," + " expected successful test result.");
233: Zhe Zhang, info, TryStmt, LOG.info("Atleast one additional enabled cipher than excluded ciphers," + " expected successful test result.");
57: Tsz-wo Sze, info, MethodDeclaration, LOG.info("get: " + PATH + "=" + path + ", " + OP + "=" + op);
70: Tsz-wo Sze, debug, IfStmt, LOG.debug("generating " + count + " records in debug");
86: Tsz-wo Sze, debug, IfStmt, LOG.debug("creating with " + data.length + " debug");
99: Tsz-wo Sze, debug, IfStmt, LOG.debug("reading " + data.length + " debug");
116: Jonathan Turner Eagles, debug, IfStmt, LOG.debug("done reading " + data.length + " debug");
202: Giridharan Kesavan, info, TryStmt, LOG.info("count = " + count);
203: Giridharan Kesavan, info, TryStmt, LOG.info("create = " + create);
204: Giridharan Kesavan, info, TryStmt, LOG.info("check = " + check);
205: Giridharan Kesavan, info, TryStmt, LOG.info("file = " + file);
44: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Testing DefaultStringifier with Text");
61: Giridharan Kesavan, info, ForStmt, LOG.info("Object: " + text);
62: Giridharan Kesavan, info, ForStmt, LOG.info("String representation of the object: " + str);
71: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Testing DefaultStringifier with Serializable Integer");
79: Giridharan Kesavan, info, MethodDeclaration, LOG.info("String representation of the object: " + str);
87: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Testing DefaultStringifier#store() and #load()");
102: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Testing DefaultStringifier#storeArray() and #loadArray()");
55: Owen O'Malley, info, MethodDeclaration, LOG.info("Testing SequenceFile with DefaultCodec");
57: Owen O'Malley, info, MethodDeclaration, LOG.info("Successfully tested SequenceFile with DefaultCodec");
136: Owen O'Malley, info, MethodDeclaration, LOG.info("Seed = " + seed);
206: Owen O'Malley, info, MethodDeclaration, LOG.info("creating " + count + " records with " + compressionType + " compression");
225: Owen O'Malley, debug, MethodDeclaration, LOG.debug("reading " + count + " records");
260: Owen O'Malley, info, CatchClause, LOG.info("Problem on row " + i);
261: Owen O'Malley, info, CatchClause, LOG.info("Expected key = " + key);
262: Owen O'Malley, info, CatchClause, LOG.info("Expected len = " + key.getLength());
263: Owen O'Malley, info, CatchClause, LOG.info("Actual key = " + k);
264: Owen O'Malley, info, CatchClause, LOG.info("Actual len = " + k.getLength());
265: Owen O'Malley, info, CatchClause, LOG.info("Expected value = " + value);
266: Owen O'Malley, info, CatchClause, LOG.info("Expected len = " + value.getLength());
267: Owen O'Malley, info, CatchClause, LOG.info("Actual value = " + v);
268: Owen O'Malley, info, CatchClause, LOG.info("Actual len = " + v.getLength());
269: Owen O'Malley, info, CatchClause, LOG.info("Key equals: " + k.equals(key));
270: Owen O'Malley, info, CatchClause, LOG.info("value equals: " + v.equals(value));
284: Owen O'Malley, debug, MethodDeclaration, LOG.debug("sorting " + count + " records");
286: Owen O'Malley, info, MethodDeclaration, LOG.info("done sorting " + count + " debug");
292: Owen O'Malley, info, MethodDeclaration, LOG.info("sorting " + count + " records in memory for debug");
303: Owen O'Malley, debug, MethodDeclaration, LOG.debug("checking order of " + count + " records");
324: Owen O'Malley, debug, MethodDeclaration, LOG.debug("sucessfully checked " + count + " records");
333: Owen O'Malley, debug, MethodDeclaration, LOG.debug("creating " + factor + " files with " + count / factor + " records");
362: Owen O'Malley, debug, ForStmt, LOG.debug("sorting file " + i + " with " + count / factor + " records");
366: Owen O'Malley, info, MethodDeclaration, LOG.info("merging " + factor + " files with " + count / factor + " debug");
388: Owen O'Malley, info, MethodDeclaration, LOG.info("Testing SequenceFile with metadata");
413: Owen O'Malley, info, IfStmt, LOG.info("The original metadata:\n" + theMetadata.toString());
414: Owen O'Malley, info, IfStmt, LOG.info("The retrieved metadata:\n" + aMetadata.toString());
422: Owen O'Malley, info, IfStmt, LOG.info("The original metadata:\n" + theMetadata.toString());
423: Owen O'Malley, info, IfStmt, LOG.info("The retrieved metadata:\n" + aMetadata.toString());
431: Owen O'Malley, info, IfStmt, LOG.info("The original metadata:\n" + theMetadata.toString());
432: Owen O'Malley, info, IfStmt, LOG.info("The retrieved metadata:\n" + aMetadata.toString());
439: Owen O'Malley, info, IfStmt, LOG.info("The original metadata:\n" + theMetadata.toString());
440: Owen O'Malley, info, IfStmt, LOG.info("The retrieved metadata:\n" + aMetadata.toString());
446: Owen O'Malley, info, MethodDeclaration, LOG.info("Successfully tested SequenceFile with metadata");
453: Owen O'Malley, info, MethodDeclaration, LOG.info("reading file: " + file.toString());
465: Owen O'Malley, info, MethodDeclaration, LOG.info("creating " + count + " records with metadata and with " + compressionType + " compression");
484: Owen O'Malley, info, MethodDeclaration, LOG.info("sorting: " + unsortedFile + " to: " + sortedFile);
790: Owen O'Malley, info, TryStmt, LOG.info("count = " + count);
791: Owen O'Malley, info, TryStmt, LOG.info("megabytes = " + megabytes);
792: Owen O'Malley, info, TryStmt, LOG.info("factor = " + factor);
793: Owen O'Malley, info, TryStmt, LOG.info("create = " + create);
794: Owen O'Malley, info, TryStmt, LOG.info("seed = " + seed);
795: Owen O'Malley, info, TryStmt, LOG.info("rwonly = " + rwonly);
796: Owen O'Malley, info, TryStmt, LOG.info("check = " + check);
797: Owen O'Malley, info, TryStmt, LOG.info("fast = " + fast);
798: Owen O'Malley, info, TryStmt, LOG.info("merge = " + merge);
799: Owen O'Malley, info, TryStmt, LOG.info("compressType = " + compressType);
800: Owen O'Malley, info, TryStmt, LOG.info("compressionCodec = " + compressionCodec);
801: Owen O'Malley, info, TryStmt, LOG.info("file = " + file);
94: Giridharan Kesavan, info, MethodDeclaration, LOG.info("generating " + count + " records in memory");
101: Giridharan Kesavan, info, MethodDeclaration, LOG.info("sorting " + count + " records");
110: Giridharan Kesavan, info, MethodDeclaration, LOG.info("creating with " + data.length + " records");
125: Giridharan Kesavan, info, MethodDeclaration, LOG.info("reading " + sample + " records");
132: Giridharan Kesavan, info, MethodDeclaration, LOG.info("done reading " + data.length);
175: Giridharan Kesavan, info, TryStmt, LOG.info("count = " + count);
176: Giridharan Kesavan, info, TryStmt, LOG.info("create = " + create);
177: Giridharan Kesavan, info, TryStmt, LOG.info("check = " + check);
178: Giridharan Kesavan, info, TryStmt, LOG.info("compress = " + compress);
179: Giridharan Kesavan, info, TryStmt, LOG.info("file = " + file);
39: Giridharan Kesavan, debug, IfStmt, LOG.debug("Value = " + val);
42: Giridharan Kesavan, debug, IfStmt, LOG.debug("Buffer = " + printer);
64: Eli Collins, error, IfStmt, LOG.error("unexpected exception:", e);
97: Jason Darrell Lowe, warn, CatchClause, logger.warn("Failed to load snappy: ", t);
87: Jason Darrell Lowe, warn, TryStmt, logger.warn("Snappy native library is available");
94: Jason Darrell Lowe, warn, IfStmt, logger.warn("Snappy native library not loaded");
92: Jason Darrell Lowe, info, IfStmt, logger.info("Snappy native library loaded");
182: Jason Darrell Lowe, error, CatchClause, logger.error(joiner.join(compressor.getClass().getCanonicalName(), "checkSetInputNullPointerException error !!!"));
196: Jason Darrell Lowe, error, CatchClause, logger.error(joiner.join(compressor.getClass().getCanonicalName(), "checkCompressNullPointerException error !!!"));
210: Jason Darrell Lowe, error, CatchClause, logger.error(joiner.join(decompressor.getClass().getCanonicalName(), "checkCompressNullPointerException error !!!"));
223: Jason Darrell Lowe, error, CatchClause, logger.error(joiner.join(decompressor.getClass().getCanonicalName(), "checkSetInputNullPointerException error !!!"));
236: Jason Darrell Lowe, error, CatchClause, logger.error(joiner.join(compressor.getClass().getCanonicalName(), "checkSetInputArrayIndexOutOfBoundsException error !!!"));
250: Jason Darrell Lowe, error, CatchClause, logger.error(joiner.join(compressor.getClass().getCanonicalName(), "checkCompressArrayIndexOutOfBoundsException error !!!"));
264: Jason Darrell Lowe, error, CatchClause, logger.error(joiner.join(decompressor.getClass().getCanonicalName(), "checkCompressArrayIndexOutOfBoundsException error !!!"));
277: Jason Darrell Lowe, error, CatchClause, logger.error(joiner.join(decompressor.getClass().getCanonicalName(), "checkNullPointerException error !!!"));
131: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Native hadoop library available but native bzip2 is not");
191: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Created a Codec object of type: " + codecClass);
204: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Generated " + count + " records");
222: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Finished compressing data");
286: Giridharan Kesavan, info, MethodDeclaration, LOG.info("SUCCESS! Completed checking " + count + " records");
301: Christopher Douglas, info, MethodDeclaration, LOG.info("seed: " + seed);
324: Christopher Douglas, info, ForStmt, LOG.info("SAMPLE " + in.getAdjustedStart() + "," + in.getAdjustedEnd());
382: Christopher Douglas, info, TryStmt, LOG.info("Wrote " + seq + " records to " + file);
480: Christopher Douglas, warn, IfStmt, LOG.warn("testCodecInitWithCompressionLevel for native skipped" + ": native libs not loaded");
474: Christopher Douglas, info, IfStmt, LOG.info("testCodecInitWithCompressionLevel with native");
497: Christopher Douglas, warn, IfStmt, LOG.warn("testCodecPoolCompressorReinit skipped: native libs not loaded");
550: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Native hadoop library available but native bzip2 is not");
572: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Creating SequenceFile with codec \"" + codecClass + "\"");
578: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Writing to SequenceFile...");
587: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Reading from the SequenceFile...");
608: Giridharan Kesavan, info, MethodDeclaration, LOG.info("SUCCESS! Completed SequenceFileCodecTest with codec \"" + codecClass + "\"");
625: Harsh J, info, MethodDeclaration, LOG.info("Creating MapFiles with " + records + " records using codec " + clazz.getSimpleName());
630: Harsh J, info, MethodDeclaration, LOG.info("Writing " + path);
685: Christopher Douglas, info, MethodDeclaration, LOG.info("seed: " + seed);
717: Christopher Douglas, info, MethodDeclaration, LOG.info(decomClass + " seed: " + seed);
815: Suresh Srinivas, info, MethodDeclaration, LOG.info("testGzipLongOverflow");
91: Eric Yang, info, MethodDeclaration, LOG.info("Created a Codec object of type: " + codecClass);
104: Eric Yang, info, MethodDeclaration, LOG.info("Generated " + count + " records");
115: Eric Yang, info, MethodDeclaration, LOG.info("Finished compressing data");
119: Eric Yang, info, MethodDeclaration, LOG.info("Finished reseting deflator");
146: Eric Yang, info, MethodDeclaration, LOG.info("Finished re-compressing data");
172: Eric Yang, info, MethodDeclaration, LOG.info("SUCCESS! Completed checking " + count + " records");
108: Chris Douglas, info, MethodDeclaration, LOG.info("seed: " + seed);
93: Devaraj Das, info, MethodDeclaration, LOG.info("Stat: " + String.valueOf(stat));
169: Devaraj Das, info, CatchClause, LOG.info("Got expected exception", nioe);
184: Chris Douglas, info, TryStmt, LOG.info("testStat() is successful.");
213: Chris Douglas, info, MethodDeclaration, LOG.info("Load permission test is successful for path: {}, stat: {}", testFilePath, stat);
215: Chris Douglas, info, MethodDeclaration, LOG.info("On mask, stat is owner: {}, group: {}, permission: {}", owner, group, permission.getFsPermission().toOctal());
251: Chris Douglas, info, TryStmt, LOG.info("testMultiThreadedStat() is successful.");
282: Suresh Srinivas, info, MethodDeclaration, LOG.info("Set a file pointer on Windows");
327: Suresh Srinivas, info, MethodDeclaration, LOG.info("Open a file on Windows with SHARE_DELETE shared mode");
442: Devaraj Das, info, MethodDeclaration, LOG.info("Open a missing file without O_CREAT and it should fail");
448: Devaraj Das, info, CatchClause, LOG.info("Got expected exception", nioe);
457: Devaraj Das, info, MethodDeclaration, LOG.info("Test creating a file with O_CREAT");
469: Devaraj Das, info, MethodDeclaration, LOG.info("Test exclusive create");
476: Devaraj Das, info, CatchClause, LOG.info("Got expected exception for failed exclusive create", nioe);
127: Tsz-Wo Nicholas Sze, info, CatchClause, LOG.info("call" + i + " caught ", e);
186: Akira Ajisaka, error, CatchClause, LOG.error(String.format("Caller-%d Call-%d caught: %s", callerId, i, StringUtils.stringifyException(e)));
222: Akira Ajisaka, error, IfStmt, LOG.error(String.format("Caller-%d Call-%d failed!", callerId, i));
241: Akira Ajisaka, error, CatchClause, LOG.error("Caught: " + StringUtils.stringifyException(e));
236: Akira Ajisaka, error, IfStmt, LOG.error("Call failed!");
568: Todd Lipcon, info, MethodDeclaration, LOG.info("Got expected exception", t);
623: Eli Collins, info, CatchClause, LOG.info("caught expected exception", e);
653: Hairong Kuang, info, CatchClause, LOG.info("Get a SocketTimeoutException ", e);
677: Suresh Srinivas, info, CatchClause, LOG.info("Get a SocketTimeoutException ", e);
790: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
825: Andrew Wang, info, MethodDeclaration, LOG.info("(initial clients) need:" + initialClients + " connections have:" + server.getNumOpenConnections());
827: Daryn Sharp, info, MethodDeclaration, LOG.info("ipc layer should be blocked");
847: Andrew Wang, info, MethodDeclaration, LOG.info("(max clients) need:" + maxAccept + " connections have:" + server.getNumOpenConnections());
857: Daryn Sharp, info, MethodDeclaration, LOG.info("releasing the calls");
901: Akira Ajisaka, error, CatchClause, LOG.error(t.toString());
923: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
1043: Tsuyoshi Ozawa, error, CatchClause, LOG.error("The Client did not interrupt after handling an Interrupted Exception");
1041: Tsuyoshi Ozawa, info, TryStmt, LOG.info("Expected thread interrupt during client cleanup");
129: Akira Ajisaka, error, CatchClause, LOG.error("Caught Exception", e);
66: Jian He, info, MethodDeclaration, LOG.info("Server started at: " + address + " at time: " + serverStartTime);
86: Akira Ajisaka, info, MethodDeclaration, LOG.info(callable1.toString());
87: Akira Ajisaka, info, MethodDeclaration, LOG.info(callable2.toString());
499: Haohui Mai, debug, IfStmt, LOG.debug("Caught " + e);
726: Haohui Mai, info, CatchClause, LOG.info("LOGGING MESSAGE: " + re.getLocalizedMessage());
748: Haohui Mai, info, CatchClause, LOG.info("LOGGING MESSAGE: " + re.getLocalizedMessage());
902: Tsz-wo Sze, error, CatchClause, LOG.error("thread " + num, e);
1152: Xiaoyu Yao, error, IfStmt, LOG.error("Last received non-RetriableException:", lastException);
1243: Xiaoyu Yao, info, MethodDeclaration, LOG.info("DecayedCallVolume: " + decayedCallVolume1);
1244: Xiaoyu Yao, info, MethodDeclaration, LOG.info("CallVolume: " + rawCallVolume1);
1245: Xiaoyu Yao, info, MethodDeclaration, LOG.info("UniqueCaller: " + uniqueCaller1);
1246: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Priority.0.CompletedCallVolume: " + callVolumePriority0);
1247: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Priority.1.CompletedCallVolume: " + callVolumePriority1);
1248: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Priority.0.AvgResponseTime: " + avgRespTimePriority0);
1249: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Priority.1.AvgResponseTime: " + avgRespTimePriority1);
1262: Steve Loughran, error, IfStmt, LOG.error("Last received non-RetriableException:", lastException);
1317: Masatake Iwasaki, info, CatchClause, LOG.info("got expected timeout.", e);
1330: Masatake Iwasaki, info, CatchClause, LOG.info("got expected timeout.", e);
1340: Masatake Iwasaki, info, CatchClause, LOG.info("got unexpected exception.", e);
1365: Masatake Iwasaki, info, CatchClause, LOG.info("got expected timeout.", e);
1357: Masatake Iwasaki, info, CatchClause, LOG.info("got unexpected exception.", e);
1485: Kihwal Lee, info, ForStmt, LOG.info("TestDisconnect request[" + i + "] " + " shouldConnect=" + isDisconnected + " willDisconnect=" + doDisconnect);
180: Jian He, info, MethodDeclaration, LOG.info("Done sleeping");
99: Haohui Mai, info, CatchClause, LOG.info("Expected exception", e.getCause());
153: Daryn Sharp, info, MethodDeclaration, LOG.info("---------------------------------");
154: Arpit Agarwal, info, MethodDeclaration, LOG.info("Testing QOP:" + getQOPNames(qop));
155: Daryn Sharp, info, MethodDeclaration, LOG.info("---------------------------------");
272: Haohui Mai, info, CatchClause, LOG.info("LOGGING MESSAGE: " + re.getLocalizedMessage());
775: yliu, info, ForStmt, LOG.info("waiting for future" + i);
799: Daryn Sharp, warn, CatchClause, LOG.warn("Auth method failure", e);
811: Daryn Sharp, warn, CatchClause, LOG.warn("Auth method failure", e);
883: Daryn Sharp, info, TryStmt, LOG.info("trying ugi:" + clientUgi + " tokens:" + clientUgi.getTokens());
171: Steve Loughran, info, MethodDeclaration, logger.info(message, throwable);
55: Arun Murthy, debug, MethodDeclaration, LOG.debug("mc:" + mc);
83: Arun Murthy, debug, MethodDeclaration, LOG.debug("--- t1 instance i1:" + t1i1);
84: Arun Murthy, debug, MethodDeclaration, LOG.debug("--- t1 instance 42:" + t1i42);
85: Arun Murthy, debug, MethodDeclaration, LOG.debug("--- t2 instance i1:" + t2i1);
98: Arun Murthy, debug, MethodDeclaration, LOG.debug("asserting foo == default foo");
266: Lei Xu, error, CatchClause, LOG.error(e.getStackTrace());
269: Lei Xu, error, IfStmt, LOG.error("Hit error, stopping now");
262: Lei Xu, info, TryStmt, LOG.info("reset lastRecs");
321: Lei Xu, error, CatchClause, LOG.error(e.getStackTrace());
310: Lei Xu, info, IfStmt, LOG.info("found key/val=" + cnt + "/" + cnt);
316: Lei Xu, error, TryStmt, LOG.error("key=" + key + " not found. Stopping now.");
86: Akira Ajisaka, debug, MethodDeclaration, LOG.debug(record.toString());
93: Arun Murthy, debug, MethodDeclaration, LOG.debug(MetricsConfig.toString(conf));
433: Akira Ajisaka, debug, MethodDeclaration, LOG.debug(recs.toString());
89: Arun Murthy, warn, CatchClause, LOG.warn("Interrupted", e);
239: Akira Ajisaka, info, CatchClause, LOG.info(e.toString());
242: Todd Lipcon, error, MethodDeclaration, LOG.error("should've thrown CME");
267: Arun Murthy, warn, CatchClause, LOG.warn("Interrupted", ex);
260: Arun Murthy, info, MethodDeclaration, LOG.info("sleeping");
275: Arun Murthy, debug, MethodDeclaration, LOG.debug("Returning new sleeping consumer queue");
199: Zhe Zhang, info, MethodDeclaration, LOG.info("Random seed = " + seed);
88: Arun Murthy, debug, MethodDeclaration, LOG.debug("tags=" + mr.tags() + " cr=" + cr);
61: Robert Kanter, info, IfStmt, LOG.info("Port is already in use; trying again");
58: Robert Kanter, info, IfStmt, LOG.info("Port is already in use; giving up");
53: Tsuyoshi Ozawa, info, TryStmt, LOG.info("Using port " + tryPort);
176: Giridharan Kesavan, info, IfStmt, LOG.info("Address is " + localhost + " Loopback=" + localhost.isLoopbackAddress() + " Linklocal=" + localhost.isLinkLocalAddress());
170: Steve Loughran, info, TryStmt, LOG.info("Local reverse DNS hostname is " + s);
267: Giridharan Kesavan, info, MethodDeclaration, LOG.info("Localhost IPAddr is " + localhost.toString());
403: Steve Loughran, info, MethodDeclaration, LOG.info(wrapped.toString(), wrapped);
78: Giridharan Kesavan, info, CatchClause, LOG.info("Got SocketTimeoutException as expected after " + diff + " millis : " + e.getMessage());
130: Todd Lipcon, info, CatchClause, LOG.info("Got expection while reading as expected : " + ste.getMessage());
132: Steve Loughran, info, MethodDeclaration, LOG.info(topology);
162: Steve Loughran, info, MethodDeclaration, LOG.info(topology);
180: Steve Loughran, info, MethodDeclaration, LOG.info("Mapping: " + cachedMap + "\n" + cachedMap.dumpTopology());
194: Steve Loughran, info, MethodDeclaration, LOG.info("Mapping: " + cachedMap + "\n" + cachedMap.dumpTopology());
745: Colin McCabe, error, CatchClause, DomainSocket.LOG.error("reader error", e);
145: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
173: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
216: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
245: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
98: Boris Shkolnik, info, MethodDeclaration, LOG.info("Local Ip addresses: " + builder.toString());
38: Akira Ajisaka, DEBUG, MethodDeclaration, GenericTestUtils.setRootLogLevel(Level.DEBUG);
48: Robert Joseph Evans, info, MethodDeclaration, LOG.info(username + " has GROUPS: " + groupList.toString());
54: Akira Ajisaka, DEBUG, MethodDeclaration, GenericTestUtils.setRootLogLevel(Level.DEBUG);
64: Robert Joseph Evans, info, MethodDeclaration, LOG.info(username + " has GROUPS: " + groupList.toString());
70: Robert Joseph Evans, info, MethodDeclaration, LOG.info("running 'mvn -Pnative -DTestGroupFallback clear test' will " + "test the normal path and 'mvn -DTestGroupFallback clear test' will" + " test the fall back functionality");
73: Akira Ajisaka, DEBUG, MethodDeclaration, GenericTestUtils.setRootLogLevel(Level.DEBUG);
83: Robert Joseph Evans, info, MethodDeclaration, LOG.info(username + " has GROUPS: " + groupList.toString());
89: Robert Joseph Evans, info, MethodDeclaration, LOG.info("running 'mvn -Pnative -DTestGroupFallback clear test' will " + "test the normal path and 'mvn -DTestGroupFallback clear test' will" + " test the fall back functionality");
92: Akira Ajisaka, DEBUG, MethodDeclaration, GenericTestUtils.setRootLogLevel(Level.DEBUG);
102: Robert Joseph Evans, info, MethodDeclaration, LOG.info(username + " has GROUPS: " + groupList.toString());
79: Harsh J, info, MethodDeclaration, TESTLOG.info("Getting groups for " + user);
118: Harsh J, info, MethodDeclaration, TESTLOG.info("Cache is being refreshed.");
124: Harsh J, info, MethodDeclaration, TESTLOG.info("Clearing the blacklist");
129: Harsh J, info, MethodDeclaration, TESTLOG.info("Resetting FakeGroupMapping");
140: Harsh J, info, MethodDeclaration, TESTLOG.info("Adding " + groups + " to groups.");
145: Harsh J, info, MethodDeclaration, TESTLOG.info("Adding " + user + " to the blacklist");
234: Harsh J, error, IfStmt, TESTLOG.error("Got unexpected exception: " + ioe.getMessage());
229: Harsh J, error, TryStmt, TESTLOG.error("We are not supposed to get here." + groups.getGroups("user1").toString());
111: cnauroth, error, IfStmt, LOG.error("Expected an exception in category {}, got {}", category, e, e);
107: cnauroth, error, TryStmt, LOG.error("Expected an exception in category {}, return code {}", category, ex);
190: cnauroth, info, MethodDeclaration, LOG.info("Output of {}", f);
238: cnauroth, info, ForeachStmt, LOG.info(line);
89: cnauroth, error, IfStmt, LOG.error("Expected an exception in category {}, got {}", category, e, e);
85: cnauroth, error, TryStmt, LOG.error("Expected an exception in category {}, return code {}", category, ex);
363: Chris Nauroth, debug, CatchClause, LOG.debug("Got the exception while LDAP querying: ", ne);
419: Chris Nauroth, debug, CatchClause, LOG.debug("Got the exception while LDAP querying: ", ne);
68: Harsh J, warn, CatchClause, TESTLOG.warn(e.getMessage());
103: Harsh J, warn, CatchClause, TESTLOG.warn(e.getMessage());
146: Harsh J, warn, CatchClause, TESTLOG.warn(e.getMessage());
159: Harsh J, warn, CatchClause, TESTLOG.warn(e.getMessage());
192: Harsh J, warn, CatchClause, TESTLOG.warn(e.getMessage());
205: Harsh J, warn, CatchClause, TESTLOG.warn(e.getMessage());
106: Xiao Chen, info, LambdaExpr, UserGroupInformation.LOG.info("Renew failure count is {}", count);
1114: Xiao Chen, info, MethodDeclaration, LOG.info(str);
1122: Xiao Chen, info, MethodDeclaration, LOG.info(str);
1135: Xiao Chen, info, MethodDeclaration, LOG.info(str);
56: Andrew Wang, info, MethodDeclaration, LOG.info("Running test " + test.getMethodName());
88: Boris Shkolnik, info, IfStmt, LOG.info("Not testing netgroups, " + "this test only runs when native code is compiled");
97: Boris Shkolnik, info, IfStmt, LOG.info("Not testing netgroups, no group mapping class specified, " + "use -DTestAccessControlListGroupMapping=$className to specify " + "group mapping class (must implement GroupMappingServiceProvider " + "interface and support netgroups)");
104: Boris Shkolnik, info, MethodDeclaration, LOG.info("Testing netgroups using: " + groupMappingClassName);
91: Devaraj Das, info, IfStmt, LOG.info("Not testing netgroups, " + "this test only runs when native code is compiled");
100: Devaraj Das, info, IfStmt, LOG.info("Not testing netgroups, no group mapping class specified, " + "use -DTestProxyUsersGroupMapping=$className to specify " + "group mapping class (must implement GroupMappingServiceProvider " + "interface and support netgroups)");
107: Devaraj Das, info, MethodDeclaration, LOG.info("Testing netgroups using: " + groupMappingClassName);
149: Zhe ZHang, info, WhileStmt, LOG.info("running delegated task...");
220: Zhe ZHang, info, WhileStmt, LOG.info("client wrap " + wrap(clientSSLEngine, clientOut, cTOs));
221: Zhe ZHang, info, WhileStmt, LOG.info("server wrap " + wrap(serverSSLEngine, serverOut, sTOc));
224: Zhe ZHang, info, WhileStmt, LOG.info("client unwrap " + unwrap(clientSSLEngine, sTOc, clientIn));
225: Zhe ZHang, info, WhileStmt, LOG.info("server unwrap " + unwrap(serverSSLEngine, cTOs, serverIn));
233: Zhe ZHang, info, IfStmt, LOG.info("closing client");
211: Tanping Wang, info, CatchClause, LOG.info("Caught an exception: ", th);
290: Owen O'Malley, info, TryStmt, LOG.info("Sleep to expire the token");
301: Owen O'Malley, info, TryStmt, LOG.info("Sleep beyond the max lifetime");
432: Xiao Chen, info, MethodDeclaration, LOG.info("Waiting for the cancelled token to be removed");
471: Xiao Chen, info, MethodDeclaration, LOG.info("Waiting for the expired token to be removed...");
288: Vinod Kumar Vavilapalli, warn, TryStmt, LOG.warn("Null Configurations are permitted " + serviceManager);
219: Vinod Kumar Vavilapalli, warn, TryStmt, LOG.warn("Null Configurations are permitted ");
157: Junping Du, debug, IfStmt, LOG.debug("Launching service with expected outcome {}", expected);
159: Junping Du, debug, ForeachStmt, LOG.debug(arg);
113: Junping Du, info, MethodDeclaration, LOG.info("Interrupt caught");
68: Junping Du, info, ForeachStmt, LOG.info(arg);
72: Junping Du, info, IfStmt, LOG.info("CLI contains " + ARG_FAILING);
55: Junping Du, error, IfStmt, LOG.error("Got {} arguments: {}", args.size(), argsList);
75: Junping Du, info, CatchClause, LOG.info("Interrupted");
538: Todd Lipcon, info, MethodDeclaration, LOG.info("DelayAnswer firing fireLatch");
542: Todd Lipcon, info, TryStmt, LOG.info("DelayAnswer waiting on waitLatch");
544: Todd Lipcon, info, TryStmt, LOG.info("DelayAnswer delay complete");
629: Todd Lipcon, info, IfStmt, log.info("Call to " + invocation + " on " + delegate, new Exception("TRACE"));
139: Anu Engineer, debug, CatchClause, LOG.debug("eventually() iteration {}", iterations, e);
252: Anu Engineer, debug, CatchClause, LOG.debug("evaluate() iteration {}", iterations, e);
574: Anu Engineer, info, CatchClause, LOG.info("Exception calling toString()", e);
75: Arun Murthy, debug, MethodDeclaration, LOG.debug(methodName + ": " + sb);
141: Todd Lipcon, error, MethodDeclaration, LOG.error("Failed!", err);
94: Mingliang Liu, info, MethodDeclaration, log.info(infoMessage);
102: Mingliang Liu, info, MethodDeclaration, log.info(infoMessage);
112: Mingliang Liu, info, MethodDeclaration, logger.info(infoMessage);
120: Mingliang Liu, info, MethodDeclaration, logger.info(infoMessage);
35: Haohui Mai, info, CatchClause, LOG.info("The AssertionError is expected.", ae);
173: Chris Nauroth, warn, CatchClause, LOG.warn("exception closing jarFile: " + jarFile, e);
155: Allen Wittenauer, info, MethodDeclaration, LOG.info(LOG4J_PROPERTIES + " =\n" + body);
59: Todd Lipcon, info, CatchClause, LightWeightGSet.LOG.info("GOOD: getting " + e, e);
72: Todd Lipcon, info, CatchClause, LightWeightGSet.LOG.info("GOOD: getting " + e, e);
85: Todd Lipcon, info, CatchClause, LightWeightGSet.LOG.info("GOOD: getting " + e, e);
92: Todd Lipcon, info, CatchClause, LightWeightGSet.LOG.info("GOOD: getting " + e, e);
123: Todd Lipcon, info, CatchClause, LightWeightGSet.LOG.info("GOOD: getting " + e, e);
138: Todd Lipcon, info, CatchClause, LightWeightGSet.LOG.info("GOOD: getting " + e, e);
153: Todd Lipcon, info, CatchClause, LightWeightGSet.LOG.info("GOOD: getting " + e, e);
546: Suresh Srinivas, info, MethodDeclaration, LightWeightGSet.LOG.info("Validating - total memory " + maxMemory + " percent " + percent + " returned capacity " + capacity);
130: Chris Nauroth, debug, MethodDeclaration, LOG.debug("generating " + NUM_KEYS + " keys");
59: Xiao Chen, info, CatchClause, LOG.info("Expected exception:", ex);
98: Andrew Wang, info, MethodDeclaration, LOG.info("Removing all elements above " + mode);
44: Eli Collins, info, IfStmt, LOG.info("TestNativeCodeLoader: libhadoop.so testing is not required.");
62: Eli Collins, info, MethodDeclaration, LOG.info("TestNativeCodeLoader: libhadoop.so is loaded.");
42: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Shutdown hook1 complete.");
48: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Shutdown hook2 complete.");
59: Xiaoyu Yao, info, CatchClause, LOG.info("Shutdown hook3 interrupted exception:", ExceptionUtils.getStackTrace(ex));
57: Xiaoyu Yao, info, TryStmt, LOG.info("Shutdown hook3 complete.");
74: Xiaoyu Yao, info, CatchClause, LOG.info("Shutdown hook4 interrupted exception:", ExceptionUtils.getStackTrace(ex));
71: Xiaoyu Yao, info, TryStmt, LOG.info("Shutdown hook4 complete.");
111: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Shutdown starts here");
260: Suresh Srinivas, info, CatchClause, LOG.info("Expected: Failed read from a file with permissions 377");
274: Suresh Srinivas, info, CatchClause, LOG.info("Expected: Failed write to a file with permissions 577");
293: Suresh Srinivas, info, CatchClause, LOG.info("Expected: Failed to execute a file with permissions 677");
331: Ivan Mitic, info, CatchClause, LOG.info("Expected: Failed to create a file when directory " + "permissions are 577");
450: Suresh Srinivas, info, CatchClause, LOG.info("Expected: Failed to create symlink with forward slashes in target");
467: Suresh Srinivas, info, CatchClause, LOG.info("Expected: Failed to create symlink with forward slashes in target");
178: Xiao Chen, debug, CatchClause, LOG.debug("Exception in createKey.", e);
116: Xiao Chen, trace, TryStmt, LOG.trace("Entering createKey Method.");
129: Xiao Chen, debug, TryStmt, LOG.debug("Creating key with name {}, cipher being used{}, " + "length of key {}, description of key {}", name, cipher, length, description);
173: Xiao Chen, trace, TryStmt, LOG.trace("Exiting createKey Method.");
207: Xiao Chen, debug, CatchClause, LOG.debug("Exception in deleteKey.", e);
188: Xiao Chen, trace, TryStmt, LOG.trace("Entering deleteKey method.");
193: Xiao Chen, debug, TryStmt, LOG.debug("Deleting key with name {}.", name);
204: Xiao Chen, trace, TryStmt, LOG.trace("Exiting deleteKey method.");
258: Xiao Chen, debug, CatchClause, LOG.debug("Exception in rolloverKey.", e);
219: Xiao Chen, trace, TryStmt, LOG.trace("Entering rolloverKey Method.");
224: Xiao Chen, debug, TryStmt, LOG.debug("Rolling key with name {}.", name);
254: Xiao Chen, trace, TryStmt, LOG.trace("Exiting rolloverKey Method.");
289: Xiao Chen, debug, CatchClause, LOG.debug("Exception in invalidateCache for key name {}.", name, e);
269: Xiao Chen, trace, TryStmt, LOG.trace("Entering invalidateCache Method.");
274: Xiao Chen, debug, TryStmt, LOG.debug("Invalidating cache with key name {}.", name);
286: Xiao Chen, trace, TryStmt, LOG.trace("Exiting invalidateCache for key name {}.", name);
322: Xiao Chen, debug, CatchClause, LOG.debug("Exception in getKeysmetadata.", e);
300: Xiao Chen, trace, TryStmt, LOG.trace("Entering getKeysMetadata method.");
318: Xiao Chen, trace, TryStmt, LOG.trace("Exiting getKeysMetadata method.");
351: Xiao Chen, debug, CatchClause, LOG.debug("Exception in getkeyNames.", e);
332: Xiao Chen, trace, TryStmt, LOG.trace("Entering getKeyNames method.");
347: Xiao Chen, trace, TryStmt, LOG.trace("Exiting getKeyNames method.");
366: Xiao Chen, debug, CatchClause, LOG.debug("Exception in getKey.", e);
361: Xiao Chen, trace, TryStmt, LOG.trace("Entering getKey method.");
362: Xiao Chen, debug, TryStmt, LOG.debug("Getting key information for key with name {}.", name);
363: Xiao Chen, trace, TryStmt, LOG.trace("Exiting getKey method.");
400: Xiao Chen, debug, CatchClause, LOG.debug("Exception in getMetadata.", e);
378: Xiao Chen, trace, TryStmt, LOG.trace("Entering getMetadata method.");
383: Xiao Chen, debug, TryStmt, LOG.debug("Getting metadata for key with name {}.", name);
396: Xiao Chen, trace, TryStmt, LOG.trace("Exiting getMetadata method.");
434: Xiao Chen, debug, CatchClause, LOG.debug("Exception in getCurrentVersion.", e);
412: Xiao Chen, trace, TryStmt, LOG.trace("Entering getCurrentVersion method.");
417: Xiao Chen, debug, TryStmt, LOG.debug("Getting key version for key with name {}.", name);
430: Xiao Chen, trace, TryStmt, LOG.trace("Exiting getCurrentVersion method.");
469: Xiao Chen, debug, CatchClause, LOG.debug("Exception in getKeyVersion.", e);
445: Xiao Chen, trace, TryStmt, LOG.trace("Entering getKeyVersion method.");
450: Xiao Chen, debug, TryStmt, LOG.debug("Getting key with version name {}.", versionName);
465: Xiao Chen, trace, TryStmt, LOG.trace("Exiting getKeyVersion method.");
541: Xiao Chen, debug, CatchClause, LOG.debug("Exception in generateEncryptedKeys.", e);
486: Xiao Chen, trace, TryStmt, LOG.trace("Entering generateEncryptedKeys method.");
490: Xiao Chen, debug, TryStmt, LOG.debug("Generating encrypted key with name {}," + " the edek Operation is {}.", name, edekOp);
533: Xiao Chen, error, IfStmt, LOG.error(error.toString());
495: Xiao Chen, debug, IfStmt, LOG.debug("edek Operation is Generate.");
517: Xiao Chen, error, CatchClause, LOG.error("Exception in generateEncryptedKeys:", e);
506: Xiao Chen, debug, MethodDeclaration, LOG.debug("Generated Encrypted key for {} number of " + "keys.", numKeys);
537: Xiao Chen, trace, TryStmt, LOG.trace("Exiting generateEncryptedKeys method.");
556: Xiao Chen, trace, MethodDeclaration, LOG.trace("Entering reencryptEncryptedKeys method.");
599: Xiao Chen, debug, CatchClause, LOG.debug("Exception in reencryptEncryptedKeys.", e);
564: Xiao Chen, warn, IfStmt, LOG.warn("Payload size {} too big for reencryptEncryptedKeys from" + " user {}.", jsonPayload.size(), user);
569: Xiao Chen, debug, TryStmt, LOG.debug("Batch reencrypting {} Encrypted Keys for key name {}", jsonPayload.size(), name);
593: Xiao Chen, info, TryStmt, LOG.info("reencryptEncryptedKeys {} keys for key {} took {}", jsonPayload.size(), name, sw.stop());
595: Xiao Chen, trace, TryStmt, LOG.trace("Exiting reencryptEncryptedKeys method.");
687: Xiao Chen, debug, CatchClause, LOG.debug("Exception in handleEncryptedKeyOp.", e);
615: Xiao Chen, trace, TryStmt, LOG.trace("Entering decryptEncryptedKey method.");
619: Xiao Chen, debug, TryStmt, LOG.debug("Decrypting key for {}, the edek Operation is {}.", versionName, eekOp);
680: Xiao Chen, error, IfStmt, LOG.error(error.toString());
683: Xiao Chen, trace, TryStmt, LOG.trace("Exiting handleEncryptedKeyOp method.");
721: Xiao Chen, debug, CatchClause, LOG.debug("Exception in getKeyVersions.", e);
699: Xiao Chen, trace, TryStmt, LOG.trace("Entering getKeyVersions method.");
704: Xiao Chen, debug, TryStmt, LOG.debug("Getting key versions for key {}", name);
717: Xiao Chen, trace, TryStmt, LOG.trace("Exiting getKeyVersions method.");
105: Alejandro Abdelnur, info, IfStmt, LOG.info("'{}' Blacklist '{}'", aclType, blacklistStr);
107: Uma Maheswara Rao G, info, ForeachStmt, LOG.info("'{}' ACL '{}'", aclType, aclStr);
134: Alejandro Abdelnur, warn, CatchClause, LOG.warn("Invalid key Operation '{}'", keyOp);
146: Alejandro Abdelnur, info, IfStmt, LOG.info("KEY_NAME '{}' KEY_OP '{}' ACL '{}'", keyName, aclType, aclStr);
125: Alejandro Abdelnur, warn, IfStmt, LOG.warn("Invalid key name '{}'", k);
185: Xiao Chen, info, IfStmt, LOG.info("{} for KEY_OP '{}' is set to '*'", prefix, keyOp);
182: Xiao Chen, warn, IfStmt, LOG.warn("Invalid KEY_OP '{}' for {}, ignoring", keyOp, prefix);
200: Alejandro Abdelnur, warn, CatchClause, LOG.warn(String.format("Could not reload ACLs file: '%s'", ex.toString()), ex);
221: Alejandro Abdelnur, debug, MethodDeclaration, LOG.debug("Loading ACLs file");
240: Arun Suresh, debug, IfStmt, LOG.debug("Checking user [{}] for: {} {} ", ugi.getShortUserName(), type.toString(), acls.get(type).getAclString());
252: Arun Suresh, debug, IfStmt, LOG.debug("user is not in {}", blacklist.getAclString());
250: Arun Suresh, debug, IfStmt, LOG.debug("user is in {}", blacklist.getAclString());
248: Arun Suresh, debug, IfStmt, LOG.debug("No blacklist for {}", type.toString());
257: Arun Suresh, debug, IfStmt, LOG.debug("User: [{}], Type: {} Result: {}", ugi.getShortUserName(), type.toString(), access);
298: Arun Suresh, debug, IfStmt, LOG.debug("User: [{}], OpType: {}, KeyName: {} Result: {}", ugi.getShortUserName(), opType.toString(), keyName, access);
314: Arun Suresh, debug, IfStmt, LOG.debug("Checking user [{}] for: {}: {}" + ugi.getShortUserName(), opType.toString(), acl.getAclString());
125: Xiao Chen, info, IfStmt, LOG.info("No audit logger configured, using default.");
157: Xiao Chen, info, TryStmt, LOG.info("Initializing audit logger {}", logger.getClass());
267: Xiao Chen, error, CatchClause, LOG.error("Failed to cleanup logger {}", logger.getClass(), ex);
154: Xiao Chen, trace, IfStmt, LOG.trace("Checking file {}, modification time is {}, last reload time is" + " {}", f.getPath(), f.lastModified(), time);
104: Xiao Chen, warn, MethodDeclaration, EXCEPTION_LOG.warn("User {} request {} {} caused exception.", KMSMDCFilter.getUgi(), KMSMDCFilter.getMethod(), KMSMDCFilter.getURL(), exception);
115: Alejandro Abdelnur, warn, MethodDeclaration, LOG.warn("User:'{}' Method:{} URL:{} Response:{}-{}", ugi, method, url, status, msg, ex);
103: Alejandro Abdelnur, debug, IfStmt, LOG.debug("KMS log starting");
105: Alejandro Abdelnur, warn, IfStmt, LOG.warn("Log4j configuration file '{}' not found", LOG4J_PROPERTIES);
106: Alejandro Abdelnur, warn, IfStmt, LOG.warn("Logging with INFO level to standard output");
124: Alejandro Abdelnur, info, TryStmt, LOG.info("-------------------------------------------------------------");
125: Alejandro Abdelnur, info, TryStmt, LOG.info("  Java runtime version : {}", System.getProperty("java.runtime.version"));
127: Yongjun Zhang, info, TryStmt, LOG.info("  User: {}", System.getProperty("user.name"));
128: Alejandro Abdelnur, info, TryStmt, LOG.info("  KMS Hadoop Version: " + VersionInfo.getVersion());
129: Alejandro Abdelnur, info, TryStmt, LOG.info("-------------------------------------------------------------");
179: Andrew Wang, info, TryStmt, LOG.info("Initialized KeyProvider " + keyProvider);
193: Andrew Wang, info, TryStmt, LOG.info("Initialized KeyProviderCryptoExtension " + keyProviderCryptoExtension);
198: Andrew Wang, info, TryStmt, LOG.info("Default key bitlength is {}", defaultBitlength);
199: Alejandro Abdelnur, info, TryStmt, LOG.info("KMS Started");
220: Xiao Chen, Error, CatchClause, LOG.error("Error closing KeyProviderCryptoExtension", ioe);
227: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("KMS Stopped");
123: John Zhuge, warn, MethodDeclaration, LOG.warn("Environment variable {} is deprecated and overriding" + " property {}, please set the property in {} instead.", varName, propName, confFile);
59: Xiao Chen, info, SwitchStmt, auditLog.info("{}[op={}, key={}, user={}, accessCount={}, interval={}ms] {}", status, event.getOp(), event.getKeyName(), event.getUser(), event.getAccessCount().get(), (event.getEndTime() - event.getStartTime()), event.getExtraMsg());
93: Xiao Chen, info, IfStmt, auditLog.info("{}[{}] {}", status, join, event.getExtraMsg());
90: Xiao Chen, info, IfStmt, auditLog.info("{} {}", status, event.getExtraMsg());
277: Xiao Chen, info, ForStmt, LOG.info("Test KMS running at: " + miniKMS.getKMSUrl());
439: Xiao Chen, error, CatchClause, LOG.error("Failed to close key provider.", e);
500: John Zhuge, info, MethodDeclaration, LOG.info("JMX URL " + url);
515: John Zhuge, info, MethodDeclaration, LOG.info("Testing JMX");
690: Andrew Wang, info, MethodDeclaration, LOG.info("Creating key with name '{}'", specialKey);
1820: Xiao Chen, info, IfStmt, LOG.info("Caught expected exception.", ex);
1839: Xiao Chen, info, CatchClause, LOG.info("reencryptEncryptedKey caught expected exception.", ex);
1857: Xiao Chen, info, CatchClause, LOG.info("reencryptEncryptedKeys caught expected exception.", ex);
2249: Andrew Wang, info, IfStmt, LOG.info("Skipping token {}", token);
2252: Andrew Wang, info, ForeachStmt, LOG.info("Got dt for " + uri + "; " + token);
2285: Andrew Wang, info, IfStmt, LOG.info("Skipping token {}", token);
2288: Andrew Wang, info, ForeachStmt, LOG.info("Got dt for " + uri + "; " + token);
2290: Andrew Wang, info, ForeachStmt, LOG.info("Renewed token of kind {}, new lifetime:{}", token.getKind(), tokenLife);
2294: Andrew Wang, info, ForeachStmt, LOG.info("Renewed token of kind {}, new lifetime:{}", token.getKind(), newTokenLife);
2305: Andrew Wang, info, IfStmt, LOG.info("Skipping token {}", token);
2308: Andrew Wang, info, ForeachStmt, LOG.info("Got dt for " + uri + "; " + token);
2310: Andrew Wang, info, ForeachStmt, LOG.info("Cancelled token of kind {}", token.getKind());
2316: Andrew Wang, info, CatchClause, LOG.info("Expected exception when renewing token", e);
2389: Xiao Chen, info, MethodDeclaration, LOG.info("Added kms dt to credentials: {}", UserGroupInformation.getCurrentUser().getCredentials().getAllTokens());
2416: Xiao Chen, info, CatchClause, LOG.info("Expected error.", e);
2443: Xiao Chen, info, MethodDeclaration, LOG.info("Added old kms dt to credentials: {}", UserGroupInformation.getCurrentUser().getCredentials().getAllTokens());
2449: Xiao Chen, info, CatchClause, LOG.info("Expected error.", e);
2457: Xiao Chen, info, MethodDeclaration, LOG.info("Credentials now are: {}", UserGroupInformation.getCurrentUser().getCredentials().getAllTokens());
2677: Xiao Chen, info, ForeachStmt, LOG.info("Rolling key {} via provider {} with token {}.", keyName, provider, token);
2745: Xiao Chen, info, ForeachStmt, LOG.info("Testing token: {}", token);
2747: Xiao Chen, info, ForeachStmt, LOG.info("Renewed token {}, new lifetime:{}", token, tokenLife);
2750: Xiao Chen, info, ForeachStmt, LOG.info("Renewed token {}, new lifetime:{}", token, newTokenLife);
2758: Xiao Chen, info, IfStmt, LOG.info("Cancelled token {}", token);
2766: Xiao Chen, info, CatchClause, LOG.info("Expected exception when renewing token", e);
3107: Xiao Chen, info, MethodDeclaration, LOG.info("Requesting jmx from " + jmxUrl);
3115: Xiao Chen, info, MethodDeclaration, LOG.info("jmx returned: " + sb.toString());
225: Alejandro Abdelnur, info, ConstructorDeclaration, LOG.info("Configuration:");
226: Alejandro Abdelnur, info, ConstructorDeclaration, LOG.info("---------------------------------------------------------------");
228: Alejandro Abdelnur, info, ForeachStmt, LOG.info("  {}: {}", entry.getKey(), entry.getValue());
230: Alejandro Abdelnur, info, ConstructorDeclaration, LOG.info("---------------------------------------------------------------");
285: Xiaoyu Yao, info, MethodDeclaration, LOG.info("MiniKdc started.");
359: Kai Zheng, info, MethodDeclaration, LOG.info("MiniKdc stopped.");
375: Alejandro Abdelnur, WARN, IfStmt, LOG.warn("WARNING: cannot delete directory " + f.getAbsolutePath());
365: Alejandro Abdelnur, WARN, IfStmt, LOG.warn("WARNING: cannot delete file " + f.getAbsolutePath());
405: Kai Zheng, error, IfStmt, LOG.error("Failed to delete keytab file: " + keytabFile);
66: Akira Ajisaka, error, CatchClause, LOG.error("Failed to start the UDP server.", e);
85: Akira Ajisaka, error, CatchClause, LOG.error("Failed to start the TCP server.", e);
106: Akira Ajisaka, error, CatchClause, LOG.error("Failed to register the MOUNT service.", e);
60: Brandon Li, error, CatchClause, LOG.error("Invalid NFS Exports provided: ", e);
164: Brandon Li, debug, IfStmt, LOG.debug("Processing match string '" + mStr + "'");
262: Brandon Li, debug, IfStmt, LOG.debug("CIDRNMatcher low = " + subnetInfo.getLowAddress() + ", high = " + subnetInfo.getHighAddress() + ", allowing client '" + address + "', '" + hostname + "'");
269: Brandon Li, debug, IfStmt, LOG.debug("CIDRNMatcher low = " + subnetInfo.getLowAddress() + ", high = " + subnetInfo.getHighAddress() + ", denying client '" + address + "', '" + hostname + "'");
298: Brandon Li, debug, IfStmt, LOG.debug("ExactMatcher '" + ipOrHost + "', allowing client " + "'" + address + "', '" + hostname + "'");
304: Brandon Li, debug, IfStmt, LOG.debug("ExactMatcher '" + ipOrHost + "', denying client " + "'" + address + "', '" + hostname + "'");
332: Brandon Li, debug, IfStmt, LOG.debug("RegexMatcher '" + pattern.pattern() + "', allowing client '" + address + "', '" + hostname + "'");
338: Brandon Li, debug, IfStmt, LOG.debug("RegexMatcher '" + pattern.pattern() + "', denying client '" + address + "', '" + hostname + "'");
402: Brandon Li, debug, IfStmt, LOG.debug("Using exact match for '" + host + "' and " + privilege);
397: Brandon Li, debug, IfStmt, LOG.debug("Using Regex match for '" + host + "' and " + privilege);
389: Brandon Li, debug, IfStmt, LOG.debug("Using CIDR match for '" + host + "' and " + privilege);
384: Brandon Li, debug, IfStmt, LOG.debug("Using CIDR match for '" + host + "' and " + privilege);
379: Brandon Li, debug, IfStmt, LOG.debug("Using match all for '" + host + "' and " + privilege);
85: Brandon Li, warn, CatchClause, LOG.warn("MD5 MessageDigest unavailable.");
45: Brandon Li, info, ConstructorDeclaration, LOG.info("NFS server port set to: " + rpcProgram.getPort());
57: Akira Ajisaka, error, CatchClause, LOG.error("Failed to register the NFSv3 service.", e);
70: Akira Ajisaka, error, CatchClause, LOG.error("Failed to start the TCP server.", e);
52: Brandon Li, debug, IfStmt, LOG.debug("Portmap mapping registration failed," + " the response size is less than 28 bytes:" + len);
90: Brandon Li, warn, MethodDeclaration, LOG.warn("Portmap mapping registration request was denied , " + deniedReply);
99: Brandon Li, warn, IfStmt, LOG.warn("Portmap mapping registration failed, accept state:" + acceptState);
102: Brandon Li, info, MethodDeclaration, LOG.info("Portmap mapping registration succeeded");
63: Akira Ajisaka, trace, IfStmt, LOG.trace(this.toString());
99: Aaron Myers, info, ConstructorDeclaration, LOG.info("Will " + (allowInsecurePorts ? "" : "not ") + "accept client " + "connections from unprivileged ports");
110: Brandon Li, info, IfStmt, LOG.info("The bound port is " + boundPort + ", different with configured port " + port);
129: Brandon Li, info, IfStmt, LOG.info("The bound port is " + boundPort + ", different with configured port " + port);
154: Brandon Li, error, CatchClause, LOG.error(request + " failure with " + host + ":" + port + ", portmap entry: " + mapEntry);
172: Brandon Li, trace, IfStmt, LOG.trace(program + " procedure #" + call.getProcedure());
176: Brandon Li, warn, IfStmt, LOG.warn("Invalid RPC call program " + call.getProgram());
183: Brandon Li, warn, IfStmt, LOG.warn("Invalid RPC call version " + ver);
194: Brandon Li, trace, IfStmt, LOG.trace("Will not allow connections from unprivileged ports. " + "Checking for valid client port...");
206: Brandon Li, warn, IfStmt, LOG.warn("Could not determine remote port of socket address '" + remoteAddress + "'. Rejecting connection.");
201: Brandon Li, warn, IfStmt, LOG.warn("Connection attempted from '" + inetRemoteAddress + "' " + "which is an unprivileged port. Rejecting connection.");
129: Haohui Mai, info, CatchClause, LOG.info("Malformed RPC request from " + e.getRemoteAddress());
45: Brandon Li, debug, IfStmt, LOG.debug("sending PRC request");
62: Brandon Li, warn, MethodDeclaration, LOG.warn("Unexpected exception from downstream: ", e.getCause());
93: Brandon Li, info, MethodDeclaration, LOG.info("Started listening to TCP requests at port " + boundPort + " for " + rpcProgram + " with workerCount " + workerCount);
74: Brandon Li, info, MethodDeclaration, LOG.info("Started listening to UDP requests at port " + boundPort + " for " + rpcProgram + " with workerCount " + workerCount);
39: Jing Zhao, Error, CatchClause, LOG.error("Error setting HOSTNAME", e);
36: Jing Zhao, debug, IfStmt, LOG.debug("HOSTNAME = " + HOSTNAME);
68: Akira Ajisaka, error, CatchClause, LOG.error("Failed to start the server. Cause:", e);
127: Brandon Li, info, MethodDeclaration, LOG.info("Portmap server started at tcp://" + tcpChannel.getLocalAddress() + ", udp://" + udpChannel.getLocalAddress());
94: Brandon Li, debug, IfStmt, LOG.debug("Portmap set key=" + key);
112: Brandon Li, debug, BlockStmt, LOG.debug("Portmap remove key=" + key);
128: Brandon Li, debug, IfStmt, LOG.debug("Portmap GETPORT key=" + key + " " + mapping);
138: Brandon Li, Warn, IfStmt, LOG.warn("Warning, no mapping for key: " + key);
135: Brandon Li, debug, IfStmt, LOG.debug("Found mapping for key: " + key + " port:" + res);
178: Brandon Li, info, IfStmt, LOG.info("PortmapHandler unknown rpc procedure=" + portmapProc);
206: Brandon Li, warn, MethodDeclaration, LOG.warn("Encountered ", e.getCause());
83: Chris Nauroth, INFO, MethodDeclaration, b.group(group).channel(NioSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).handler(new XceiverClientInitializer(this.pipeline, semaphore));
96: Chris Nauroth, debug, MethodDeclaration, LOG.debug("Connecting to server Port : " + port);
97: Anu Engineer, error, IfStmt, LOG.error("A reply received for message that was not queued. trace " + "ID: {}", msg.getTraceID());
104: Chris Nauroth, debug, MethodDeclaration, LOG.debug("channelRegistered: Connected to ctx");
110: Chris Nauroth, info, MethodDeclaration, LOG.info("Exception in client " + cause.toString());
169: Anu Engineer, error, IfStmt, LOG.error("Command with Trace already exists. Ignoring this command. " + "{}. Previous Command: {}", request.getTraceID(), previous.toString());
92: Mukul Kumar Singh, debug, MethodDeclaration, LOG.debug("initializing pipeline:{} with nodes:{}", clusterId, group.getPeers());
144: Anu Engineer, error, CatchClause, LOG.error("Failed to reinitialize RaftPeer:{} datanode: {}  ", p, datanode, ioe);
158: Tsz-Wo Nicholas Sze, debug, MethodDeclaration, LOG.debug("Connecting to pipeline:{} leader:{}", getPipeline().getPipelineName(), RatisHelper.toRaftPeerId(pipeline.getLeader()));
216: Weiwei Yang, debug, MethodDeclaration, LOG.debug("sendCommand {} {}", isReadOnlyRequest, request);
220: Weiwei Yang, debug, MethodDeclaration, LOG.debug("reply {} {}", isReadOnlyRequest, reply);
229: Tsz-Wo Nicholas Sze, debug, MethodDeclaration, LOG.debug("sendCommandAsync {} {}", isReadOnlyRequest, request);
255: Tsz-Wo Nicholas Sze, debug, MethodCallExpr, LOG.debug("received reply {} for request: {} exception: {}", request, reply, e);
144: Anu Engineer, debug, IfStmt, LOG.debug("Created container " + containerId + " leader:" + pipeline.getLeader() + " machines:" + pipeline.getMachines());
271: Anu Engineer, debug, IfStmt, LOG.debug("Deleted container {}, leader: {}, machines: {} ", pipeline.getContainerName(), pipeline.getLeader(), pipeline.getMachines());
312: Anu Engineer, debug, IfStmt, LOG.debug("Read container {}, leader: {}, machines: {} ", pipeline.getContainerName(), pipeline.getLeader(), pipeline.getMachines());
347: Weiwei Yang, debug, TryStmt, LOG.debug("Close container {}", pipeline);
251: Anu Engineer, error, IfStmt, LOG.error("Ozone is not supported in a security enabled cluster. ");
168: Nanda kumar, debug, IfStmt, LOG.debug("Not a valid tag" + tag);
216: Nanda kumar, warn, CatchClause, LOG.warn("Cannot access storage directory " + rootPath, ex);
203: Nanda kumar, warn, IfStmt, LOG.warn("Storage directory " + rootPath + " does not exist");
208: Nanda kumar, warn, IfStmt, LOG.warn(rootPath + "is not a directory");
212: Nanda kumar, warn, IfStmt, LOG.warn("Cannot access storage directory " + rootPath);
53: Nandakumar, debug, IfStmt, LOG.debug("Executing callbacks for lease on {}", resource);
59: Nandakumar, warn, CatchClause, LOG.warn("Exception while executing callback for lease on {}", resource, e);
65: Nandakumar, debug, MethodDeclaration, LOG.debug("Starting LeaseManager service");
78: Nandakumar, debug, MethodDeclaration, LOG.debug("Starting LeaseManager#LeaseMonitor Thread");
110: Nandakumar, debug, IfStmt, LOG.debug("Acquiring lease on {} for {} milliseconds", resource, timeout);
150: Nandakumar, debug, IfStmt, LOG.debug("Releasing lease on {}", resource);
166: Nandakumar, debug, MethodDeclaration, LOG.debug("Shutting down LeaseManager service");
206: Nandakumar, debug, WhileStmt, LOG.debug("LeaseMonitor: checking for lease expiry");
105: Anu Engineer, debug, MethodDeclaration, LOG.debug("Running background service : {}", serviceName);
113: Anu Engineer, debug, MethodDeclaration, LOG.debug("Number of background tasks to execute : {}", tasks.size());
135: Weiwei Yang, warn, CatchClause, LOG.warn("Background task fails to execute, " + "retrying in next interval", e);
139: Weiwei Yang, warn, CatchClause, LOG.warn("Background task executes timed out, " + "retrying in next interval", e);
132: Weiwei Yang, debug, IfStmt, LOG.debug("task execution result size {}", result.getSize());
148: Weiwei Yang, info, MethodDeclaration, LOG.info("Shutting down service {}", this.serviceName);
82: Weiwei Yang, debug, IfStmt, LOG.debug("LevelDB successfully opened");
83: Weiwei Yang, debug, IfStmt, LOG.debug("[Option] cacheSize = " + options.cacheSize());
84: Weiwei Yang, debug, IfStmt, LOG.debug("[Option] createIfMissing = " + options.createIfMissing());
85: Weiwei Yang, debug, IfStmt, LOG.debug("[Option] blockSize = " + options.blockSize());
86: Weiwei Yang, debug, IfStmt, LOG.debug("[Option] compressionType= " + options.compressionType());
87: Weiwei Yang, debug, IfStmt, LOG.debug("[Option] maxOpenFiles= " + options.maxOpenFiles());
88: Weiwei Yang, debug, IfStmt, LOG.debug("[Option] writeBufferSize= " + options.writeBufferSize());
365: Weiwei Yang, debug, IfStmt, LOG.debug("getRangeKVs ({}) numOfKeysScanned={}, numOfKeysHinted={}", filter.getClass().getSimpleName(), filter.getKeysScannedNum(), filter.getKeysHintedNum());
374: Weiwei Yang, debug, IfStmt, LOG.debug("Time consumed for getRangeKVs() is {}ms," + " result length is {}.", timeConsumed, result.size());
77: Nanda kumar, warn, IfStmt, LOG.warn("jmx registration failed during RocksDB init, db path :{}", dbFile.getAbsolutePath());
87: Anu Engineer, debug, IfStmt, LOG.debug("RocksDB successfully opened.");
88: Anu Engineer, debug, IfStmt, LOG.debug("[Option] dbLocation= {}", dbLocation.getAbsolutePath());
89: Anu Engineer, debug, IfStmt, LOG.debug("[Option] createIfMissing = {}", options.createIfMissing());
90: Anu Engineer, debug, IfStmt, LOG.debug("[Option] compactionPriority= {}", options.compactionStyle());
91: Anu Engineer, debug, IfStmt, LOG.debug("[Option] compressionType= {}", options.compressionType());
92: Anu Engineer, debug, IfStmt, LOG.debug("[Option] maxOpenFiles= {}", options.maxOpenFiles());
93: Anu Engineer, debug, IfStmt, LOG.debug("[Option] writeBufferSize= {}", options.writeBufferSize());
226: Weiwei Yang, debug, IfStmt, LOG.debug("getRangeKVs ({}) numOfKeysScanned={}, numOfKeysHinted={}", filter.getClass().getSimpleName(), filter.getKeysScannedNum(), filter.getKeysHintedNum());
233: Anu Engineer, debug, IfStmt, LOG.debug("Time consumed for getRangeKVs() is {}ms," + " result length is {}.", timeConsumed, result.size());
283: Anu Engineer, warn, CatchClause, LOG.warn("Failed to delete dir {}", fileOrDir.getAbsolutePath(), e);
117: Mukul Kumar Singh, trace, MethodDeclaration, LOG.trace("newRaftClient: {}, leader={}, group={}", rpcType, leader, group);
216: Anu Engineer, error, CatchClause, LOG.error("Stale Node Interval is cannot be honored due to " + "mis-configured {}. ex:  {}", OZONE_SCM_HEARTBEAT_PROCESS_INTERVAL, ex);
227: Anu Engineer, error, CatchClause, LOG.error("Stale Node Interval MS is cannot be honored due to " + "mis-configured {}. ex:  {}", OZONE_SCM_HEARTBEAT_INTERVAL, ex);
254: Anu Engineer, error, CatchClause, LOG.error("Dead Node Interval MS is cannot be honored due to " + "mis-configured {}. ex:  {}", OZONE_SCM_STALENODE_INTERVAL, ex);
117: Anu Engineer, error, IfStmt, LOG.error("A valid file path is needed for config setting {}", ScmConfigKeys.OZONE_SCM_DATANODE_ID);
147: Xiaoyu Yao, error, CatchClause, LOG.error("Unable to load HDDS DataNode plugins. " + "Specified list of plugins: {}", pluginsValue, e);
157: Xiaoyu Yao, warn, CatchClause, LOG.warn("ServicePlugin {} could not be started", plugin, t);
155: Xiaoyu Yao, info, TryStmt, LOG.info("Started plug-in {}", plugin);
191: Mukul Kumar Singh, info, CatchClause, LOG.info("Interrupted during StorageContainerManager join.");
203: Xiaoyu Yao, warn, CatchClause, LOG.warn("ServicePlugin {} could not be stopped", plugin, t);
201: Xiaoyu Yao, info, TryStmt, LOG.info("Stopped plug-in {}", plugin);
219: Mukul Kumar Singh, warn, CatchClause, LOG.warn("ServicePlugin {} could not be closed", plugin, t);
238: Mukul Kumar Singh, error, CatchClause, LOG.error("Exception in HddsDatanodeService.", e);
122: Chris Nauroth, error, IfStmt, log.error("Rejecting write chunk request. Chunk overwrite " + "without explicit request. {}", info.toString());
146: Chris Nauroth, error, IfStmt, log.error("Invalid container Name: {}", pipeline.getContainerName());
154: Chris Nauroth, error, IfStmt, log.error("Unable to find the data directory: {}", dataDir);
181: Chris Nauroth, error, IfStmt, log.error(err);
215: Anu Engineer, error, CatchClause, log.error("Unable to release lock ??, Fatal Error.");
202: Anu Engineer, error, IfStmt, log.error("Invalid write size found. Size:{}  Expected: {} ", size, data.length);
246: Chris Nauroth, error, IfStmt, log.error("Checksum mismatch. Provided: {} , computed: {}", chunkInfo.getChecksum(), DigestUtils.sha256Hex(sha.digest()));
270: Chris Nauroth, error, IfStmt, log.error("Unable to find the chunk file. chunk info : {}", data.toString());
300: Anu Engineer, error, CatchClause, log.error("I/O error is lock release.");
128: Anu Engineer, info, MethodDeclaration, log.info("Operation: {} : Trace ID: {} : Message: {} : Result: {}", msg.getCmdType().name(), msg.getTraceID(), ex.getMessage(), ex.getResult().getValueDescriptor().getName());
145: Anu Engineer, info, MethodDeclaration, log.info("Operation: {} : Trace ID: {} : Message: {} ", msg.getCmdType().name(), msg.getTraceID(), ex.getMessage());
198: Chris Nauroth, error, IfStmt, log.error("container already exists on disk. File: {}", containerFile.toPath());
205: Chris Nauroth, error, IfStmt, log.error("metadata found on disk, but missing container. Refusing to" + " write this container. File: {} ", metadataFile.toPath());
214: Chris Nauroth, error, IfStmt, log.error("Unable to create parent path. Path: {}", parentPath.toString());
220: Chris Nauroth, error, IfStmt, log.error("creation of a new container file failed. File: {}", containerFile.toPath());
226: Chris Nauroth, error, IfStmt, log.error("creation of the metadata file failed. File: {}", metadataFile.toPath());
249: Chris Nauroth, error, IfStmt, log.error("Unable to create directory for metadata storage. Path: {}", metadataPath);
114: Chris Nauroth, error, CatchClause, LOG.error("write data failed. error: {}", e);
119: Chris Nauroth, error, CatchClause, LOG.error("write data failed. error: {}", e);
92: Tsz-Wo Nicholas Sze, debug, TryStmt, LOG.debug("writing chunk:{} chunk stage:{} chunk file:{} tmp chunk file", info.getChunkName(), stage, chunkFile, tmpChunkFile);
178: Chris Nauroth, error, CatchClause, LOG.error("read data failed. error: {}", e);
183: Chris Nauroth, error, CatchClause, LOG.error("read data failed. error: {}", e);
214: Chris Nauroth, error, IfStmt, LOG.error("Not Supported Operation. Trying to delete a " + "chunk that is in shared file. chunk info : " + info.toString());
121: Owen O'Malley, warn, CatchClause, LOG.warn("Failed to get scmUsed and remaining for container " + "storage location {}", loc.getNormalizedUri());
165: Anu Engineer, error, IfStmt, LOG.error("Container metadata directory doesn't exist " + "and cannot be created. Path: {}", path.toString());
176: Anu Engineer, error, IfStmt, LOG.error("Invalid path to container metadata directory. path: {}", path.toString());
181: Anu Engineer, info, ForeachStmt, LOG.info("Loading containers under {}", path);
185: Anu Engineer, debug, ForeachStmt, LOG.debug("Loading container {}", containerFile);
300: Anu Engineer, error, CatchClause, LOG.error("read failed for file: {} ex: {}", containerName, ex.getMessage());
344: Anu Engineer, error, CatchClause, LOG.error("Internal error: We seem to be running a JVM without a " + "needed hash algorithm.");
330: Anu Engineer, debug, IfStmt, LOG.debug("container already exists. {}", containerData.getName());
483: Anu Engineer, debug, IfStmt, LOG.debug("No such container. Name: {}", containerName);
488: Anu Engineer, debug, IfStmt, LOG.debug("Invalid container data. Name: {}", containerName);
594: Anu Engineer, Error, CatchClause, LOG.error("Error in DB compaction while closing container", e);
696: Anu Engineer, warn, IfStmt, LOG.warn("Unable to delete container file backup : {}.", containerFileBK.getAbsolutePath());
868: Anu Engineer, debug, MethodDeclaration, LOG.debug("Starting container report iteration.");
887: Anu Engineer, debug, MethodDeclaration, LOG.debug("Starting container report iteration.");
72: Nandakumar, error, IfStmt, LOG.error("Unable to create the container storage location at : {}", dataDir);
166: Anu Engineer, info, IfStmt, LOG.info("Cached ScmUsed found for {} : {} ", dataLocation, cachedScmUsed);
181: Anu Engineer, warn, IfStmt, LOG.warn("Failed to delete old scmUsed file in {}.", dataLocation);
96: Anu Engineer, trace, MethodDeclaration, LOG.trace("Command {}, trace ID: {} ", msg.getCmdType().toString(), msg.getTraceID());
187: Chris Nauroth, warn, CatchClause, LOG.warn("Container operation failed. " + "Container: {} Operation: {}  trace ID: {} Error: {}", msg.getCreateContainer().getContainerData().getName(), msg.getCmdType().name(), msg.getTraceID(), ex.toString(), ex);
231: Chris Nauroth, warn, CatchClause, LOG.warn("Container operation failed. " + "Container: {} Operation: {}  trace ID: {} Error: {}", msg.getCreateContainer().getContainerData().getName(), msg.getCmdType().name(), msg.getTraceID(), ex.toString(), ex);
274: Chris Nauroth, warn, CatchClause, LOG.warn("Container operation failed. " + "Container: {} Operation: {}  trace ID: {} Error: {}", msg.getCreateContainer().getContainerData().getName(), msg.getCmdType().name(), msg.getTraceID(), ex.toString(), ex);
317: Xiaoyu Yao, debug, IfStmt, LOG.debug("Malformed read container request. trace ID: {}", msg.getTraceID());
347: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed read container request. trace ID: {}", msg.getTraceID());
368: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed delete container request. trace ID: {}", msg.getTraceID());
392: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed create container request. trace ID: {}", msg.getTraceID());
419: Xiaoyu Yao, debug, IfStmt, LOG.debug("Malformed close Container request. trace ID: {}", msg.getTraceID());
448: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed write chunk request. trace ID: {}", msg.getTraceID());
488: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed read chunk request. trace ID: {}", msg.getTraceID());
517: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed delete chunk request. trace ID: {}", msg.getTraceID());
549: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed put key request. trace ID: {}", msg.getTraceID());
577: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed get key request. trace ID: {}", msg.getTraceID());
600: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed delete key request. trace ID: {}", msg.getTraceID());
629: Anu Engineer, debug, IfStmt, LOG.debug("Malformed put small file request. trace ID: {}", msg.getTraceID());
678: Anu Engineer, debug, IfStmt, LOG.debug("Malformed get small file request. trace ID: {}", msg.getTraceID());
59: Weiwei Yang, debug, IfStmt, LOG.debug("Select container {} for block deletion, " + "pending deletion blocks num: {}.", entry.getContainer().getContainerName(), entry.getNumPendingDeletionBlocks());
80: Weiwei Yang, debug, IfStmt, LOG.debug("Stop looking for next container, there is no" + " pending deletion block contained in remaining containers.");
74: Weiwei Yang, debug, IfStmt, LOG.debug("Select container {} for block deletion, " + "pending deletion blocks num: {}.", entry.getContainer().getContainerName(), entry.getNumPendingDeletionBlocks());
148: Anu Engineer, error, CatchClause, LOG.error("Unable to finish the execution.", e);
135: Anu Engineer, debug, TryStmt, LOG.debug("Executing cycle Number : {}", context.getExecutionCount());
201: Anu Engineer, Error, CatchClause, LOG.error("Error attempting to shutdown.", e);
198: Anu Engineer, error, IfStmt, LOG.error("Unable to shutdown state machine properly.");
289: Anu Engineer, error, CatchClause, LOG.error("Unable to start the DatanodeState Machine", ex);
287: Anu Engineer, info, TryStmt, LOG.info("Ozone container server started.");
318: Anu Engineer, error, CatchClause, LOG.error("Stop ozone container server failed.", e);
316: Anu Engineer, info, TryStmt, LOG.info("Ozone container server stopped.");
202: Anu Engineer, trace, MethodDeclaration, LOG.trace("Incrementing the Missed count. Ex : {}", ex);
206: Anu Engineer, warn, IfStmt, LOG.warn("Unable to communicate to SCM server at {}. We have not been " + "able to communicate to this SCM server for past {} seconds.", this.getAddress().getHostString() + ":" + this.getAddress().getPort(), this.getMissedCount() * getScmHeartbeatInterval(this.conf));
133: Anu Engineer, warn, IfStmt, LOG.warn("Trying to add an existing SCM Machine to Machines group. " + "Ignoring the request.");
168: Anu Engineer, warn, IfStmt, LOG.warn("Trying to remove a non-existent SCM machine. " + "Ignoring the request.");
209: Xiaoyu Yao, debug, IfStmt, LOG.debug("Task {} executed, state transited from {} to {}", task.getClass().getSimpleName(), this.state, newState);
121: Weiwei Yang, warn, CatchClause, LOG.warn("Failed to initiate block deleting tasks, " + "caused by unable to get containers info. " + "Retry in next interval. ", e);
127: Weiwei Yang, debug, IfStmt, LOG.debug("Unexpected error occurs during deleting blocks.", e);
111: Weiwei Yang, info, TryStmt, LOG.info("Plan to choose {} containers for block deletion, " + "actually returns {} valid containers.", containerLimitPerInterval, containers.size());
182: Weiwei Yang, debug, IfStmt, LOG.debug("No under deletion block found in container : {}", containerData.getContainerName());
187: Weiwei Yang, debug, MethodDeclaration, LOG.debug("Container : {}, To-Delete blocks : {}", containerData.getContainerName(), toDeleteBlocks.size());
191: Weiwei Yang, error, IfStmt, LOG.error("Invalid container data dir {} : " + "not exist or not a directory", dataDir.getAbsolutePath());
198: Weiwei Yang, debug, LambdaExpr, LOG.debug("Deleting block {}", blockName);
212: Weiwei Yang, error, CatchClause, LOG.error("Failed to parse block info for block {}", blockName, e);
206: Weiwei Yang, debug, IfStmt, LOG.debug("block {} chunk {} deleted", blockName, chunkFile.getAbsolutePath());
226: Weiwei Yang, info, IfStmt, LOG.info("Container: {}, deleted blocks: {}, task elapsed time: {}ms", containerData.getContainerName(), succeedBlocks.size(), Time.monotonicNow() - startTime);
58: Chen Liang, debug, MethodDeclaration, LOG.debug("Processing Close Container command.");
73: Chen Liang, error, CatchClause, LOG.error("Can't close container " + containerName, e);
70: Anu Engineer, error, IfStmt, LOG.error("Duplicate handler for the same command. Exiting. Handle " + "key : { }", h.getCommandType().getDescriptorForType().getName());
90: Anu Engineer, error, IfStmt, LOG.error("Unknown SCM Command queued. There is no handler for this " + "command. Command: {}", command.getType().getDescriptorForType().getName());
62: Anu Engineer, debug, MethodDeclaration, LOG.debug("Processing Container Report.");
75: Anu Engineer, error, CatchClause, LOG.error("Unable to process the Container Report command.", ex);
76: Weiwei Yang, warn, IfStmt, LOG.warn("Skipping handling command, expected command " + "type {} but found {}", SCMCmdType.deleteBlocksCommand, command.getType());
81: Weiwei Yang, debug, MethodDeclaration, LOG.debug("Processing block deletion command.");
94: Weiwei Yang, info, MethodDeclaration, LOG.info("Start to delete container blocks, TXIDs={}, " + "numOfContainers={}, numOfBlocks={}", summary.getTxIDSummary(), summary.getNumOfContainers(), summary.getNumOfBlocks());
110: Weiwei Yang, warn, CatchClause, LOG.warn("Failed to delete blocks for container={}, TXID={}", entry.getContainerName(), entry.getTxID(), e);
133: Weiwei Yang, error, CatchClause, LOG.error("Unable to send block deletion ACK to SCM {}", endPoint.getAddress().toString(), e);
124: Weiwei Yang, debug, IfStmt, LOG.debug("Sending following block deletion ACK to SCM");
127: Weiwei Yang, debug, ForeachStmt, LOG.debug(result.getTxID() + " : " + result.getSuccess());
156: Weiwei Yang, debug, IfStmt, LOG.debug("Processing Container : {}, DB path : {}", containerId, containerInfo.getDBPath());
185: Yiqun Lin, debug, IfStmt, LOG.debug("Block {} not found or already under deletion in" + " container {}, skip deleting it.", blk, containerId);
175: Yiqun Lin, debug, TryStmt, LOG.debug("Transited Block {} to DELETING state in container {}", blk, containerId);
86: Anu Engineer, error, IfStmt, LOG.error("Failed to get SCM addresses: " + e.getMessage());
92: Anu Engineer, error, IfStmt, LOG.error("Null or empty SCM address list found.");
112: Nanda kumar, error, IfStmt, LOG.error("A valid file path is needed for config setting {}", ScmConfigKeys.OZONE_SCM_DATANODE_ID);
122: Anu Engineer, info, IfStmt, LOG.info("DatanodeDetails is persisted to {}", dataNodeIDPath);
131: Anu Engineer, trace, MethodDeclaration, LOG.trace("Entering init container state");
139: Anu Engineer, trace, MethodDeclaration, LOG.trace("Exiting init container state");
67: Anu Engineer, trace, MethodDeclaration, LOG.trace("Entering handshake task.");
75: Anu Engineer, trace, MethodDeclaration, LOG.trace("Exiting handshake task.");
141: Anu Engineer, Error, CatchClause, LOG.error("Error in executing end point task.", e);
150: Weiwei Yang, debug, IfStmt, LOG.debug("Illegal state {} found, expecting {}.", rpcEndpoint.getState().name(), EndPointStates.HEARTBEAT);
144: Weiwei Yang, debug, IfStmt, LOG.debug("Received SCM notification to register." + " Interrupt HEARTBEAT and transit to REGISTER state.");
160: Weiwei Yang, debug, IfStmt, LOG.debug(DeletedContainerBlocksSummary.getFrom(db.blocksTobeDeleted()).toString());
172: Chen Liang, debug, IfStmt, LOG.debug("Received SCM container close request for container {}", closeContainer.getContainerName());
244: Anu Engineer, error, IfStmt, LOG.error("No endpoint specified.");
250: Anu Engineer, error, IfStmt, LOG.error("No config specified.");
256: Anu Engineer, error, IfStmt, LOG.error("No datanode specified.");
92: Nanda kumar, error, IfStmt, LOG.error("DatanodeDetails cannot be null in RegisterEndpoint task, " + "shutting down the endpoint.");
185: Anu Engineer, error, IfStmt, LOG.error("No endpoint specified.");
191: Anu Engineer, error, IfStmt, LOG.error("No config specified.");
197: Anu Engineer, error, IfStmt, LOG.error("No datanode specified.");
78: Anu Engineer, error, CatchClause, LOG.error("Unable find a random free port for the server, " + "fallback to use default port {}", this.port, e);
76: Anu Engineer, info, TryStmt, LOG.info("Found a free port for the server : {}", this.port);
105: Chris Nauroth, INFO, MethodDeclaration, channel = new ServerBootstrap().group(bossGroup, workerGroup).channel(NioServerSocketChannel.class).handler(new LoggingHandler(LogLevel.INFO)).childHandler(new XceiverServerInitializer(storageContainer)).bind(port).syncUninterruptibly().channel();
64: Chris Nauroth, debug, MethodDeclaration, LOG.debug("Writing the reponse back to client.");
79: Chris Nauroth, error, MethodDeclaration, LOG.error("An exception caught in the pipeline : " + cause.toString());
190: Tsz-Wo Nicholas Sze, trace, MethodDeclaration, LOG.trace("dispatch {}", requestProto);
192: Tsz-Wo Nicholas Sze, trace, MethodDeclaration, LOG.trace("response {}", response);
149: Anu Engineer, warn, IfStmt, LOG.warn("Storage directory for Ratis is not configured. Mapping Ratis " + "storage under {}. It is a good idea to map this to an SSD disk.", storageDir);
173: Anu Engineer, error, CatchClause, LOG.error("Unable find a random free port for the server, " + "fallback to use default port {}", localPort, e);
164: Anu Engineer, info, TryStmt, LOG.info("Found a free port for the server : {}", localPort);
184: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("Starting {} {} at port {}", getClass().getSimpleName(), server.getId(), getIPCPort());
80: Anu Engineer, Error, CatchClause, LOG.error("Error closing DB. Container: " + container, e);
143: Anu Engineer, Error, CatchClause, LOG.error("Error opening DB. Container:{} ContainerPath:{}", containerName, containerDBPath, e);
179: Anu Engineer, info, MethodDeclaration, LOG.info("Attempting to stop container services.");
193: Anu Engineer, warn, CatchClause, LOG.warn("container service shutdown error:", ex);
191: Anu Engineer, info, TryStmt, LOG.info("container services shutdown complete.");
108: Xiaoyu Yao, info, IfStmt, LOG.info("Required directories {} already exist.", testRoot);
114: Xiaoyu Yao, info, IfStmt, LOG.info("Data dir create failed.");
140: Anu Engineer, Error, CatchClause, LOG.error("Error attempting to shutdown.", e);
137: Anu Engineer, error, IfStmt, LOG.error("Unable to shutdown properly.");
349: Xiaoyu Yao, info, LambdaExpr, LOG.info("Test with {} = {}", entry.getKey(), entry.getValue());
179: Anu Engineer, info, IfStmt, LOG.info(String.format("HTTP server of %s is listening at http://%s", name.toUpperCase(), realAddress));
188: Anu Engineer, info, IfStmt, LOG.info(String.format("HTTP server of %s is listening at https://%s", name.toUpperCase(), realAddress));
196: Anu Engineer, warn, CatchClause, LOG.warn("Unable to allocate container: {}", ex);
192: Xiaoyu Yao, warn, IfStmt, LOG.warn("Unable to allocate container.");
218: Anu Engineer, trace, MethodDeclaration, LOG.trace("Size;{} , type : {}, factor : {} ", size, type, factor);
221: Anu Engineer, warn, IfStmt, LOG.warn("Invalid block size requested : {}", size);
227: Anu Engineer, warn, IfStmt, LOG.warn("Not out of Chill mode.");
340: Anu Engineer, trace, MethodDeclaration, LOG.trace("New block allocated : {} Container ID: {}", blockKey, containerInfo.toString());
344: Anu Engineer, error, IfStmt, LOG.error("Pipeline Machine count is zero.");
382: Anu Engineer, debug, IfStmt, LOG.debug("Container {} allocated by block service" + "can't be found in SCM", containerName);
413: Weiwei Yang, info, MethodDeclaration, LOG.info("Deleting blocks {}", String.join(",", blockIDs));
61: Yiqun Lin, warn, CatchClause, SCMBlockDeletingService.LOG.warn("Got container info error.", e);
65: Yiqun Lin, warn, IfStmt, SCMBlockDeletingService.LOG.warn("Container {} not found, continue to process next", tx.getContainerName());
93: Yiqun Lin, debug, ForeachStmt, SCMBlockDeletingService.LOG.debug("Transaction added: {} <- TX({})", dnID, tx.getTxID());
209: Weiwei Yang, warn, CatchClause, LOG.warn("Cannot increase count for txID " + txID, ex);
242: Weiwei Yang, warn, CatchClause, LOG.warn("Cannot commit txID " + txID, ex);
134: Yiqun Lin, debug, IfStmt, LOG.debug("Scanned deleted blocks log and got {} delTX to process.", transactions.getTXNum());
150: Yiqun Lin, debug, IfStmt, LOG.debug("Added delete block command for datanode {} in the queue," + " number of delete block transactions: {}, TxID list: {}", dnId, dnTXs.size(), String.join(",", transactions.getTransactionIDList(dnId)));
160: Yiqun Lin, info, IfStmt, LOG.info("Totally added {} delete blocks command for" + " {} datanodes, task elapsed time: {}ms", dnTxCount, transactions.getDatanodeIDs().size(), Time.monotonicNow() - startTime);
137: Anu Engineer, trace, ConstructorDeclaration, LOG.trace("Container State Manager created.");
143: Anu Engineer, trace, ConstructorDeclaration, LOG.trace("Starting Container Lease Manager.");
416: Xiaoyu Yao, Error, IfStmt, LOG.error("Error while processing container report from datanode :" + " {}, for container: {}, reason: container doesn't exist in" + "container database.", reports.getDatanodeDetails(), datanodeState.getContainerName());
412: Nanda kumar, info, IfStmt, LOG.info("Closing the Container: {}", newState.getContainerName());
494: Nanda kumar, error, IfStmt, LOG.error("Failed to close container {}, reason : Not able " + "to " + "update container state, current container state: {}.", newState.getContainerName(), state);
589: Anu Engineer, debug, IfStmt, LOG.debug("Container state manager has container {} but not found " + "in container store, a deleted container?", info.getContainerName());
170: Anu Engineer, error, IfStmt, LOG.error("Could not list the containers", e);
165: Anu Engineer, info, IfStmt, LOG.info("No containers to load for this cluster.");
187: Anu Engineer, error, CatchClause, LOG.error("Unable to create a container information. ", ex);
314: Anu Engineer, trace, MethodDeclaration, LOG.trace("New container allocated: {}", containerInfo);
336: Anu Engineer, error, CatchClause, LOG.error(error);
151: Nanda kumar, debug, LambdaExpr, LOG.debug("Starting close container Hash map cleaner.");
167: Nanda kumar, error, CatchClause, LOG.error("Unable to finish cleaning the closed containers map.", ex);
165: Nanda kumar, debug, TryStmt, LOG.debug("Finished running, close container Hash map cleaner.");
111: Anu Engineer, error, IfStmt, LOG.error(msg);
120: Anu Engineer, error, IfStmt, LOG.error(msg);
132: Anu Engineer, error, IfStmt, LOG.error(msg);
176: Anu Engineer, error, IfStmt, LOG.error("Unable to find the required number of healthy nodes that " + "meet the criteria. Required nodes: {}, Found nodes: {}", nodesRequired, results.size());
235: Nanda kumar, debug, IfStmt, LOG.debug("Not within the time window for processing: {}", pool.getPoolName());
241: Nanda kumar, debug, IfStmt, LOG.debug("Adding pool {} to container processing queue", pool.getPoolName());
317: Weiwei Yang, warn, CatchClause, LOG.warn("Skipping processing container report from datanode {}, " + "cause: failed to get the corresponding node pool", datanodeDetails.toString(), e);
312: Nanda kumar, debug, TryStmt, LOG.debug("Discarding the container report for pool {}. " + "That pool is not currently in the pool reconciliation process." + " Container Name: {}", poolName, containerReport.getDatanodeDetails());
171: Anu Engineer, error, IfStmt, LOG.error("Datanode list for {} is Empty. Pool with no nodes ? ", pool.getPoolName());
223: Anu Engineer, error, IfStmt, LOG.error("Not able to determine the state of Node: {}, Exceeded max " + "try and node manager returns INVALID state. This indicates we " + "are dealing with a node that we don't know about.", datanode);
243: Nanda kumar, debug, IfStmt, LOG.debug("Cannot handle container report when the pool is in {} status.", status);
256: Anu Engineer, debug, IfStmt, LOG.debug("Total Nodes processed : {} Node Name: {} ", nodeProcessed, datanodeDetails.getUuid());
260: Anu Engineer, debug, ForeachStmt, LOG.debug("Total Containers processed: {} Container Name: {}", containerProcessedCount.get(), info.getContainerName());
102: Anu Engineer, error, IfStmt, LOG.error("Failure to remove the object from the Map.Key:{}, " + "ContainerID: {}", key, value);
170: Anu Engineer, debug, IfStmt, LOG.debug("key: {} does not exist in the attributeMap", key);
192: Anu Engineer, debug, IfStmt, LOG.debug("key: {} does not exist in the attributeMap", key);
186: Anu Engineer, debug, IfStmt, LOG.debug("ContainerID: {} does not exist in the set pointed by " + "key:{}", value, key);
209: Anu Engineer, debug, MethodDeclaration, LOG.debug("No such Key. Key {}", key);
240: Anu Engineer, trace, IfStmt, LOG.trace("reinserted the removed key. {}", currentKey);
124: Anu Engineer, debug, IfStmt, LOG.debug("Duplicate container ID detected. {}", id);
134: Anu Engineer, trace, TryStmt, LOG.trace("Created container with {} successfully.", id);
227: Anu Engineer, error, CatchClause, LOG.error("Unable to update the container state. {}", ex);
224: Anu Engineer, trace, TryStmt, LOG.trace("Updated the container {} to new state. Old = {}, new = " + "{}", id, currentState, newState);
196: Anu Engineer, info, ConstructorDeclaration, LOG.info("Entering startup chill mode.");
332: Anu Engineer, info, IfStmt, LOG.info("Leaving startup chill mode.");
336: Anu Engineer, info, IfStmt, LOG.info("Leaving manual chill mode.");
346: Anu Engineer, info, MethodDeclaration, LOG.info("Entering manual chill mode.");
355: yuanbo, info, MethodDeclaration, LOG.info("Leaving manual chill mode.");
464: Anu Engineer, info, IfStmt, LOG.info("Current Thread is isInterrupted, shutting down HB " + "processing thread for Node Manager.");
471: Anu Engineer, error, IfStmt, LOG.error("SCM is being flooded by heartbeats. Not able to keep up with" + " the heartbeat counts. Processed {} heartbeats. Breaking out of" + " loop. Leaving rest to be processed later. ", lastHBProcessedCount);
530: Anu Engineer, info, IfStmt, LOG.info("Current Thread is interrupted, shutting down HB processing " + "thread for Node Manager.");
541: Anu Engineer, error, IfStmt, LOG.error("Total time spend processing datanode HB's is greater than " + "configured values for datanode heartbeats. Please adjust the" + " heartbeat configs. Time Spend on HB processing: {} seconds " + "Datanode heartbeat Interval: {} seconds , heartbeats " + "processed: {}", TimeUnit.MILLISECONDS.toSeconds(lastHBcheckFinished - lastHBcheckStart), datanodeHBIntervalSeconds, lastHBProcessedCount);
558: Anu Engineer, trace, MethodDeclaration, LOG.trace("Moving healthy node to stale: {}", entry.getKey());
576: Anu Engineer, trace, MethodDeclaration, LOG.trace("Moving stale node to dead: {}", entry.getKey());
603: Anu Engineer, trace, IfStmt, LOG.trace("Processing Heartbeat from datanode {}: queueing time {}", datanodeUuid, processTimestamp - recvTimestamp);
643: Xiaoyu Yao, warn, MethodDeclaration, LOG.warn("SCM receive heartbeat from unregistered datanode {}", datanodeUuid);
652: Anu Engineer, debug, IfStmt, LOG.debug("SCM updateNodeStat based on heartbeat from previous" + "dead datanode {}", dnId);
707: Anu Engineer, error, IfStmt, LOG.error("Unable to shutdown NodeManager properly.");
774: Anu Engineer, info, IfStmt, LOG.info("Leaving startup chill mode.");
791: Anu Engineer, info, MethodDeclaration, LOG.info("Data node with ID: {} Registered.", datanodeDetails.getUuid());
812: Anu Engineer, trace, IfStmt, LOG.trace("Datanode is already registered. Datanode: {}", datanodeDetails.toString());
854: Anu Engineer, error, IfStmt, LOG.error("Datanode ID in heartbeat is null");
129: Anu Engineer, error, CatchClause, LOG.error("Loading node pool error " + e);
124: Anu Engineer, warn, CatchClause, LOG.warn("Can't add a datanode to node pool, continue next...");
120: Weiwei Yang, debug, IfStmt, LOG.debug("Adding node: {} to node pool: {}", nodeId, poolName);
84: Anu Engineer, debug, IfStmt, LOG.debug("re-used pipelineChannel:{} for container:{}", pipelineChannel.getName(), containerName);
77: Anu Engineer, debug, IfStmt, LOG.debug("created new pipelineChannel:{} for container:{}", pipelineChannel.getName(), containerName);
89: Anu Engineer, error, IfStmt, LOG.error("Get pipelineChannel call failed. We are not able to find" + "free nodes or operational pipelineChannel.");
121: Anu Engineer, error, IfStmt, LOG.error("No Operational conduits found. Returning null.");
130: Anu Engineer, error, CatchClause, LOG.error("Unhandled exception occurred, Placement policy will not be " + "functional.");
173: Anu Engineer, debug, MethodDeclaration, LOG.debug("Getting replication pipeline for {} : Replication {}", containerName, replicationFactor.toString());
187: Anu Engineer, debug, MethodDeclaration, LOG.debug("Creating a pipeline: {} with nodes:{}", pipelineID, datanodes.stream().map(DatanodeDetails::toString).collect(Collectors.joining(",")));
201: Anu Engineer, debug, MethodDeclaration, LOG.debug("Closing pipeline. pipelineID: {}", pipelineID);
213: Anu Engineer, debug, MethodDeclaration, LOG.debug("Getting data nodes from pipeline : {}", pipelineID);
225: Anu Engineer, debug, MethodDeclaration, LOG.debug("Updating pipeline: {} with new nodes:{}", pipelineID, newDatanodes.stream().map(DatanodeDetails::toString).collect(Collectors.joining(",")));
90: Anu Engineer, info, IfStmt, LOG.info("Allocating a new ratis pipelineChannel of size: {}", count);
87: Anu Engineer, info, IfStmt, LOG.info("Allocating a new standalone pipeline channel of size: {}", count);
120: Anu Engineer, info, MethodDeclaration, LOG.info(StorageContainerManager.buildRpcServerStartMessage("RPC server for Block Protocol", getBlockRpcAddress()));
131: Anu Engineer, error, CatchClause, LOG.error("Block Protocol RPC stop failed.", ex);
128: Anu Engineer, info, TryStmt, LOG.info("Stopping the RPC server for Block Protocol");
137: Anu Engineer, trace, MethodDeclaration, LOG.trace("Join RPC server for Block Protocol");
171: Anu Engineer, info, MethodDeclaration, LOG.info("SCM is informed by KSM to delete {} blocks", keyBlocksInfoList.size());
184: Anu Engineer, warn, CatchClause, LOG.warn("Fail to delete block: {}", keyBlocks.getGroupID(), scmEx);
199: Anu Engineer, warn, CatchClause, LOG.warn("Fail to delete blocks for object key: {}", keyBlocks.getGroupID(), ex);
118: Anu Engineer, info, MethodDeclaration, LOG.info(StorageContainerManager.buildRpcServerStartMessage("RPC server for Client ", getClientRpcAddress()));
129: Anu Engineer, error, CatchClause, LOG.error("Client Protocol RPC stop failed.", ex);
126: Anu Engineer, info, TryStmt, LOG.info("Stopping the RPC server for Client Protocol");
135: Anu Engineer, trace, MethodDeclaration, LOG.trace("Join RPC server for Client Protocol");
201: Anu Engineer, info, MethodDeclaration, LOG.info("Object type {} name {} op {} new stage {}", type, name, op, stage);
248: Anu Engineer, debug, IfStmt, LOG.debug("Got block deletion ACK from datanode, TXIDs={}, " + "success={}", result.getTxID(), result.getSuccess());
257: Anu Engineer, warn, IfStmt, LOG.warn("Got failed ACK for TXID={}, prepare to resend the " + "TX in next interval", result.getTxID());
252: Anu Engineer, debug, IfStmt, LOG.debug("Purging TXID={} from block deletion log", result.getTxID());
267: Anu Engineer, info, MethodDeclaration, LOG.info(StorageContainerManager.buildRpcServerStartMessage("RPC server for DataNodes", getDatanodeRpcAddress()));
278: Anu Engineer, error, CatchClause, LOG.error(" datanodeRpcServer stop failed.", ex);
275: Anu Engineer, info, TryStmt, LOG.info("Stopping the RPC server for DataNodes");
284: Anu Engineer, trace, MethodDeclaration, LOG.trace("Join RPC server for DataNodes");
262: Anu Engineer, error, CatchClause, LOG.error("Failed to start the StorageContainerManager.", t);
329: Anu Engineer, error, CatchClause, LOG.error("Could not initialize SCM version file", ioe);
363: Anu Engineer, error, IfStmt, LOG.error("Must specify a valid cluster ID after the " + StartupOption.CLUSTERID.getName() + " flag");
435: Anu Engineer, debug, SynchronizedStmt, LOG.debug("Remove expired container stat entry for datanode: " + "{}.", removalNotification.getKey());
502: Anu Engineer, info, MethodDeclaration, LOG.info(buildRpcServerStartMessage("StorageContainerLocationProtocol RPC server", getClientRpcAddress()));
509: Anu Engineer, info, MethodDeclaration, LOG.info(buildRpcServerStartMessage("ScmBlockLocationProtocol RPC " + "server", getBlockProtocolServer().getBlockRpcAddress()));
513: Anu Engineer, info, MethodDeclaration, LOG.info(buildRpcServerStartMessage("ScmDatanodeProtocl RPC " + "server", getDatanodeProtocolServer().getDatanodeRpcAddress()));
533: Anu Engineer, error, CatchClause, LOG.error("Storage Container Manager datanode RPC stop failed.", ex);
529: Anu Engineer, info, TryStmt, LOG.info("Stopping datanode service RPC server");
540: Anu Engineer, error, CatchClause, LOG.error("Storage Container Manager blockRpcServer stop failed.", ex);
537: Anu Engineer, info, TryStmt, LOG.info("Stopping block service RPC server");
547: Anu Engineer, error, CatchClause, LOG.error("Storage Container Manager clientRpcServer stop failed.", ex);
544: Anu Engineer, info, TryStmt, LOG.info("Stopping the StorageContainerLocationProtocol RPC server");
554: Anu Engineer, error, CatchClause, LOG.error("Storage Container Manager HTTP server stop failed.", ex);
551: Anu Engineer, info, TryStmt, LOG.info("Stopping Storage Container Manager HTTP server.");
561: Anu Engineer, error, CatchClause, LOG.error("SCM block manager service stop failed.", ex);
558: Anu Engineer, info, TryStmt, LOG.info("Stopping Block Manager Service.");
587: Anu Engineer, info, CatchClause, LOG.info("Interrupted during StorageContainerManager join.");
130: Anu Engineer, info, TryStmt, LOG.info("testDefaultNodePoolReload: Finish adding nodes to pool" + " and close.");
141: Anu Engineer, info, TryStmt, LOG.info("testDefaultNodePoolReload: Finish reloading node pool.");
493: Jitendra Pandey, error, CatchClause, LOG.error("The conf property " + DFS_NAMENODE_SHARED_EDITS_DIR_KEY + " is not properly set with correct journal node hostnames");
497: Jitendra Pandey, error, CatchClause, LOG.error("The conf property " + DFS_NAMENODE_SHARED_EDITS_DIR_KEY + "is not set properly with correct journal node uri");
458: Jitendra Pandey, warn, IfStmt, LOG.warn(DFS_NAMENODE_SHARED_EDITS_DIR_KEY + " is to be " + "configured as nameservice" + " specific key(append it with nameserviceId), no need" + " to append it with namenodeId");
835: Zhe Zhang, warn, CatchClause, LOG.warn("Getting exception  while trying to determine if nameservice " + nsId + " can use logical URI: " + e);
1165: Aaron Myers, trace, IfStmt, LOG.trace(String.format("addressKey: %s nsId: %s nnId: %s", addressKey, nsId, nnId));
1180: Aaron Myers, warn, CatchClause, LOG.warn("Exception in creating socket address " + addr, e);
1489: Andrew Wang, warn, CatchClause, LOG.warn("Setting password to null since IOException is caught" + " when getting password", ioe);
1562: Andrew Wang, warn, IfStmt, LOG.warn("SSL config " + sslProp + " is missing. If " + DFSConfigKeys.DFS_SERVER_HTTPS_KEYSTORE_RESOURCE_KEY + " is specified, make sure it is a relative path");
1593: Ravi Prakash, info, IfStmt, LOG.info("Starting web server as: " + SecurityUtil.getServerPrincipal(conf.get(spnegoUserNameKey), httpAddr.getHostName()));
1605: Jing Zhao, info, IfStmt, LOG.info("Starting Web-server for " + name + " at: " + uri);
1618: Jing Zhao, info, IfStmt, LOG.info("Starting Web-server for " + name + " at: " + uri);
76: Ravi Prakash, error, IfStmt, LOG.error(FETCH_FAILED);
191: Aaron Myers, error, IfStmt, LOG.error(message);
125: Yiqun Lin, debug, IfStmt, LOG.debug("No node to choose.");
138: Yiqun Lin, debug, IfStmt, LOG.debug("First trial failed, node has no type {}, " + "making second trial carrying this type", type);
192: Chen Liang, debug, IfStmt, LOG.debug("Invalid scope {}, non-existing node", scope);
231: Yiqun Lin, error, IfStmt, LOG.error("Unexpected node type: {}.", excludedNode.getClass());
248: Chen Liang, debug, IfStmt, LOG.debug("Node {} is excluded, continuing.", chosen);
251: Chen Liang, debug, MethodDeclaration, LOG.debug("chooseRandom returning {}", chosen);
197: Yiqun Lin, debug, MethodDeclaration, LOG.debug("adding node {}", n.getName());
297: Yiqun Lin, debug, MethodDeclaration, LOG.debug("removing node {}", n.getName());
382: Yiqun Lin, debug, MethodDeclaration, LOG.debug("child add storage: {}:{}", childName, type);
419: Yiqun Lin, debug, MethodDeclaration, LOG.debug("child remove storage: {}:{}", childName, type);
84: Todd Lipcon, error, CatchClause, LOG.error("error closing DomainPeerServer: ", e);
99: Todd Lipcon, error, CatchClause, LOG.error("error closing TcpPeerServer: ", e);
124: Chris Nauroth, debug, IfStmt, LOG.debug("SASL server doing general handshake for peer = {}, datanodeId = {}", peer, datanodeId);
119: Chris Nauroth, debug, IfStmt, LOG.debug("SASL server skipping handshake in secured configuration for " + "peer = {}, datanodeId = {}", peer, datanodeId);
114: Chris Nauroth, debug, IfStmt, LOG.debug("SASL server skipping handshake in unsecured configuration for " + "peer = {}, datanodeId = {}", peer, datanodeId);
109: Chris Nauroth, debug, IfStmt, LOG.debug("SASL server doing encrypted handshake for peer = {}, datanodeId = {}", peer, datanodeId);
169: Chris Nauroth, debug, IfStmt, LOG.debug("Server using encryption algorithm " + dnConf.getEncryptionAlgorithm());
398: cnauroth, debug, IfStmt, LOG.debug("Server using cipher suite {} with client {}", cipherOption.getCipherSuite().getName(), peer.getRemoteAddressString());
393: cnauroth, debug, IfStmt, LOG.debug("Server accepts cipher suites {}, " + "but client {} does not accept any of them", cipherSuites, peer.getRemoteAddressString());
70: Virajith Jalaparti, info, ConstructorDeclaration, LOG.info("Connecting to address: " + addr);
306: Todd Lipcon, Info, ForeachStmt, ListenableFuture<Void> future = logger.format(nsInfo);
328: Todd Lipcon, Info, ForeachStmt, ListenableFuture<Void> future = logger.doUpgrade(sInfo);
399: Todd Lipcon, warn, CatchClause, QuorumJournalManager.LOG.warn("Remote journal " + IPCLoggerChannel.this + " failed to " + "write txns " + firstTxnId + "-" + (firstTxnId + numTxns - 1) + ". Will try to write to this JN again after the next " + "log roll.", e);
417: Todd Lipcon, warn, IfStmt, QuorumJournalManager.LOG.warn("Took " + (rpcTime / 1000) + "ms to send a batch of " + numTxns + " edits (" + data.length + " bytes) to " + "remote journal " + IPCLoggerChannel.this);
525: Todd Lipcon, info, IfStmt, QuorumJournalManager.LOG.info("Restarting previously-stopped writes to " + IPCLoggerChannel.this + " in segment starting at txid " + txid);
127: Erik Krogen, info, IfStmt, QuorumJournalManager.LOG.info("Pause detected while waiting for " + "QuorumCall response; increasing timeout threshold by pause time " + "of " + pauseTime + " ms.");
187: Todd Lipcon, info, IfStmt, QuorumJournalManager.LOG.info(msg);
185: Todd Lipcon, warn, IfStmt, QuorumJournalManager.LOG.warn(msg);
207: Todd Lipcon, Info, MethodDeclaration, Map<AsyncLogger, NewEpochResponseProto> resps = loggers.waitForWriteQuorum(loggers.newEpoch(nsInfo, myEpoch), newEpochTimeoutMs, "newEpoch(" + myEpoch + ")");
217: Todd Lipcon, Info, MethodDeclaration, QuorumCall<AsyncLogger, Void> call = loggers.format(nsInfo);
277: Todd Lipcon, info, MethodDeclaration, LOG.info("Beginning recovery of unclosed segment starting at txid " + segmentTxId);
286: Aaron Myers, info, MethodDeclaration, LOG.info("Recovery prepare phase complete. Responses:\n" + QuorumCall.mapToString(prepareResponses));
333: Todd Lipcon, info, IfStmt, LOG.info("None of the responders had a log to recover: " + QuorumCall.mapToString(prepareResponses));
310: Todd Lipcon, info, IfStmt, LOG.info("Using longest log: " + bestEntry);
306: Todd Lipcon, info, IfStmt, LOG.info("Using already-accepted recovery for segment " + "starting at txid " + segmentTxId + ": " + bestEntry);
383: Jing Zhao, warn, IfStmt, LOG.warn("Quorum journal URI '" + uri + "' has an even number " + "of Journal Nodes specified. This is not recommended!");
435: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting recovery process for unclosed journal segments...");
437: Todd Lipcon, info, MethodDeclaration, LOG.info("Successfully started new epoch " + loggers.getEpoch());
440: Todd Lipcon, debug, IfStmt, LOG.debug("newEpoch(" + loggers.getEpoch() + ") responses:\n" + QuorumCall.mapToString(resps));
481: Todd Lipcon, debug, MethodDeclaration, LOG.debug("selectInputStream manifests:\n" + Joiner.on("\n").withKeyValueSeparator(": ").join(resps));
504: Wei-Chiu Chuang, warn, IfStmt, LOG.warn("Found endTxId (" + endTxId + ") that is less than " + "the startTxId (" + remoteLog.getStartTxId() + ") - setting it to startTxId.");
74: Todd Lipcon, warn, MethodDeclaration, QuorumJournalManager.LOG.warn("Aborting " + this);
190: Jing Zhao, Info, TryStmt, impl.startLogSegment(convert(req.getReqInfo()), req.getTxid(), layoutVersion);
203: Todd Lipcon, Info, TryStmt, impl.finalizeLogSegment(convert(req.getReqInfo()), req.getStartTxId(), req.getEndTxId());
215: Todd Lipcon, Info, TryStmt, impl.purgeLogsOlderThan(convert(req.getReqInfo()), req.getMinTxIdToKeep());
82: Todd Lipcon, warn, IfStmt, LOG.warn("Received null remoteUser while authorizing access to " + "GetJournalEditServlet");
88: Aaron Myers, debug, IfStmt, LOG.debug("Validating request made by " + remotePrincipal + " / " + remoteShortName + ". This user is: " + UserGroupInformation.getLoginUser());
102: cnauroth, debug, CatchClause, LOG.debug("SecondaryNameNode principal could not be added", e);
110: cnauroth, warn, CatchClause, LOG.warn(msg);
116: Aaron Myers, debug, BlockStmt, LOG.debug("isValidRequestor is comparing to valid requestor: " + v);
119: Aaron Myers, debug, BlockStmt, LOG.debug("isValidRequestor is allowing: " + remotePrincipal);
130: Aaron Myers, debug, BlockStmt, LOG.debug("isValidRequestor is allowing other JN principal: " + remotePrincipal);
136: Aaron Myers, debug, BlockStmt, LOG.debug("isValidRequestor is rejecting: " + remotePrincipal);
147: Todd Lipcon, warn, IfStmt, LOG.warn("Received non-NN/JN request for edits from " + request.getRemoteHost());
173: Todd Lipcon, warn, IfStmt, LOG.warn("Received an invalid request file transfer request from " + request.getRemoteAddr() + ": " + msg);
196: Xiaoyu Yao, info, IfStmt, LOG.info("Purging no-longer needed file {}", txid);
198: Xiaoyu Yao, warn, IfStmt, LOG.warn("Unable to delete no-longer-needed data {}", f);
216: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Formatting journal {} with nsid: {}", sd, getNamespaceID());
280: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Closing journal storage for {}", sd);
205: Todd Lipcon, info, MethodDeclaration, LOG.info("Scanning storage " + fjm);
211: Todd Lipcon, info, WhileStmt, LOG.info("Latest log is " + latestLog);
214: Todd Lipcon, warn, IfStmt, LOG.warn("Latest log " + latestLog + " has no transactions. " + "moving it aside and looking for previous log");
222: Todd Lipcon, info, MethodDeclaration, LOG.info("No files in " + fjm);
233: Todd Lipcon, info, MethodDeclaration, LOG.info("Formatting " + this + " with namespace info: " + nsInfo);
345: Todd Lipcon, info, MethodDeclaration, LOG.info("Updating lastPromisedEpoch from " + lastPromisedEpoch.get() + " to " + newEpoch + " for client " + Server.getRemoteIp());
402: Todd Lipcon, trace, IfStmt, LOG.trace("Writing txid " + firstTxnId + "-" + lastTxnId);
425: Todd Lipcon, warn, IfStmt, LOG.warn("Sync of transaction range " + firstTxnId + "-" + lastTxnId + " took " + milliSeconds + "ms");
543: Todd Lipcon, warn, IfStmt, LOG.warn("Client is requesting a new log segment " + txid + " though we are already writing " + curSegment + ". " + "Aborting the current segment in order to begin the new one.");
574: Todd Lipcon, info, IfStmt, LOG.info("Updating lastWriterEpoch from " + curLastWriterEpoch + " to " + reqInfo.getEpoch() + " for client " + Server.getRemoteIp());
626: Todd Lipcon, info, IfStmt, LOG.info("Validating log segment " + elf.getFile() + " about to be " + "finalized");
719: Todd Lipcon, info, IfStmt, LOG.info("Edit log file " + elf + " appears to be empty. " + "Moving it aside...");
729: Todd Lipcon, Info, MethodDeclaration, LOG.info("getSegmentInfo(" + segmentTxId + "): " + elf + " -> " + TextFormat.shortDebugString(ret));
773: Todd Lipcon, info, MethodDeclaration, LOG.info("Prepared recovery for segment " + segmentTxId + ": " + TextFormat.shortDebugString(resp));
859: Todd Lipcon, info, IfStmt, LOG.info("Skipping download of log " + TextFormat.shortDebugString(segment) + ": already have up-to-date logs");
826: Todd Lipcon, info, IfStmt, LOG.info("Synchronizing log " + TextFormat.shortDebugString(segment) + ": old segment " + TextFormat.shortDebugString(currentSegment) + " is not the right length");
819: Todd Lipcon, info, IfStmt, LOG.info("Synchronizing log " + TextFormat.shortDebugString(segment) + ": no current segment in place");
892: Todd Lipcon, info, MethodDeclaration, LOG.info("Accepted recovery for segment " + segmentTxId + ": " + TextFormat.shortDebugString(newData));
915: Todd Lipcon, info, MethodDeclaration, LOG.info("Synchronizing log " + TextFormat.shortDebugString(segment) + " from " + url);
934: Aaron Myers, warn, IfStmt, LOG.warn("Failed to delete temporary file " + tmpFile);
972: Todd Lipcon, info, IfStmt, LOG.info("Rolling forward previously half-completed synchronization: " + tmp + " -> " + dst);
1044: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting upgrade of edits directory: " + ".\n   old LV = " + oldLV + "; old CTime = " + oldCTime + ".\n   new LV = " + storage.getLayoutVersion() + "; new CTime = " + storage.getCTime());
1082: Todd Lipcon, info, MethodDeclaration, LOG.info("Finalizing upgrade for journal " + storage.getRoot() + "." + (storage.getLayoutVersion() == 0 ? "" : "\n   cur LV = " + storage.getLayoutVersion() + "; cur CTime = " + storage.getCTime()));
1129: Jing Zhao, error, IfStmt, LOG.error("The endTxId of the temporary file is not less than the " + "last committed transaction id. Aborting move to final file" + finalFile);
1114: Arpit Agarwal, error, IfStmt, LOG.error(finalFile.getParentFile() + " doesn't exist. Aborting tmp " + "segment move to current directory");
1124: Arpit Agarwal, warn, IfStmt, LOG.warn("Unable to move edits file from " + tmpFile + " to " + finalFile);
101: Hanisha Koneru, info, IfStmt, LOG.info("Initializing journal in directory " + logDir);
242: Arpit Agarwal, error, CatchClause, LOG.error("Failed to start JournalNode.", ioe);
283: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to stop HTTP server for " + this, ioe);
406: Todd Lipcon, Error, MethodDeclaration, LOG.fatal("Error reported on file " + f + "... exiting", new Exception());
417: Brahma Reddy Battula, error, CatchClause, LOG.error("Failed to start journalnode.", e);
84: Inigo Goiri, info, ConstructorDeclaration, LOG.info("RPC server is binding to " + bindHost + ":" + addr.getPort());
121: Arpit Agarwal, info, IfStmt, LOG.info("Starting SyncJournal daemon for journal " + jid);
135: Arpit Agarwal, info, IfStmt, LOG.info(editsSyncDir + " directory already exists.");
144: Jing Zhao, warn, IfStmt, LOG.warn("Other JournalNode addresses not available. Journal Syncing " + "cannot be done");
152: Jing Zhao, warn, CatchClause, LOG.warn("Could not add proxy for Journal at addresss " + addr, e);
156: Jing Zhao, error, IfStmt, LOG.error("Cannot sync as there is no other JN available for sync.");
170: Arpit Agarwal, error, CatchClause, LOG.error("JournalNodeSyncer daemon received Runtime exception.", e);
176: Arpit Agarwal, error, IfStmt, LOG.error("Failed to create directory for downloading log " + "segments: %s. Stopping Journal Node Sync.", journal.getStorage().getEditsSyncDir());
201: Arpit Agarwal, warn, IfStmt, LOG.warn("JournalNodeSyncer interrupted", t);
195: Arpit Agarwal, warn, IfStmt, LOG.warn("JournalNodeSyncer received an exception while " + "shutting down.", t);
191: Arpit Agarwal, info, IfStmt, LOG.info("Stopping JournalNode Sync.");
206: Arpit Agarwal, error, CatchClause, LOG.error("JournalNodeSyncer daemon received Runtime exception. ", t);
184: Arpit Agarwal, warn, IfStmt, LOG.warn("Journal cannot sync. Not formatted.");
215: Arpit Agarwal, warn, IfStmt, LOG.warn("JournalNodeSyncer interrupted", e);
213: Arpit Agarwal, info, IfStmt, LOG.info("Stopping JournalNode Sync.");
231: Jing Zhao, info, MethodDeclaration, LOG.info("Syncing Journal " + jn.getBoundIpcAddress().getAddress() + ":" + jn.getBoundIpcAddress().getPort() + " with " + otherJNProxies.get(index) + ", journal id: " + jid);
236: Jing Zhao, error, IfStmt, LOG.error("JournalNode Proxy not found.");
244: Jing Zhao, error, CatchClause, LOG.error("Exception in getting local edit log manifest", e);
253: Jing Zhao, error, CatchClause, LOG.error("Could not sync with Journal at " + otherJNProxies.get(journalNodeIndexForSync), e);
304: Jing Zhao, error, CatchClause, LOG.error("The conf property " + DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY + " not set properly.");
307: Arpit Agarwal, error, CatchClause, LOG.error("Could not parse JournalNode addresses: " + uriStr);
287: Arpit Agarwal, error, IfStmt, LOG.error("The conf property " + DFSConfigKeys.DFS_NAMENODE_SHARED_EDITS_DIR_KEY + " not set properly, " + "it has been configured with different journalnode values " + sharedEditsUri.toString() + " for a" + " single nameserviceId" + nameServiceId);
297: Arpit Agarwal, error, IfStmt, LOG.error("Could not construct Shared Edits Uri");
327: Jing Zhao, warn, IfStmt, LOG.warn("Journal at " + remoteJNproxy.jnAddr + " has no edit logs");
356: Arpit Agarwal, error, CatchClause, LOG.error("EditLogManifest's fromUrl field syntax incorrect", e);
358: Jing Zhao, error, CatchClause, LOG.error("MalformedURL when download missing log segment", e);
360: Jing Zhao, error, CatchClause, LOG.error("Exception in downloading missing log segment from url " + url, e);
345: Arpit Agarwal, error, IfStmt, LOG.error("EditLogManifest response does not have fromUrl " + "field set. Aborting current sync attempt");
364: Jing Zhao, error, IfStmt, LOG.error("Aborting current sync attempt.");
425: Jing Zhao, info, MethodDeclaration, LOG.info("Downloading missing Edit Log from " + url + " to " + jnStorage.getRoot());
433: Jing Zhao, info, IfStmt, LOG.info("Skipping download of remote edit log " + log + " since it's" + " already stored locally at " + finalEditsFile);
446: Jing Zhao, error, CatchClause, LOG.error("Download of Edit Log file for Syncing failed. Deleting temp " + "file: " + tmpEditsFile);
449: Jing Zhao, warn, IfStmt, LOG.warn("Deleting " + tmpEditsFile + " has failed");
453: Jing Zhao, info, MethodDeclaration, LOG.info("Downloaded file " + tmpEditsFile.getName() + " of size " + tmpEditsFile.length() + " bytes.");
461: Arpit Agarwal, info, CatchClause, LOG.info("Could not move %s to current directory.", tmpEditsFile);
464: Jing Zhao, warn, IfStmt, LOG.warn("Deleting " + tmpEditsFile + " has failed");
186: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Exporting access keys");
210: Todd Lipcon, info, MethodDeclaration, LOG.info("Setting block keys");
240: Todd Lipcon, info, MethodDeclaration, LOG.info("Updating block keys");
301: Todd Lipcon, debug, IfStmt, LOG.debug("Checking access for user=" + userId + ", block=" + block + ", access mode=" + mode + " using " + id);
425: Inigo Goiri, debug, IfStmt, LOG.debug("Generating block token for " + identifier);
284: Todd Lipcon, warn, IfStmt, LOG.warn("No KEY found for persisted identifier " + identifier.toString());
89: Virajith Jalaparti, info, MethodDeclaration, LOG.info("Attempting to load InMemoryAliasMap from \"{}\"", directory);
98: Virajith Jalaparti, info, MethodDeclaration, LOG.info("Starting InMemoryLevelDBAliasMapServer on {}", rpcAddress);
144: Virajith Jalaparti, info, MethodDeclaration, LOG.info("Stopping InMemoryLevelDBAliasMapServer");
148: Virajith Jalaparti, error, CatchClause, LOG.error(e.getMessage());
233: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info(key + " = " + v + " (default=" + defaultValue + ")");
242: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info(key + " = " + v + " (default=" + defaultValue + ")");
251: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info(key + " = " + v + " (default=" + defaultValue + ")");
364: Tsz-Wo Nicholas Sze, info, IfStmt, LOG.info(dn + "[" + t + "] has utilization=" + utilization + " >= average=" + average + " but it is not specified as a source; skipping it.");
438: Tsz-wo Sze, info, MethodDeclaration, LOG.info(items.size() + " " + name + ": " + items);
467: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("chooseStorageGroups for " + matcher + ": overUtilized => underUtilized");
475: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("chooseStorageGroups for " + matcher + ": overUtilized => belowAvgUtilized");
483: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("chooseStorageGroups for " + matcher + ": underUtilized => aboveAvgUtilized");
533: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Decided to move " + StringUtils.byteDesc(size) + " bytes from " + source.getDisplayName() + " to " + target.getDisplayName());
611: Todd Lipcon, info, IfStmt, LOG.info("Need to move " + StringUtils.byteDesc(bytesLeftToMove) + " to make the cluster balanced.");
620: Akira Ajisaka, error, IfStmt, LOG.error("Balancer exiting as upgrade is not finalized, " + "please finalize the HDFS upgrade before running the balancer.");
635: Jing Zhao, info, IfStmt, LOG.info("Will move " + StringUtils.byteDesc(bytesBeingMoved) + " in this iteration");
680: Tsz-wo Sze, info, MethodDeclaration, LOG.info("namenodes  = " + namenodes);
681: Tsz-wo Sze, info, MethodDeclaration, LOG.info("parameters = " + p);
682: Ming Ma, info, MethodDeclaration, LOG.info("included nodes = " + p.getIncludedNodes());
683: Ming Ma, info, MethodDeclaration, LOG.info("excluded nodes = " + p.getExcludedNodes());
684: Ming Ma, info, MethodDeclaration, LOG.info("source nodes = " + p.getSourceNodes());
714: Ming Ma, info, IfStmt, LOG.info("Skipping blockpool " + nnc.getBlockpoolID());
733: Zhe Zhang, info, IfStmt, LOG.info("Keytab is configured, will login using keytab.");
861: Andrew Wang, info, IfStmt, LOG.info("Will run the balancer even during an ongoing HDFS " + "upgrade. Most users will not want to run the balancer " + "during an upgrade since it will not affect used space " + "on over-utilized machines.");
857: Allen Wittenauer, info, IfStmt, LOG.info("Using a idleiterations of " + maxIdleIteration);
849: Ming Ma, info, IfStmt, LOG.info("Balancer will run on the following blockpools: " + blockpools.toString());
814: Todd Lipcon, info, TryStmt, LOG.info("Using a threshold of " + threshold);
926: Jitendra Nath Pandey, error, CatchClause, LOG.error("Exiting balancer due an exception", e);
292: Jing Zhao, debug, IfStmt, LOG.debug("Decided to move " + this);
349: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("Start moving " + this);
390: Wei-Chiu Chuang, warn, CatchClause, LOG.warn("Failed to move " + this, e);
388: Jing Zhao, info, TryStmt, LOG.info("Successfully moved " + this);
688: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info(this + " activateDelay " + delta / 1000.0 + " seconds");
791: Tsz-Wo Nicholas Sze, trace, IfStmt, LOG.trace("getBlocks(" + getDatanodeInfo() + ", " + StringUtils.TraditionalBinaryPrefix.long2String(size, "B", 2) + ") returns " + newBlksLocs.getBlocks().length + " blocks.");
835: Tsz-Wo Nicholas Sze, trace, IfStmt, LOG.trace("Add " + block + " to " + this);
930: Tsz-Wo Nicholas Sze, trace, IfStmt, LOG.trace(this + " blocksToReceive=" + blocksToReceive + ", scheduledSize=" + getScheduledSize() + ", srcBlocks#=" + srcBlocks.size());
973: Kihwal Lee, info, IfStmt, LOG.info("Failed to find a pending move for " + noMoveInterval + " ms.  Skipping " + this);
964: Zhe Zhang, warn, CatchClause, LOG.warn("Exception while getting reportedBlock list", e);
951: Konstantin V Shvachko, debug, IfStmt, LOG.debug("Sleeping " + delay + "  msec.");
993: Zhe Zhang, info, IfStmt, LOG.info("The maximum iteration time (" + MAX_ITERATION_TIME / 1000 + " seconds) has been reached. Stopping " + this);
1097: Tsz-Wo Nicholas Sze, trace, IfStmt, LOG.trace("Excluding datanode " + dn + ": outOfService=" + outOfService + ", excluded=" + excluded + ", notIncluded=" + notIncluded);
1140: Tsz-Wo Nicholas Sze, warn, IfStmt, LOG.warn("No mover threads available: skip moving " + p);
1179: Konstantin V Shvachko, debug, IfStmt, LOG.debug("Balancer allowed RPCs per sec = " + BALANCER_NUM_RPC_PER_SEC);
1180: Konstantin V Shvachko, debug, IfStmt, LOG.debug("Balancer concurrent threads = " + concurrentThreads);
1181: Konstantin V Shvachko, debug, IfStmt, LOG.debug("Disperse Interval sec = " + concurrentThreads / BALANCER_NUM_RPC_PER_SEC);
1197: Kihwal Lee, info, IfStmt, LOG.info("Limiting threads per target to the specified max.");
1200: Kihwal Lee, info, IfStmt, LOG.info("Allocating " + threadsPerTarget + " threads per target.");
1191: Kihwal Lee, warn, IfStmt, LOG.warn(DFSConfigKeys.DFS_BALANCER_MOVERTHREADS_KEY + "=" + maxMoverThreads + " is too small for moving blocks to " + targets.size() + " targets. Balancing may be slower.");
1227: Jing Zhao, warn, CatchClause, LOG.warn("Dispatcher thread failed", e.getCause());
75: Tsz-wo Sze, info, IfStmt, LOG.info("Block token params received from NN: update interval=" + StringUtils.formatTime(updateInterval) + ", token lifetime=" + StringUtils.formatTime(tokenLifetime));
159: Tsz-wo Sze, warn, CatchClause, LOG.warn("Exception shutting down access key updater thread", e);
172: Tsz-wo Sze, info, ConstructorDeclaration, LOG.info("Update block keys every " + StringUtils.formatTime(sleepInterval));
187: Tsz-wo Sze, debug, CatchClause, LOG.debug("InterruptedException in block key updater thread", e);
189: Tsz-wo Sze, error, CatchClause, LOG.error("Exception in block key updater thread", e);
182: Tsz-wo Sze, error, CatchClause, LOG.error("Failed to set keys", e);
199: Tsz-wo Sze, warn, CatchClause, LOG.warn("Exception shutting down key updater thread", e);
208: Allen Wittenauer, debug, IfStmt, LOG.debug("No block has been moved for " + notChangedIterations + " iterations, " + "maximum notChangedIterations before exit is: " + ((maxNotChangedIterations >= 0) ? maxNotChangedIterations : "Infinite"));
282: Tsz-wo Sze, warn, CatchClause, LOG.warn("Failed to delete " + idPath, ioe);
57: Kihwal Lee, info, MethodDeclaration, LOG.info("Available space block placement policy initialized: " + DFSConfigKeys.DFS_NAMENODE_AVAILABLE_SPACE_BLOCK_PLACEMENT_POLICY_BALANCED_SPACE_PREFERENCE_FRACTION_KEY + " = " + balancedPreferencePercent);
62: Kihwal Lee, warn, IfStmt, LOG.warn("The value of " + DFS_NAMENODE_AVAILABLE_SPACE_BLOCK_PLACEMENT_POLICY_BALANCED_SPACE_PREFERENCE_FRACTION_KEY + " is greater than 1.0 but should be in the range 0.0 - 1.0");
67: Kihwal Lee, warn, IfStmt, LOG.warn("The value of " + DFS_NAMENODE_AVAILABLE_SPACE_BLOCK_PLACEMENT_POLICY_BALANCED_SPACE_PREFERENCE_FRACTION_KEY + " is less than 0.5 so datanodes with more used percent will" + " receive  more block allocations.");
565: Akira Ajisaka, info, ConstructorDeclaration, LOG.info("defaultReplication         = {}", defaultReplication);
566: Akira Ajisaka, info, ConstructorDeclaration, LOG.info("maxReplication             = {}", maxReplication);
567: Akira Ajisaka, info, ConstructorDeclaration, LOG.info("minReplication             = {}", minReplication);
568: Akira Ajisaka, info, ConstructorDeclaration, LOG.info("maxReplicationStreams      = {}", maxReplicationStreams);
569: Akira Ajisaka, info, ConstructorDeclaration, LOG.info("redundancyRecheckInterval  = {}ms", redundancyRecheckIntervalMs);
570: Akira Ajisaka, info, ConstructorDeclaration, LOG.info("encryptDataTransfer        = {}", encryptDataTransfer);
571: Akira Ajisaka, info, ConstructorDeclaration, LOG.info("maxNumBlocksToLog          = {}", maxNumBlocksToLog);
579: Akira Ajisaka, info, MethodDeclaration, LOG.info("{} = {}", DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_ENABLE_KEY, isEnabled);
601: Akira Ajisaka, info, MethodDeclaration, LOG.info("{}={} min(s), {}={} min(s), {}={}", DFSConfigKeys.DFS_BLOCK_ACCESS_KEY_UPDATE_INTERVAL_KEY, updateMin, DFSConfigKeys.DFS_BLOCK_ACCESS_TOKEN_LIFETIME_KEY, lifetimeMin, DFSConfigKeys.DFS_DATA_ENCRYPTION_ALGORITHM_KEY, encryptionAlgorithm);
776: Akira Ajisaka, warn, IfStmt, LOG.warn("{} is corrupt but has no associated node.", block.getBlockId());
1258: Akira Ajisaka, warn, IfStmt, LOG.warn("Inconsistent number of corrupt replicas for {}" + " blockMap has {} but corrupt replicas map has {}", blk, numCorruptNodes, numCorruptReplicas);
1335: Akira Ajisaka, debug, IfStmt, LOG.debug("blocks = {}", java.util.Arrays.asList(blocks));
1474: Andrew Wang, warn, IfStmt, blockLog.warn("BLOCK* getBlocks: Asking for blocks from an" + " unrecorded node {}", datanode);
1555: Vinitha Reddy Gankidi, info, MethodDeclaration, LOG.info("Removed blocks associated with storage {} from DataNode {}", storageInfo, node);
1578: Akira Ajisaka, Debug, MethodDeclaration, StringBuilder datanodes = blockLog.isDebugEnabled() ? new StringBuilder() : null;
1594: Uma Mahesh, debug, IfStmt, blockLog.debug("BLOCK* addToInvalidates: {} {}", storedBlock, datanodes);
1641: Kihwal Lee, debug, IfStmt, blockLog.debug("BLOCK* findAndMarkBlockAsCorrupt: {} not found on {}", blk, dn);
1661: Xiaoyu Yao, debug, IfStmt, blockLog.debug("BLOCK markBlockAsCorrupt: {} cannot be marked as" + " corrupt as it does not belong to any file", b);
1718: Xiaoyu Yao, debug, MethodDeclaration, blockLog.debug("BLOCK* invalidateBlock: {} on {}", b, dn);
1738: Andrew Wang, debug, IfStmt, blockLog.debug("BLOCK* invalidateBlocks: {} on {} listed for deletion.", b, dn);
1727: Xiaoyu Yao, debug, IfStmt, blockLog.debug("BLOCK* invalidateBlocks: postponing " + "invalidation of {} on {} because {} replica(s) are located on " + "nodes with potentially out-of-date block reports", b, dn, nr.replicasOnStaleNodes());
1891: Zhe Zhang, debug, IfStmt, blockLog.debug("BLOCK* ask {} to replicate {} to {}", rw.getSrcNodes(), rw.getBlock(), targetList);
1896: Zhe Zhang, debug, IfStmt, blockLog.debug("BLOCK* neededReconstruction = {} pendingReconstruction = {}", neededReconstruction.size(), pendingReconstruction.size());
1935: Akira Ajisaka, debug, IfStmt, LOG.debug("Block {} cannot be reconstructed from any node", block);
1947: Zhe Zhang, debug, IfStmt, blockLog.debug("BLOCK* Removing {} from neededReconstruction as" + " it has enough replicas", block);
1993: Jing Zhao, debug, MethodDeclaration, LOG.debug("check if target {} increases racks, srcs={}", target, Arrays.asList(srcs));
1998: Jing Zhao, debug, IfStmt, LOG.debug("the target {} is in the same rack with src {}", target, src);
2024: Andrew Wang, debug, IfStmt, blockLog.debug("BLOCK* Removing {} from neededReconstruction as" + " it has enough replicas", block);
2050: Andrew Wang, debug, MethodDeclaration, blockLog.debug("BLOCK* block {} is moved from neededReconstruction to " + "pendingReconstruction", block);
2332: Colin Patrick Mccabe, warn, CatchClause, LOG.warn("Unregistered datanode {}", nodeReg);
2336: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("Failed to find datanode {}", nodeReg);
2418: Akira Ajisaka, debug, IfStmt, LOG.debug("Adjusting safe-mode totals for deletion." + "decreasing safeBlocks by {}, totalBlocks by {}", numRemovedSafe, numRemovedComplete);
2509: Yuanbo Liu, info, IfStmt, blockLog.info("BLOCK* processReport 0x{}: " + "discarded non-initial block report from {}" + " because namenode still in startup phase", strBlockReportId, nodeID);
2546: Yuanbo Liu, debug, ForeachStmt, blockLog.debug("BLOCK* processReport 0x{}: {} on node {} size {} does not" + " belong to any file", strBlockReportId, b, node, b.getNumBytes());
2555: Yuanbo Liu, info, MethodDeclaration, blockLog.info("BLOCK* processReport 0x{}: from storage {} node {}, " + "blocks: {}, hasStaleStorage: {}, processing time: {} msecs, " + "invalidatedBlocks: {}", strBlockReportId, storage.getStorageID(), nodeID, newReport.getNumberOfBlocks(), node.hasStaleStorages(), (endTime - startTime), invalidatedBlocks.size());
2578: Vinitha Reddy Gankidi, debug, IfStmt, LOG.debug("Processing RPC with index {} out of total {} RPCs in " + "processReport 0x{}", context.getCurRpc(), context.getTotalRpcs(), Long.toHexString(context.getReportId()));
2622: Akira Ajisaka, info, TryStmt, LOG.info("Rescan of postponedMisreplicatedBlocks completed in {}" + " msecs. {} blocks are left. {} blocks were removed.", (Time.monotonicNow() - startTime), endSize, (startSize - endSize));
2605: Akira Ajisaka, debug, IfStmt, LOG.debug("BLOCK* rescanPostponedMisreplicatedBlocks: " + "Postponed mis-replicated block {} no longer found " + "in block map.", b);
2611: Akira Ajisaka, debug, ForStmt, LOG.debug("BLOCK* rescanPostponedMisreplicatedBlocks: " + "Re-scanned block {}, result is {}", b, res);
2651: Yuanbo Liu, warn, IfStmt, blockLog.warn("BLOCK* processReport 0x{}: Report from the DataNode ({}) " + "is unsorted. This will cause overhead on the NameNode " + "which needs to sort the Full BR. Please update the " + "DataNode to the same version of Hadoop HDFS as the " + "NameNode ({}).", strBlockReportId, storageInfo.getDatanodeDescriptor().getDatanodeUuid(), VersionInfo.getVersion());
2687: Yuanbo Liu, info, IfStmt, blockLog.info("BLOCK* processReport 0x{}: logged info for {} of {} " + "reported.", strBlockReportId, maxNumBlocksToLog, numBlocksLogged);
2733: Xiaoyu Yao, debug, IfStmt, blockLog.debug("BLOCK* markBlockReplicasAsCorrupt: mark block replica" + " {} on {} as corrupt because the dn is not in the new committed " + "storage list.", b, storage.getDatanodeDescriptor());
2763: Akira Ajisaka, debug, IfStmt, LOG.debug("Initial report of block {} on {} size {} replicaState = {}", iblk.getBlockName(), storageInfo.getDatanodeDescriptor(), iblk.getNumBytes(), reportedState);
2844: Akira Ajisaka, debug, ForeachStmt, LOG.debug("Reported block {} on {} size {} replicaState = {}", replica, dn, replica.getNumBytes(), reportedState);
2911: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("In memory blockUCState = {}", ucState);
2954: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("Queueing reported block {} in state {}" + " from datanode {} for later processing because {}.", block, reportedState, storageInfo.getDatanodeDescriptor(), reason);
2977: Akira Ajisaka, debug, ForeachStmt, LOG.debug("Processing previouly queued message {}", rbi);
3002: Akira Ajisaka, info, IfStmt, LOG.info("Processing {} messages from DataNodes " + "that were previously queued during standby state", count);
3101: Akira Ajisaka, warn, SwitchStmt, LOG.warn("{}", msg);
3200: Xiaoyu Yao, debug, IfStmt, blockLog.debug("BLOCK* addStoredBlock: {} on {} size {} but it does not" + " belong to any file", block, node, block.getNumBytes());
3229: Arpit Agarwal, debug, IfStmt, blockLog.debug("BLOCK* addStoredBlock: Redundant addStoredBlock request" + " received for {} on node {} size {}", storedBlock, node, storedBlock.getNumBytes());
3220: Andrew Wang, warn, IfStmt, blockLog.warn("BLOCK* addStoredBlock: block {} moved to storageType " + "{} on node {}", storedBlock, storageInfo.getStorageType(), node);
3215: Uma Mahesh, debug, IfStmt, blockLog.debug("BLOCK* addStoredBlock: {} is added to {} (size={})", node, storedBlock, storedBlock.getNumBytes());
3280: Akira Ajisaka, warn, IfStmt, LOG.warn("Inconsistent number of corrupt replicas for {}" + ". blockMap has {} but corrupt replicas map has {}", storedBlock, numCorruptNodes, corruptReplicasCount);
3331: Xiaoyu Yao, debug, CatchClause, blockLog.debug("invalidateCorruptReplicas error in deleting bad block" + " {} on {}", blk, node, e);
3357: Zhe Zhang, info, CatchClause, LOG.info("Interrupted while processing reconstruction queues.");
3359: Zhe Zhang, Error, CatchClause, LOG.error("Error while processing reconstruction queues async", e);
3377: Zhe Zhang, warn, CatchClause, LOG.warn("Interrupted while waiting for " + "reconstructionQueueInitializer. Returning..");
3413: Xiaoyu Yao, trace, SwitchStmt, LOG.trace("under replicated block {}: {}", block, res);
3417: Xiaoyu Yao, trace, SwitchStmt, LOG.trace("over replicated block {}: {}", block, res);
3421: Xiaoyu Yao, trace, SwitchStmt, LOG.trace("invalid block {}: {}", block, res);
3425: Xiaoyu Yao, trace, SwitchStmt, LOG.trace("postpone block {}: {}", block, res);
3430: Xiaoyu Yao, trace, SwitchStmt, LOG.trace("under construction block {}: {}", block, res);
3447: Akira Ajisaka, info, IfStmt, LOG.info("Total number of blocks            = {}", blocksMap.size());
3448: Akira Ajisaka, info, IfStmt, LOG.info("Number of invalid blocks          = {}", nrInvalid);
3449: Akira Ajisaka, info, IfStmt, LOG.info("Number of under-replicated blocks = {}", nrUnderReplicated);
3450: Akira Ajisaka, info, IfStmt, LOG.info("Number of  over-replicated blocks = {}{}", nrOverReplicated, ((nrPostponed > 0) ? (" (" + nrPostponed + " postponed)") : ""));
3452: Akira Ajisaka, info, IfStmt, LOG.info("Number of blocks being written    = {}", nrUnderConstruction);
3454: Jing Zhao, info, IfStmt, NameNode.stateChangeLog.info("STATE* Replication Queue initialization " + "scan for invalid, over- and under-replicated blocks " + "completed in " + (Time.monotonicNow() - startTimeMisReplicatedScan) + " msec");
3469: Jing Zhao, info, IfStmt, LOG.info("Interrupted while processing replication queues.");
3575: Ming Ma, trace, IfStmt, LOG.trace("BLOCK* processExtraRedundancyBlock: Postponing {}" + " since storage {} does not yet have up-to-date information.", block, storage);
3689: Jing Zhao, warn, IfStmt, LOG.warn("excess types chosen for block {} among storages {} is empty", storedBlock, nonExcess);
3734: Zhe Zhang, debug, MethodDeclaration, blockLog.debug("BLOCK* chooseExcessRedundancies: " + "({}, {}) is added to invalidated blocks set", chosen, storedBlock);
3753: Jing Zhao, debug, MethodDeclaration, blockLog.debug("BLOCK* removeStoredBlock: {} from {}", storedBlock, node);
3757: Andrew Wang, debug, IfStmt, blockLog.debug("BLOCK* removeStoredBlock: {} has already been" + " removed from node {}", storedBlock, node);
3770: Andrew Wang, debug, IfStmt, blockLog.debug("BLOCK* removeStoredBlock: {} removed from caching " + "related lists on node {}", storedBlock, node);
3796: Brahma Reddy Battula, debug, ForeachStmt, NameNode.blockStateChangeLog.debug("BLOCK* Removing stale replica {}" + " of {}", r, Block.toString(r));
3857: Andrew Wang, warn, IfStmt, blockLog.warn("BLOCK* blockReceived: {} is expected to be removed " + "from an unrecorded node {}", block, delHint);
3883: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("Reported block {} on {} size {} replicaState = {}", block, node, block.getNumBytes(), reportedState);
3906: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("In memory blockUCState = {}", ucState);
3959: Andrew Wang, warn, IfStmt, blockLog.warn("BLOCK* processIncrementalBlockReport" + " is received from dead or unregistered node {}", nodeID);
4012: Suresh Srinivas, warn, SwitchStmt, blockLog.warn(msg);
4016: Andrew Wang, debug, ForeachStmt, blockLog.debug("BLOCK* block {}: {} is received from {}", rdbi.getStatus(), rdbi.getBlock(), node);
4019: Andrew Wang, debug, MethodDeclaration, blockLog.debug("*BLOCK* NameNode.processIncrementalBlockReport: from " + "{} receiving: {}, received: {}, deleted: {}", node, receiving, received, deleted);
4165: Akira Ajisaka, info, MethodDeclaration, LOG.info("Invalidated {} extra redundancy blocks on {} after " + "it is in service", numExtraRedundancy, srcNode);
4176: Andrew Wang, info, IfStmt, LOG.info("Node {} hasn't sent its first block report.", node);
4187: Zhe Zhang, info, IfStmt, LOG.info("Node {} is dead and there are no low redundancy" + " blocks or blocks pending reconstruction. Safe to decommission or", " put in maintenance.", node);
4193: Chris Douglas, warn, MethodDeclaration, LOG.warn("Node {} is dead " + "while in {}. Cannot be safely " + "decommissioned or be in maintenance since there is risk of reduced " + "data durability or data loss. Either restart the failed node or " + "force decommissioning or maintenance by removing, calling " + "refreshNodes, then re-adding to the excludes or host config files.", node, node.getAdminState());
4321: Zhe Zhang, debug, IfStmt, LOG.debug("In safemode, not computing reconstruction work");
4327: Akira Ajisaka, warn, IfStmt, LOG.warn("DataNode {} cannot be found with UUID {}" + ", removing block invalidation work.", dn, dn.getDatanodeUuid());
4343: Xiaoyu Yao, debug, MethodDeclaration, blockLog.debug("BLOCK* {}: ask {} to delete {}", getClass().getSimpleName(), dn, toInvalidate);
4524: Andrew Wang, info, IfStmt, LOG.info("Stopping RedundancyMonitor for testing.");
4517: Andrew Wang, info, IfStmt, LOG.info("Stopping RedundancyMonitor.");
4519: Andrew Wang, info, IfStmt, LOG.info("RedundancyMonitor received an exception" + " while shutting down.", t);
4527: Andrew Wang, error, CatchClause, LOG.error("RedundancyMonitor thread received Runtime exception. ", t);
4558: Colin Patrick Mccabe, info, IfStmt, LOG.info("Stopping for testing.");
4552: Colin Patrick Mccabe, info, IfStmt, LOG.info("Stopping thread.");
4554: Colin Patrick Mccabe, info, IfStmt, LOG.info("Received an exception while shutting down.", t);
4561: Colin Patrick Mccabe, error, CatchClause, LOG.error("Thread received Runtime exception.", t);
4579: Colin Patrick Mccabe, Info, TryStmt, LOG.info("StorageInfo TreeSet fill ratio {} : {}{}", storage.getStorageID(), ratio, (ratio < storageInfoDefragmentRatio) ? " (queued for defragmentation)" : "");
4607: Colin Patrick Mccabe, Info, IfStmt, LOG.info("StorageInfo TreeSet defragmented {} : {}{}", storage.getStorageID(), storage.treeSetFillRatio(), aborted ? " (aborted)" : "");
4752: Haohui Mai, info, MethodDeclaration, LOG.info("initializing replication queues");
4911: Uma Mahesh, info, IfStmt, LOG.info("Block report queue is full");
134: Andrew Wang, warn, IfStmt, LOG.warn("The threshold value shouldn't be greater than 1, " + "threshold: {}", threshold);
161: Jing Zhao, info, ConstructorDeclaration, LOG.info("{} = {}", DFS_NAMENODE_SAFEMODE_THRESHOLD_PCT_KEY, threshold);
162: Jing Zhao, info, ConstructorDeclaration, LOG.info("{} = {}", DFS_NAMENODE_SAFEMODE_MIN_DATANODES_KEY, datanodeThreshold);
164: Jing Zhao, info, ConstructorDeclaration, LOG.info("{} = {}", DFS_NAMENODE_SAFEMODE_EXTENSION_KEY, extension);
254: Jing Zhao, debug, SynchronizedStmt, LOG.debug("Adjusting block totals from {}/{} to {}/{}", blockSafe, blockTotal, blockSafe + deltaSafe, blockTotal + deltaTotal);
379: Arpit Agarwal, warn, IfStmt, LOG.warn("forceExit used when normal exist would suffice. Treating " + "force exit as normal safe mode exit.");
372: Arpit Agarwal, error, IfStmt, LOG.error("Refusing to leave safe mode without a force flag. " + "Exiting safe mode will cause a deletion of {} byte(s). Please " + "use -forceExit flag to exit safe mode forcefully if data loss is" + " acceptable.", bytesInFuture);
367: Arpit Agarwal, warn, IfStmt, LOG.warn("Leaving safe mode due to forceExit. This will cause a data " + "loss of {} byte(s).", bytesInFuture);
391: Jing Zhao, info, IfStmt, NameNode.stateChangeLog.info("STATE* Safe mode is OFF");
396: Jing Zhao, info, MethodDeclaration, NameNode.stateChangeLog.info("STATE* Leaving safe mode after {} secs", timeInSafemode / 1000);
402: Jing Zhao, info, MethodDeclaration, NameNode.stateChangeLog.info("STATE* Network topology has {} racks and {}" + " datanodes", nt.getNumOfRacks(), nt.getNumOfLeaves());
404: Jing Zhao, info, MethodDeclaration, NameNode.stateChangeLog.info("STATE* UnderReplicatedBlocks has {} blocks", blockManager.numOfUnderReplicatedBlocks());
585: Jing Zhao, warn, IfStmt, LOG.warn("SafeMode is in inconsistent filesystem state. " + "BlockManagerSafeMode data: blockTotal={}, blockSafe={}; " + "BlockManager data: activeBlocks={}", blockTotal, blockSafe, activeBlocks);
602: Jing Zhao, info, MethodDeclaration, NameNode.stateChangeLog.info(msg + " \n" + getSafeModeTip());
638: Jing Zhao, info, IfStmt, LOG.info("NameNode is being shutdown, exit SafeModeMonitor thread");
205: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Failed to choose with favored nodes (=" + favoredNodes + "), disregard favored nodes hint and retry.", nr);
230: Vinayakumar B, warn, IfStmt, LOG.warn("Could not find a target for file " + src + " with favored node " + favoredNode);
404: Tsz-Wo Nicholas Sze, trace, IfStmt, LOG.trace("storageTypes=" + storageTypes);
427: Tsz-wo Sze, warn, IfStmt, LOG.warn(message + " " + e.getMessage());
425: Tsz-wo Sze, trace, IfStmt, LOG.trace(message, e);
628: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Failed to choose from local rack (location = " + localRack + "), retry with the rack of the next replica (location = " + nextNode.getNetworkLocation() + ")", e);
638: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Failed to choose from local rack (location = " + localRack + "); the second replica is not found, retry choosing randomly", e);
660: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Failed to choose from the next rack (location = " + nextRack + "), retry choosing randomly", e);
692: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Failed to choose remote rack (location = ~" + localMachine.getNetworkLocation() + "), fallback to local rack", e);
823: Xiao Chen, info, IfStmt, LOG.info("Not enough replicas was chosen. Reason:{}", reasonMap);
1124: Arpit Agarwal, debug, IfStmt, LOG.debug("No excess replica can be found. excessTypes: {}." + " moreThanOne: {}. exactlyOne: {}.", excessTypes, moreThanOne, exactlyOne);
142: Xiao Chen, warn, CatchClause, LOG.warn("Only able to place {} of total expected {}" + " (maxNodesPerRack={}, numOfReplicas={}) nodes " + "evenly across racks, falling back to evenly place on the " + "remaining racks. This may not guarantee rack-level fault " + "tolerance. Please check if the racks are configured properly.", results.size(), totalReplicaExpected, maxNodesPerRack, numOfReplicas);
148: Andrew Wang, debug, CatchClause, LOG.debug("Caught exception was:", e);
135: Andrew Wang, trace, TryStmt, LOG.trace("Chosen nodes: {}", results);
136: Andrew Wang, trace, TryStmt, LOG.trace("Excluded nodes: {}", excludedNodes);
178: Andrew Wang, trace, WhileStmt, LOG.trace("Chosen nodes: {}", results);
179: Andrew Wang, trace, WhileStmt, LOG.trace("Excluded nodes: {}", excludedNodes);
180: Xiao Chen, trace, WhileStmt, LOG.trace("New Excluded nodes: {}", newExcludeNodes);
195: Xiao Chen, debug, IfStmt, LOG.debug("Best effort placement failed: expecting {} replicas, only " + "chose {}.", totalReplicaExpected, numResultsOflastChoose);
93: Vinayakumar B, warn, IfStmt, LOG.warn("Could not find a target for file " + src + " within nodegroup of favored node " + favoredNode);
313: Tsz-wo Sze, warn, IfStmt, LOG.warn("Not able to find datanode " + hostname + " which has dependency with datanode " + chosenNode.getHostName());
89: Lei Xu, warn, IfStmt, LOG.warn("Upgrade domain isn't defined for " + datanodeInfo);
197: Colin Patrick Mccabe, info, IfStmt, LOG.info("Can't register DN {} because it is already registered.", dn.getDatanodeUuid());
204: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Registered DN {} ({}).", dn.getDatanodeUuid(), dn.getXferAddr());
220: Colin Patrick Mccabe, info, IfStmt, LOG.info("Can't unregister DN {} because it is not currently " + "registered.", dn.getDatanodeUuid());
230: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("DN {} ({}) requested a lease even though it wasn't yet " + "registered.  Registering now.", dn.getDatanodeUuid(), dn.getXferAddr());
255: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Can't create a new BR lease for DN {}, because " + "numPending equals maxPending at {}.  Current leases: {}", dn.getDatanodeUuid(), numPending, allLeases.toString());
266: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Created a new BR lease 0x{} for DN {}.  numPending = {}", Long.toHexString(node.leaseId), dn.getDatanodeUuid(), numPending);
277: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Removing expired block report lease 0x{} for DN {}.", Long.toHexString(node.leaseId), node.datanodeUuid);
294: Colin Patrick Mccabe, trace, MethodDeclaration, LOG.trace("No entries remaining in the pending list.");
300: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Datanode {} is using BR lease id 0x0 to bypass " + "rate-limiting.", dn.getDatanodeUuid());
306: Colin Patrick Mccabe, info, IfStmt, LOG.info("BR lease 0x{} is not valid for unknown datanode {}", Long.toHexString(id), dn.getDatanodeUuid());
311: Konstantin V Shvachko, warn, IfStmt, LOG.warn("BR lease 0x{} is not valid for DN {}, because the DN " + "is not in the pending set.", Long.toHexString(id), dn.getDatanodeUuid());
317: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("BR lease 0x{} is not valid for DN {}, because the lease " + "has expired.", Long.toHexString(id), dn.getDatanodeUuid());
322: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("BR lease 0x{} is not valid for DN {}.  Expected BR lease 0x{}.", Long.toHexString(id), dn.getDatanodeUuid(), Long.toHexString(node.leaseId));
328: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("BR lease 0x{} is valid for DN {}.", Long.toHexString(id), dn.getDatanodeUuid());
337: Colin Patrick Mccabe, info, IfStmt, LOG.info("Can't remove lease for unknown datanode {}", dn.getDatanodeUuid());
343: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("DN {} has no lease to remove.", dn.getDatanodeUuid());
349: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("Removed BR lease 0x{} for DN {}.  numPending = {}", Long.toHexString(id), dn.getDatanodeUuid(), numPending);
238: Jing Zhao, warn, IfStmt, NameNode.blockStateChangeLog.warn("BLOCK*" + " BlockUnderConstructionFeature.initializeBlockRecovery:" + " No blocks found, lease removed.");
280: Xiaoyu Yao, debug, IfStmt, NameNode.blockStateChangeLog.debug("BLOCK* {} recovery started, primary={}", this, primary);
160: Colin McCabe, info, MethodDeclaration, LOG.info("Starting CacheReplicationMonitor with interval " + intervalMs + " milliseconds");
204: Andrew Wang, info, CatchClause, LOG.info("Shutting down CacheReplicationMonitor.");
207: Andrew Wang, error, CatchClause, LOG.error("Thread exiting", t);
169: Colin Patrick Mccabe, info, IfStmt, LOG.info("Shutting down CacheReplicationMonitor");
173: Haohui Mai, debug, IfStmt, LOG.debug("Rescanning because of pending operations");
178: Haohui Mai, debug, IfStmt, LOG.debug("Rescanning after {} milliseconds", (curTimeMs - startTimeMs));
200: Haohui Mai, debug, WhileStmt, LOG.debug("Scanned {} directive(s) and {} block(s) in {} millisecond(s).", scannedDirectives, scannedBlocks, (curTimeMs - startTimeMs));
237: Andrew Wang, warn, CatchClause, LOG.warn("Interrupted while waiting for CacheReplicationMonitor" + " rescan", e);
329: Andrew Wang, debug, IfStmt, LOG.debug("Directive {}: the directive expired at {} (now = {})", directive.getId(), directive.getExpiryTime(), now);
339: Kihwal Lee, debug, CatchClause, LOG.debug("Directive {}: Failed to resolve path {} ({})", directive.getId(), path, e.getMessage());
358: Andrew Wang, debug, IfStmt, LOG.debug("Directive {}: ignoring non-directive, non-file inode {} ", directive.getId(), node);
344: Andrew Wang, debug, IfStmt, LOG.debug("Directive {}: No inode found at {}", directive.getId(), path);
385: Andrew Wang, debug, IfStmt, LOG.debug("Directive {}: not scanning file {} because " + "bytesNeeded for pool {} is {}, but the pool's limit is {}", directive.getId(), file.getFullPathName(), pool.getPoolName(), pool.getBytesNeeded(), pool.getLimit());
399: Andrew Wang, trace, IfStmt, LOG.trace("Directive {}: can't cache block {} because it is in state " + "{}, not COMPLETE.", directive.getId(), blockInfo, blockInfo.getBlockUCState());
442: Andrew Wang, trace, ForeachStmt, LOG.trace("Directive {}: setting replication for block {} to {}", directive.getId(), blockInfo, ocblock.getReplication());
450: Andrew Wang, debug, MethodDeclaration, LOG.debug("Directive {}: caching {}: {}/{} bytes", directive.getId(), file.getFullPathName(), cachedTotal, neededTotal);
512: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Block {}: removing from PENDING_CACHED for node {} " + "because it cannot fit in remaining cache size {}.", cblock.getBlockId(), dn.getDatanodeUuid(), remaining);
536: Andrew Wang, trace, IfStmt, LOG.trace("Block {}: removing from PENDING_UNCACHED for node {} " + "because the DataNode uncached it.", cblock.getBlockId(), datanode.getDatanodeUuid());
548: Andrew Wang, trace, IfStmt, LOG.trace("Block {}: can't cache block because it is {}", cblock.getBlockId(), reason);
561: Colin Patrick Mccabe, trace, ForStmt, LOG.trace("Block {}: removing from PENDING_CACHED for node {} " + "because we already have {} cached replicas and we only" + " need {}", cblock.getBlockId(), datanode.getDatanodeUuid(), numCached, neededCached);
576: Andrew Wang, trace, ForStmt, LOG.trace("Block {}: removing from PENDING_UNCACHED for node {} " + "because we only have {} cached replicas and we need " + "{}", cblock.getBlockId(), datanode.getDatanodeUuid(), numCached, neededCached);
600: Andrew Wang, trace, IfStmt, LOG.trace("Block {}: removing from cachedBlocks, since neededCached " + "== 0, and pendingUncached and pendingCached are empty.", cblock.getBlockId());
631: Colin McCabe, warn, IfStmt, LOG.warn("Logic error: we're trying to uncache more replicas than " + "actually exist for " + cachedBlock);
661: Andrew Wang, debug, IfStmt, LOG.debug("Block {}: can't add new cached replicas," + " because there is no record of this block " + "on the NameNode.", cachedBlock.getBlockId());
667: Andrew Wang, debug, IfStmt, LOG.debug("Block {}: can't cache this block, because it is not yet" + " complete.", cachedBlock.getBlockId());
715: Andrew Wang, trace, IfStmt, LOG.trace("Block {}: DataNode {} is not a valid possibility " + "because the block has size {}, but the DataNode only has {} " + "bytes of cache remaining ({} pending bytes, {} already cached.)", blockInfo.getBlockId(), datanode.getDatanodeUuid(), blockInfo.getNumBytes(), pendingCapacity, pendingBytes, datanode.getCacheRemaining());
729: Andrew Wang, trace, ForeachStmt, LOG.trace("Block {}: added to PENDING_CACHED on DataNode {}", blockInfo.getBlockId(), datanode.getDatanodeUuid());
737: Andrew Wang, debug, IfStmt, LOG.debug("Block {}: we only have {} of {} cached replicas." + " {} DataNodes have insufficient cache capacity.", blockInfo.getBlockId(), (cachedBlock.getReplication() - neededCached + chosen.size()), cachedBlock.getReplication(), outOfCapacity);
231: Lei Xu, warn, IfStmt, LOG.warn("Failed to resolve {} in {}. ", hostName, fn);
93: Xiaoyu Yao, debug, IfStmt, NameNode.blockStateChangeLog.debug("BLOCK NameSystem.addToCorruptReplicasMap: duplicate requested for" + " {} to add as corrupt on {} by {} {}", blk, dn, Server.getRemoteIp(), reasonText);
88: Xiaoyu Yao, debug, IfStmt, NameNode.blockStateChangeLog.debug("BLOCK NameSystem.addToCorruptReplicasMap: {} added as corrupt on " + "{} by {} {}", blk, dn, Server.getRemoteIp(), reasonText);
166: Andrew Wang, warn, IfStmt, LOG.warn("Deprecated configuration key {} will be ignored.", deprecatedKey);
168: Manoj Govindassamy, warn, IfStmt, LOG.warn("Please update your configuration to use {} instead.", DFSConfigKeys.DFS_NAMENODE_DECOMMISSION_BLOCKS_PER_INTERVAL_KEY);
188: Manoj Govindassamy, debug, MethodDeclaration, LOG.debug("Activating DatanodeAdminManager with interval {} seconds, " + "{} max blocks per interval, " + "{} max concurrently tracked nodes.", intervalSecs, blocksPerInterval, maxConcurrentTrackedNodes);
223: Inigo Goiri, trace, IfStmt, LOG.trace("startDecommission: Node {} in {}, nothing to do.", node, node.getAdminState());
216: Andrew Wang, info, ForeachStmt, LOG.info("Starting decommission of {} {} with {} blocks", node, storage, storage.numBlocks());
246: Inigo Goiri, trace, IfStmt, LOG.trace("stopDecommission: Node {} in {}, nothing to do.", node, node.getAdminState());
276: Inigo Goiri, trace, IfStmt, LOG.trace("startMaintenance: Node {} in {}, nothing to do.", node, node.getAdminState());
267: Ming Ma, info, ForeachStmt, LOG.info("Starting maintenance of {} {} with {} blocks", node, storage, storage.numBlocks());
325: Inigo Goiri, trace, IfStmt, LOG.trace("stopMaintenance: Node {} in {}, nothing to do.", node, node.getAdminState());
332: Chris Douglas, info, MethodDeclaration, LOG.info("Decommissioning complete for node {}", dn);
337: Ming Ma, info, MethodDeclaration, LOG.info("Node {} has entered maintenance mode.", dn);
351: Chris Douglas, trace, IfStmt, LOG.trace("Block {} does not need replication.", block);
360: Ming Ma, trace, MethodDeclaration, LOG.trace("Block {} numExpected={}, numLive={}", block, numExpected, numLive);
371: Chris Douglas, trace, IfStmt, LOG.trace("UC block {} insufficiently-replicated since numLive " + "({}) < minR ({})", block, numLive, blockManager.getMinStorageNum(block));
366: Chris Douglas, trace, IfStmt, LOG.trace("UC block {} sufficiently-replicated since numLive ({}) " + ">= minR ({})", block, numLive, blockManager.getMinStorageNum(block));
401: Chris Nauroth, info, MethodDeclaration, NameNode.blockStateChangeLog.info("Block: " + block + ", Expected Replicas: " + curExpectedRedundancy + ", live replicas: " + curReplicas + ", corrupt replicas: " + num.corruptReplicas() + ", decommissioned replicas: " + num.decommissioned() + ", decommissioning replicas: " + num.decommissioning() + ", maintenance replicas: " + num.maintenanceReplicas() + ", live entering maintenance replicas: " + num.liveEnteringMaintenanceReplicas() + ", excess replicas: " + num.excessReplicas() + ", Is Open File: " + bc.isUnderConstruction() + ", Datanodes having this block: " + nodeList + ", Current Datanode: " + srcNode + ", Is current datanode decommissioning: " + srcNode.isDecommissionInProgress() + ", Is current datanode entering maintenance: " + srcNode.isEnteringMaintenance());
476: Chris Douglas, trace, MethodDeclaration, LOG.trace("Processed {} blocks so far this tick", numBlocksChecked);
483: Manoj Govindassamy, info, IfStmt, LOG.info("Namesystem is not running, skipping " + "decommissioning/maintenance checks.");
500: Chris Douglas, info, IfStmt, LOG.info("Checked {} blocks and {} nodes this tick", numBlocksChecked, numNodesChecked);
595: Chris Douglas, debug, IfStmt, LOG.debug("Node {} still has {} blocks to replicate " + "before it is a candidate to finish {}.", dn, blocks.size(), dn.getAdminState());
589: Uma Mahesh, debug, IfStmt, LOG.debug("Node {} {} healthy." + " It needs to replicate {} more blocks." + " {} is still in progress.", dn, isHealthy ? "is" : "isn't", blocks.size(), dn.getAdminState());
586: Chris Douglas, debug, IfStmt, LOG.debug("Node {} is sufficiently replicated and healthy, " + "marked as {}.", dn, dn.getAdminState());
676: Manoj Govindassamy, debug, TryStmt, LOG.debug("Yielded lock during decommission/maintenance check");
691: Chris Douglas, trace, IfStmt, LOG.trace("Removing unknown block {}", block);
750: Inigo Goiri, warn, IfStmt, LOG.warn("File {} is not under construction. Skipping add to " + "low redundancy open files!", ucFile.getLocalName());
438: Andrew Wang, info, IfStmt, LOG.info("Number of failed storages changes from {} to {}", this.volumeFailures, volFailures);
495: Virajith Jalaparti, info, IfStmt, LOG.info("Adding new storage ID {} for DN {}", s.getStorageID(), getXferAddr());
520: Andrew Wang, debug, SynchronizedStmt, LOG.debug("Number of storages reported in heartbeat={};" + " Number of storages in storageMap={}", reports.length, storageMap.size());
551: Andrew Wang, debug, IfStmt, LOG.debug("Deferring removal of stale storage {} with {} blocks", storageInfo, storageInfo.numBlocks());
548: Andrew Wang, info, IfStmt, LOG.info("Removed storage {} from DataNode {}", storageInfo, this);
562: Andrew Wang, info, IfStmt, LOG.info("{} failed.", storageInfo);
658: Zhe Zhang, debug, MethodDeclaration, BlockManager.LOG.debug("Adding block reconstruction task " + task + "to " + getName() + ", current queue size is " + erasurecodeBlocks.size());
668: Suresh Srinivas, info, IfStmt, BlockManager.LOG.info(block + " is already in the recovery queue");
768: Xiao Chen, debug, IfStmt, BlockPlacementPolicy.LOG.debug("The node {} does not have enough {} space (required={}," + " scheduled={}, remaining={}).", this, t, requiredSize, scheduledSize, remaining);
987: Andrew Wang, info, IfStmt, LOG.info("Adding new storage ID {} for DN {}", s.getStorageID(), getXferAddr());
262: Colin McCabe, error, CatchClause, LOG.error("error reading hosts files: ", e);
301: Tsz-wo Sze, info, ConstructorDeclaration, LOG.info(DFSConfigKeys.DFS_BLOCK_INVALIDATE_LIMIT_KEY + ": configured=" + configuredBlockInvalidateLimit + ", counted=" + countedBlockInvalidateLimit + ", effected=" + blockInvalidateLimit);
309: Tsz-wo Sze, info, ConstructorDeclaration, LOG.info(DFSConfigKeys.DFS_NAMENODE_DATANODE_REGISTRATION_IP_HOSTNAME_CHECK_KEY + "=" + checkIpHostnameInRegistration);
356: Suresh Srinivas, warn, IfStmt, LOG.warn("The given interval for marking stale datanode = " + staleInterval + ", which is less than " + DFSConfigKeys.DFS_NAMENODE_STALE_DATANODE_MINIMUM_INTERVAL_DEFAULT + " heartbeat intervals. This may cause too frequent changes of " + "stale states of DataNodes since a heartbeat msg may be missing " + "due to temporary short-term failures. Reset stale interval to " + minStaleInterval + ".");
366: Suresh Srinivas, warn, IfStmt, LOG.warn("The given interval for marking stale datanode = " + staleInterval + ", which is larger than heartbeat expire interval " + heartbeatExpireInterval + ".");
514: cnauroth, error, IfStmt, LOG.error("Node Resolution failed. Please make sure that rack " + "awareness scripts are functional.");
642: Andrew Wang, error, IfStmt, NameNode.stateChangeLog.error("BLOCK* NameSystem.getDatanode: " + e.getLocalizedMessage());
712: Tsz-wo Sze, Info, MethodDeclaration, networktopology.remove(nodeInfo);
717: Eli Collins, debug, IfStmt, LOG.debug("remove datanode " + nodeInfo);
734: Tsz-wo Sze, warn, IfStmt, NameNode.stateChangeLog.warn("BLOCK* removeDatanode: " + node + " does not exist");
752: Jing Zhao, info, IfStmt, NameNode.stateChangeLog.info("BLOCK* removeDeadDatanode: lost heartbeat from " + d + ", removeBlocksFromBlockMap " + removeBlocksFromBlockMap);
780: Tsz-wo Sze, debug, IfStmt, LOG.debug(getClass().getSimpleName() + ".addDatanode: " + "node " + node + " is added to datanodeMap.");
792: Tsz-wo Sze, debug, IfStmt, LOG.debug(getClass().getSimpleName() + ".wipeDatanode(" + node + "): storage " + key + " is removed from datanodeMap.");
878: Chris Nauroth, error, CatchClause, LOG.error("Unresolved topology mapping. Using " + NetworkTopology.DEFAULT_RACK + " for host " + node.getHostName());
905: Chris Nauroth, error, IfStmt, LOG.error("The resolve call returned null!");
935: Tsz-wo Sze, error, CatchClause, LOG.error("Unresolved dependency mapping for host " + node.getHostName() + ". Continuing with an empty dependency list");
960: Tsz-wo Sze, error, IfStmt, LOG.error("The dependency call returned null for host " + node.getHostName());
1023: Tsz-wo Sze, warn, IfStmt, LOG.warn("Unresolved datanode registration: " + message);
1040: Aaron Myers, info, TryStmt, NameNode.stateChangeLog.info("BLOCK* registerDatanode: from " + nodeReg + " storage " + nodeReg.getDatanodeUuid());
1048: Aaron Myers, info, IfStmt, NameNode.LOG.info("BLOCK* registerDatanode: " + nodeN);
1063: Aaron Myers, debug, IfStmt, NameNode.stateChangeLog.debug("BLOCK* registerDatanode: " + "node restarted.");
1390: Aaron Myers, debug, IfStmt, LOG.debug(message);
1386: Aaron Myers, info, IfStmt, LOG.info(message);
1429: Eli Collins, warn, CatchClause, LOG.warn("Invalid hostname " + hostStr + " in hosts file");
1512: Colin McCabe, debug, IfStmt, LOG.debug("getDatanodeListForReport with " + "includedNodes = " + hostConfigManager.getIncludes() + ", excludedNodes = " + hostConfigManager.getExcludes() + ", foundNodes = " + foundNodes + ", nodes = " + nodes);
1574: Jing Zhao, info, IfStmt, LOG.info("Skipped stale nodes for recovery : " + (storages.length - recoveryLocations.size()));
1681: Andrew Wang, debug, IfStmt, LOG.debug("Pending replication tasks: " + numReplicationTasks + " erasure-coded tasks: " + numECTasks);
1722: Arpit Agarwal, debug, IfStmt, LOG.debug("DataNode " + nodeReg + " reported slow peers: " + slowPeersMap);
1734: Hanisha Koneru, debug, IfStmt, LOG.debug("DataNode " + nodeReg + " reported slow disks: " + slowDisks.getSlowDisks());
1767: Chris Nauroth, debug, IfStmt, LOG.debug("Received handleLifeline from nodeReg = " + nodeReg);
1837: Todd Lipcon, info, MethodDeclaration, LOG.info("Marking all datandoes as stale");
47: zhezhang, debug, ConstructorDeclaration, BlockManager.LOG.debug("Creating an ErasureCodingWork to {} reconstruct ", block);
161: Jing Zhao, debug, IfStmt, BlockManager.LOG.debug("Add replication task from source {} to " + "target {} for EC block {}", source, target, targetBlk);
86: Zhe Zhang, debug, IfStmt, blockLog.debug("BLOCK* ExcessRedundancyMap.add({}, {})", dn, blk);
106: Zhe Zhang, debug, IfStmt, blockLog.debug("BLOCK* ExcessRedundancyMap.remove({}, {})", dn, blk);
84: Suresh Srinivas, info, IfStmt, LOG.info("Setting heartbeat recheck interval to " + staleInterval + " since " + DFSConfigKeys.DFS_NAMENODE_STALE_DATANODE_INTERVAL_KEY + " is less than " + DFSConfigKeys.DFS_NAMENODE_HEARTBEAT_RECHECK_INTERVAL_KEY);
261: Andrew Wang, info, IfStmt, LOG.info("Dead node {} is decommissioned immediately.", node);
281: Ming Ma, info, IfStmt, LOG.info("MinReplicationToBeInMaintenance is set to zero. " + node + " is put in maintenance state" + " immediately.");
277: Ming Ma, info, IfStmt, LOG.info("Decommissioned node " + node + " is put in maintenance state" + " immediately.");
272: Ming Ma, info, IfStmt, LOG.info("Dead node {} is put in maintenance state immediately.", node);
292: Ming Ma, info, MethodDeclaration, LOG.info("Stopping maintenance of {} node {}", node.isAlive() ? "live" : "dead", node);
304: Andrew Wang, info, MethodDeclaration, LOG.info("Stopping decommissioning of {} node {}", node.isAlive() ? "live" : "dead", node);
453: Tsz-wo Sze, error, CatchClause, LOG.error("Exception while checking heartbeat", e);
462: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("Skipping next heartbeat scan due to excessive pause");
102: Haohui Mai, warn, CatchClause, LOG.warn(String.format("Failed to parse `%s` in `%s`. " + "Ignoring in " + "the %s list.", line, fn, type));
96: Haohui Mai, warn, IfStmt, LOG.warn(String.format("Failed to resolve address `%s` in `%s`. " + "Ignoring in the %s list.", line, fn, type));
79: Akira Ajisaka, info, MethodDeclaration, log.info("{} is set to {}", DFSConfigKeys.DFS_NAMENODE_STARTUP_DELAY_BLOCK_DELETION_SEC_KEY, DFSUtil.durationToString(pendingPeriodInMs));
85: Akira Ajisaka, info, MethodDeclaration, log.info("The block deletion will start around {}", sdf.format(calendar.getTime()));
190: Xiaoyu Yao, debug, IfStmt, NameNode.blockStateChangeLog.debug("BLOCK* {}: add {} to {}", getClass().getSimpleName(), block, datanode);
282: Akira Ajisaka, debug, IfStmt, BlockManager.LOG.debug("Block deletion is delayed during NameNode startup. " + "The deletion will start after {} ms.", delay);
277: Andrew Wang, debug, IfStmt, NameNode.blockStateChangeLog.debug("BLOCK* NameSystem.LowRedundancyBlock.add: {}" + " has only {} replicas and need {} replicas so is added to" + " neededReconstructions at priority level {}", block, curReplicas, expectedReplicas, priLevel);
365: Andrew Wang, debug, IfStmt, NameNode.blockStateChangeLog.debug("BLOCK* NameSystem.LowRedundancyBlock.remove: Removing block" + " {} from priority queue {}", block, i);
354: Andrew Wang, debug, IfStmt, NameNode.blockStateChangeLog.debug("BLOCK* NameSystem.LowRedundancyBlock.remove: Removing block {}" + " from priority queue {}", block, priLevel);
425: Zhe Zhang, debug, IfStmt, NameNode.stateChangeLog.debug("LowRedundancyBlocks.update " + block + " curReplicas " + curReplicas + " curExpectedReplicas " + curExpectedReplicas + " oldReplicas " + oldReplicas + " oldExpectedReplicas  " + oldExpectedReplicas + " curPri  " + curPri + " oldPri  " + oldPri);
438: Andrew Wang, debug, IfStmt, NameNode.blockStateChangeLog.debug("BLOCK* NameSystem.LowRedundancyBlock.update: {} has only {} " + "replicas and needs {} replicas so is added to " + "neededReconstructions at priority level {}", block, curReplicas, curExpectedReplicas, curPri);
108: Zhe Zhang, debug, IfStmt, LOG.debug("Removing pending reconstruction for {}", block);
248: Zhe Zhang, debug, CatchClause, LOG.debug("PendingReconstructionMonitor thread is interrupted.", ie);
261: Zhe Zhang, debug, SynchronizedStmt, LOG.debug("PendingReconstructionMonitor checking Q");
270: Zhe Zhang, warn, IfStmt, LOG.warn("PendingReconstructionMonitor timed out " + block);
80: Chris Douglas, info, IfStmt, LOG.info("Block recovery attempt for " + block + " rejected, as the " + "previous attempt times out in " + timeoutIn + " seconds.");
115: Virajith Jalaparti, info, ConstructorDeclaration, LOG.info("Loaded alias map class: " + aliasMap.getClass() + " storage: " + providedStorageInfo);
134: Virajith Jalaparti, info, IfStmt, LOG.info("Provided storage transitioning to state " + State.NORMAL);
142: Virajith Jalaparti, warn, IfStmt, LOG.warn("Reserved storage {} reported as non-provided from {}", s, dn);
152: Virajith Jalaparti, info, IfStmt, LOG.info("Calling process first blk report from storage: " + providedStorageInfo);
200: Virajith Jalaparti, warn, IfStmt, LOG.warn("Reserved storage {} reported as non-provided from {}", storage, node);
405: Virajith Jalaparti, error, IfStmt, LOG.error("Cannot find a source node to replicate block: " + block + " from");
479: Virajith Jalaparti, info, IfStmt, LOG.info("Provided storage {} transitioning to state {}", this, State.FAILED);
35: Zhe Zhang, debug, ConstructorDeclaration, BlockManager.LOG.debug("Creating a ReplicationWork to reconstruct " + block);
270: Hanisha Koneru, debug, CatchClause, LOG.debug("Failed to serialize statistics" + e);
200: Arpit Agarwal, debug, CatchClause, LOG.debug("Failed to serialize statistics" + e);
155: Todd Lipcon, debug, BlockStmt, LOG.debug("getUGI is returning: " + ugi.getShortUserName());
81: Vinayakumar B, info, MethodDeclaration, metricsLog.info(" >> Begin " + nodeName + " metrics dump");
103: Vinayakumar B, error, CatchClause, metricsLog.error("Failed to get " + nodeName + " metrics for mbean " + mbeanName.toString(), e);
99: Vinayakumar B, info, ForeachStmt, metricsLog.info(mBeanNameName + ":" + attribute.getName() + "=" + trimLine(valueStr));
107: Vinayakumar B, info, MethodDeclaration, metricsLog.info(" << End " + nodeName + " metrics dump");
153: Vinayakumar B, warn, IfStmt, LOG.warn("Metrics logging will not be async since " + "the logger is not log4j");
400: Xiaoyu Yao, warn, CatchClause, LOG.warn("Failed to get directory size : {}", root, e);
431: Xiaoyu Yao, info, IfStmt, LOG.info("Will remove files: {}", Arrays.toString(files));
672: Xiaoyu Yao, warn, CatchClause, LOG.warn("Cannot access storage directory {}", rootPath, ex);
654: Xiaoyu Yao, warn, IfStmt, LOG.warn("Storage directory {} does not exist", rootPath);
657: Xiaoyu Yao, info, IfStmt, LOG.info("{} does not exist. Creating ...", rootPath);
664: Xiaoyu Yao, warn, IfStmt, LOG.warn("{} is not a directory", rootPath);
668: Xiaoyu Yao, warn, IfStmt, LOG.warn("Cannot access storage directory {}", rootPath);
774: Xiaoyu Yao, info, SwitchStmt, LOG.info("Completing previous upgrade for storage directory {}", rootPath);
779: Xiaoyu Yao, info, SwitchStmt, LOG.info("Recovering storage directory {} from previous upgrade", rootPath);
786: Xiaoyu Yao, info, SwitchStmt, LOG.info("Completing previous rollback for storage directory {}", rootPath);
791: Xiaoyu Yao, info, SwitchStmt, LOG.info("Recovering storage directory {} from previous rollback", rootPath);
796: Xiaoyu Yao, info, SwitchStmt, LOG.info("Completing previous finalize for storage directory {}", rootPath);
801: Xiaoyu Yao, info, SwitchStmt, LOG.info("Completing previous checkpoint for storage directory {}", rootPath);
809: Xiaoyu Yao, info, SwitchStmt, LOG.info("Recovering storage directory {} from failed checkpoint", rootPath);
864: Xiaoyu Yao, info, IfStmt, LOG.info("Locking is disabled for {}", this.root);
871: Todd Lipcon, info, IfStmt, LOG.info(msg);
909: Xiaoyu Yao, error, CatchClause, LOG.error("It appears that another node {} has already locked the " + "storage directory: {}", lockingJvmName, root, oe);
914: Xiaoyu Yao, error, CatchClause, LOG.error("Failed to acquire lock on {}. If this storage directory is" + " mounted via NFS, ensure that the appropriate nfs lock services" + " are running.", lockF, e);
901: Xiaoyu Yao, error, IfStmt, LOG.error("Unable to acquire file lock on path {}", lockF);
905: Xiaoyu Yao, info, TryStmt, LOG.info("Lock on {} acquired by nodename {}", lockF, jvmName);
1119: Todd Lipcon, error, IfStmt, LOG.error(msg);
1335: Xiaoyu Yao, debug, IfStmt, LOG.debug("Failed to preserve last modified date from'{}' to '{}'", srcFile, destFile);
93: Todd Lipcon, error, CatchClause, LOG.error("Syntax error in URI " + s + ". Please check hdfs configuration.", e);
99: Todd Lipcon, warn, IfStmt, LOG.warn("Path " + s + " should be specified as a URI " + "in configuration files. Please update hdfs configuration.");
142: Todd Lipcon, Error, CatchClause, LOG.error("Error while processing URI: " + name, e);
244: Jing Zhao, warn, CatchClause, LOG.warn("Unable to download file " + f, ioe);
237: Jing Zhao, warn, IfStmt, LOG.warn("Overwriting existing file " + f + " with file downloaded from " + url);
314: Jing Zhao, info, MethodDeclaration, LOG.info(xferStats.toString());
337: Jing Zhao, info, MethodDeclaration, LOG.info("Deleting temporary files: " + files);
340: Jing Zhao, warn, IfStmt, LOG.warn("Deleting " + file + " has failed");
400: Arpit Agarwal, info, IfStmt, LOG.info(DFSConfigKeys.DFS_DATANODE_FILEIO_PROFILING_SAMPLING_PERCENTAGE_KEY + " set to " + fileIOSamplingPercentage + ". Enabling file IO profiling");
395: Arpit Agarwal, info, IfStmt, LOG.info(DFSConfigKeys.DFS_DATANODE_FILEIO_PROFILING_SAMPLING_PERCENTAGE_KEY + " set to " + fileIOSamplingPercentage + ". Disabling file IO profiling");
177: Virajith Jalaparti, info, MethodDeclaration, LOG.info("TextFileRegionAliasMap: read path {}", tmpfile);
326: Xiao Chen, debug, MethodDeclaration, LOG.debug("block={}, bytesPerCRC={}, crcPerBlock={}, md5out={}", getBlock(), getBytesPerCRC(), getCrcPerBlock(), md5out);
401: Xiao Chen, debug, IfStmt, LOG.debug("block={}, getBytesPerCRC={}, crcPerBlock={}, compositeCrc={}", getBlock(), getBytesPerCRC(), getCrcPerBlock(), CrcUtil.toMultiCrcString(composedCrcs));
505: Kai Zheng, warn, CatchClause, LOG.warn("Failed to get the checksum", e);
495: Kai Zheng, warn, CatchClause, LOG.warn("Exception while reading checksum", ioe);
570: Xiao Chen, debug, IfStmt, LOG.debug("flatBlockChecksumData.length={}, numDataUnits={}, " + "checksumLen={}, digest={}", flatBlockChecksumData.length, numDataUnits, checksumLen, CrcUtil.toSingleCrcString(digest));
601: Uma Maheswara Rao G, debug, TryStmt, LOG.debug("write to {}: {}, block={}", getDatanode(), Op.BLOCK_CHECKSUM, block);
641: Kai Zheng, debug, IfStmt, LOG.debug("Retrieving checksum from an earlier-version DataNode: " + "inferring checksum by reading first byte");
655: Xiao Chen, debug, SwitchStmt, LOG.debug("got reply from datanode:{}, md5={}", targetDatanode, md5);
670: Xiao Chen, debug, IfStmt, LOG.debug("got reply from datanode:{} for blockIdx:{}, checksum:{}", targetDatanode, blockIdx, CrcUtil.toMultiCrcString(checksumBytes));
693: Kai Zheng, debug, MethodDeclaration, LOG.debug("Recalculate checksum for the missing/failed block index {}", errBlkIndex);
719: Xiao Chen, debug, MethodDeclaration, LOG.debug("Recalculated checksum for the block index:{}, checksum={}", errBlkIndex, checksumRecon.getDigestObject());
755: Kai Zheng, debug, IfStmt, LOG.debug("set bytesPerCRC={}, crcPerBlock={}", getBytesPerCRC(), getCrcPerBlock());
102: Todd Lipcon, info, IfStmt, LOG.info("Removed " + bpos);
108: Todd Lipcon, warn, IfStmt, LOG.warn("Couldn't remove BPOS " + t + " from bpByNameserviceId map");
149: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Refresh request received for nameservices: " + conf.get(DFSConfigKeys.DFS_NAMESERVICES));
161: Xiaoyu Yao, warn, CatchClause, LOG.warn("Unable to get NameNode addresses.");
210: Todd Lipcon, info, IfStmt, LOG.info("Starting BPOfferServices for nameservices: " + Joiner.on(",").useForNull("<default>").join(toAdd));
238: Todd Lipcon, info, IfStmt, LOG.info("Stopping BPOfferServices for nameservices: " + Joiner.on(",").useForNull("<default>").join(toRemove));
251: Todd Lipcon, info, IfStmt, LOG.info("Refreshing list of NNs for nameservices: " + Joiner.on(",").useForNull("<default>").join(toRefresh));
162: Xiaoyu Yao, info, SwitchStmt, LOG.info("Block pool storage directory for location {} and block pool" + " id {} does not exist", location, nsInfo.getBlockPoolID());
168: Xiaoyu Yao, info, SwitchStmt, LOG.info("Block pool storage directory for location {} and block pool" + " id {} is not formatted. Formatting ...", location, nsInfo.getBlockPoolID());
228: Xiaoyu Yao, warn, CatchClause, LOG.warn("Failed to analyze storage directories for block pool {}", nsInfo.getBlockPoolID(), e);
251: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Analyzing storage directories for bpid {}", nsInfo.getBlockPoolID());
280: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Formatting block pool {} directory {}", blockpoolID, bpSdir.getCurrentDir());
297: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Removing block level storage: {}", absPathToRemove);
377: Xiaoyu Yao, info, IfStmt, LOG.info("Restored {} block files from trash.", restored);
401: Xiaoyu Yao, info, IfStmt, LOG.info("Restored {} block files from trash " + "before the layout upgrade. These blocks will be moved to " + "the previous directory during the upgrade", restored);
450: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Upgrading block pool storage directory {}.\n   old LV = {}; old" + " CTime = {}.\n   new LV = {}; new CTime = {}", bpSd.getRoot(), oldLV, this.getCTime(), HdfsServerConstants.DATANODE_LAYOUT_VERSION, nsInfo.getCTime());
509: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Upgrade of {} is complete", name);
618: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Rolling back storage directory {}.\n   target LV = {}; target " + "CTime = {}", bpSd.getRoot(), nsInfo.getLayoutVersion(), nsInfo.getCTime());
633: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Rollback of {} is complete", bpSd.getRoot());
652: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Finalizing upgrade for storage directory {}.\n   cur LV = {}; " + "cur CTime = {}", dataDirPath, this.getLayoutVersion(), this.getCTime());
668: Xiaoyu Yao, error, CatchClause, LOG.error("Finalize upgrade for {} failed.", dataDirPath, ex);
670: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Finalize upgrade for {} is complete.", dataDirPath);
696: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Linked blocks from {} to {}. {}", fromDir, toDir, hardLink.linkStats.report());
764: Xiaoyu Yao, warn, CatchClause, LOG.warn("Failed to get block file for replica {}", info, e);
792: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Restoring {} to {}", blockFile, restoreDirectory);
804: Kihwal Lee, error, IfStmt, LOG.error("Trash and PreviousDir shouldn't both exist for storage " + "directory {}", sd);
818: Xiaoyu Yao, info, ForeachStmt, LOG.info("Cleared trash for storage directory {}", trashRoot);
863: Xiaoyu Yao, info, IfStmt, LOG.info("{} already exists.", markerFile);
861: Xiaoyu Yao, info, IfStmt, LOG.info("Created {}", markerFile);
886: Xiaoyu Yao, info, IfStmt, LOG.info("Deleting {}", markerFile);
889: Xiaoyu Yao, warn, IfStmt, LOG.warn("Failed to delete {}", markerFile);
288: Arpit Agarwal, warn, CatchClause, DataNode.LOG.warn("IOException in BlockReceiver constructor :" + ioe.getMessage() + (cause == null ? "" : ". Cause is "), cause);
191: Todd Lipcon, debug, IfStmt, LOG.debug(getClass().getSimpleName() + ": " + block + "\n storageType=" + storageType + ", inAddr=" + inAddr + ", myAddr=" + myAddr + "\n stage=" + stage + ", newGs=" + newGs + ", minBytesRcvd=" + minBytesRcvd + ", maxBytesRcvd=" + maxBytesRcvd + "\n clientname=" + clientname + ", srcDataNode=" + srcDataNode + ", datanode=" + datanode.getDisplayName() + "\n requestedChecksum=" + requestedChecksum + "\n cachingStrategy=" + cachingStrategy + "\n allowLazyPersist=" + allowLazyPersist + ", pinning=" + pinning + ", isClient=" + isClient + ", isDatanode=" + isDatanode + ", responseInterval=" + responseInterval + ", storageID=" + (storageId != null ? storageId : "null"));
394: Kihwal Lee, info, IfStmt, LOG.info("A packet was last sent " + diff + " milliseconds ago.");
440: Michael Stack, warn, IfStmt, LOG.warn("Slow flushOrSync took " + duration + "ms (threshold=" + datanodeSlowLogThresholdMs + "ms), isSync:" + isSync + ", flushTotalNanos=" + flushTotalNanos + "ns, volume=" + getVolumeBaseUri() + ", blockId=" + replicaInfo.getBlockId());
453: Jitendra Nath Pandey, info, MethodDeclaration, LOG.info(datanode.getDNRegistrationForBP(bpid) + ":Exception writing " + block + " to mirror " + mirrorAddr, ioe);
477: Yongjun Zhang, warn, CatchClause, LOG.warn("Checksum error in block " + block + " from " + inAddr + ", " + specificOffset, ce);
487: Suresh Srinivas, warn, CatchClause, LOG.warn("Failed to report bad " + block + " from datanode " + srcDataNode + " to namenode");
483: Suresh Srinivas, info, TryStmt, LOG.info("report corrupt " + block + " from datanode " + srcDataNode + " to namenode");
532: Aaron Myers, debug, IfStmt, LOG.debug("Receiving one packet for block " + block + ": " + header);
598: Michael Stack, warn, IfStmt, LOG.warn("Slow BlockReceiver write packet to mirror took " + duration + "ms (threshold=" + datanodeSlowLogThresholdMs + "ms), " + "downstream DNs=" + Arrays.toString(downstreamDNs) + ", blockId=" + replicaInfo.getBlockId());
709: cnauroth, debug, IfStmt, LOG.debug("receivePacket for " + block + ": previous write did not end at the chunk boundary." + " onDiskLen=" + onDiskLen);
733: Arpit Agarwal, warn, IfStmt, LOG.warn("Slow BlockReceiver write data to disk cost:" + duration + "ms (threshold=" + datanodeSlowLogThresholdMs + "ms), " + "volume=" + getVolumeBaseUri() + ", blockId=" + replicaInfo.getBlockId());
773: Kihwal Lee, debug, IfStmt, LOG.debug("Writing out partial crc for data len " + len + ", skip=" + skip);
613: Todd Lipcon, debug, IfStmt, LOG.debug("Receiving an empty packet or the end of the block " + block);
933: Colin McCabe, Error, CatchClause, LOG.warn("Error managing cache for writer of block " + block, t);
926: Michael Stack, warn, IfStmt, LOG.warn("Slow manageWriterOsCache took " + duration + "ms (threshold=" + datanodeSlowLogThresholdMs + "ms), volume=" + getVolumeBaseUri() + ", blockId=" + replicaInfo.getBlockId());
1010: Kihwal Lee, info, IfStmt, LOG.info("Exception for " + block, ioe);
1063: Suresh Srinivas, warn, IfStmt, LOG.warn(msg + "\n" + StringUtils.getStackTrace(responder));
1091: Arpit Agarwal, debug, IfStmt, LOG.debug("Will collect peer metrics for downstream node {}", mirrorNameForMetrics);
1157: cnauroth, debug, IfStmt, LOG.debug("computePartialChunkCrc for " + block + ": sizePartialChunk=" + sizePartialChunk + ", block offset=" + blkoff + ", metafile offset=" + ckoff);
1181: cnauroth, debug, IfStmt, LOG.debug("Read in partial CRC chunk from disk for " + block);
1268: Suresh Srinivas, debug, IfStmt, LOG.debug(myString + ": enqueue " + p);
1290: Kihwal Lee, info, IfStmt, LOG.info("Cannot send OOB response " + ackStatus + ". Responder not running.");
1307: Kihwal Lee, info, MethodDeclaration, LOG.info("Sending an out of band ack of type " + ackStatus);
1327: Kihwal Lee, debug, IfStmt, LOG.debug(myString + ": seqno=" + seqno + " waiting for local datanode to finish write.");
1351: Kihwal Lee, debug, IfStmt, LOG.debug(myString + ": closing");
1370: Todd Lipcon, Info, MethodDeclaration, final long startTime = ClientTraceLog.isInfoEnabled() ? System.nanoTime() : 0;
1489: Todd Lipcon, warn, CatchClause, LOG.warn("IOException in BlockReceiver.run(): ", e);
1492: Todd Lipcon, info, IfStmt, LOG.info(myString, e);
1500: Todd Lipcon, info, IfStmt, LOG.info(myString, e);
1454: Suresh Srinivas, info, IfStmt, LOG.info(myString, ioe);
1387: Suresh Srinivas, debug, IfStmt, LOG.debug(myString + " got " + ack);
1392: Kihwal Lee, info, IfStmt, LOG.info("Relaying an out of band ack of type " + oobStatus);
1424: Suresh Srinivas, debug, IfStmt, LOG.debug("Calculated invalid ack time: " + ackTimeNanos + "ns.");
1470: Suresh Srinivas, info, IfStmt, LOG.info(myString + ": Thread is interrupted.");
1506: Todd Lipcon, info, MethodDeclaration, LOG.info(myString + " terminating");
1518: Colin Patrick Mccabe, Info, TryStmt, endTime = ClientTraceLog.isInfoEnabled() ? System.nanoTime() : 0;
1537: Suresh Srinivas, info, IfStmt, LOG.info("Received " + block + " size " + block.getNumBytes() + " from " + inAddr);
1533: Suresh Srinivas, info, IfStmt, ClientTraceLog.info(String.format(DN_CLIENTTRACE_FORMAT, inAddr, myAddr, block.getNumBytes(), "HDFS_WRITE", clientname, offset, dnR.getDatanodeUuid(), block, endTime - startTime));
1645: Suresh Srinivas, debug, IfStmt, LOG.debug(myString + ", replyAck=" + replyAck);
1639: Michael Stack, warn, IfStmt, LOG.warn("Slow PacketResponder send ack to upstream took " + duration + "ms (threshold=" + datanodeSlowLogThresholdMs + "ms), " + myString + ", replyAck=" + replyAck + ", downstream DNs=" + Arrays.toString(downstreamDNs) + ", blockId=" + replicaInfo.getBlockId());
162: Zhe Zhang, warn, CatchClause, InterDatanodeProtocol.LOG.warn("Recovery for replica " + block + " on data-node " + id + " is already in progress. Recovery id = " + rBlock.getNewGenerationStamp() + " is aborted.", ripE);
169: Yiqun Lin, warn, CatchClause, InterDatanodeProtocol.LOG.warn("Failed to recover block (block=" + block + ", datanode=" + id + ")", e);
155: Yongjun Zhang, debug, IfStmt, LOG.debug("Block recovery: Ignored replica with invalid " + "generation stamp or length: " + info + " from " + "DataNode: " + id);
152: Yongjun Zhang, debug, IfStmt, LOG.debug("Block recovery: DataNode: " + id + " does not have " + "replica for block: " + block);
145: Yongjun Zhang, debug, IfStmt, LOG.debug("Block recovery: Ignored replica with invalid " + "original state: " + info + " from DataNode: " + id);
200: Xiao Chen, info, MethodDeclaration, LOG.info("BlockRecoveryWorker: block={} (length={})," + " isTruncateRecovery={}, syncList={}", block, block.getNumBytes(), isTruncateRecovery, syncList);
209: Yongjun Zhang, debug, IfStmt, LOG.debug("syncBlock for block " + block + ", all datanodes don't " + "have the block or their replicas have 0 length. The block can " + "be deleted.");
252: Yongjun Zhang, debug, IfStmt, LOG.debug("syncBlock replicaInfo: block=" + block + ", from datanode " + r.id + ", receivedState=" + rState.name() + ", receivedLength=" + r.rInfo.getNumBytes() + ", bestState=FINALIZED, finalizedLength=" + finalizedLength);
270: Yongjun Zhang, debug, IfStmt, LOG.debug("syncBlock replicaInfo: block=" + block + ", from datanode " + r.id + ", receivedState=" + rState.name() + ", receivedLength=" + r.rInfo.getNumBytes() + ", bestState=" + bestState.name());
291: Xiao Chen, info, MethodDeclaration, LOG.info("BlockRecoveryWorker: block={} (length={}), bestState={}," + " newBlock={} (length={}), participatingList={}", block, block.getNumBytes(), bestState.name(), newBlock, newBlock.getNumBytes(), participatingList);
304: Zhe Zhang, warn, CatchClause, InterDatanodeProtocol.LOG.warn("Failed to updateBlock (newblock=" + newBlock + ", datanode=" + r.id + ")", e);
326: Yongjun Zhang, debug, IfStmt, LOG.debug("Datanode triggering commitBlockSynchronization, block=" + block + ", newGs=" + newBlock.getGenerationStamp() + ", newLength=" + newBlock.getNumBytes());
425: Zhe Zhang, warn, CatchClause, InterDatanodeProtocol.LOG.warn("Recovery for replica " + block + " on data-node " + id + " is already in progress. Recovery id = " + rBlock.getNewGenerationStamp() + " is aborted.", ripE);
431: Yiqun Lin, warn, CatchClause, InterDatanodeProtocol.LOG.warn("Failed to recover block (block=" + block + ", datanode=" + id + ")", e);
439: Zhe Zhang, debug, IfStmt, LOG.debug("Recovering block " + block + ", length=" + block.getNumBytes() + ", safeLength=" + safeLength + ", syncList=" + syncBlocks);
493: Zhe Zhang, warn, CatchClause, InterDatanodeProtocol.LOG.warn("Failed to updateBlock (newblock=" + ", datanode=" + r.id + ")", e);
547: Xiao Chen, info, MethodDeclaration, LOG.info("BlockRecoveryWorker: " + who + " calls recoverBlock(" + block + ", targets=[" + Joiner.on(", ").join(targets) + "]" + ", newGenerationStamp=" + rb.getNewGenerationStamp() + ", newBlock=" + rb.getNewBlock() + ", isStriped=" + rb.isStriped() + ")");
605: Zhe Zhang, warn, CatchClause, LOG.warn("recoverBlocks FAILED: " + b, e);
187: Colin Patrick Mccabe, info, IfStmt, LOG.info("Disabled block scanner.");
184: Colin Patrick Mccabe, info, IfStmt, LOG.info("Initialized block scanner with targetBytesPerSec {}", this.conf.targetBytesPerSec);
211: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Not adding volume scanner for {}, because the block " + "scanner is disabled.", volume);
217: Colin Patrick Mccabe, error, IfStmt, LOG.error("Already have a scanner for volume {}.", volume);
221: Colin Patrick Mccabe, debug, TryStmt, LOG.debug("Adding scanner for volume {} (StorageID {})", volume, volume.getStorageID());
245: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Not removing volume scanner for {}, because the block " + "scanner is disabled.", volume.getStorageID());
251: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("No scanner found to remove for volumeId {}", volume.getStorageID());
255: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Removing scanner for volume {} (StorageID {})", volume, volume.getStorageID());
332: Yongjun Zhang, debug, IfStmt, LOG.debug("Not scanning suspicious block {} on {}, because the block " + "scanner is disabled.", block, storageId);
364: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("Periodic block scanner is not running");
372: Colin Patrick Mccabe, trace, MethodDeclaration, LOG.trace("Returned Servlet info {}", resp);
274: Tsz-Wo Nicholas Sze, debug, IfStmt, DataNode.LOG.debug("Bumping up the client provided" + " block's genstamp to latest " + replica.getGenerationStamp() + " for block " + block);
285: Todd Lipcon, debug, IfStmt, DataNode.LOG.debug("block=" + block + ", replica=" + replica);
335: cnauroth, warn, IfStmt, LOG.warn("Could not find metadata file for " + block);
381: Todd Lipcon, warn, IfStmt, LOG.warn(datanode.getDNRegistrationForBP(block.getBlockPoolId()) + ":sendBlock() : " + msg);
416: Todd Lipcon, debug, IfStmt, DataNode.LOG.debug("replica=" + replica);
449: Wei-Chiu Chuang, warn, CatchClause, DataNode.LOG.warn("meta file " + finalized.getMetaFile() + " is missing!");
472: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to drop cache on file close", e);
650: Harsh J, error, IfStmt, LOG.error("BlockSender.sendChunks() exception: ", e);
681: Arpit Agarwal, warn, CatchClause, LOG.warn(" Could not read or failed to verify checksum for data" + " at offset " + offset + " for block " + block, e);
776: Arpit Agarwal, Debug, MethodDeclaration, final long startTime = ClientTraceLog.isDebugEnabled() ? System.nanoTime() : 0;
825: Arpit Agarwal, debug, IfStmt, ClientTraceLog.debug(String.format(clientTraceFmt, totalRead, initialOffset, endTime - startTime));
213: Tsz-Wo Nicholas Sze, warn, IfStmt, LOG.warn("Block pool ID needed, but service not yet registered with " + "NN, trace:", new Exception());
378: Mingliang Liu, info, IfStmt, LOG.info("Acknowledging ACTIVE Namenode during handshake" + actor);
509: Suresh Srinivas, warn, CatchClause, LOG.warn("Couldn't report bad block " + block + " to " + actor, e);
596: Andrew Wang, info, IfStmt, LOG.info("Namenode " + actor + " relinquishing ACTIVE state with " + "txid=" + nnHaState.getTxId());
576: Andrew Wang, info, IfStmt, LOG.info("Namenode " + actor + " trying to claim ACTIVE state with " + "txid=" + txid);
590: Andrew Wang, info, IfStmt, LOG.info("Namenode " + actor + " taking over ACTIVE state from " + bpServiceToActive + " at higher txid=" + txid);
588: Andrew Wang, info, IfStmt, LOG.info("Acknowledging ACTIVE Namenode " + actor);
742: Andrew Wang, info, SwitchStmt, LOG.info("DatanodeCommand action: DNA_CACHE for " + blockIdCmd.getBlockPoolId() + " of [" + blockIdArrayToString(blockIdCmd.getBlockIds()) + "]");
748: Andrew Wang, info, SwitchStmt, LOG.info("DatanodeCommand action: DNA_UNCACHE for " + blockIdCmd.getBlockPoolId() + " of [" + blockIdArrayToString(blockIdCmd.getBlockIds()) + "]");
759: Arpit Agarwal, info, SwitchStmt, LOG.info("Got finalize command for block pool " + bp);
772: Todd Lipcon, info, SwitchStmt, LOG.info("DatanodeCommand action: DNA_ACCESSKEYUPDATE");
780: Todd Lipcon, info, SwitchStmt, LOG.info("DatanodeCommand action: DNA_BALANCERBANDWIDTHUPDATE");
786: Harsh J, info, IfStmt, LOG.info("Updating balance throttler bandwidth from " + dxcs.balanceThrottler.getBandwidth() + " bytes/s " + "to: " + bandwidth + " bytes/s.");
793: Uma Maheswara Rao G, info, SwitchStmt, LOG.info("DatanodeCommand action: DNA_ERASURE_CODING_RECOVERY");
799: Todd Lipcon, warn, SwitchStmt, LOG.warn("Unknown DatanodeCommand action: " + cmd.getAction());
812: Aaron Myers, info, SwitchStmt, LOG.info("DatanodeCommand action from standby: DNA_ACCESSKEYUPDATE");
828: Suresh Srinivas, warn, SwitchStmt, LOG.warn("Got a command from standby NN - ignoring command:" + cmd.getAction());
831: Suresh Srinivas, warn, SwitchStmt, LOG.warn("Unknown DatanodeCommand action: " + cmd.getAction());
233: Suresh Srinivas, warn, CatchClause, LOG.warn("Problem connecting to server: " + nnAddr);
235: Suresh Srinivas, warn, CatchClause, LOG.warn("Problem connecting to server: " + nnAddr);
230: Suresh Srinivas, debug, TryStmt, LOG.debug(this + " received versionRequest response: " + nsInfo);
258: Aaron Myers, warn, IfStmt, LOG.warn(ive.getMessage());
263: Aaron Myers, info, IfStmt, LOG.info("Reported NameNode version '" + nnVersion + "' does not match " + "DataNode version '" + dnVersion + "' but is within acceptable " + "limits. Note: This is normal during a rolling upgrade.");
422: cnauroth, info, TryStmt, LOG.info((success ? "S" : "Uns") + "uccessfully sent block report 0x" + Long.toHexString(reportId) + ",  containing " + reports.length + " storage report(s), of which we sent " + numReportsSent + "." + " The reports had " + totalBlockCount + " total blocks and used " + numRPCs + " RPC(s). This took " + brCreateCost + " msec to generate and " + brSendCost + " msecs for RPC and NN processing." + " Got back " + ((nCmds == 0) ? "no commands" : ((nCmds == 1) ? "one command: " + cmds.get(0) : (nCmds + " commands: " + Joiner.on("; ").join(cmds)))) + ".");
452: Andrew Wang, debug, IfStmt, LOG.debug("Sending cacheReport from service actor: " + this);
466: Andrew Wang, debug, IfStmt, LOG.debug("CacheReport of " + blockIds.size() + " block(s) took " + createCost + " msec to generate and " + sendCost + " msecs for RPC and NN processing");
495: Arpit Agarwal, debug, IfStmt, LOG.debug("Sending heartbeat with " + reports.length + " storage reports from service actor: " + this);
598: Arpit Agarwal, error, IfStmt, LOG.error("Invalid BlockPoolId " + rollingUpgradeStatus.getBlockPoolId() + " in HeartbeatResponse. Expected " + bpos.getBlockPoolId());
612: Colin McCabe, info, MethodDeclaration, LOG.info("For namenode " + nnAddr + " using" + " BLOCKREPORT_INTERVAL of " + dnConf.blockReportInterval + "msec" + " CACHEREPORT_INTERVAL of " + dnConf.cacheReportInterval + "msec" + " Initial delay: " + dnConf.initialBlockReportDelayMs + "msec" + "; heartBeatInterval=" + dnConf.heartBeatInterval + (lifelineSender != null ? "; lifelineIntervalMs=" + dnConf.getLifelineIntervalMs() : ""));
720: Suresh Srinivas, warn, IfStmt, LOG.warn(this + " is shutting down", re);
724: Suresh Srinivas, warn, CatchClause, LOG.warn("RemoteException in offerService", re);
727: Suresh Srinivas, warn, CatchClause, LOG.warn("IOException in offerService", e);
649: Colin Patrick Mccabe, warn, IfStmt, LOG.warn(nnAddr + " sent back a full block report lease " + "ID of 0x" + Long.toHexString(resp.getFullBlockReportLeaseId()) + ", but we already have a lease ID of 0x" + Long.toHexString(fullBlockReportLeaseId) + ". " + "Overwriting old lease ID.");
679: Suresh Srinivas, info, IfStmt, LOG.info("Took " + (endProcessCommands - startProcessCommands) + "ms to process " + resp.getCommands().length + " commands from NN");
694: Colin Patrick Mccabe, info, IfStmt, LOG.info("Forcing a full block report to " + nnAddr);
763: Suresh Srinivas, info, MethodDeclaration, LOG.info(this + " beginning handshake with NN");
773: Vinayakumar B, info, CatchClause, LOG.info("Problem connecting to server: " + nnAddr + " :" + e.getLocalizedMessage());
777: Suresh Srinivas, info, CatchClause, LOG.info("Problem connecting to server: " + nnAddr);
782: Suresh Srinivas, info, MethodDeclaration, LOG.info("Block pool " + this + " successfully registered with NN");
795: Suresh Srinivas, info, CatchClause, LOG.info("BPOfferService " + this + " interrupted while " + stateString);
809: Suresh Srinivas, info, MethodDeclaration, LOG.info(this + " starting to offer service");
849: Suresh Srinivas, warn, CatchClause, LOG.warn("Unexpected exception in block pool " + this, ex);
852: Suresh Srinivas, warn, TryStmt, LOG.warn("Ending block pool service for: " + this);
828: Haohui Mai, error, IfStmt, LOG.error("Initialization failed for " + this + ". Exiting. ", ioe);
823: Vinayakumar B, error, IfStmt, LOG.error("Initialization failed for " + this + " " + ioe.getLocalizedMessage());
843: Suresh Srinivas, error, CatchClause, LOG.error("Exception in BPOfferService for " + this, ex);
879: Suresh Srinivas, Error, CatchClause, LOG.warn("Error processing datanode Command", ioe);
918: Colin Patrick Mccabe, info, IfStmt, LOG.info(bpos.toString() + ": scheduling a full block report.");
915: Colin Patrick Mccabe, info, IfStmt, LOG.info(bpos.toString() + ": scheduling an incremental block report.");
945: Kihwal Lee, warn, CatchClause, LOG.warn(baae.getMessage() + nnAddr, baae);
1008: Chris Nauroth, warn, CatchClause, LOG.warn("IOException in LifelineSender for " + BPServiceActor.this, e);
1013: Chris Nauroth, info, MethodDeclaration, LOG.info("LifelineSender for " + BPServiceActor.this + " exiting.");
1024: Chris Nauroth, error, MethodDeclaration, LOG.error(thread + " terminating on unexpected exception", t);
1046: Chris Nauroth, debug, IfStmt, LOG.debug("Skipping sending lifeline for " + BPServiceActor.this + ", because it is not due.");
1053: Chris Nauroth, debug, IfStmt, LOG.debug("Skipping sending lifeline for " + BPServiceActor.this + ", because heartbeats are disabled for tests.");
1067: Chris Nauroth, debug, IfStmt, LOG.debug("Sending lifeline with " + reports.length + " storage " + " reports from service actor: " + BPServiceActor.this);
489: Todd Lipcon, debug, IfStmt, LOG.debug(this.fileDescriptorPassingDisabledReason);
483: Todd Lipcon, info, IfStmt, LOG.info("File descriptor passing is enabled.");
480: Steve Loughran, warn, IfStmt, LOG.warn("File descriptor passing is disabled because {}", reason);
496: Steve Loughran, info, TryStmt, LOG.info("Configured hostname is {}", hostName);
547: Arpit Agarwal, warn, CatchClause, LOG.warn("Exception while sending the block report after refreshing" + " volumes {} to {}", property, newVal, e);
536: Steve Loughran, info, TryStmt, LOG.info("Reconfiguring {} to {}", property, newVal);
587: Arpit Agarwal, warn, IfStmt, LOG.warn(String.format("Exception in updating balancer max concurrent movers %s to %s", property, newVal), rootException);
564: Steve Loughran, info, TryStmt, LOG.info("Reconfiguring {} to {}", property, newVal);
699: Steve Loughran, info, IfStmt, LOG.info("Deactivation request received for active volume: {}", dir.getRoot());
727: Steve Loughran, info, IfStmt, LOG.info("Deactivation request received for failed volume: {}", failedStorageLocation);
763: Steve Loughran, info, IfStmt, LOG.info("Adding new volumes: {}", Joiner.on(",").join(changedVolumes.newLocations));
806: Steve Loughran, error, CatchClause, LOG.error("Failed to add volume: {}", volume, e);
800: Steve Loughran, info, IfStmt, LOG.info("Successfully added volume: {}", volume);
797: Steve Loughran, error, IfStmt, LOG.error("Failed to add volume: {}", volume, ioe);
815: Steve Loughran, error, CatchClause, LOG.error("Failed to remove volume", e);
868: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info(String.format("Deactivating volumes (clear failure=%b): %s", clearFailure, Joiner.on(",").join(storageLocations)));
970: Steve Loughran, error, CatchClause, LOG.error("Unable to load DataNode plugins. " + "Specified list of plugins: {}", pluginsValue, e);
980: Steve Loughran, warn, CatchClause, LOG.warn("ServicePlugin {} could not be started", p, t);
978: Steve Loughran, info, TryStmt, LOG.info("Started plug-in {}", p);
1030: Steve Loughran, info, MethodDeclaration, LOG.info("Opened IPC server at {}", ipcServer.getListenerAddress());
1089: Steve Loughran, info, IfStmt, LOG.info("Periodic Directory Tree Verification scan " + "is disabled because {}", reason);
1144: Steve Loughran, info, MethodDeclaration, LOG.info("Opened streaming server at {}", streamingAddr);
1162: Steve Loughran, info, IfStmt, LOG.info("Listening on UNIX domain socket: {}", domainPeerServer.getBindPath());
1179: Todd Lipcon, warn, IfStmt, LOG.warn("Although short-circuit local reads are configured, " + "they are disabled because you didn't configure {}", DFSConfigKeys.DFS_DOMAIN_SOCKET_PATH_KEY);
1210: Steve Loughran, error, IfStmt, LOG.error("Cannot find BPOfferService for reporting block received " + "for bpid={}", block.getBlockPoolId());
1222: Steve Loughran, error, IfStmt, LOG.error("Cannot find BPOfferService for reporting block receiving " + "for bpid={}", block.getBlockPoolId());
1233: Todd Lipcon, error, IfStmt, LOG.error("Cannot find BPOfferService for reporting block deleted for bpid=" + block.getBlockPoolId());
1244: Steve Loughran, warn, IfStmt, LOG.warn("Cannot find FsVolumeSpi to report bad block: {}", block);
1387: Steve Loughran, info, MethodDeclaration, LOG.info("Starting DataNode with maxLockedMemory = {}", dnConf.maxLockedMemory);
1414: Steve Loughran, info, MethodDeclaration, LOG.info("dnUserName = {}", dnUserName);
1415: Steve Loughran, info, MethodDeclaration, LOG.info("supergroup = {}", supergroup);
1532: Steve Loughran, info, IfStmt, LOG.info("Generated and persisted new Datanode UUID {}", storage.getDatanodeUuid());
1601: Steve Loughran, info, IfStmt, LOG.info("Block token params received from NN: " + "for block pool {} keyUpdateInterval={} min(s), " + "tokenLifetime={} min(s)", blockPoolId, blockKeyUpdateInterval / (60 * 1000), blockTokenLifetime / (60 * 1000));
1708: Steve Loughran, info, IfStmt, LOG.info("Setting up storage: nsid={};bpid={};lv={};" + "nsInfo={};dnuuid={}", bpStorage.getNamespaceID(), bpid, storage.getLayoutVersion(), nsInfo, storage.getDatanodeUuid());
1821: Steve Loughran, debug, MethodDeclaration, LOG.debug("Connecting to datanode {} addr={}", dnAddr, addr);
1891: Steve Loughran, Info, IfStmt, LOG.trace("getBlockLocalPathInfo for block={} " + "returning null", block);
1887: Steve Loughran, Info, IfStmt, LOG.trace("getBlockLocalPathInfo successful " + "block={} blockfile {} metafile {}", block, info.getBlockPath(), info.getMetaPath());
1937: Aaron Myers, debug, CatchClause, LOG.debug("requestShortCircuitFdsForRead failed", e);
1952: Steve Loughran, debug, IfStmt, LOG.debug("Got: {}", id);
1972: Steve Loughran, warn, CatchClause, LOG.warn("ServicePlugin {} could not be stopped", p, t);
1970: Steve Loughran, info, TryStmt, LOG.info("Stopped plug-in {}", p);
1995: Steve Loughran, trace, CatchClause, LOG.trace("Exception interrupting DataXceiverServer", e);
2016: Vinayakumar B, warn, CatchClause, LOG.warn("Exception shutting down DataNode HttpServer", e);
2049: Steve Loughran, info, WhileStmt, LOG.info("Waiting for threadgroup to exit, active threads is {}", this.threadGroup.activeCount());
2096: Steve Loughran, warn, CatchClause, LOG.warn("Received exception in BlockPoolManager#shutDownAll", ie);
2104: Steve Loughran, warn, CatchClause, LOG.warn("Exception when unlocking storage", ie);
2121: Kihwal Lee, info, MethodDeclaration, LOG.info("Shutdown complete.");
2142: Xiaoyu Yao, Error, IfStmt, LOG.debug("checkDiskErrorAsync: no volume failures detected");
2139: Xiaoyu Yao, Error, IfStmt, LOG.warn("checkDiskErrorAsync callback got {} failed volumes: {}", failedVolumes.size(), failedVolumes);
2151: Steve Loughran, warn, MethodDeclaration, LOG.warn("DataNode.handleDiskError on: " + "[{}] Keep Running: {}", failedVolumes, hasEnoughResources);
2170: Xiaoyu Yao, warn, MethodDeclaration, LOG.warn("DataNode is shutting down due to failed volumes: [" + failedVolumes + "]");
2200: Aaron T. Myers, warn, CatchClause, LOG.warn("failed to increment network error counts for " + host);
2250: Yongjun Zhang, warn, IfStmt, LOG.warn("Cannot find FsVolumeSpi to report bad block: " + block);
2255: Colin Patrick Mccabe, warn, MethodDeclaration, LOG.warn(msg);
2289: Todd Lipcon, info, IfStmt, LOG.info(errStr);
2315: Suresh Srinivas, info, IfStmt, LOG.info(bpReg + " Starting thread to transfer " + block + " to " + xfersBuilder);
2332: Todd Lipcon, warn, CatchClause, LOG.warn("Failed to transfer block " + blocks[i], ie);
2449: Steve Loughran, debug, IfStmt, DataTransferProtocol.LOG.debug("{}: {} (numBytes={}), stage={}, " + "clientname={}, targets={}, target storage types={}, " + "target storage IDs={}", getClass().getSimpleName(), b, b.getNumBytes(), stage, clientname, Arrays.asList(targets), targetStorageTypes == null ? "[]" : Arrays.asList(targetStorageTypes), targetStorageIds == null ? "[]" : Arrays.asList(targetStorageIds));
2558: Steve Loughran, warn, CatchClause, LOG.warn("{}:Failed to transfer {} to {} got", bpReg, b, targets[0], ie);
2484: Steve Loughran, debug, TryStmt, LOG.debug("Connecting to datanode {}", dnAddr);
2528: Steve Loughran, info, TryStmt, LOG.info("{}, at {}: Transmitted {} (numBytes={}) to {}", getClass().getSimpleName(), DataNode.this.getDisplayName(), b, b.getNumBytes(), curTarget);
2536: Steve Loughran, debug, IfStmt, LOG.debug("{}: close-ack={}", getClass().getSimpleName(), closeAck);
2691: Steve Loughran, error, CatchClause, LOG.error("Failed to initialize storage directory {}." + "Exception details: {}", locationString, ioe.toString());
2739: Steve Loughran, warn, CatchClause, LOG.warn("Received exception in Datanode#join: {}", ex.toString());
2796: Todd Lipcon, error, IfStmt, LOG.error("-r, --rack arguments are not supported anymore. RackID " + "resolution is handled by the NameNode.");
2870: Haohui Mai, error, CatchClause, LOG.error("Exception in secureMain", e);
2944: Steve Loughran, debug, ForeachStmt, LOG.debug("Got: {}", id);
3137: Anu Engineer, debug, CatchClause, LOG.debug("Reading diskbalancer Status failed. ex:{}", ex);
3157: Steve Loughran, info, MethodDeclaration, LOG.info("deleteBlockPool command received for block pool {}, " + "force={}", blockPoolId, force);
3160: Steve Loughran, warn, IfStmt, LOG.warn("The block pool {} is still running, cannot be deleted.", blockPoolId);
3173: Steve Loughran, info, MethodDeclaration, LOG.info("shutdownDatanode command received (upgrade={}). " + "Shutting down Datanode...", forUpgrade);
3204: Eric Payne, info, MethodDeclaration, LOG.info("Evicting all writers.");
3339: Xiaoyu Yao, error, CatchClause, LOG.error("Interruped while running disk check", e);
3348: Xiaoyu Yao, Error, IfStmt, LOG.debug("checkDiskError encountered no failures");
3344: Xiaoyu Yao, Error, IfStmt, LOG.warn("checkDiskError got {} failed volumes - {}", unhealthyVolumes.size(), unhealthyVolumes);
3354: Xiaoyu Yao, debug, IfStmt, LOG.debug("handleVolumeFailures done with empty " + "unhealthyVolumes");
3373: Steve Loughran, Error, CatchClause, LOG.warn("Error occurred when removing unhealthy storage dirs", e);
3375: Steve Loughran, debug, MethodDeclaration, LOG.debug("{}", sb);
3557: Steve Loughran, error, SwitchStmt, LOG.error("Disk Balancer - Unknown key in get balancer setting. Key: {}", key);
3591: Akira Ajisaka, warn, IfStmt, LOG.warn("DataNode volume info not available.");
160: Xiaoyu Yao, info, IfStmt, LOG.info("Generated new storageID {} for directory {} {}", sd.getStorageUuid(), sd.getRoot(), (oldStorageID == null ? "" : (" to replace " + oldStorageID)));
176: Xiaoyu Yao, info, IfStmt, LOG.info("Enabled trash for bpid {}", bpid);
184: Xiaoyu Yao, info, IfStmt, LOG.info("Cleared trash for bpid {}", bpid);
278: Xiaoyu Yao, info, SwitchStmt, LOG.info("Storage directory with location {} does not exist", location);
282: Xiaoyu Yao, info, SwitchStmt, LOG.info("Storage directory with location {} is not formatted for " + "namespace {}. Formatting...", location, nsInfo.getNamespaceID());
327: Xiaoyu Yao, error, IfStmt, LOG.warn(errorMessage);
354: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Using {} threads to upgrade data directories ({}={}, " + "dataDirs={})", min, key, n, dataDirs);
421: Xiaoyu Yao, info, IfStmt, LOG.info("Storage directory {} has already been used.", dataDir);
418: Xiaoyu Yao, warn, CatchClause, LOG.warn("Failed to add storage directory {}", dataDir, e);
427: Xiaoyu Yao, info, IfStmt, LOG.info("loadDataStorage: {} upgrade tasks", tasks.size());
433: Xiaoyu Yao, warn, CatchClause, LOG.warn("Failed to upgrade storage directory {}", t.dataDir, e);
466: Xiaoyu Yao, warn, CatchClause, LOG.warn("Failed to add storage directory {} for block pool {}", dataDir, bpid, e);
472: Xiaoyu Yao, info, IfStmt, LOG.info("loadBlockPoolSliceStorage: {} upgrade tasks", tasks.size());
477: Xiaoyu Yao, warn, CatchClause, LOG.warn("Failed to upgrade storage directory {} for block pool {}", t.dataDir, bpid, e);
522: Xiaoyu Yao, warn, CatchClause, LOG.warn("I/O error attempting to unlock storage directory {}.", sd.getRoot(), e);
672: Xiaoyu Yao, error, IfStmt, LOG.error("Unable to acquire file lock on path {}", oldF);
793: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Upgrading storage directory {}.\n old LV = {}; old CTime = {}" + ".\n new LV = {}; new CTime = {}", sd.getRoot(), oldLV, this.getCTime(), HdfsServerConstants.DATANODE_LAYOUT_VERSION, nsInfo.getCTime());
849: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Upgrade of {} is complete", sd.getRoot());
855: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Updating layout version from {} to {} for storage {}", layoutVersion, HdfsServerConstants.DATANODE_LAYOUT_VERSION, sd.getRoot());
913: Xiaoyu Yao, info, IfStmt, LOG.info("Layout version rolled back to {} for storage {}", HdfsServerConstants.DATANODE_LAYOUT_VERSION, sd.getRoot());
931: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Rolling back storage directory {}.\n   target LV = {}; target " + "CTime = {}", sd.getRoot(), HdfsServerConstants.DATANODE_LAYOUT_VERSION, nsInfo.getCTime());
944: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Rollback of {} is complete", sd.getRoot());
962: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Finalizing upgrade for storage directory {}.\n   cur LV = {}; " + "cur CTime = {}", dataDirPath, this.getLayoutVersion(), this.getCTime());
983: Suresh Srinivas, error, CatchClause, LOG.error("Finalize upgrade for " + dataDirPath + " failed", ex);
985: Suresh Srinivas, info, MethodDeclaration, LOG.info("Finalize upgrade for " + dataDirPath + " is complete");
1052: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Linked blocks from {} to {}. {}", fromDir, toDir, hardLink.linkStats.report());
1074: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Start linking block files from {} to {}", from, to);
1095: Xiaoyu Yao, error, IfStmt, LOG.error("There are {} duplicate block " + "entries within the same volume.", duplicates.size());
1238: Xiaoyu Yao, warn, IfStmt, LOG.warn("Unexpectedly low genstamp on {}.", duplicate.src.getAbsolutePath());
1262: Xiaoyu Yao, warn, IfStmt, LOG.warn("Unexpectedly short length on {}.", duplicate.src.getAbsolutePath());
1267: Xiaoyu Yao, warn, IfStmt, LOG.warn("Unexpectedly short length on {}.", prevLongest.src.getAbsolutePath());
1283: Xiaoyu Yao, warn, IfStmt, LOG.warn("Discarding {}.", args.src.getAbsolutePath());
152: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("Number of active connections is: {}", datanode.getXceiverCount());
201: Steve Loughran, info, MethodDeclaration, LOG.info("Stopped the writer: {}", peer);
321: Tsz-wo Sze, error, IfStmt, LOG.error(s, t);
314: Steve Loughran, info, IfStmt, LOG.info("{}; {}", s1, t.toString());
312: Andrew Wang, trace, IfStmt, LOG.trace(s1, t);
305: Steve Loughran, info, IfStmt, LOG.info("{}; {}", s, t.toString());
303: Tsz-wo Sze, trace, IfStmt, LOG.trace(s, t);
325: Steve Loughran, debug, TryStmt, LOG.debug("{}:Number of active connections is: {}", datanode.getDisplayName(), datanode.getXceiverCount());
245: cnauroth, info, IfStmt, LOG.info("Failed to read expected SASL data transfer protection " + "handshake from client at {}" + ". Perhaps the client is running an older version of Hadoop " + "which does not support SASL data transfer protection", peer.getRemoteAddressString(), imne);
240: cnauroth, info, IfStmt, LOG.info("Failed to read expected encryption handshake from client " + "at {}. Perhaps the client " + "is running an older version of Hadoop which does not support " + "encryption", peer.getRemoteAddressString(), imne);
417: Steve Loughran, info, IfStmt, LOG.info("Unregistering {} because the " + "requestShortCircuitFdsForRead operation failed.", registeredSlotId);
425: Todd Lipcon, info, IfStmt, BlockSender.ClientTraceLog.info(String.format("src: 127.0.0.1, dest: 127.0.0.1, op: REQUEST_SHORT_CIRCUIT_FDS," + " blockid: %s, srvID: %s, success: %b", blk.getBlockId(), dnR.getDatanodeUuid(), success));
386: Weiwei Yang, error, CatchClause, LOG.error("Request short-circuit read file descriptor" + " failed with unknown error.", e);
410: Steve Loughran, trace, IfStmt, LOG.trace("Receipt verification is not enabled on the DataNode. " + "Not verifying {}", slotId);
404: Steve Loughran, trace, IfStmt, LOG.trace("Reading receipt verification byte for {}", slotId);
463: Colin McCabe, info, IfStmt, BlockSender.ClientTraceLog.info(String.format("src: 127.0.0.1, dest: 127.0.0.1, op: RELEASE_SHORT_CIRCUIT_FDS," + " shmId: %016x%016x, slotIdx: %d, srvID: %s, success: %b", slotId.getShmId().getHi(), slotId.getShmId().getLo(), slotId.getSlotIdx(), datanode.getDatanodeUuid(), success));
532: Colin McCabe, info, IfStmt, BlockSender.ClientTraceLog.info(String.format("cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, " + "op: REQUEST_SHORT_CIRCUIT_SHM, " + "shmId: n/a, srvID: %s, success: false", clientName, datanode.getDatanodeUuid()));
524: Colin McCabe, info, IfStmt, BlockSender.ClientTraceLog.info(String.format("cliID: %s, src: 127.0.0.1, dest: 127.0.0.1, " + "op: REQUEST_SHORT_CIRCUIT_SHM," + " shmId: %016x%016x, srvID: %s, success: true", clientName, shmInfo.getShmId().getHi(), shmInfo.getShmId().getLo(), datanode.getDatanodeUuid()));
551: Colin Patrick Mccabe, warn, CatchClause, LOG.warn("Failed to shut down socket in error handler", e);
547: Steve Loughran, warn, TryStmt, LOG.warn("Failed to send success response back to the client. " + "Shutting down socket for {}", shmInfo.getShmId());
583: Todd Lipcon, Info, MethodDeclaration, final String clientTraceFmt = clientName.length() > 0 && ClientTraceLog.isInfoEnabled() ? String.format(DN_CLIENTTRACE_FORMAT, localAddress, remoteAddress, "%d", "HDFS_READ", clientName, "%d", dnR.getDatanodeUuid(), block, "%d") : dnR + " Served block " + block + " to " + remoteAddress;
633: Steve Loughran, trace, CatchClause, LOG.trace("{}:Ignoring exception while serving {} to {}", dnR, block, remoteAddress, ignored);
643: Steve Loughran, warn, IfStmt, LOG.warn("{}:Got exception while serving {} to {}", dnR, block, remoteAddress, ioe);
598: Todd Lipcon, info, CatchClause, LOG.info(msg);
622: Todd Lipcon, Error, CatchClause, LOG.debug("Error reading client status response. Will close connection.", ioe);
616: Steve Loughran, warn, IfStmt, LOG.warn("Client {} did not send a valid status code " + "after reading. Will close connection.", peer.getRemoteAddressString());
719: Steve Loughran, debug, IfStmt, LOG.debug("opWriteBlock: stage={}, clientname={}\n  " + "block  ={}, newGs={}, bytesRcvd=[{}, {}]\n  " + "targets={}; pipelineSize={}, srcDataNode={}, pinning={}", stage, clientname, block, latestGenerationStamp, minBytesRcvd, maxBytesRcvd, Arrays.asList(targets), pipelineSize, srcDataNode, pinning);
725: Steve Loughran, debug, IfStmt, LOG.debug("isDatanode={}, isClient={}, isTransfer={}", isDatanode, isClient, isTransfer);
727: Steve Loughran, debug, IfStmt, LOG.debug("writeBlock receive buf size {} tcp no delay {}", peer.getReceiveBufferSize(), peer.getTcpNoDelay());
738: Steve Loughran, info, MethodDeclaration, LOG.info("Receiving {} src: {} dest: {}", block, remoteAddress, localAddress);
922: Steve Loughran, info, CatchClause, LOG.info("opWriteBlock {} received exception {}", block, ioe.toString());
775: Steve Loughran, debug, IfStmt, LOG.debug("Connecting to datanode {}", mirrorNode);
867: Steve Loughran, info, IfStmt, LOG.info("{}:Exception transfering {} to mirror {}- continuing " + "without the mirror", datanode, block, mirrorNode, e);
863: Steve Loughran, error, IfStmt, LOG.error("{}:Exception transfering block {} to mirror {}", datanode, block, mirrorNode, e);
840: Steve Loughran, debug, IfStmt, LOG.debug("Datanode {} got response for connect" + "ack  from downstream datanode with firstbadlink as {}", targets.length, firstBadLink);
877: Steve Loughran, debug, IfStmt, LOG.debug("Datanode {} forwarding connect ack to upstream " + "firstbadlink is {}", targets.length, firstBadLink);
896: Steve Loughran, trace, IfStmt, LOG.trace("TRANSFER: send close-ack");
914: Steve Loughran, info, IfStmt, LOG.info("Received {} src: {} dest: {} of size {}", block, remoteAddress, localAddress, block.getNumBytes());
961: Steve Loughran, info, CatchClause, LOG.info("transferBlock {} received exception {}", blk, ioe.toString());
1000: Steve Loughran, info, CatchClause, LOG.info("blockChecksum {} received exception {}", block, ioe.toString());
1046: Steve Loughran, info, CatchClause, LOG.info("blockChecksum {} received exception {}", stripedBlockInfo.getBlock(), ioe.toString());
1069: Tsz-Wo Nicholas Sze, info, IfStmt, LOG.info(msg);
1078: Todd Lipcon, info, IfStmt, LOG.info(msg);
1108: Steve Loughran, info, CatchClause, LOG.info("opCopyBlock {} received exception {}", block, ioe.toString());
1105: Steve Loughran, info, TryStmt, LOG.info("Copied {} to {}", block, peer.getRemoteAddressString());
1146: Todd Lipcon, warn, IfStmt, LOG.warn(msg);
1236: Todd Lipcon, info, CatchClause, LOG.info(errMsg);
1258: Steve Loughran, Error, CatchClause, LOG.warn("Error writing reply back to {}", peer.getRemoteAddressString());
1170: Steve Loughran, debug, IfStmt, LOG.debug("Connecting to datanode {}", dnAddr);
1227: Steve Loughran, info, IfStmt, LOG.info("Moved {} from {}, delHint={}", block, peer.getRemoteAddressString(), delHint);
1163: Steve Loughran, info, IfStmt, LOG.info("Moved {} from StorageType {} to {}", block, oldReplica.getVolume().getStorageType(), storageType);
1407: Steve Loughran, debug, IfStmt, LOG.debug("Checking block access token for block '{}' with mode '{}'", blk.getBlockId(), mode);
1426: Steve Loughran, warn, TryStmt, LOG.warn("Block token verification failed: op={}, " + "remoteAddress={}, message={}", op, remoteAddress, e.getLocalizedMessage());
78: Andrew Wang, info, ConstructorDeclaration, LOG.info("Balancing bandwidth is " + bandwidth + " bytes/s");
79: Arpit Agarwal, info, ConstructorDeclaration, LOG.info("Number threads for balancing is " + maxThreads);
164: Eli Collins, warn, IfStmt, LOG.warn(datanode.getDisplayName() + ":DataXceiverServer: ", ace);
168: Eli Collins, warn, CatchClause, LOG.warn(datanode.getDisplayName() + ":DataXceiverServer: ", ie);
181: Eli Collins, error, CatchClause, LOG.error(datanode.getDisplayName() + ":DataXceiverServer: Exiting due to: ", te);
192: Eli Collins, warn, CatchClause, LOG.warn(datanode.getDisplayName() + " :DataXceiverServer: close exception", ie);
224: Eli Collins, warn, CatchClause, LOG.warn(datanode.getDisplayName() + ":DataXceiverServer.kill(): ", ie);
255: Brandon Li, warn, CatchClause, LOG.warn("Got error when sending OOB message.", e);
257: Brandon Li, warn, CatchClause, LOG.warn("Interrupted when sending OOB message.");
281: Kihwal Lee, info, MethodDeclaration, LOG.info("Closing all peers.");
241: Colin Patrick Mccabe, error, IfStmt, LOG.error(DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_THROTTLE_LIMIT_MS_PER_SEC_KEY + " set to value below 1 ms/sec. Assuming default value of " + DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_THROTTLE_LIMIT_MS_PER_SEC_DEFAULT);
236: Colin Patrick Mccabe, error, IfStmt, LOG.error(DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_THROTTLE_LIMIT_MS_PER_SEC_KEY + " set to value above 1000 ms/sec. Assuming default value of " + DFSConfigKeys.DFS_DATANODE_DIRECTORYSCAN_THROTTLE_LIMIT_MS_PER_SEC_DEFAULT);
283: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info(logMsg);
324: Todd Lipcon, error, CatchClause, LOG.error("Exception during DirectoryScanner execution - will continue next cycle", e);
327: Todd Lipcon, error, CatchClause, LOG.error("System Error during DirectoryScanner execution - permanently terminating periodic scanner", er);
315: Todd Lipcon, warn, IfStmt, LOG.warn("this cycle terminating immediately because 'shouldRun' has been deactivated");
342: Todd Lipcon, warn, IfStmt, LOG.warn("DirectoryScanner: shutdown has been called");
340: Todd Lipcon, warn, IfStmt, LOG.warn("DirectoryScanner: shutdown has been called, but periodic scanner not started");
355: Eli Collins, error, CatchClause, LOG.error("interrupted while waiting for masterThread to " + "terminate", e);
363: Eli Collins, error, CatchClause, LOG.error("interrupted while waiting for reportCompileThreadPool to " + "terminate", e);
473: Todd Lipcon, info, ForeachStmt, LOG.info(statsRecord.toString());
564: Colin Patrick Mccabe, error, CatchClause, LOG.error("Unexpected IOException by closing FsVolumeReference", e);
558: Colin Patrick Mccabe, Error, CatchClause, LOG.error("Error compiling report for the volume, StorageId: " + fsVolumeSpi.getStorageID(), ex);
162: Arpit Agarwal, error, IfStmt, LOG.error("Disk Balancer : Scheduler did not terminate.");
189: Arpit Agarwal, error, IfStmt, LOG.error("Disk Balancer - Executing another plan, submitPlan failed.");
222: Anu Engineer, warn, CatchClause, LOG.warn("Disk Balancer - Error when closing volume references: ", e);
275: Arpit Agarwal, error, IfStmt, LOG.error("Disk Balancer - No such plan. Cancel plan failed. PlanID: " + planID);
379: Arpit Agarwal, error, IfStmt, LOG.error("Disk Balancer - Invalid plan version.");
396: Arpit Agarwal, error, IfStmt, LOG.error("Disk Balancer -  Invalid plan.");
405: Arpit Agarwal, error, IfStmt, LOG.error("Disk Balancer - Invalid plan hash.");
436: Arpit Agarwal, error, IfStmt, LOG.error("Disk Balancer - " + errorString);
450: Arpit Agarwal, error, IfStmt, LOG.error("Disk Balancer - Plan was generated for another node.");
478: Anu Engineer, error, IfStmt, LOG.error(errMsg);
487: Anu Engineer, error, IfStmt, LOG.error(errMsg);
518: Arpit Agarwal, error, CatchClause, LOG.error("Disk Balancer - Internal Error.", ex);
539: Lei Xu, info, MethodDeclaration, LOG.info("Executing Disk balancer plan. Plan File: {}, Plan ID: {}", planFile, planID);
560: Anu Engineer, warn, IfStmt, LOG.warn(errMsg);
755: Anu Engineer, debug, IfStmt, LOG.debug("Found 0 or less as max disk throughput, ignoring config " + "value. value : " + diskBandwidth);
762: Anu Engineer, debug, IfStmt, LOG.debug("Found 0 or less for block tolerance value, ignoring config" + "value. value : " + blockTolerance);
770: Anu Engineer, debug, IfStmt, LOG.debug("Found  less than 0 for maxDiskErrors value, ignoring " + "config value. value : " + maxDiskErrors);
923: Anu Engineer, info, IfStmt, LOG.info("Maximum error count exceeded. Error count: {} Max error:{} ", item.getErrorCount(), item.getMaxDiskErrors());
971: Anu Engineer, error, CatchClause, LOG.error("Unable to get json from Item.");
969: Anu Engineer, error, TryStmt, LOG.error("No movable source blocks found. {}", item.toJson());
988: Anu Engineer, Error, CatchClause, LOG.error("Error closing a block pool iter. ex: {}", ex);
1010: Anu Engineer, error, IfStmt, LOG.error(errMsg);
1018: Anu Engineer, error, IfStmt, LOG.error(errMsg);
1026: Anu Engineer, error, IfStmt, LOG.error(errMsg);
1039: Anu Engineer, error, IfStmt, LOG.error("No block pools found on volume. volume : {}. Exiting.", source.getBaseURI());
1122: Anu Engineer, error, CatchClause, LOG.error("Exception while trying to copy blocks. error: {}", ex);
1125: Anu Engineer, error, CatchClause, LOG.error("Copy Block Thread interrupted, exiting the copy.");
1049: Anu Engineer, error, IfStmt, LOG.error("Exceeded the max error count. source {}, dest: {} " + "error count: {}", source.getBaseURI(), dest.getBaseURI(), item.getErrorCount());
1057: Anu Engineer, info, IfStmt, LOG.info("Copy from {} to {} done. copied {} bytes and {} " + "blocks.", source.getBaseURI(), dest.getBaseURI(), item.getBytesCopied(), item.getBlocksCopied());
1068: Anu Engineer, error, IfStmt, LOG.error("No source blocks, exiting the copy. Source: {}, " + "Dest:{}", source.getBaseURI(), dest.getBaseURI());
1101: Anu Engineer, debug, TryStmt, LOG.debug("Moved block with size {} from  {} to {}", block.getNumBytes(), source.getBaseURI(), dest.getBaseURI());
205: Tsuyoshi Ozawa, info, IfStmt, DataNode.LOG.info("dfs.blockreport.initialDelay is " + "greater than or equal to" + "dfs.blockreport.intervalMsec." + " Setting initial delay to 0 msec:");
219: Chris Nauroth, warn, IfStmt, DataNode.LOG.warn(String.format("%s must be set to a value greater than %s.  " + "Resetting value to 3 * %s, which is %d milliseconds.", DFS_DATANODE_LIFELINE_INTERVAL_SECONDS_KEY, DFS_HEARTBEAT_INTERVAL_KEY, DFS_HEARTBEAT_INTERVAL_KEY, confLifelineIntervalMs));
48: Kihwal Lee, Error, CatchClause, DataNode.LOG.info("trySendErrorReport encountered RemoteException  " + "errorMessage: " + errorMessage + "  errorCode: " + errorCode, re);
251: Arpit Agarwal, warn, IfStmt, LOG.warn("Failed to delete file {}", f);
160: Tsz-Wo Nicholas Sze, warn, CatchClause, LOG.warn(getClass().getSimpleName() + " interrupted");
207: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("call blockReceivedAndDeleted: " + Arrays.toString(reports));
205: Lei Xu, info, IfStmt, DataNode.LOG.info("detachFile failed to delete temporary file " + tmpFile);
239: Lei Xu, info, IfStmt, DataNode.LOG.info("Breaking hardlink for " + linkCount + "x-linked " + "block " + this);
373: Lei Xu, debug, IfStmt, LOG.debug("Renaming " + oldmeta + " to " + newmeta);
468: Lei Xu, info, MethodDeclaration, LOG.info("truncateBlock: blockFile=" + blockFile + ", metaFile=" + metaFile + ", oldlen=" + oldlen + ", newlen=" + newlen);
232: Lei Xu, warn, IfStmt, DataNode.LOG.warn(msg + "\n" + StringUtils.getStackTrace(thread));
252: Lei Xu, debug, IfStmt, DataNode.LOG.debug("writeTo blockfile is " + blockFile + " of size " + blockFile.length());
254: Lei Xu, debug, IfStmt, DataNode.LOG.debug("writeTo metafile is " + metaFile + " of size " + metaFile.length());
333: Lei Xu, warn, IfStmt, DataNode.LOG.warn("Failed to delete restart meta file: " + restartMeta.getPath());
399: Lei Xu, warn, CatchClause, LOG.warn("Cannot move meta file " + newmeta + "back to the finalized directory " + oldmeta, ex);
53: Arpit Agarwal, warn, IfStmt, LOG.warn(DFSConfigKeys.DFS_DATANODE_FILEIO_PROFILING_SAMPLING_PERCENTAGE_KEY + " value cannot be more than 100. Setting value to 100");
93: Virajith Jalaparti, warn, IfStmt, LOG.warn("Creating an reference to the remote FS for provided block " + this);
98: Virajith Jalaparti, warn, CatchClause, LOG.warn("Failed to obtain filesystem for " + fileURI);
135: Virajith Jalaparti, warn, IfStmt, LOG.warn("Creating an reference to the remote FS for provided block " + this);
140: Virajith Jalaparti, warn, CatchClause, LOG.warn("Failed to obtain filesystem for " + pathPrefix);
66: Kihwal Lee, info, CatchClause, DataNode.LOG.info("reportBadBlock encountered RemoteException for " + "block:  " + block, re);
117: Yiqun Lin, trace, IfStmt, LOG.trace("removing shm " + shm);
189: Colin McCabe, debug, IfStmt, LOG.debug("Disabling ShortCircuitRegistry", e);
184: Colin McCabe, debug, IfStmt, LOG.debug("created new ShortCircuitRegistry with interruptCheck=" + interruptCheck + ", shmPath=" + shmFactory.getPath());
252: Colin McCabe, info, IfStmt, LOG.info(bld.toString());
310: Colin McCabe, trace, IfStmt, LOG.trace("createNewMemorySegment: ShortCircuitRegistry is " + "not enabled.");
334: Colin McCabe, trace, IfStmt, LOG.trace("createNewMemorySegment: created " + info.shmId);
343: Colin McCabe, trace, IfStmt, LOG.trace(this + " can't register a slot because the " + "ShortCircuitRegistry is not enabled.");
363: Colin McCabe, trace, IfStmt, LOG.trace(this + ": registered " + blockId + " with slot " + slotId + " (isCached=" + isCached + ")");
372: Colin McCabe, trace, IfStmt, LOG.trace("unregisterSlot: ShortCircuitRegistry is " + "not enabled.");
216: Virajith Jalaparti, info, IfStmt, Storage.LOG.info("Skipping creating directory for block pool " + blockPoolID + " for PROVIDED storage location " + this);
229: Lei Xu, warn, CatchClause, DataStorage.LOG.warn("Invalid directory in: " + data.getCanonicalPath() + ": " + e.getMessage());
263: Colin Patrick Mccabe, trace, MethodDeclaration, LOG.trace("Starting VolumeScanner {}", scanner.volume);
271: Lei Xu, trace, IfStmt, LOG.trace("Successfully scanned {} on {}", block, volume);
276: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Volume {}: block {} is no longer in the dataset.", volume, block);
287: Colin Patrick Mccabe, info, IfStmt, LOG.info("Volume {}: verification failed for {} because of " + "FileNotFoundException.  This may be due to a race with write.", volume, block);
292: Lei Xu, warn, MethodDeclaration, LOG.warn("Reporting bad {} on {}", block, volume);
297: Yongjun Zhang, warn, CatchClause, LOG.warn("Cannot report bad block " + block, ie);
312: Colin Patrick Mccabe, error, CatchClause, LOG.error("unable to instantiate {}", conf.resultHandler, e);
324: Colin Patrick Mccabe, warn, CatchClause, LOG.warn("{}: error saving {}.", this, iter, e);
338: Colin Patrick Mccabe, trace, ForStmt, LOG.trace("{}: updateScannedBytes is zeroing out slotIdx {}.  " + "curMinute = {}; newMinute = {}", this, slotIdx, curMinute, newMinute);
366: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("{}: no block pools are registered.", this);
386: Colin Patrick Mccabe, info, IfStmt, LOG.info("Now scanning bpid {} on volume {}", iter.getBlockPoolId(), volume);
395: Colin Patrick Mccabe, info, IfStmt, LOG.info("Now rescanning bpid {} on volume {}, after more than " + "{} hour(s)", iter.getBlockPoolId(), volume, TimeUnit.HOURS.convert(conf.scanPeriodMs, TimeUnit.MILLISECONDS));
403: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("{}: no suitable block pools found to scan.  Waiting {} ms.", this, minTimeoutMs);
432: Colin Patrick Mccabe, info, CatchClause, LOG.info("FileNotFoundException while finding block {} on volume {}", cblock, volume);
435: Colin Patrick Mccabe, warn, CatchClause, LOG.warn("I/O error while finding block {} on volume {}", cblock, volume);
426: Kihwal Lee, info, IfStmt, LOG.info("Replica {} was not found in the VolumeMap for volume {}", cblock, volume);
441: Wei-Chiu Chuang, debug, MethodDeclaration, LOG.debug("start scanning block {}", block);
479: Colin Patrick Mccabe, trace, MethodDeclaration, LOG.trace("{}: calculateShouldScan: effectiveBytesPerSec = {}, and " + "targetBytesPerSec = {}.  startMinute = {}, curMinute = {}, " + "shouldScan = {}", storageId, effectiveBytesPerSec, targetBytesPerSec, startMinute, curMinute, shouldScan);
518: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("{}: no block pools are ready to scan yet.  Waiting " + "{} ms.", this, timeout);
544: Colin Patrick Mccabe, info, IfStmt, LOG.info("{}: finished scanning block pool {}", this, curBlockIter.getBlockPoolId());
553: yliu, debug, IfStmt, LOG.debug("{}: saving block iterator {} after {} ms.", this, curBlockIter, saveDelta);
612: Colin Patrick Mccabe, trace, TryStmt, LOG.trace("{}: thread starting.", this);
640: Colin Patrick Mccabe, error, CatchClause, LOG.error("{} exiting because of exception ", this, e);
625: Wei-Chiu Chuang, debug, IfStmt, LOG.debug("{}: wait for {} milliseconds", this, timeout);
642: Colin Patrick Mccabe, info, TryStmt, LOG.info("{} exiting.", this);
673: Yongjun Zhang, debug, IfStmt, LOG.debug("{}: Not scheduling suspect block {} for " + "rescanning, because this volume scanner is stopping.", this, block);
679: Yongjun Zhang, debug, IfStmt, LOG.debug("{}: Not scheduling suspect block {} for " + "rescanning, because we rescanned it recently.", this, block);
684: Yongjun Zhang, debug, IfStmt, LOG.debug("{}: suspect block {} is already queued for " + "rescanning.", this, block);
690: Yongjun Zhang, debug, MethodDeclaration, LOG.debug("{}: Scheduling suspect block {} for rescanning.", this, block);
702: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("{}: already enabled scanning on block pool {}", this, bpid);
712: Colin Patrick Mccabe, debug, CatchClause, LOG.debug("{}: failed to load block iterator: " + e.getMessage(), this);
714: Colin Patrick Mccabe, warn, CatchClause, LOG.warn("{}: failed to load block iterator.", this, e);
710: Colin Patrick Mccabe, trace, TryStmt, LOG.trace("{}: loaded block iterator for {}.", this, bpid);
718: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("{}: created new block iterator for {}.", this, bpid);
735: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("{}: disabling scanning on block pool {}", this, bpid);
745: Colin Patrick Mccabe, warn, MethodDeclaration, LOG.warn("{}: can't remove block pool {}, because it was never " + "added.", this, bpid);
153: Hanisha Koneru, SEVERE, CatchClause, log.log(Level.SEVERE, "SafeAtomicHelper is broken!", atomicReferenceFieldUpdaterFailure);
183: Xiaoyu Yao, trace, IfStmt, LOG.trace("Skipped checking all volumes, time since last check {} is less " + "than the minimum gap between checks ({} ms).", gap, minDiskCheckGapMs);
194: Xiaoyu Yao, warn, IfStmt, LOG.warn("checkAllVolumesAsync - no volumes can be referenced");
210: Arpit Agarwal, info, ForStmt, LOG.info("Scheduled health check for volume {}", reference.getVolume());
233: Arpit Agarwal, warn, IfStmt, LOG.warn("checkAllVolumes timed out after {} ms" + maxAllowedTimeForCheckMs);
277: Xiaoyu Yao, debug, IfStmt, LOG.debug("Cannot schedule check on null volume");
345: Arpit Agarwal, debug, SwitchStmt, LOG.debug("Volume {} is {}.", reference.getVolume(), result);
349: Arpit Agarwal, warn, SwitchStmt, LOG.warn("Volume {} detected as being unhealthy", reference.getVolume());
354: Arpit Agarwal, error, SwitchStmt, LOG.error("Unexpected health check result {} for volume {}", result, reference.getVolume());
366: Arpit Agarwal, warn, MethodDeclaration, LOG.warn("Exception running disk checks against volume " + reference.getVolume(), exception);
397: Arpit Agarwal, warn, CatchClause, LOG.warn("Unexpected exception", e);
412: Arpit Agarwal, warn, CatchClause, LOG.warn("DatasetVolumeChecker interrupted during shutdown.");
209: Arpit Agarwal, warn, CatchClause, LOG.warn("Exception checking StorageLocation " + location, e.getCause());
197: Arpit Agarwal, warn, SwitchStmt, LOG.warn("StorageLocation {} appears to be degraded.", location);
200: Arpit Agarwal, warn, SwitchStmt, LOG.warn("StorageLocation {} detected as failed.", location);
205: Arpit Agarwal, error, SwitchStmt, LOG.error("Unexpected health check result {} for StorageLocation {}", result, location);
237: Arpit Agarwal, warn, CatchClause, LOG.warn("StorageLocationChecker interrupted during shutdown.");
130: Arpit Agarwal, debug, IfStmt, LOG.debug("Skipped checking {}. Time since last check {}ms " + "is less than the min gap {}ms.", target, msSinceLastCheck, minMsBetweenChecks);
137: Hanisha Koneru, info, MethodDeclaration, LOG.info("Scheduling a check for {}", target);
75: Lei Xu, debug, MethodDeclaration, LOG.debug("Using striped reads");
95: Uma Maheswara Rao G, info, MethodDeclaration, LOG.info("Execution for striped reading rejected, " + "Executing in current thread");
106: Lei Xu, debug, MethodDeclaration, LOG.debug("Using striped block reconstruction; pool threads={}", numThreads);
150: Jing Zhao, warn, CatchClause, LOG.warn("Failed to reconstruct striped block {}", reconInfo.getExtendedBlock().getLocalBlock(), e);
145: Jing Zhao, warn, IfStmt, LOG.warn("No missing internal block. Skip reconstruction for task:{}", reconInfo);
133: Wei-Chiu Chuang, info, CatchClause, LOG.info("Exception while creating remote block reader, datanode {}", source, e);
175: Uma Maheswara Rao G, warn, CatchClause, LOG.warn("Found Checksum error for {} from {} at {}", block, source, e.getPos());
180: Uma Maheswara Rao G, info, CatchClause, LOG.info(e.getMessage());
67: Kai Zheng, warn, CatchClause, LOG.warn("Failed to reconstruct striped block: {}", getBlockGroup(), e);
335: Uma Maheswara Rao G, info, CatchClause, LOG.info("Read data interrupted.", e);
154: Uma Maheswara Rao G, warn, CatchClause, LOG.warn(e.getMessage());
171: Uma Maheswara Rao G, warn, CatchClause, LOG.warn(e.getMessage());
189: Uma Maheswara Rao G, warn, CatchClause, LOG.warn(e.getMessage());
85: Aaron Myers, info, MethodDeclaration, LOG.info("Available space volume choosing policy initialized: " + DFS_DATANODE_AVAILABLE_SPACE_VOLUME_CHOOSING_POLICY_BALANCED_SPACE_THRESHOLD_KEY + " = " + balancedSpaceThreshold + ", " + DFS_DATANODE_AVAILABLE_SPACE_VOLUME_CHOOSING_POLICY_BALANCED_SPACE_PREFERENCE_FRACTION_KEY + " = " + balancedPreferencePercent);
92: Aaron Myers, warn, IfStmt, LOG.warn("The value of " + DFS_DATANODE_AVAILABLE_SPACE_VOLUME_CHOOSING_POLICY_BALANCED_SPACE_PREFERENCE_FRACTION_KEY + " is greater than 1.0 but should be in the range 0.0 - 1.0");
97: Aaron Myers, warn, IfStmt, LOG.warn("The value of " + DFS_DATANODE_AVAILABLE_SPACE_VOLUME_CHOOSING_POLICY_BALANCED_SPACE_PREFERENCE_FRACTION_KEY + " is less than 0.5 so volumes with less available disk space will receive more block allocations");
179: Aaron Myers, debug, IfStmt, LOG.debug("Volumes are imbalanced. Selecting " + volume + " from low available space volumes for write of block size " + replicaSize);
171: Aaron Myers, debug, IfStmt, LOG.debug("Volumes are imbalanced. Selecting " + volume + " from high available space volumes for write of block size " + replicaSize);
143: Aaron Myers, debug, IfStmt, LOG.debug("All volumes are within the configured free space balance " + "threshold. Selecting " + volume + " for write of block size " + replicaSize);
60: Xiaoyu Yao, debug, IfStmt, LOG.debug("Could not get file descriptor for inputstream of class " + this.dataIn.getClass());
56: Xiaoyu Yao, warn, CatchClause, LOG.warn("Could not get file descriptor for inputstream of class " + this.dataIn.getClass());
70: Xiaoyu Yao, warn, CatchClause, LOG.warn("Could not get file descriptor for outputstream of class " + this.dataOut.getClass());
66: Xiaoyu Yao, debug, IfStmt, LOG.debug("Could not get file descriptor for outputstream of class " + this.dataOut.getClass());
250: Kihwal Lee, info, IfStmt, FsDatasetImpl.LOG.info("Cached dfsUsed found for " + currentDir + ": " + cachedDfsUsed);
266: Kihwal Lee, warn, IfStmt, FsDatasetImpl.LOG.warn("Failed to delete old dfsUsed file in " + outFile.getParent());
341: arp, info, MethodDeclaration, FsDatasetImpl.LOG.info("Moved " + blockFile + " to " + targetBlockFile);
343: arp, info, MethodDeclaration, FsDatasetImpl.LOG.info("Moved " + metaFile + " to " + targetMetaFile);
371: arp, info, IfStmt, FsDatasetImpl.LOG.info("Recovered " + numRecovered + " replicas from " + lazypersistDir);
431: arp, warn, CatchClause, LOG.warn("Failed to mkdirs " + targetDir);
439: arp, warn, CatchClause, LOG.warn("Failed to move meta file from " + metaFile + " to " + targetMetaFile, e);
448: arp, warn, CatchClause, LOG.warn("Failed to move block file from " + blockFile + " to " + targetBlockFile, e);
457: arp, warn, IfStmt, LOG.warn("Failed to move " + blockFile + " to " + targetDir);
507: Kihwal Lee, warn, IfStmt, FsDatasetImpl.LOG.warn("Failed to delete restart meta file: " + restartMeta.getPath());
661: arp, debug, IfStmt, LOG.debug("resolveDuplicateReplicas decide to keep " + replicaToKeep + ".  Will try to delete " + replicaToDelete);
670: Lei Xu, warn, IfStmt, LOG.warn("Failed to delete block file for replica " + replicaToDelete);
673: Lei Xu, warn, IfStmt, LOG.warn("Failed to delete meta file for replica " + replicaToDelete);
745: Akira Ajisaka, warn, CatchClause, FsDatasetImpl.LOG.warn("Getting exception while validating integrity " + "and setting length for blockFile", e);
777: Colin Patrick Mccabe, info, IfStmt, LOG.info("Replica Cache file: " + replicaFile.getPath() + " doesn't exist ");
783: Colin Patrick Mccabe, info, IfStmt, LOG.info("Replica Cache file: " + replicaFile.getPath() + " has gone stale");
787: Colin Patrick Mccabe, info, IfStmt, LOG.info("Replica Cache file: " + replicaFile.getPath() + " cannot be deleted");
841: Kihwal Lee, info, IfStmt, LOG.info("Failed to delete replica cache file: " + replicaFile.getPath());
826: Colin Patrick Mccabe, info, TryStmt, LOG.info("Successfully read replica from cache file : " + replicaFile.getPath());
192: Suresh Srinivas, info, IfStmt, LOG.info("Shutting down all async disk service threads");
200: Suresh Srinivas, info, IfStmt, LOG.info("All async disk service threads have been shut down");
190: Todd Lipcon, warn, IfStmt, LOG.warn("AsyncDiskService has already shut down.");
213: Michael Stack, warn, CatchClause, LOG.warn("sync_file_range error", e);
225: Suresh Srinivas, info, MethodDeclaration, LOG.info("Scheduling " + block.getLocalBlock() + " replica " + replicaToDelete + " for deletion");
238: Kihwal Lee, info, MethodDeclaration, LOG.info("Deleting " + block.getLocalBlock() + " replica " + replicaToDelete);
283: Lei Xu, error, IfStmt, LOG.error("Trash dir for replica " + replicaToDelete + " is null");
296: Lei Xu, debug, IfStmt, LOG.debug("Moving files " + replicaToDelete.getBlockURI() + " and " + replicaToDelete.getMetadataURI() + " to trash.");
309: Lei Xu, Error, CatchClause, LOG.error("Error moving files to trash: " + replicaToDelete, e);
333: Suresh Srinivas, info, IfStmt, LOG.info("Deleted " + block.getBlockPoolId() + " " + block.getLocalBlock() + " URI " + replicaToDelete.getBlockURI());
323: Arpit Agarwal, warn, IfStmt, LOG.warn("Unexpected error trying to " + (trashDirectory == null ? "delete" : "move") + " block " + block.getBlockPoolId() + " " + block.getLocalBlock() + " at file " + replicaToDelete.getBlockURI() + ". Ignored.");
300: Andrew Wang, debug, IfStmt, LOG.debug("Block with id {}, pool {} already exists in the " + "FsDatasetCache with state {}", blockId, bpid, prevValue.state);
309: Andrew Wang, debug, MethodDeclaration, LOG.debug("Initiating caching for Block with id {}, pool {}", blockId, bpid);
323: Andrew Wang, debug, IfStmt, LOG.debug("Block with id {}, pool {} does not need to be uncached, " + "because it is not currently in the mappableBlockMap.", blockId, bpid);
331: Andrew Wang, debug, SwitchStmt, LOG.debug("Cancelling caching for block with id {}, pool {}.", blockId, bpid);
349: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("{} has been scheduled for immediate uncaching.", key);
341: Andrew Wang, debug, IfStmt, LOG.debug("{} is anchored, and can't be uncached now.  Scheduling it " + "for uncaching in {} ", key, DurationFormatUtils.formatDurationHMS(revocationPollingMs));
354: Andrew Wang, debug, SwitchStmt, LOG.debug("Block with id {}, pool {} does not need to be uncached, " + "because it is in state {}.", blockId, bpid, prevValue.state);
499: Andrew Wang, debug, IfStmt, LOG.debug("Caching of {} was aborted.  We are now caching only {} " + "bytes in total.", key, usedBytesCount.get());
441: Colin McCabe, warn, IfStmt, LOG.warn("Failed to cache " + key + ": could not reserve " + length + " more bytes in the cache: " + DFSConfigKeys.DFS_DATANODE_MAX_LOCKED_MEMORY_KEY + " of " + maxBytes + " exceeded.");
452: Colin McCabe, warn, CatchClause, LOG.warn("Failed to cache " + key + ": Underlying blocks are not backed by files.", e);
456: Colin McCabe, info, CatchClause, LOG.info("Failed to cache " + key + ": failed to find backing " + "files.");
460: Colin McCabe, warn, CatchClause, LOG.warn("Failed to cache " + key + ": failed to open file", e);
468: Colin McCabe, warn, CatchClause, LOG.warn("Failed to cache " + key + ": checksum verification failed.");
471: Colin McCabe, warn, CatchClause, LOG.warn("Failed to cache " + key, e);
481: Colin McCabe, warn, IfStmt, LOG.warn("Caching of " + key + " was cancelled.");
486: Andrew Wang, debug, TryStmt, LOG.debug("Successfully cached {}.  We are now caching {} bytes in" + " total.", key, newUsedBytes);
538: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Uncaching {} now that it is no longer in use " + "by any clients.", key);
544: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("Forcibly uncaching {} after {} " + "because client(s) {} refused to stop using it.", key, DurationFormatUtils.formatDurationHMS(revocationTimeMs), dataset.datanode.getShortCircuitRegistry().getClientNames(key));
550: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Replica {} still can't be uncached because some " + "clients continue to use it.  Will wait for {}", key, DurationFormatUtils.formatDurationHMS(delta));
583: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Deferred uncaching of {} completed. usedBytes = {}", key, newUsedBytes);
580: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Uncaching of {} completed. usedBytes = {}", key, newUsedBytes);
138: Todd Lipcon, warn, IfStmt, LOG.warn("Data node cannot fully support concurrent reading" + " and writing without native code extensions on Windows.");
401: Arpit Agarwal, error, IfStmt, LOG.error(errorMsg);
432: Lei Xu, info, MethodDeclaration, LOG.info("Added volume - " + storageLocation + ", StorageType: " + storageLocation.getStorageType());
476: Colin Patrick Mccabe, warn, CatchClause, LOG.warn("Caught exception when adding " + fsVolume + ". Will throw later.", e);
495: Lei Xu, info, MethodDeclaration, LOG.info("Added volume - " + location + ", StorageType: " + storageType);
516: Lei Xu, info, ForStmt, LOG.info("Checking removing StorageLocation " + sdLocation + " with id " + sd.getStorageUuid());
519: Lei Xu, info, IfStmt, LOG.info("Removing StorageLocation " + sdLocation + " with id " + sd.getStorageUuid() + " from FsDataset.");
536: Haohui Mai, trace, ForStmt, LOG.trace("checking for block " + block.getBlockId() + " with storageLocation " + blockStorageLocation);
716: cnauroth, warn, CatchClause, LOG.warn("Exception thrown while metric collection. Exception : " + e.getMessage());
861: Lei Xu, debug, IfStmt, LOG.debug("addFinalizedBlock: Moved " + replicaInfo.getMetadataURI() + " to " + dstmeta + " and " + replicaInfo.getBlockURI() + " to " + dstfile);
910: Lei Xu, debug, IfStmt, LOG.debug("Copied " + srcReplica.getBlockURI() + " to " + dstFile);
907: Lei Xu, debug, IfStmt, LOG.debug("Copied " + srcReplica.getMetadataURI() + " meta to " + dstMeta + " and calculated checksum");
1163: Arpit Agarwal, info, TryStmt, LOG.info("Appending to " + replicaInfo);
1294: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Recover failed append to " + b);
1327: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Recover failed close " + b);
1416: Suresh Srinivas, info, MethodDeclaration, LOG.info("Recover RBW replica " + b);
1432: Yongjun Zhang, info, TryStmt, LOG.info("At " + datanode.getDisplayName() + ", Recovering " + rbw);
1469: Konstantin V Shvachko, info, IfStmt, LOG.info("Resetting bytesOnDisk to match blockDataLength (={}) for " + "replica {}", blockDataLength, rbw);
1510: Arpit Agarwal, info, TryStmt, LOG.info("Convert " + b + " from Temporary to RBW, visible length=" + visible);
1610: Colin Patrick Mccabe, warn, IfStmt, LOG.warn("Unable to stop existing writer for block " + b + " after " + writerStopMs + " miniseconds.");
1662: Tsz-wo Sze, debug, IfStmt, LOG.debug("Changing meta file offset of block " + b + " from " + oldPos + " to " + newPos);
1770: Arpit Agarwal, warn, IfStmt, LOG.warn("Block " + b + " unfinalized and removed. ");
1792: Lei Xu, warn, IfStmt, LOG.warn("Not able to delete the meta data for replica " + info);
1788: Lei Xu, warn, IfStmt, LOG.warn("Not able to delete the block data for replica " + info);
1828: Xiao Chen, warn, IfStmt, LOG.warn("Storage volume: " + volStorageID + " missing for the" + " replica block: " + b + ". Probably being removed!");
1969: Lei Xu, debug, IfStmt, LOG.debug("blockId=" + blockId + ", replica=" + r);
2040: Lei Xu, warn, CatchClause, LOG.warn("Parent directory check failed; replica " + info + " is not backed by a local file");
2046: Lei Xu, debug, IfStmt, LOG.debug("Block file " + removing.getBlockURI() + " is to be deleted");
2089: Colin Patrick Mccabe, warn, CatchClause, LOG.warn("Volume " + v + " is closed, ignore the deletion task for " + "block " + invalidBlks[i]);
2139: Colin McCabe, warn, IfStmt, LOG.warn("Failed to cache block with id " + blockId + ", pool " + bpid + ": ReplicaInfo not found.");
2144: Andrew Wang, warn, IfStmt, LOG.warn("Failed to cache block with id " + blockId + ", pool " + bpid + ": replica is not finalized; it is in state " + info.getState());
2157: Andrew Wang, warn, CatchClause, LOG.warn("Failed to cache block with id " + blockId + ": volume was not an instance of FsVolumeImpl.");
2152: Andrew Wang, warn, IfStmt, LOG.warn("Failed to cache block with id " + blockId + ", pool " + bpid + ": volume not found.");
2162: arp, warn, IfStmt, LOG.warn("Caching not supported on block with id " + blockId + " since the volume is backed by RAM.");
2243: Tsz-wo Sze, Error, CatchClause, LOG.warn("Error registering FSDatasetState MBean", e);
2245: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Registered FSDatasetState MBean");
2277: Arpit Agarwal, warn, CatchClause, LOG.warn("FsDatasetImpl.shutdown ignoring InterruptedException " + "from LazyWriter.join");
2353: Virajith Jalaparti, warn, IfStmt, LOG.warn("Deleting missing provided block " + memBlockInfo);
2349: Virajith Jalaparti, warn, IfStmt, LOG.warn("Added missing block to memory " + diskBlockInfo);
2363: Tsz-wo Sze, warn, IfStmt, LOG.warn("Deleted a metadata file without a block " + diskMetaFile.getAbsolutePath());
2375: Tsz-wo Sze, warn, IfStmt, LOG.warn("Removed block " + blockId + " from memory with missing block file on the disk");
2379: Tsz-wo Sze, warn, IfStmt, LOG.warn("Deleted a metadata file for the deleted block " + diskMetaFile.getAbsolutePath());
2405: Tsz-wo Sze, warn, IfStmt, LOG.warn("Added missing block to memory " + diskBlockInfo);
2447: Tsz-wo Sze, warn, IfStmt, LOG.warn("Updating generation stamp for block " + blockId + " from " + memBlockInfo.getGenerationStamp() + " to " + diskGS);
2431: Lei Xu, warn, IfStmt, LOG.warn("Failed to delete " + diskFile);
2481: Lei Xu, warn, CatchClause, LOG.warn("Block URI could not be resolved to a file", e);
2475: Lei Xu, warn, TryStmt, LOG.warn("Updating generation stamp for block " + blockId + " from " + memBlockInfo.getGenerationStamp() + " to " + gs);
2463: Jing Zhao, warn, IfStmt, LOG.warn(warningPrefix + diskMetaFile.getAbsolutePath());
2461: Jing Zhao, warn, IfStmt, LOG.warn(warningPrefix + "null");
2490: Tsz-wo Sze, warn, IfStmt, LOG.warn("Updating size of block " + blockId + " from " + memBlockInfo.getNumBytes() + " to " + memBlockInfo.getBlockDataLength());
2499: Tsz-wo Sze, warn, IfStmt, LOG.warn("Reporting the block " + corruptBlock + " as corrupt due to length mismatch");
2505: Brahma Reddy Battula, warn, CatchClause, LOG.warn("Failed to report bad block " + corruptBlock, e);
2553: Suresh Srinivas, info, MethodDeclaration, LOG.info("initReplicaRecovery: " + block + ", recoveryId=" + recoveryId + ", replica=" + replica);
2611: Tsz-wo Sze, info, IfStmt, LOG.info("initReplicaRecovery: changing replica state for " + block + " from " + replica.getState() + " to " + rur.getState());
2604: Tsz-wo Sze, info, IfStmt, LOG.info("initReplicaRecovery: update recovery id for " + block + " from " + oldRecoveryID + " to " + recoveryId);
2632: Arpit Agarwal, info, TryStmt, LOG.info("updateReplica: " + oldBlock + ", recoveryId=" + recoveryId + ", length=" + newlength + ", replica=" + replica);
2756: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Adding block pool " + bpid);
2767: Arpit Agarwal, info, TryStmt, LOG.info("Removing block pool " + bpid);
2810: Tsz-wo Sze, warn, CatchClause, LOG.warn(e.getMessage());
2846: Arpit Agarwal, warn, IfStmt, LOG.warn(bpid + " has some block files, cannot delete unless forced");
2934: cnauroth, debug, IfStmt, LOG.debug("LazyWriter: Finish persisting RamDisk block: " + " block pool Id: " + bpId + " block id: " + blockId + " to block file " + savedFiles[1] + " and meta file " + savedFiles[0] + " on target volume " + targetVolume);
2947: cnauroth, warn, IfStmt, LOG.warn("Failed to save replica " + block + ". re-enqueueing it.");
3088: arp, warn, CatchClause, LOG.warn("Exception saving replica " + block, ioe);
3091: arp, warn, IfStmt, LOG.warn("Failed to save replica " + block + ". re-enqueueing it.");
3073: cnauroth, debug, IfStmt, LOG.debug("LazyWriter: Start persisting RamDisk block:" + " block pool Id: " + block.getBlockPoolId() + " block id: " + block.getBlockId() + " on target volume " + targetVolume);
3116: arp, debug, IfStmt, LOG.debug("Evicting block " + replicaState);
3168: arp, info, CatchClause, LOG.info("LazyWriter was interrupted, exiting");
3171: arp, warn, CatchClause, LOG.warn("Ignoring exception in LazyWriter:", e);
3249: Arpit Agarwal, info, CatchClause, LOG.info("Ignoring exception ", ioe);
60: Virajith Jalaparti, error, CatchClause, FsVolumeImpl.LOG.error("Exception in creating null checksum stream: " + e);
136: Tsz-wo Sze, warn, MethodDeclaration, FsDatasetImpl.LOG.warn("Block " + blockFile + " does not have a metafile!");
220: Colin Patrick Mccabe, trace, MethodDeclaration, FsDatasetImpl.LOG.trace("Reference count: " + op + " " + this + ": " + this.reference.getReferenceCount());
222: Colin Patrick Mccabe, trace, MethodDeclaration, FsDatasetImpl.LOG.trace(Joiner.on("\n").join(Thread.currentThread().getStackTrace()));
248: Colin Patrick Mccabe, debug, IfStmt, FsDatasetImpl.LOG.debug("Decrease reference count <= 0 on " + this + Joiner.on("\n").join(Thread.currentThread().getStackTrace()));
315: Colin Patrick Mccabe, debug, IfStmt, FsDatasetImpl.LOG.debug(String.format("The reference count for %s is %d, wait to be 0.", this, reference.getReferenceCount()));
506: Lei Xu, error, CatchClause, LOG.error("Unable to get disk statistics for volume " + this);
683: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("getNextSubDir({}, {}): no subdirectories found in {}", storageID, bpid, dir.getAbsolutePath());
693: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("getNextSubDir({}, {}): picking next subdirectory {} " + "within {}", storageID, bpid, nextSubDir, dir.getAbsolutePath());
690: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("getNextSubDir({}, {}): no more subdirectories found in {}", storageID, bpid, dir.getAbsolutePath());
725: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("getSubdirEntries({}, {}): purging entries cache for {} " + "after {} ms.", storageID, bpid, state.curFinalizedSubDir, delta);
743: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("getSubdirEntries({}, {}): listed {} entries in {}", storageID, bpid, entries.size(), dir.getAbsolutePath());
740: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("getSubdirEntries({}, {}): no entries found in {}", storageID, bpid, dir.getAbsolutePath());
826: Colin Patrick Mccabe, error, CatchClause, LOG.error("nextBlock({}, {}): I/O error", storageID, bpid, e);
796: Kihwal Lee, error, IfStmt, LOG.error("nextBlock({}, {}): block id {} found in invalid " + "directory.  Expected directory: {}.  " + "Actual directory: {}", storageID, bpid, block.getBlockId(), expectedBlockDir.getPath(), actualBlockDir.getPath());
810: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("nextBlock({}, {}): advancing to {}", storageID, bpid, block);
786: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("nextBlock({}, {}): advancing from {} to next " + "subdirectory.", storageID, bpid, state.curFinalizedSubDir);
867: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("save({}, {}): saved {}", storageID, bpid, WRITER.writeValueAsString(state));
875: Colin Patrick Mccabe, trace, MethodDeclaration, LOG.trace("load({}, {}): loaded iterator {} from {}: {}", storageID, bpid, name, file.getAbsoluteFile(), WRITER.writeValueAsString(state));
1344: Chris Douglas, warn, CatchClause, LOG.warn("Exception occurred while compiling report: ", ioe);
1425: Lei Xu, warn, IfStmt, LOG.warn("Block: " + blockId + " found in invalid directory.  Expected directory: " + expectedBlockDir + ".  Actual directory: " + actualBlockDir);
1460: Lei Xu, warn, IfStmt, FsDatasetImpl.LOG.warn("LazyWriter failed to create " + lazyPersistDir);
92: Colin Patrick Mccabe, warn, CatchClause, FsDatasetImpl.LOG.warn("Chosen a closed volume: " + volume);
206: Colin Patrick Mccabe, info, CatchClause, FsDatasetImpl.LOG.info("The volume " + v + " is closed while " + "adding replicas, ignored.");
209: Kihwal Lee, info, CatchClause, FsDatasetImpl.LOG.info("Caught exception while adding replicas " + "from " + v + ". Will throw later.", ioe);
198: Kihwal Lee, info, TryStmt, FsDatasetImpl.LOG.info("Adding replicas to map for block pool " + bpid + " on volume " + v + "...");
203: Kihwal Lee, info, TryStmt, FsDatasetImpl.LOG.info("Time to add replicas to map for block pool" + " " + bpid + " on volume " + v + ": " + timeTaken + "ms");
229: Aaron Myers, info, MethodDeclaration, FsDatasetImpl.LOG.info("Total time to add all replicas to map: " + totalTimeTaken + "ms");
249: Colin Patrick Mccabe, debug, CatchClause, FsDatasetImpl.LOG.debug("Caught exception when obtaining " + "reference count on closed volume", e);
252: Colin Patrick Mccabe, error, CatchClause, FsDatasetImpl.LOG.error("Unexpected IOException", e);
269: Lei Xu, debug, IfStmt, FsDatasetImpl.LOG.debug("Waiting for volume reference to be released.");
274: Lei Xu, info, CatchClause, FsDatasetImpl.LOG.info("Thread interrupted when waiting for " + "volume reference to be released.");
279: Lei Xu, info, MethodDeclaration, FsDatasetImpl.LOG.info("Volume reference is released.");
305: Colin Patrick Mccabe, info, MethodDeclaration, FsDatasetImpl.LOG.info("Added new volume: " + volume.getStorageID());
329: Lei Xu, debug, IfStmt, FsDatasetImpl.LOG.debug("Volume " + target + " does not exist or is removed by others.");
321: Lei Xu, Error, CatchClause, FsDatasetImpl.LOG.warn("Error occurs when waiting volume to close: " + target, e);
326: Lei Xu, info, IfStmt, FsDatasetImpl.LOG.info("Removed volume: " + target);
418: Aaron Myers, info, CatchClause, FsDatasetImpl.LOG.info("Caught exception while scanning " + v + ". Will throw later.", ioe);
408: Aaron Myers, info, TryStmt, FsDatasetImpl.LOG.info("Scanning block pool " + bpid + " on volume " + v + "...");
413: Aaron Myers, info, TryStmt, FsDatasetImpl.LOG.info("Time taken to scan block pool " + bpid + " on " + v + ": " + timeTaken + "ms");
439: Aaron Myers, info, MethodDeclaration, FsDatasetImpl.LOG.info("Total time to scan all replicas for block pool " + bpid + ": " + totalTimeTaken + "ms");
90: Virajith Jalaparti, debug, IfStmt, LOG.debug("Path {} is not a prefix of the path {}", prefix, fullPath);
148: Virajith Jalaparti, info, ConstructorDeclaration, LOG.info("Created alias map using class: " + aliasMap.getClass());
176: Virajith Jalaparti, error, IfStmt, LOG.error("Got null reader from BlockAliasMap " + aliasMap + "; no blocks will be populated");
211: Virajith Jalaparti, warn, IfStmt, LOG.warn("A block with id " + newReplica.getBlockId() + " exists locally. Skipping PROVIDED replica");
293: Virajith Jalaparti, warn, CatchClause, LOG.warn("Exception when trying to get capacity of ProvidedVolume: {}", e);
321: Virajith Jalaparti, warn, IfStmt, LOG.warn("Volume {} has less than 0 available space", this);
458: Virajith Jalaparti, warn, CatchClause, LOG.warn("Exception in getting reader from provided alias map");
498: Virajith Jalaparti, trace, MethodDeclaration, LOG.trace("load({}, {}): loaded iterator {}: {}", getStorageID(), bpid, name, WRITER.writeValueAsString(state));
535: Virajith Jalaparti, info, MethodDeclaration, LOG.info("Creating volumemap for provided volume " + this);
576: Virajith Jalaparti, info, MethodDeclaration, LOG.info("Adding block pool " + bpid + " to volume with id " + getStorageID());
617: Virajith Jalaparti, info, MethodDeclaration, LOG.info("Compiling report for volume: " + this + " bpid " + bpid);
176: cnauroth, info, IfStmt, LOG.info("Shutting down all async lazy persist service threads");
183: cnauroth, info, IfStmt, LOG.info("All async lazy persist service threads have been shut down");
174: cnauroth, warn, IfStmt, LOG.warn("AsyncLazyPersistService has already shut down.");
194: cnauroth, debug, IfStmt, LOG.debug("LazyWriter schedule async task to persist RamDisk block pool id: " + bpId + " block id: " + blockId);
251: cnauroth, warn, CatchClause, FsDatasetImpl.LOG.warn("LazyWriter failed to async persist RamDisk block pool id: " + bpId + "block Id: " + blockId, e);
143: arp, warn, IfStmt, LOG.warn("Failed to delete block file " + savedBlockFile);
150: arp, warn, IfStmt, LOG.warn("Failed to delete meta file " + savedMetaFile);
97: Arpit Agarwal, Error, CatchClause, LOG.error("Error in releasing FS Volume references", e);
103: Arpit Agarwal, debug, IfStmt, LOG.debug("No disk stats available for detecting outliers.");
113: Arpit Agarwal, error, CatchClause, LOG.error("Disk Outlier Detection thread interrupted", e);
148: Arpit Agarwal, debug, MethodDeclaration, LOG.debug("Updated disk outliers.");
169: Arpit Agarwal, error, CatchClause, LOG.error("Disk Outlier Detection daemon did not shutdown", e);
126: Arpit Agarwal, trace, MethodDeclaration, LOG.trace("DataNodePeerMetrics: Got stats: {}", stats);
111: Arpit Agarwal, debug, IfStmt, LOG.debug("Skipping statistical outlier detection as we don't have " + "latency data for enough resources. Have {}, need at least {}", stats.size(), minNumResources);
128: Arpit Agarwal, trace, MethodDeclaration, LOG.trace("getOutliers: List={}, MedianLatency={}, " + "MedianAbsoluteDeviation={}, upperLimitLatency={}", sorted, median, mad, upperLimitLatency);
243: Haohui Mai, info, IfStmt, LOG.info("Listening HTTP traffic on " + httpAddress);
264: Haohui Mai, info, IfStmt, LOG.info("Listening HTTPS traffic on " + httpsAddress);
77: cnauroth, error, MethodDeclaration, LOG.error("Exception in " + this.getClass().getSimpleName(), cause);
84: Haohui Mai, debug, IfStmt, LOG.debug("Proxy failed. Cause: ", future.cause());
93: Haohui Mai, debug, MethodDeclaration, LOG.debug("Proxy for " + uri + " failed. cause: ", cause);
129: Haohui Mai, info, IfStmt, LOG.info("Proxy " + uri + " failed. Cause: ", future.cause());
148: Xiaoyu Yao, debug, IfStmt, LOG.debug("Proxy for " + uri + " failed. cause: ", cause);
52: Tsuyoshi Ozawa, trace, IfStmt, LOG.trace("GOT EXCEPTION", e);
82: Haohui Mai, ERROR, IfStmt, LOG.warn("INTERNAL_SERVER_ERROR", e);
80: Xiao Chen, debug, IfStmt, LOG.debug("Exception in channel handler ", cause);
145: Sangjin Lee, Error, CatchClause, LOG.warn("Error retrieving hostname: ", e);
148: Andrew Wang, info, TryStmt, REQLOG.info(host + " " + req.getMethod() + " " + req.getUri() + " " + getResponseCode());
187: Haohui Mai, Error, MethodDeclaration, LOG.debug("Error ", cause);
60: Anu Engineer, info, MethodDeclaration, LOG.info("Executing \"Cancel plan\" command.");
101: Anu Engineer, error, CatchClause, LOG.error("Cancelling plan on  {} failed. Result: {}, Message: {}", plan.getNodeName(), ex.getResult().toString(), ex.getMessage());
122: Anu Engineer, error, CatchClause, LOG.error("Cancelling plan on  {} failed. Result: {}, Message: {}", nodeAddress, ex.getResult().toString(), ex.getMessage());
160: Anu Engineer, debug, MethodDeclaration, LOG.debug("using name node URI : {}", this.getClusterURI());
166: Anu Engineer, debug, MethodDeclaration, LOG.debug("Reading cluster info");
196: Anu Engineer, debug, IfStmt, LOG.debug("Another Diskbalancer instance is running ? - Target " + "Directory already exists. {}", diskBalancerLogs);
369: Anu Engineer, error, IfStmt, LOG.error(errMessage + validArguments.toString());
496: Anu Engineer, info, MethodDeclaration, LOG.info(outputLine);
523: Anu Engineer, info, CatchClause, LOG.info(outputLine);
513: Anu Engineer, info, IfStmt, LOG.info(outputLine);
62: Anu Engineer, info, MethodDeclaration, LOG.info("Executing \"execute plan\" command");
78: Arpit Agarwal, warn, IfStmt, LOG.warn("Skipping date check on this plan. This could mean we are " + "executing an old plan and may not be the right plan for this " + "data node.");
107: Anu Engineer, error, CatchClause, LOG.error("Submitting plan on  {} failed. Result: {}, Message: {}", plan.getNodeName(), ex.getResult().toString(), ex.getMessage());
50: Anu Engineer, debug, MethodDeclaration, LOG.debug("Processing help Command.");
94: Anu Engineer, debug, MethodDeclaration, LOG.debug("Processing Plan Command.");
137: Anu Engineer, debug, MethodDeclaration, LOG.debug("threshold Percentage is {}", this.thresholdPercentage);
178: Anu Engineer, error, CatchClause, LOG.error(errMsg, e);
262: Anu Engineer, debug, IfStmt, LOG.debug("Setting bandwidth to {}", this.bandwidth);
266: Anu Engineer, debug, IfStmt, LOG.debug("Setting max error to {}", this.maxError);
58: Arpit Agarwal, info, MethodDeclaration, LOG.info("Executing \"query plan\" command.");
72: Anu Engineer, debug, IfStmt, LOG.debug("Using default data node port :  {}", nodeAddress);
87: Arpit Agarwal, error, CatchClause, LOG.error("Query plan failed. ex: {}", ex);
41: Anu Engineer, debug, MethodDeclaration, LOG.debug("Cluster URI : {}", clusterURI);
42: Anu Engineer, debug, MethodDeclaration, LOG.debug("scheme : {}", clusterURI.getScheme());
47: Anu Engineer, debug, IfStmt, LOG.debug("Creating NameNode connector");
44: Anu Engineer, debug, IfStmt, LOG.debug("Creating a JsonNodeConnector");
68: Tsz-Wo Nicholas Sze, error, CatchClause, LOG.error("Unable to connect to NameNode " + ex.toString());
62: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("Reading cluster info from file : " + dataFilePath);
66: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info(message);
136: Anu Engineer, debug, MethodDeclaration, LOG.debug("Using connector : {}", clusterConnector.getConnectorInfo());
307: Arpit Agarwal, warn, IfStmt, LOG.warn("Nodes to process is null. No nodes processed.");
333: Arpit Agarwal, error, CatchClause, LOG.error("Compute Node plan was cancelled or interrupted : ", e);
335: Arpit Agarwal, error, CatchClause, LOG.error("Unable to compute plan : ", e);
189: Anu Engineer, error, MethodDeclaration, LOG.error(errMessage);
70: Arpit Agarwal, info, MethodDeclaration, LOG.info("Starting plan for Node : {}:{}", node.getDataNodeName(), node.getDataNodePort());
83: Arpit Agarwal, info, MethodDeclaration, LOG.info(message);
114: Anu Engineer, debug, IfStmt, LOG.debug("Skipping compute move. lowVolume: {} highVolume: {}", lowVolume.getPath(), highVolume.getPath());
120: Anu Engineer, debug, IfStmt, LOG.debug("Step : {} ", nextStep.toString());
134: Arpit Agarwal, info, MethodDeclaration, LOG.info(message);
186: Anu Engineer, debug, IfStmt, LOG.debug("{} Skipping disk from computation. Maximum data size " + "achieved.", lowVolume.getPath());
197: Anu Engineer, debug, IfStmt, LOG.debug(" {} Skipping disk from computation. Minimum data size " + "achieved.", highVolume.getPath());
210: Arpit Agarwal, debug, IfStmt, LOG.debug(nextStep.toString());
233: Anu Engineer, debug, IfStmt, LOG.debug(message);
266: Anu Engineer, debug, IfStmt, LOG.debug(format);
48: Arpit Agarwal, debug, IfStmt, LOG.debug(message);
183: Andrew Wang, error, CatchClause, LOG.error(e + ".  Exiting ...");
255: Jing Zhao, warn, CatchClause, LOG.warn("Failed to get snapshottable directories." + " Ignore and continue.", e);
305: Tsz-Wo Nicholas Sze, error, IfStmt, LOG.error("Failed to move some block's after " + retryMaxAttempts + " retries.");
329: Jing Zhao, warn, CatchClause, LOG.warn("Failed to list directory " + fullPath + ". Ignore the directory and continue.", e);
370: Jing Zhao, warn, CatchClause, LOG.warn("Failed to check the status of " + parent + ". Ignore it and continue.", e);
385: Chris Nauroth, warn, CatchClause, LOG.warn("Failed to get default policy for " + fullPath, e);
391: Jing Zhao, warn, IfStmt, LOG.warn("Failed to get the storage policy of file " + fullPath);
617: Zhe Zhang, info, IfStmt, LOG.info("Keytab is configured, will login using keytab.");
642: Jing Zhao, info, MethodDeclaration, LOG.info("namenodes = " + namenodes);
880: Jing Zhao, error, CatchClause, LOG.error("Exiting " + Mover.class.getSimpleName() + " due to an exception", e);
131: Todd Lipcon, info, SwitchStmt, LOG.info("Storage directory " + sd.getRoot() + " is not formatted.");
132: Todd Lipcon, info, SwitchStmt, LOG.info("Formatting ...");
165: Todd Lipcon, trace, IfStmt, LOG.trace("Got journal, " + "state = " + bnState + "; firstTxId = " + firstTxId + "; numTxns = " + numTxns);
203: Tsuyoshi Ozawa, trace, IfStmt, LOG.trace("data:" + StringUtils.byteToHexString(data));
253: Todd Lipcon, info, WhileStmt, LOG.info("Loading edits into backupnode to try to catch up from txid " + lastAppliedTxId + " to " + target);
276: Todd Lipcon, debug, IfStmt, LOG.debug("Logs rolled while catching up to current segment");
293: Jitendra Nath Pandey, warn, IfStmt, LOG.warn("Unable to find stream starting with " + editLog.getCurSegmentTxId() + ". This indicates that there is an error in synchronization in BackupImage");
301: Todd Lipcon, info, TryStmt, LOG.info("Going to finish converging with remaining " + remainingTxns + " txns from in-progress stream " + stream);
313: Todd Lipcon, info, SynchronizedStmt, LOG.info("Successfully synced BackupNode with NameNode at txnid " + lastAppliedTxId);
325: Suresh Srinivas, debug, IfStmt, LOG.debug("State transition " + bnState + " -> " + newState);
344: Todd Lipcon, info, IfStmt, LOG.info("Stopped applying edits to prepare for checkpoint.");
368: Todd Lipcon, info, MethodDeclaration, LOG.info("Waiting until the NameNode rolls its edit logs in order " + "to freeze the BackupNode namespace.");
377: Todd Lipcon, warn, CatchClause, LOG.warn("Interrupted waiting for namespace to freeze", ie);
381: Todd Lipcon, info, MethodDeclaration, LOG.info("BackupNode namespace frozen.");
208: Todd Lipcon, error, CatchClause, LOG.error("Failed to report to name-node.", e);
262: Suresh Srinivas, error, IfStmt, LOG.warn(errorMsg);
268: Suresh Srinivas, error, IfStmt, LOG.warn(errorMsg);
299: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Fenced by " + fencerInfo + " with epoch " + epoch);
335: Todd Lipcon, info, CatchClause, LOG.info("Problem connecting to server: " + nnAddress);
339: Suresh Srinivas, warn, CatchClause, LOG.warn("Encountered exception ", e);
387: Todd Lipcon, info, CatchClause, LOG.info("Problem connecting to name-node: " + nnRpcAddress);
391: Suresh Srinivas, warn, CatchClause, LOG.warn("Encountered exception ", e);
404: Todd Lipcon, error, IfStmt, LOG.error(msg);
421: Andrew Wang, error, IfStmt, LOG.error(errorMsg);
210: Andrew Wang, info, IfStmt, LOG.info("Using minimum value {} for {}", MIN_CACHED_BLOCKS_PERCENT, DFS_NAMENODE_PATH_BASED_CACHE_BLOCK_MAP_ALLOCATION_PERCENT);
351: Andrew Wang, trace, MethodDeclaration, LOG.trace("Validating directive {} pool maxRelativeExpiryTime {}", info, maxRelativeExpiryTime);
539: Colin McCabe, warn, CatchClause, LOG.warn("addDirective of " + info + " failed: ", e);
542: Andrew Wang, info, MethodDeclaration, LOG.info("addDirective of {} successful.", info);
641: Colin McCabe, warn, CatchClause, LOG.warn("modifyDirective of " + idString + " failed: ", e);
644: Andrew Wang, info, MethodDeclaration, LOG.info("modifyDirective of {} successfully applied {}.", idString, info);
680: Colin McCabe, warn, CatchClause, LOG.warn("removeDirective of " + id + " failed: ", e);
683: Colin McCabe, info, MethodDeclaration, LOG.info("removeDirective of " + id + " successful.");
778: Colin McCabe, info, CatchClause, LOG.info("addCachePool of " + info + " failed: ", e);
781: Andrew Wang, info, MethodDeclaration, LOG.info("addCachePool of {} successful.", info);
848: Colin McCabe, info, CatchClause, LOG.info("modifyCachePool of " + info + " failed: ", e);
851: Andrew Wang, info, MethodDeclaration, LOG.info("modifyCachePool of {} successful; {}", info.getPoolName(), bld.toString());
883: Colin McCabe, info, CatchClause, LOG.info("removeCachePool of " + poolName + " failed: ", e);
886: Colin McCabe, info, MethodDeclaration, LOG.info("removeCachePool of " + poolName + " successful.");
939: Andrew Wang, warn, IfStmt, LOG.warn("Datanode {} is not a valid cache location for block {} " + "because that node does not have a backing replica!", datanode, block.getBlock().getBlockName());
970: Andrew Wang, debug, MethodDeclaration, LOG.debug("Processed cache report from {}, blocks: {}, " + "processing time: {} msecs", datanodeID, blockIds.size(), (endTime - startTime));
983: Andrew Wang, trace, ForStmt, LOG.trace("Cache report from datanode {} has block {}", datanode, blockId);
994: Andrew Wang, trace, IfStmt, LOG.trace("Added block {}  to cachedBlocks", cachedBlock);
1001: Andrew Wang, trace, IfStmt, LOG.trace("Added block {} to CACHED list.", cachedBlock);
1005: Andrew Wang, trace, IfStmt, LOG.trace("Removed block {} from PENDING_CACHED list.", cachedBlock);
78: Todd Lipcon, warn, IfStmt, LOG.warn("Configuration key " + key + " is deprecated! Ignoring..." + " Instead please specify a value for " + DFS_NAMENODE_CHECKPOINT_TXNS_KEY);
87: Todd Lipcon, warn, CatchClause, LOG.warn("Checkpointer got exception", e);
108: Todd Lipcon, info, MethodDeclaration, LOG.info("Checkpoint Period : " + checkpointConf.getPeriod() + " secs " + "(" + checkpointConf.getPeriod() / 60 + " min)");
111: Todd Lipcon, info, MethodDeclaration, LOG.info("Transactions count is  : " + checkpointConf.getTxnCount() + ", to trigger checkpoint");
156: Todd Lipcon, error, CatchClause, LOG.error("Exception in doCheckpoint: ", e);
158: Todd Lipcon, error, CatchClause, LOG.error("Throwable Exception in doCheckpoint: ", e);
211: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Doing checkpoint. Last applied: " + lastApplied);
221: Todd Lipcon, info, IfStmt, LOG.info("Unable to roll forward using only logs. Downloading " + "image with txid " + sig.mostRecentCheckpointTxId);
243: Konstantin Shvachko, info, IfStmt, LOG.info("Loading image with txid " + sig.mostRecentCheckpointTxId);
283: Todd Lipcon, info, MethodDeclaration, LOG.info("Checkpoint completed in " + (monotonicNow() - startTime) / 1000 + " seconds." + " New Image Size: " + imageSize);
314: Todd Lipcon, info, MethodDeclaration, LOG.info("Checkpointer about to load edits from " + editsStreams.size() + " stream(s).");
196: Lei Xu, warn, CatchClause, LOG.warn("Encountered error getting ec policy for " + inode.getFullPathName(), ioe);
143: Arpit Agarwal, error, IfStmt, NameNode.LOG.error("BUG: Inconsistent storagespace for directory " + dir.getFullPathName() + ". Cached = " + usage.getStorageSpace() + " != Computed = " + computed);
68: Todd Lipcon, Error, CatchClause, Storage.LOG.error("Error connecting to: " + bnAddress, e);
124: Konstantin Shvachko, info, IfStmt, LOG.info("Nothing to flush");
192: Todd Lipcon, error, CatchClause, LOG.error("caught exception initializing " + this, e);
223: Harsh J, debug, IfStmt, LOG.debug("skipping " + skipAmt + " bytes at the end " + "of edit log  '" + getName() + "': reached txid " + txId + " out of " + lastTxId);
256: Todd Lipcon, error, CatchClause, LOG.error("nextValidOp: got exception while reading " + this, e);
321: Jing Zhao, warn, CatchClause, LOG.warn("Log file " + file + " has no valid header", e);
200: Jitendra Nath Pandey, info, IfStmt, LOG.info("Nothing to flush");
237: Haohui Mai, debug, IfStmt, LOG.debug("Preallocated " + total + " bytes at the end of " + "the edit log (offset " + oldSize + ")");
179: Wei-Chiu Chuang, warn, MethodDeclaration, LOG.warn("The edits buffer is " + size() + " bytes long with " + numTxns + " unflushed transactions. " + "Below is the list of unflushed transactions:");
190: Wei-Chiu Chuang, warn, CatchClause, LOG.warn("Unable to dump remaining ops. Remaining raw bytes: " + Hex.encodeHexString(remainingRawEdits), ioe);
185: Wei-Chiu Chuang, warn, WhileStmt, LOG.warn("Unflushed op [" + numTransactions + "]: " + op);
664: Xiao Chen, info, MethodDeclaration, LOG.info("Zone {}({}) is submitted for re-encryption.", zoneName, inode.getId());
689: Xiao Chen, info, MethodDeclaration, LOG.info("Cancelled zone {}({}) for re-encryption.", zoneName, zoneId);
275: Kai Zheng, info, IfStmt, LOG.info("The policy name " + assignedNewName + " already exists");
280: Kai Zheng, info, IfStmt, LOG.info("A policy with same schema " + policy.getSchema().toString() + " and cell size " + p.getCellSize() + " already exists");
336: Rakesh Radhakrishnan, info, MethodDeclaration, LOG.info("Remove erasure coding policy " + name);
372: Rakesh Radhakrishnan, info, MethodDeclaration, LOG.info("Disable the erasure coding policy " + name);
390: Rakesh Radhakrishnan, info, MethodDeclaration, LOG.info("Enable the erasure coding policy " + name);
128: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to start log segment " + txid + " at " + currentInProgress + ": " + e.getLocalizedMessage());
143: Todd Lipcon, info, MethodDeclaration, LOG.info("Finalizing edits file " + inprogressFile + " -> " + dstFile);
183: Todd Lipcon, info, MethodDeclaration, LOG.info("Purging logs older than " + minTxIdToKeep);
216: Andrew Wang, error, CatchClause, LOG.error("got IOException while trying to validate header of " + elf + ".  Skipping.", e);
245: Jing Zhao, info, MethodDeclaration, LOG.info("Discard the EditLog files, the given start txid is " + startTxId);
259: Jing Zhao, info, ForeachStmt, LOG.info("Trash the EditLog file " + elf);
295: Todd Lipcon, error, CatchClause, LOG.error("Edits file " + f + " has improperly formatted " + "transaction ID");
310: Todd Lipcon, error, CatchClause, LOG.error("In-progress edits file " + f + " has improperly " + "formatted transaction ID");
326: Vinayakumar B, error, CatchClause, LOG.error("In-progress stale edits file " + f + " has improperly " + "formatted transaction ID");
349: Andrew Wang, debug, IfStmt, LOG.debug(this + ": selecting input streams starting at " + fromTxId + (inProgressOk ? " (inProgress ok) " : " (excluding inProgress) ") + "from among " + elfs.size() + " candidate file(s)");
364: Andrew Wang, debug, IfStmt, LOG.debug("passing over " + elf + " because it is in progress " + "and we are ignoring in-progress logs.");
372: Todd Lipcon, error, CatchClause, LOG.error("got IOException while trying to validate header of " + elf + ".  Skipping.", e);
380: Andrew Wang, debug, IfStmt, LOG.debug("passing over " + elf + " because it ends at " + elf.lastTxId + ", but we only care about transactions " + "as new as " + fromTxId);
388: Todd Lipcon, debug, ForeachStmt, LOG.debug("selecting edit log stream " + elf);
396: Todd Lipcon, info, MethodDeclaration, LOG.info("Recovering unfinalized segments in " + currentDir);
407: Todd Lipcon, info, IfStmt, LOG.info("Deleting zero-length edit log file " + elf);
628: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting upgrade of edits directory " + sd.getRoot());
632: Todd Lipcon, error, CatchClause, LOG.error("Failed to move aside pre-upgrade storage " + "in image directory " + sd.getRoot(), ioe);
144: Haohui Mai, warn, CatchClause, NameNode.stateChangeLog.warn("DIR* NameSystem.append: " + ie.getMessage());
154: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.appendFile: file {} for {} at {} block {} block" + " size {}", srcArg, holder, clientMachine, lb.getBlock(), lb.getBlock().getNumBytes());
411: Wei Yan, info, IfStmt, FSDirectory.LOG.info("Replication remains unchanged at {} for {}", oldBR, iip.getPath());
408: Haohui Mai, info, IfStmt, FSDirectory.LOG.info("Increasing replication from {} to {} for {}", oldBR, targetReplication, iip.getPath());
405: Haohui Mai, info, IfStmt, FSDirectory.LOG.info("Decreasing replication from {} to {} for {}", oldBR, targetReplication, iip.getPath());
56: Jing Zhao, debug, IfStmt, FSDirectory.LOG.debug("concat {} to {}", Arrays.toString(srcs), target);
70: Jing Zhao, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.concat: " + Arrays.toString(srcs) + " to " + target);
237: Jing Zhao, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSNamesystem.concat to " + targetIIP.getPath());
55: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSDirectory.delete: " + iip.getPath());
180: Kihwal Lee, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.delete: " + iip.getPath());
201: Kihwal Lee, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* Namesystem.delete: " + iip.getPath() + " is removed");
220: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedDelete: failed to remove " + iip.getPath() + " because the root is not allowed to be deleted");
214: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSDirectory.unprotectedDelete: failed to remove " + iip.getPath() + " because it does not exist");
269: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSDirectory.unprotectedDelete: " + iip.getPath() + " is removed");
283: cnauroth, info, ConstructorDeclaration, LOG.info("ACLs enabled? " + aclsEnabled);
287: Chris Nauroth, info, ConstructorDeclaration, LOG.info("POSIX ACL inheritance enabled? " + posixAclInheritanceEnabled);
291: Haohui Mai, info, ConstructorDeclaration, LOG.info("XAttrs enabled? " + xattrsEnabled);
355: Akira Ajisaka, info, ConstructorDeclaration, NameNode.LOG.info("Caching file names occurring more than " + threshold + " times");
379: Yongjun Zhang, info, IfStmt, LOG.info("Add user " + tmp + " to the list that will bypass external" + " attribute provider.");
767: Kihwal Lee, info, TryStmt, LOG.info("Initializing quota with " + threads + " thread(s)");
776: Akira Ajisaka, info, TryStmt, LOG.info("Quota initialization completed in " + (Time.monotonicNow() - start) + " milliseconds\n" + counts);
837: Kihwal Lee, warn, IfStmt, LOG.warn("Namespace quota violation in image for " + dir.getFullPathName() + " quota = " + nsQuota + " < consumed = " + nsConsumed);
845: Kihwal Lee, warn, IfStmt, LOG.warn("Storagespace quota violation in image for " + dir.getFullPathName() + " quota = " + ssQuota + " < consumed = " + ssConsumed);
855: Kihwal Lee, warn, IfStmt, LOG.warn("Storage type quota violation in image for " + dir.getFullPathName() + " type = " + t.toString() + " quota = " + typeQuota + " < consumed " + typeSpace);
862: Kihwal Lee, debug, IfStmt, LOG.debug("Setting quota for " + dir + "\n" + myCounts);
994: Tsz-wo Sze, error, CatchClause, NameNode.LOG.error("BUG: unexpected exception ", e);
1053: Konstantin V Shvachko, warn, CatchClause, LOG.warn("Unexpected exception while updating disk space.", e);
1189: Tsz-wo Sze, ERROR, IfStmt, NameNode.LOG.error("ERROR in FSDirectory.verifyINodeName", e);
1210: Tsz-wo Sze, error, IfStmt, NameNode.LOG.error("FSDirectory.verifyMaxDirItems: " + e.getLocalizedMessage());
1227: Chris Nauroth, debug, IfStmt, LOG.debug("child: {}, posixAclInheritanceEnabled: {}, modes: {}", child, posixAclInheritanceEnabled, modes);
1239: Chris Nauroth, debug, IfStmt, LOG.debug("{}: no parent default ACL to inherit", child);
1315: Brandon Li, warn, CatchClause, NameNode.LOG.warn("FSDirectory.addChildNoQuotaCheck - unexpected", e);
1365: Arpit Agarwal, error, IfStmt, LOG.error("{} ignoring path {} with scheme", errorString, dir);
1363: Arpit Agarwal, error, IfStmt, LOG.error("{} ignoring relative path {}", errorString, dir);
1359: Arpit Agarwal, error, IfStmt, LOG.error("{} ignoring reserved path {}", errorString, dir);
1431: Andrew Wang, Error, CatchClause, NameNode.LOG.warn("Error parsing protocol buffer of " + "EZ XAttr " + xattr.getName() + " dir:" + inode.getFullPathName());
1684: Kihwal Lee, debug, IfStmt, NameNode.LOG.debug("Resolved path is " + DFSUtil.byteArray2PathString(components));
391: Xiao Chen, info, IfStmt, NameNode.LOG.info("Cannot find inode {}, skip saving xattr for" + " re-encryption", entry.getInodeId());
455: Haohui Mai, debug, IfStmt, NameNode.LOG.debug("Encryption zone " + encryptionZone.getPath() + " does not have a valid path.");
464: Haohui Mai, warn, IfStmt, NameNode.LOG.warn("Could not find encryption XAttr for file " + iip.getPath() + " in encryption zone " + encryptionZone.getPath());
571: Andrew Wang, info, MethodDeclaration, NameNode.LOG.info("Warming up {} EDEKs... (initialDelay={}, " + "retryInterval={})", keyNames.length, initialDelay, retryInterval);
576: Andrew Wang, info, CatchClause, NameNode.LOG.info("EDEKCacheLoader interrupted before warming up.");
598: Andrew Wang, debug, IfStmt, NameNode.LOG.debug("Failed to warm up EDEKs.", ioe);
595: Andrew Wang, info, IfStmt, NameNode.LOG.info("Failed to warm up EDEKs.", ioe);
601: Andrew Wang, error, CatchClause, NameNode.LOG.error("Cannot warm up EDEKs.", e);
588: Andrew Wang, info, TryStmt, NameNode.LOG.info("Successfully warmed up {} EDEKs.", keyNames.length);
607: Andrew Wang, info, CatchClause, NameNode.LOG.info("EDEKCacheLoader interrupted during retry.");
615: Andrew Wang, warn, IfStmt, NameNode.LOG.warn("Unable to warm up EDEKs.");
617: Andrew Wang, warn, IfStmt, NameNode.LOG.warn("Last seen exception:", lastSeenIOE);
46: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.mkdirs: " + src);
185: Jing Zhao, debug, IfStmt, NameNode.stateChangeLog.debug("mkdirs: created directory " + cur);
53: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.renameTo: " + src + " to " + dst);
175: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + "failed to rename " + src + " to " + dst + " because destination " + "exists");
182: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + "failed to rename " + src + " to " + dst + " because destination's " + "parent does not exist");
208: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSDirectory" + ".unprotectedRenameTo: " + src + " is renamed to " + dst);
222: Haohui Mai, warn, MethodDeclaration, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + "failed to rename " + src + " to " + dst);
237: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.renameTo: with options -" + " " + src + " to " + dst);
286: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSDirectory.renameTo: " + src + " to " + dst);
370: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + error);
387: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + error);
393: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + error);
422: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSDirectory.unprotectedRenameTo: " + src + " is renamed to " + dst);
455: Haohui Mai, warn, MethodDeclaration, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + "failed to rename " + src + " to " + dst);
478: Kihwal Lee, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSDirectory.renameTo: " + srcIIP.getPath() + " to " + dstIIP.getPath());
512: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + error);
531: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + error);
537: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + error);
546: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + error);
560: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + error);
566: Haohui Mai, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedRenameTo: " + error);
640: Jing Zhao, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirRenameOp.unprotectedRenameTo:" + error);
654: Jing Zhao, warn, IfStmt, NameNode.stateChangeLog.warn("DIR* FSDirRenameOp.unprotectedRenameTo: " + "failed to rename " + srcIIP.getPath() + " to " + dstIIP.getPath() + " because the source can not be removed");
51: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.createSymlink: target=" + target + " link=" + link);
119: Haohui Mai, info, IfStmt, NameNode.stateChangeLog.info("addSymlink: failed to add " + path);
126: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("addSymlink: " + path + " is added");
268: Walter Su, debug, IfStmt, NameNode.stateChangeLog.debug("BLOCK* prepareFileForTruncate: " + "{} Scheduling in-place block truncate to new size {}", uc, uc.getTruncateBlock().getNumBytes());
252: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("BLOCK* prepareFileForTruncate: Scheduling copy-on-truncate to new" + " size {}  new block {} old block {}", truncatedBlockUC.getNumBytes(), newBlock, oldBlock);
92: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSDirectory.removeBlock: " + path + " with " + block + " block is removed from the file system");
112: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("persistBlocks: " + path + " with " + file.getBlocks().length + " blocks is persisted to" + " the file system");
408: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.startFile: added " + src + " inode " + newNode.getId() + " " + holder);
464: Kihwal Lee, warn, CatchClause, NameNode.stateChangeLog.warn("DIR* FSDirectory.unprotectedAddFile: exception when add " + existing.getPath() + " to the file system", e);
468: Kihwal Lee, warn, IfStmt, NameNode.stateChangeLog.warn("Please increase " + "dfs.namenode.fs-limits.max-directory-items and make it " + "consistent across all NameNodes.");
517: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* FSDirectory.addBlock: " + path + " with " + block + " block is added to the in-memory " + "file system");
571: Haohui Mai, info, IfStmt, NameNode.stateChangeLog.info("DIR* addFile: failed to add " + existing.getPath() + "/" + DFSUtil.bytes2String(localName));
577: Kihwal Lee, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* addFile: " + DFSUtil.bytes2String(localName) + " is added");
633: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("BLOCK* NameSystem.allocateBlock: handling block allocation" + " writing to a file with a complete previous block: src=" + src + " lastBlock=" + lastBlockInFile);
672: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.completeFile: " + src + " for " + holder);
703: Haohui Mai, info, IfStmt, NameNode.stateChangeLog.info("DIR* completeFile: " + "request from " + holder + " to complete inode " + fileId + "(" + src + ") which is already closed. But, it appears to be " + "an RPC retry. Returning success");
756: Haohui Mai, debug, IfStmt, NameNode.stateChangeLog.debug("persistNewBlock: " + path + " with new block " + file.getLastBlock().toString() + ", current total block count is " + file.getBlocks().length);
796: Chris Nauroth, info, MethodDeclaration, NameNode.stateChangeLog.info(sb.toString());
227: Jing Zhao, info, MethodDeclaration, LOG.info("Edit logging is async:" + asyncEditLogging);
265: Todd Lipcon, warn, IfStmt, LOG.warn("Initializing shared journals for READ, already open for READ", new Exception());
301: Todd Lipcon, error, IfStmt, LOG.error("No edits directories configured!");
389: Todd Lipcon, debug, IfStmt, LOG.debug("Closing log when already closed");
406: Tsz-wo Sze, Error, CatchClause, LOG.warn("Error closing journalSet", ioe);
604: Yongjun Zhang, info, MethodDeclaration, LOG.info("logSyncAll toSyncToTxId=" + lastWrittenTxId + " lastSyncedTxid=" + synctxid + " mostRecentTxid=" + txid);
609: Yongjun Zhang, info, MethodDeclaration, LOG.info("Done logSyncAll lastWrittenTxId=" + lastWrittenTxId + " lastSyncedTxid=" + synctxid + " mostRecentTxid=" + txid);
691: Chen Liang, error, CatchClause, LOG.error(msg, new Exception());
717: Chen Liang, error, SynchronizedStmt, LOG.error(msg, new Exception());
774: Chen Liang, info, MethodDeclaration, LOG.info(buf.toString());
1314: Suresh Srinivas, info, MethodDeclaration, LOG.info("Rolling edit logs");
1329: Suresh Srinivas, info, MethodDeclaration, LOG.info("Started a new log segment at txid " + txid);
1342: Tsz-wo Sze, warn, IfStmt, LOG.warn(mess);
1361: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting log segment at " + segmentTxId);
1406: Yongjun Zhang, info, MethodDeclaration, LOG.info("Ending log segment " + curSegmentTxId + ", " + getLastWrittenTxId());
1447: Jitendra Nath Pandey, warn, CatchClause, LOG.warn("All journals failed to abort", e);
1530: Todd Lipcon, info, IfStmt, LOG.info("Backup node " + bnReg + " re-registers");
1534: Todd Lipcon, info, MethodDeclaration, LOG.info("Registering new backup node: " + bnReg);
1545: Jitendra Nath Pandey, info, IfStmt, LOG.info("Removing backup journal " + bjm);
1786: Todd Lipcon, warn, IfStmt, LOG.warn("No class configured for " + uriScheme + ", " + key + " is empty");
128: Jing Zhao, debug, IfStmt, LOG.debug("logSync " + edit);
150: Jing Zhao, debug, IfStmt, LOG.debug("logEdit " + edit);
198: Jing Zhao, info, CatchClause, LOG.info(Thread.currentThread().getName() + " was interrupted, exiting");
206: Jing Zhao, fatal, MethodDeclaration, LOG.fatal(message, t);
157: Suresh Srinivas, info, TryStmt, FSImage.LOG.info("Start loading edits file " + edits.getName());
160: Todd Lipcon, info, TryStmt, FSImage.LOG.info("Edits file " + edits.getName() + " of size " + edits.length() + " edits # " + numEdits + " loaded in " + (monotonicNow() - startTime) / 1000 + " seconds");
180: Todd Lipcon, trace, IfStmt, LOG.trace("Acquiring write lock to replay edit log");
306: Todd Lipcon, trace, IfStmt, LOG.trace("replaying edit log finished");
289: Tsz-wo Sze, info, CatchClause, LOG.info("Stopped at OP_START_ROLLING_UPGRADE for rollback.");
292: Eli Collins, warn, CatchClause, MetaRecoveryContext.LOG.warn("Stopped reading edit log at " + in.getPosition() + "/" + in.length());
214: Todd Lipcon, error, CatchClause, FSImage.LOG.error(errorMessage, e);
257: Eli Collins, error, CatchClause, LOG.error("Encountered exception on operation " + op, e);
246: Tsz-wo Sze, trace, IfStmt, LOG.trace("op=" + op + ", startOpt=" + startOpt + ", numEdits=" + numEdits + ", totalEdits=" + totalEdits);
281: Aaron Myers, info, IfStmt, LOG.info("replaying edit log: " + deltaTxId + "/" + numTxns + " transactions completed. (" + percent + "%)");
343: Todd Lipcon, trace, IfStmt, LOG.trace("replaying edit log: " + op);
353: Jing Zhao, debug, IfStmt, FSNamesystem.LOG.debug(op.opCode + ": " + path + " numblocks : " + addCloseOp.blocks.length + " clientHolder " + addCloseOp.clientName + " clientMachine " + addCloseOp.clientMachine);
404: Eli Collins, debug, IfStmt, FSNamesystem.LOG.debug("Reopening an already-closed file " + "for append");
437: Aaron Myers, debug, IfStmt, FSNamesystem.LOG.debug(op.opCode + ": " + path + " numblocks : " + addCloseOp.blocks.length + " clientHolder " + addCloseOp.clientName + " clientMachine " + addCloseOp.clientMachine);
477: Jing Zhao, debug, IfStmt, FSNamesystem.LOG.debug(op.opCode + ": " + path + " clientName " + appendOp.clientName + " clientMachine " + appendOp.clientMachine + " newBlock " + appendOp.newBlock);
503: Aaron Myers, debug, IfStmt, FSNamesystem.LOG.debug(op.opCode + ": " + path + " numblocks : " + updateOp.blocks.length);
523: Jing Zhao, debug, IfStmt, FSNamesystem.LOG.debug(op.opCode + ": " + path + " new block id : " + addBlockOp.getLastBlock().getBlockId());
1178: Todd Lipcon, debug, MethodDeclaration, FSImage.LOG.debug(sb.toString());
1237: Colin Patrick Mccabe, warn, CatchClause, FSImage.LOG.warn("Caught exception after scanning through " + numValid + " ops from " + in + " while determining its valid length. Position was " + lastPos, t);
1242: Jing Zhao, warn, CatchClause, FSImage.LOG.warn("After resync, position is " + in.getPosition());
170: Arpit Agarwal, info, MethodDeclaration, LOG.info("Allocated new BlockPoolId: " + ns.getBlockPoolID());
230: Todd Lipcon, trace, IfStmt, LOG.trace("Data dir states:\n  " + Joiner.on("\n  ").withKeyValueSeparator(": ").join(dataDirStates));
287: Todd Lipcon, info, SwitchStmt, LOG.info("Formatting ...");
336: Kihwal Lee, info, TryStmt, LOG.info("Wrote VERSION in the new storage, " + sd.getCurrentDir());
454: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting upgrade of local storage directories." + "\n   old LV = " + oldLV + "; old CTime = " + oldCTime + ".\n   new LV = " + storage.getLayoutVersion() + "; new CTime = " + storage.getCTime());
465: Todd Lipcon, error, CatchClause, LOG.error("Failed to move aside pre-upgrade storage " + "in image directory " + sd.getRoot(), e);
517: Jing Zhao, info, ForStmt, LOG.info("Can perform rollback for " + sd);
527: Jing Zhao, info, IfStmt, LOG.info("Can perform rollback for shared edit log.");
540: Brandon Li, info, ForStmt, LOG.info("Rolling back storage directory " + sd.getRoot() + ".\n   new LV = " + prevState.getStorage().getLayoutVersion() + "; new CTime = " + prevState.getStorage().getCTime());
599: Todd Lipcon, info, MethodDeclaration, LOG.info("Finalizing upgrade for local dirs. " + (storage.getLayoutVersion() == 0 ? "" : "\n   cur LV = " + storage.getLayoutVersion() + "; cur CTime = " + storage.getCTime()));
636: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Reloading namespace from " + file);
715: Todd Lipcon, debug, ForeachStmt, LOG.debug("Planning to load edit log stream: " + l);
718: Todd Lipcon, info, IfStmt, LOG.info("No edit log streams selected.");
731: Yongjun Zhang, error, CatchClause, LOG.error("Failed to load image from " + imageFile, e);
781: Yongjun Zhang, info, MethodDeclaration, LOG.info("Planning to load image: " + imageFile);
875: Jitendra Nath Pandey, debug, MethodDeclaration, LOG.debug("About to load edits:\n  " + Joiner.on("\n  ").join(editStreams));
885: Eli Collins, info, ForeachStmt, LOG.info("Reading " + editIn + " expecting start txid #" + (lastAppliedTxId + 1));
947: Todd Lipcon, info, MethodDeclaration, LOG.info("Loaded image for txid " + txId + " from " + curFile);
966: Arpit Agarwal, error, IfStmt, LOG.error("Detected " + numErrors + " errors while saving FsImage " + dstFile);
1022: Todd Lipcon, info, CatchClause, LOG.info("Cancelled image saving for " + sd.getRoot() + ": " + snce.getMessage());
1026: Todd Lipcon, error, CatchClause, LOG.error("Unable to save image for " + sd.getRoot(), t);
1044: Todd Lipcon, error, CatchClause, LOG.error("Caught interrupted exception while waiting for thread " + thread.getName() + " to finish. Retrying join");
1097: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Save namespace ...");
1134: Arpit Agarwal, fatal, IfStmt, LOG.fatal("NameNode process will exit now... The saved FsImage " + nnf + " is potentially corrupted.");
1227: Tsz-wo Sze, warn, CatchClause, LOG.warn("Unable to purge old storage " + nnf.getName(), e);
1242: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to rename checkpoint in " + sd, ioe);
1266: Jing Zhao, warn, CatchClause, LOG.warn("Unable to rename checkpoint in " + image.sd, ioe);
1288: Todd Lipcon, warn, IfStmt, LOG.warn("Unable to delete cancelled checkpoint in " + sd);
1301: Tsz-wo Sze, debug, IfStmt, LOG.debug("renaming  " + fromFile.getAbsolutePath() + " to " + toFile.getAbsolutePath());
1346: Konstantin Shvachko, info, MethodDeclaration, LOG.info("Start checkpoint at txid " + getEditLog().getLastWrittenTxId());
1366: Todd Lipcon, error, IfStmt, LOG.error(msg);
1386: Konstantin Shvachko, info, MethodDeclaration, LOG.info("End checkpoint at txid " + getEditLog().getLastWrittenTxId());
367: Tsz-wo Sze, info, IfStmt, LOG.info("Upgrading to sequential block IDs. Generation stamp " + "for new blocks set to " + startingGenStamp);
390: Suresh Srinivas, debug, IfStmt, LOG.debug("Old layout version doesn't have inode id." + " Will assign new id for each inode.");
386: Suresh Srinivas, debug, IfStmt, LOG.debug("load last allocated InodeId from fsimage:" + lastInodeId);
409: Todd Lipcon, info, TryStmt, LOG.info("Loading image file " + curFile + " using " + compression);
412: Todd Lipcon, info, TryStmt, LOG.info("Number of files = " + numFiles);
446: Kihwal Lee, info, MethodDeclaration, LOG.info("Image file " + curFile + " of size " + curFile.length() + " bytes loaded in " + (monotonicNow() - startTime) / 1000 + " seconds.");
629: Andrew Wang, info, IfStmt, LOG.info("Renaming reserved path " + oldPath + " to " + newPath);
935: Todd Lipcon, info, MethodDeclaration, LOG.info("Number of files under construction = " + size);
1084: Aaron Myers, info, ForeachStmt, LOG.info("Will rename reserved path " + key + " to " + value);
1129: Aaron Myers, info, IfStmt, LOG.info("Upgrade process renamed reserved path " + oldPath + " to " + path);
1180: Aaron Myers, info, IfStmt, LOG.info("Renamed root path " + FSDirectory.DOT_RESERVED_STRING + " to " + renameString);
1284: Kihwal Lee, info, TryStmt, LOG.info("Saving image file " + newFile + " using " + compression);
1321: Kihwal Lee, info, MethodDeclaration, LOG.info("Image file " + newFile + " of size " + newFile.length() + " bytes saved in " + (monotonicNow() - startTime) / 1000 + " seconds.");
266: Vinayakumar B, info, MethodDeclaration, LOG.info("Loading " + numInodes + " INodes.");
633: Haohui Mai, warn, IfStmt, LOG.warn("Fail to find inode " + id + " when saving the leases.");
638: Haohui Mai, warn, IfStmt, LOG.warn("Fail to save the lease for inode id " + id + " as the file is not under construction");
190: Arpit Agarwal, info, TryStmt, LOG.info("Loaded FSImage in {} seconds.", (end - start) / 1000);
302: Arpit Agarwal, warn, SwitchStmt, LOG.warn("Unrecognized section {}", n);
455: Arpit Agarwal, info, TryStmt, LOG.info("Saving image file {} using {}", file, compression);
459: Arpit Agarwal, info, TryStmt, LOG.info("Image file {} of size {} bytes saved in {} seconds {}.", file, file.length(), (monotonicNow() - startTime) / 1000, (numErrors > 0 ? (" with" + numErrors + " errors") : ""));
168: Todd Lipcon, error, IfStmt, LOG.error("Image checkpoint time " + latestNameCheckpointTime + " > edits checkpoint time " + latestEditsCheckpointTime);
170: Todd Lipcon, error, IfStmt, LOG.error("Name-node will treat the image as the latest state of " + "the namespace. Old edits will be discarded.");
198: Jitendra Nath Pandey, debug, MethodDeclaration, LOG.debug("Performing recovery in " + latestNameSD + " and " + latestEditsSD);
234: Jitendra Nath Pandey, warn, BlockStmt, LOG.warn("Unable to delete dir " + curFile + " before rename");
264: Jitendra Nath Pandey, debug, IfStmt, LOG.debug("Name checkpoint time is newer than edits, not loading edits.");
78: Todd Lipcon, info, IfStmt, LOG.info("No version file in " + sd.getRoot());
88: Eli Collins, warn, CatchClause, LOG.warn("Unable to determine the max transaction ID seen by " + sd, ioe);
97: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to inspect storage directory " + currentDir, ioe);
103: Todd Lipcon, debug, ForeachStmt, LOG.debug("Checking file " + f);
119: Todd Lipcon, warn, IfStmt, LOG.warn("Found image file at " + f + " but storage directory is " + "not configured to contain images.");
114: Todd Lipcon, error, CatchClause, LOG.error("Image file " + f + " has improperly formatted " + "transaction ID");
680: Harsh J, warn, IfStmt, LOG.warn("Only one image storage directory (" + DFS_NAMENODE_NAME_DIR_KEY + ") configured. Beware of data loss" + " due to lack of redundant storage directories!");
685: Harsh J, warn, IfStmt, LOG.warn("Only one namespace edits storage directory (" + DFS_NAMENODE_EDITS_DIR_KEY + ") configured. Beware of data loss" + " due to lack of redundant storage directories!");
716: Junping Du, warn, CatchClause, LOG.warn("Encountered exception loading fsimage", ioe);
721: Todd Lipcon, info, MethodDeclaration, LOG.info("Finished loading FSImage in " + timeTakenToLoadFSImage + " msecs");
749: Uma Mahesh, info, ConstructorDeclaration, LOG.info("KeyProvider: " + provider);
752: Daryn Sharp, info, IfStmt, LOG.info("Enabling async auditlog");
907: Todd Lipcon, error, CatchClause, LOG.error(getClass().getSimpleName() + " initialization failed.", e);
911: Aaron Myers, error, CatchClause, LOG.error(getClass().getSimpleName() + " initialization failed.", re);
774: Tsz-wo Sze, info, TryStmt, LOG.info("fsOwner             = " + fsOwner);
775: Tsz-wo Sze, info, TryStmt, LOG.info("supergroup          = " + supergroup);
776: Tsz-wo Sze, info, TryStmt, LOG.info("isPermissionEnabled = " + isPermissionEnabled);
785: Tsz-wo Sze, info, IfStmt, LOG.info("Determined nameservice ID: " + nameserviceId);
787: Tsz-wo Sze, info, TryStmt, LOG.info("HA Enabled: " + haEnabled);
789: Tsz-wo Sze, warn, IfStmt, LOG.warn("Configured NNs:\n" + DFSUtil.nnAddressesAsString(conf));
896: Jitendra Pandey, info, IfStmt, LOG.info("Using INode attribute provider: " + klass.getName());
979: Suresh Srinivas, info, MethodDeclaration, LOG.info("Retry cache on namenode is " + (enable ? "enabled" : "disabled"));
987: Suresh Srinivas, info, IfStmt, LOG.info("Retry cache will use " + heapPercent + " of total heap and retry cache entry expiry time is " + entryExpiryMillis + " millis");
1091: Tsz-wo Sze, info, TryStmt, LOG.info("Need to save fs image? " + needToSave + " (staleImage=" + staleImage + ", haEnabled=" + haEnabled + ", isRollingUpgrade=" + isRollingUpgrade() + ")");
1203: Suresh Srinivas, info, MethodDeclaration, LOG.info("Starting services required for active state");
1214: Todd Lipcon, info, IfStmt, LOG.info("Catching up to latest edits from old active before " + "taking over writer role in edits logs");
1225: Aaron Myers, info, IfStmt, LOG.info("Reprocessing replication and invalidation queues");
1230: Todd Lipcon, debug, IfStmt, LOG.debug("NameNode metadata after re-processing " + "replication and invalidation queues during failover:\n" + metaSaveAsString());
1236: Todd Lipcon, info, IfStmt, LOG.info("Will take over writing edit logs at txnid " + nextTxId);
1272: Arpit Agarwal, warn, IfStmt, LOG.warn("Lazy persist file scrubber is disabled," + " configured scrub interval is zero.");
1312: Suresh Srinivas, info, MethodDeclaration, LOG.info("Stopping services started for active state");
1365: Suresh Srinivas, info, MethodDeclaration, LOG.info("Starting services required for standby state");
1408: Suresh Srinivas, info, MethodDeclaration, LOG.info("Stopping services started for standby state");
1491: Todd Lipcon, warn, BlockStmt, LOG.warn("!!! WARNING !!!" + "\n\tThe NameNode currently runs without persistent storage." + "\n\tAny changes to the file system meta-data may be lost." + "\n\tRecommended actions:" + "\n\t\t- shutdown and restart NameNode with configured \"" + propertyName + "\" in hdfs-site.xml;" + "\n\t\t- use Backup Node as a persistent and up-to-date storage " + "of the file system meta-data.");
1542: Todd Lipcon, warn, IfStmt, LOG.warn("Edits URI " + dir + " listed multiple times in " + DFS_NAMENODE_SHARED_EDITS_DIR_KEY + ". Ignoring duplicates.");
1550: Todd Lipcon, warn, IfStmt, LOG.warn("Edits URI " + dir + " listed multiple times in " + DFS_NAMENODE_SHARED_EDITS_DIR_KEY + " and " + DFS_NAMENODE_EDITS_DIR_KEY + ". Ignoring duplicates.");
1990: Haohui Mai, warn, CatchClause, LOG.warn("Failed to update the access time of " + src, e);
2098: Haohui Mai, debug, TryStmt, NameNode.stateChangeLog.debug("DIR* NameSystem.truncate: src={} newLength={}", src, newLength);
2313: Andrew Wang, debug, IfStmt, LOG.debug("Ignoring unknown CryptoProtocolVersion provided by " + "client: " + c.getUnknownValue());
2371: Andrew Wang, debug, IfStmt, NameNode.stateChangeLog.debug(builder.toString());
2567: Suresh Srinivas, info, IfStmt, LOG.info("startFile: recover " + lease + ", src=" + src + " client " + clientName);
2609: Xiaoyu Yao, debug, MethodDeclaration, NameNode.stateChangeLog.debug("DIR* NameSystem.appendFile: src={}, holder={}, clientMachine={}", srcArg, holder, clientMachine);
2666: Xiaoyu Yao, debug, MethodDeclaration, NameNode.stateChangeLog.debug("BLOCK* getAdditionalBlock: {}  inodeId {}" + " for {}", src, fileId, clientName);
2767: Xiaoyu Yao, debug, MethodDeclaration, NameNode.stateChangeLog.debug("BLOCK* NameSystem.abandonBlock: {} of file {}", b, src);
2776: Xiaoyu Yao, debug, TryStmt, NameNode.stateChangeLog.debug("BLOCK* NameSystem.abandonBlock: {} is " + "removed from pendingCreates", b);
2847: Jing Zhao, info, IfStmt, NameNode.stateChangeLog.info("DIR* completeFile: " + src + " is closed by " + holder);
2894: Tsz-Wo Nicholas Sze, info, IfStmt, LOG.info("BLOCK* " + err + "(numNodes= " + numNodes + (numNodes < min ? " < " : " >= ") + " minimum = " + min + ") in file " + src);
3260: Suresh Srinivas, info, MethodDeclaration, NameNode.stateChangeLog.info("BLOCK* fsync: " + src + " for " + clientName);
3297: Suresh Srinivas, info, MethodDeclaration, LOG.info("Recovering " + lease + ", src=" + src);
3320: Ravi Prakash, warn, IfStmt, NameNode.stateChangeLog.warn("BLOCK*" + " internalReleaseLease: All existing blocks are COMPLETE," + " lease removed, file " + src + " closed.");
3335: Todd Lipcon, warn, IfStmt, NameNode.stateChangeLog.warn(message);
3359: Ravi Prakash, warn, IfStmt, NameNode.stateChangeLog.warn("BLOCK*" + " internalReleaseLease: Committed blocks are minimally" + " replicated, lease removed, file" + src + " closed.");
3372: Todd Lipcon, warn, SwitchStmt, NameNode.stateChangeLog.warn(message);
3403: Uma Maheswara Rao G, warn, IfStmt, NameNode.stateChangeLog.warn("BLOCK* internalReleaseLease: " + "Removed empty last block and closed file " + src);
3554: Konstantin V Shvachko, info, MethodDeclaration, LOG.info("commitBlockSynchronization(oldBlock=" + oldBlock + ", newgenerationstamp=" + newgenerationstamp + ", newlength=" + newlength + ", newtargets=" + Arrays.asList(newtargets) + ", closeFile=" + closeFile + ", deleteBlock=" + deleteblock + ")");
3580: Konstantin V Shvachko, debug, IfStmt, LOG.debug("Block (=" + oldBlock + ") not found");
3615: Konstantin V Shvachko, debug, IfStmt, LOG.debug("Unexpected block (=" + oldBlock + ") since the file (=" + iFile.getLocalName() + ") is not under construction");
3711: Konstantin V Shvachko, info, IfStmt, LOG.info("commitBlockSynchronization(" + oldBlock + ") successful");
3704: Konstantin V Shvachko, info, IfStmt, LOG.info("commitBlockSynchronization(oldBlock=" + oldBlock + ", file=" + src + (copyTruncate ? ", newBlock=" + truncatedBlock : ", newgenerationstamp=" + newgenerationstamp) + ", newlength=" + newlength + ", newtargets=" + Arrays.asList(newtargets) + ") successful");
3933: Xiaoyu Yao, debug, MethodDeclaration, NameNode.stateChangeLog.debug("closeFile: {} with {} blocks is persisted" + " to the file system", path, file.getBlocks().length);
3966: Todd Lipcon, error, CatchClause, FSNamesystem.LOG.error("Exception in NameNodeResourceMonitor: ", e);
3955: Haohui Mai, warn, IfStmt, LOG.warn(lowResourcesMsg + "Already in safe mode.");
3953: Haohui Mai, warn, IfStmt, LOG.warn(lowResourcesMsg + "Entering safe mode.");
3998: Jing Zhao, error, CatchClause, FSNamesystem.LOG.error("Swallowing exception in " + NameNodeEditLogRoller.class.getSimpleName() + ":", e);
3992: Andrew Wang, info, IfStmt, FSNamesystem.LOG.info("NameNode rolling its own edit log because" + " number of edits in open segment exceeds threshold of " + rollThreshold);
4004: Andrew Wang, info, CatchClause, FSNamesystem.LOG.info(NameNodeEditLogRoller.class.getSimpleName() + " was interrupted, exiting");
4047: Inigo Goiri, info, IfStmt, LOG.info("Cannot find block info for block " + b);
4057: arp, warn, ForeachStmt, LOG.warn("Removing lazyPersist file " + bc.getName() + " with no replicas.");
4088: Kihwal Lee, error, CatchClause, FSNamesystem.LOG.error("Ignoring exception in LazyPersistFileScrubber:", e);
4083: Arpit Agarwal, debug, IfStmt, FSNamesystem.LOG.debug("Namenode is in safemode, skipping scrubbing of corrupted lazy-persist files.");
4095: arp, info, CatchClause, FSNamesystem.LOG.info("LazyPersistFileScrubber was interrupted, exiting");
4403: Jing Zhao, info, IfStmt, LOG.info("New namespace image has been created");
4492: Eli Collins, error, SwitchStmt, LOG.error("Unexpected safe mode action");
4577: Jing Zhao, info, TryStmt, NameNode.stateChangeLog.info("STATE* Safe mode is ON.\n" + getSafeModeTip());
4592: Suresh Srinivas, info, IfStmt, NameNode.stateChangeLog.info("STATE* Safe mode is already OFF");
4643: Andrew Wang, info, IfStmt, LOG.info("Roll Edit Log from " + Server.getRemoteAddress());
4661: Suresh Srinivas, info, TryStmt, LOG.info("Start checkpoint for " + backupNode.getAddress());
4689: Todd Lipcon, info, TryStmt, LOG.info("End checkpoint for " + registration.getAddress());
4970: Lei Xu, info, MethodDeclaration, LOG.info("Registered FSNamesystemState, ReplicatedBlocksState and " + "ECBlockGroupsState MBeans.");
5007: Robert Kanter, error, CatchClause, LOG.error("Failed to close provider.", e);
5121: Andrew Wang, warn, CatchClause, LOG.warn("Failed to fetch TopUser metrics", e);
5245: Kihwal Lee, info, ForStmt, NameNode.stateChangeLog.info("*DIR* reportBadBlocks for block: {} on" + " datanode: {}", blk, nodes[j].getXferAddr());
5309: Haohui Mai, info, MethodDeclaration, LOG.info("updatePipeline(" + oldBlock.getLocalBlock() + ", newGS=" + newBlock.getGenerationStamp() + ", newLength=" + newBlock.getNumBytes() + ", newNodes=" + Arrays.asList(newNodes) + ", client=" + clientName + ")");
5327: Haohui Mai, info, MethodDeclaration, LOG.info("updatePipeline(" + oldBlock.getLocalBlock() + " => " + newBlock.getLocalBlock() + ") success");
5347: Jing Zhao, warn, IfStmt, LOG.warn(msg);
5354: Todd Lipcon, warn, IfStmt, LOG.warn(msg);
5465: Xiaoyu Yao, debug, IfStmt, LOG.debug("there are no corrupt file blocks.");
5503: Xiaoyu Yao, debug, IfStmt, LOG.debug("list corrupt file blocks returned: " + count);
5576: Todd Lipcon, warn, IfStmt, LOG.warn("trying to get DT with no secret manager running");
6223: Vinayakumar B, debug, IfStmt, LOG.debug("Get corrupt file blocks returned error: " + e.getMessage());
6226: Steve Loughran, warn, CatchClause, LOG.warn("Get corrupt file blocks returned error", e);
6679: Tsz-wo Sze, Info, TryStmt, getEditLog().logStartRollingUpgrade(rollingUpgradeInfo.getStartTime());
6720: Jing Zhao, info, MethodDeclaration, LOG.info("Successfully saved namespace for preparing rolling upgrade.");
6771: Kihwal Lee, warn, CatchClause, LOG.warn("Encountered exception setting Rollback Image", ioe);
6865: Arpit Agarwal, Info, TryStmt, getEditLog().logFinalizeRollingUpgrade(rollingUpgradeInfo.getFinalizeTime());
7361: Xiao Chen, info, IfStmt, LOG.info("Re-encryption using key version " + keyVersionName + " for zone " + zone);
7517: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("Enable the erasure coding policy " + ecPolicyName);
7547: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("Disable the erasure coding policy " + ecPolicyName);
7902: Daryn Sharp, info, MethodDeclaration, auditLog.info(message);
7908: Daryn Sharp, warn, IfStmt, LOG.warn("Log4j is required to enable async auditlog");
120: Zhe Zhang, info, ConstructorDeclaration, FSNamesystem.LOG.info("fsLock is fair: " + fair);
136: Zhe Zhang, info, ConstructorDeclaration, FSNamesystem.LOG.info("Detailed lock hold time metrics enabled: " + this.metricsEnabled);
195: Zhe Zhang, info, IfStmt, FSNamesystem.LOG.info("FSNamesystem read lock held for " + readLockIntervalMs + " ms via\n" + StringUtils.getStackTrace(Thread.currentThread()) + "\tNumber of suppressed read-lock reports: " + numSuppressedWarnings + "\n\tLongest read-lock held interval: " + longestLockHeldIntervalMs);
280: Zhe Zhang, info, IfStmt, FSNamesystem.LOG.info("FSNamesystem write lock held for " + writeLockIntervalMs + " ms via\n" + StringUtils.getStackTrace(Thread.currentThread()) + "\tNumber of suppressed write-lock reports: " + numSuppressedWarnings + "\n\tLongest write-lock held interval: " + longestLockHeldIntervalMs);
46: Haohui Mai, Info, MethodDeclaration, fsn.getEditLog().logAddCacheDirectiveInfo(effectiveDirective, logRetryCache);
57: Haohui Mai, Info, MethodDeclaration, fsn.getEditLog().logModifyCacheDirectiveInfo(directive, logRetryCache);
67: Haohui Mai, Info, MethodDeclaration, fsn.getEditLog().logRemoveCacheDirectiveInfo(id, logRetryCache);
87: Haohui Mai, info, MethodDeclaration, fsn.getEditLog().logAddCachePool(info, logRetryCache);
171: Todd Lipcon, debug, IfStmt, LOG.debug("ACCESS CHECK: " + this + ", doCheckOwner=" + doCheckOwner + ", ancestorAccess=" + ancestorAccess + ", parentAccess=" + parentAccess + ", access=" + access + ", subAccess=" + subAccess + ", ignoreEmptyDir=" + ignoreEmptyDir);
652: Kihwal Lee, debug, IfStmt, LOG.debug("UnresolvedPathException " + " path: " + path + " preceding: " + preceding + " count: " + i + " link: " + link + " target: " + target + " remainder: " + remainder);
139: Rakesh Radhakrishnan, debug, IfStmt, LOG.debug("Traversing directory {}", parent.getFullPathName());
191: Andrew Wang, warn, IfStmt, LOG.warn("Received non-NN/SNN/administrator request for image or edits from " + request.getUserPrincipal().getName() + " at " + request.getRemoteHost());
204: Andrew Wang, warn, IfStmt, LOG.warn("Received an invalid request file transfer request " + "from a secondary with storage info " + theirStorageInfoString);
250: Andrew Wang, warn, IfStmt, LOG.warn("Received null remoteUser while authorizing access to getImage servlet");
266: cnauroth, debug, CatchClause, LOG.debug("SecondaryNameNode principal could not be added", e);
274: cnauroth, warn, CatchClause, LOG.warn(msg);
288: Andrew Wang, info, IfStmt, LOG.info("ImageServlet allowing checkpointer: " + remoteUser);
294: Andrew Wang, info, IfStmt, LOG.info("ImageServlet allowing administrator: " + remoteUser);
298: Andrew Wang, info, MethodDeclaration, LOG.info("ImageServlet rejecting: " + remoteUser);
595: Uma Maheswara Rao G, debug, IfStmt, LOG.debug("The current effective storage policy id : " + id + " is not suitable for striped mode EC file : " + getName() + ". So, just returning unspecified storage policy id");
124: Jitendra Nath Pandey, error, CatchClause, LOG.error("Unable to abort stream " + stream, ioe);
265: Todd Lipcon, info, IfStmt, LOG.info("Skipping jas " + jas + " since it's disabled");
272: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to determine input streams from " + jas.getManager() + ". Skipping.", ioe);
352: Jitendra Nath Pandey, error, ForeachStmt, LOG.error("Disabling journal " + j);
402: Todd Lipcon, Error, IfStmt, LOG.error("Error: " + status + " failed for (journal " + jas + ")", t);
390: Todd Lipcon, fatal, IfStmt, LOG.fatal(msg, t);
411: Aaron Myers, Error, IfStmt, LOG.error("Error: " + message);
562: Jitendra Nath Pandey, Error, CatchClause, LOG.error("Error in setting outputbuffer capacity");
638: Jitendra Nath Pandey, warn, CatchClause, LOG.warn("Cannot list edit logs in " + fjm, t);
662: Jitendra Nath Pandey, debug, IfStmt, LOG.debug("Found gap in logs at " + curStartTxId + ": " + "not returning previous logs in manifest.");
681: Jitendra Nath Pandey, debug, IfStmt, LOG.debug("Generated manifest for logs since " + fromTxId + ":" + ret);
157: Arpit Agarwal, warn, IfStmt, LOG.warn("The file {} is not under construction but has lease.", cons.getFullPathName());
171: Arpit Agarwal, info, MethodDeclaration, LOG.info("Number of blocks under construction: {}", numUCBlocks);
266: Arpit Agarwal, info, IfStmt, LOG.info("Took {} ms to collect {} open files with leases {}", (endTimeMs - startTimeMs), iipSet.size(), ((ancestorDir != null) ? " under " + ancestorDir.getFullPathName() : "."));
309: Arpit Agarwal, warn, IfStmt, LOG.warn("The file {} is not under construction but has lease.", inodeFile.getFullPathName());
374: Arpit Agarwal, debug, IfStmt, LOG.debug("inode {} not found in lease.files (={})", inodeId, lease);
380: Arpit Agarwal, error, IfStmt, LOG.error("{} not found in sortedLeases", lease);
393: Arpit Agarwal, warn, IfStmt, LOG.warn("Removing non-existent lease! holder={} src={}", holder, src.getFullPathName());
536: Arpit Agarwal, debug, CatchClause, LOG.debug("{} is interrupted", name, ie);
538: Haohui Mai, warn, CatchClause, LOG.warn("Unexpected throwable: ", e);
558: Arpit Agarwal, info, WhileStmt, LOG.info("{} has expired hard limit", leaseToCheck);
606: Arpit Agarwal, warn, CatchClause, LOG.warn("Removing lease with an invalid path: {},{}", p, leaseToCheck, e);
589: Arpit Agarwal, warn, CatchClause, LOG.warn("Cannot release the path {} in the lease {}. It will be " + "retried.", p, leaseToCheck, e);
598: Arpit Agarwal, debug, IfStmt, LOG.debug("Started block recovery {} lease {}", p, leaseToCheck);
595: Arpit Agarwal, debug, IfStmt, LOG.debug("Lease recovery for inode {} is complete. File closed" + ".", id);
611: Arpit Agarwal, debug, IfStmt, LOG.debug("Breaking out of checkLeases after {} ms.", fsnamesystem.getMaxLockHoldToReleaseLeaseMs());
656: Todd Lipcon, warn, CatchClause, LOG.warn("Encountered exception ", ie);
96: Eli Collins, error, MethodDeclaration, LOG.error(prompt);
105: Suresh Srinivas, info, IfStmt, LOG.info("Continuing");
119: Eli Collins, error, MethodDeclaration, LOG.error("Exiting on user request.");
143: Todd Lipcon, info, MethodDeclaration, LOG.info("initialized with " + size() + " entries " + lookups + " lookups");
470: Andrew Wang, info, MethodDeclaration, LOG.info("Setting ADDRESS {}", address);
580: cnauroth, info, MethodDeclaration, LOG.info("Setting lifeline RPC address {}", lifelineRPCAddress);
706: Kihwal Lee, info, IfStmt, LOG.info("Clients are to use " + clientNamenodeAddress + " to access" + " this namenode/service.");
801: Wei-Chiu Chuang, error, CatchClause, LOG.error("Unable to load NameNode plugins. Specified list of plugins: " + pluginsValue, e);
809: Todd Lipcon, warn, CatchClause, LOG.warn("ServicePlugin " + p + " could not be started", t);
812: Arpit Agarwal, info, MethodDeclaration, LOG.info(getRole() + " RPC up at: " + getNameNodeAddress());
814: Eli Collins, info, IfStmt, LOG.info(getRole() + " service RPC up at: " + rpcServer.getServiceRpcAddress());
828: Suresh Srinivas, warn, CatchClause, LOG.warn("ServicePlugin " + p + " could not be stopped", t);
877: Suresh Srinivas, error, CatchClause, LOG.error("Exception while stopping httpserver", e);
928: Arpit Agarwal, info, IfStmt, LOG.info("Clients should use {} to access" + " this namenode/service.", clientNamenodeAddress);
959: Yongjun Zhang, warn, CatchClause, LOG.warn("Encountered exception when handling exception (" + e.getMessage() + "):", ex);
985: Suresh Srinivas, info, CatchClause, LOG.info("Caught interrupted exception ", ie);
1003: Suresh Srinivas, warn, CatchClause, LOG.warn("Encountered exception while exiting state ", e);
1090: cnauroth, info, CatchClause, LOG.info("Caught InterruptedException joining NameNodeHttpServer", e);
1161: Junping Du, warn, CatchClause, LOG.warn("Encountered exception during format: ", ioe);
1226: Andrew Wang, error, IfStmt, LOG.error("No shared edits directory configured for namespace " + nsId + " namenode " + namenodeId);
1273: Aaron Myers, error, CatchClause, LOG.error("Could not initialize shared edits dir", ioe);
1280: Junping Du, warn, CatchClause, LOG.warn("Could not close sharedEditsImage", ioe);
1289: Aaron Myers, warn, CatchClause, LOG.warn("Could not unlock storage directories", ioe);
1262: Todd Lipcon, Info, TryStmt, sharedEditsImage.getEditLog().formatNonFileJournals(nsInfo);
1322: Chris Nauroth, debug, ForeachStmt, LOG.debug("Beginning to copy stream " + stream + " to shared edits");
1327: Chris Nauroth, trace, IfStmt, LOG.trace("copying op: " + op);
1339: Chris Nauroth, debug, IfStmt, LOG.debug("ending log segment because of END_LOG_SEGMENT op in " + stream);
1346: Chris Nauroth, debug, IfStmt, LOG.debug("ending log segment because of end of stream in " + stream);
1489: Andrew Wang, error, IfStmt, LOG.error("Invalid argument: " + args[i]);
1469: Andrew Wang, error, IfStmt, LOG.error("Must specify a rolling upgrade startup option " + RollingUpgradeStartupOption.getAllOptionString());
1461: Andrew Wang, error, IfStmt, LOG.error("Unknown upgrade flag " + flag);
1447: Andrew Wang, error, IfStmt, LOG.error("Must specify a valid cluster ID after the " + StartupOption.CLUSTERID.getName() + " flag");
1400: Andrew Wang, error, IfStmt, LOG.error("Must specify a valid cluster ID after the " + StartupOption.CLUSTERID.getName() + " flag");
1410: Andrew Wang, error, IfStmt, LOG.error("Must specify a valid cluster ID after the " + StartupOption.CLUSTERID.getName() + " flag");
1543: Eli Collins, info, MethodDeclaration, MetaRecoveryContext.LOG.info("starting recovery...");
1552: Eli Collins, info, CatchClause, MetaRecoveryContext.LOG.info("RECOVERY FAILED: caught exception", e);
1555: Eli Collins, info, CatchClause, MetaRecoveryContext.LOG.info("RECOVERY FAILED: caught exception", e);
1550: Eli Collins, info, TryStmt, MetaRecoveryContext.LOG.info("RECOVERY COMPLETE");
1583: Tsz-wo Sze, info, MethodDeclaration, LOG.info("createNameNode " + Arrays.asList(argv));
1688: Andrew Wang, debug, IfStmt, LOG.debug("Setting " + FS_DEFAULT_NAME_KEY + " to " + defaultUri.toString());
1715: Andrew Wang, error, CatchClause, LOG.error("Failed to start namenode.", e);
1731: Arpit Agarwal, warn, IfStmt, LOG.warn("Remote IP {} checking available resources took {}ms", Server.getRemoteIp(), end - start);
1864: Andrew Wang, error, TryStmt, LOG.error(message, t);
1999: Todd Lipcon, warn, IfStmt, LOG.warn("Allowing manual HA control from " + Server.getRemoteAddress() + " even though automatic HA is enabled, because the user " + "specified the force flag");
2070: Xiaoyu Yao, info, TryStmt, LOG.info("RECONFIGURE* changed heartbeatInterval to " + datanodeManager.getHeartbeatInterval());
2094: Xiaoyu Yao, info, TryStmt, LOG.info("RECONFIGURE* changed heartbeatRecheckInterval to " + datanodeManager.getHeartbeatRecheckInterval());
328: Kihwal Lee, warn, CatchClause, LOG.warn(errMsg, e);
331: Kihwal Lee, Error, CatchClause, LOG.warn("Error in looking up block", e);
274: Kihwal Lee, warn, IfStmt, LOG.warn("Block " + blockId + " " + NONEXISTENT_STATUS);
438: Todd Lipcon, warn, CatchClause, LOG.warn(errMsg, e);
358: Uma Mahesh, info, IfStmt, LOG.info(sb);
366: Todd Lipcon, info, TryStmt, LOG.info(msg);
864: Eli Collins, info, IfStmt, LOG.info("Fsck: ignoring open file " + path);
902: Eli Collins, error, CatchClause, LOG.error("Fsck: error deleting corrupted file " + path, e);
900: Eli Collins, info, TryStmt, LOG.info("Fsck: deleted corrupt file " + path);
979: Eli Collins, error, CatchClause, LOG.error("copyBlocksToLostFound: error processing " + fullName, e);
931: Eli Collins, warn, IfStmt, LOG.warn("Fsck: can't copy the remains of " + fullName + " to " + "lost+found, because " + target + " already exists.");
962: Eli Collins, error, CatchClause, LOG.error("Fsck: could not copy block " + lblock.getBlock() + " to " + target, e);
975: Jing Zhao, info, IfStmt, LOG.info("Fsck: copied the remains of the corrupted file " + fullName + " to /lost+found");
972: Eli Collins, warn, IfStmt, LOG.warn("Fsck: there were errors copying the remains of the " + "corrupted file " + fullName + " to /lost+found");
1010: Todd Lipcon, info, CatchClause, LOG.info("Could not obtain block from any node:  " + ie);
1060: Todd Lipcon, info, CatchClause, LOG.info("Failed to connect to " + targetAddr + ":" + ex);
1078: Eli Collins, Error, CatchClause, LOG.error("Error reading block", e);
1122: Todd Lipcon, warn, IfStmt, LOG.warn("Cannot use /lost+found : a regular file with this name exists.");
1133: Todd Lipcon, warn, IfStmt, LOG.warn("Cannot initialize /lost+found .");
100: Haohui Mai, info, MethodDeclaration, HttpServer2.LOG.info("Added filter '" + name + "' (class=" + className + ")");
212: Suresh Srinivas, error, IfStmt, HttpServer2.LOG.error("WebHDFS and security are enabled, but configuration property '" + DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_PRINCIPAL_KEY + "' is not set.");
224: Suresh Srinivas, error, IfStmt, HttpServer2.LOG.error("WebHDFS and security are enabled, but configuration property '" + DFSConfigKeys.DFS_WEB_AUTHENTICATION_KERBEROS_KEYTAB_KEY + "' is not set.");
85: Aaron Myers, debug, IfStmt, LOG.debug("Space available on volume '" + volume + "' is " + availableSpace);
89: Aaron Myers, warn, IfStmt, LOG.warn("Space available on volume '" + volume + "' is " + availableSpace + ", which is below the configured reserved amount " + duReserved);
193: Todd Lipcon, debug, IfStmt, LOG.debug("Going to check the following volumes disk space: " + volumes);
348: Arpit Agarwal, info, IfStmt, LOG.info("Service RPC server is binding to " + bindHost + ":" + serviceRpcAddr.getPort());
406: cnauroth, info, IfStmt, LOG.info("Lifeline RPC server is binding to {}:{}", bindHost, lifelineRpcAddr.getPort());
446: Kihwal Lee, info, ConstructorDeclaration, LOG.info("RPC server is binding to " + bindHost + ":" + rpcAddr.getPort());
652: Todd Lipcon, Error, MethodDeclaration, LOG.info("Error report from " + registration + ": " + msg);
757: Todd Lipcon, debug, IfStmt, stateChangeLog.debug("*DIR* NameNode.create: file " + src + " for " + clientName + " at " + clientMachine);
792: Todd Lipcon, debug, IfStmt, stateChangeLog.debug("*DIR* NameNode.append: file " + src + " for " + clientName + " at " + clientMachine);
892: Todd Lipcon, debug, IfStmt, LOG.debug("getAdditionalDatanode: src=" + src + ", fileId=" + fileId + ", blk=" + blk + ", existings=" + Arrays.asList(existings) + ", excludes=" + Arrays.asList(excludes) + ", numAdditionalNodes=" + numAdditionalNodes + ", clientName=" + clientName);
995: Todd Lipcon, debug, IfStmt, stateChangeLog.debug("*DIR* NameNode.rename: " + src + " to " + dst);
1042: Todd Lipcon, debug, IfStmt, stateChangeLog.debug("*DIR* NameNode.rename: " + src + " to " + dst);
1068: Plamen Jeliazkov, debug, IfStmt, stateChangeLog.debug("*DIR* NameNode.truncate: " + src + " to " + newLength);
1084: Todd Lipcon, debug, IfStmt, stateChangeLog.debug("*DIR* Namenode.delete: src=" + src + ", recursive=" + recursive);
1120: Todd Lipcon, debug, IfStmt, stateChangeLog.debug("*DIR* NameNode.mkdirs: " + src);
1327: Tsz-wo Sze, info, MethodDeclaration, LOG.info("rollingUpgrade " + action);
1511: Suresh Srinivas, debug, IfStmt, blockStateChangeLog.debug("*BLOCK* NameNode.blockReport: " + "from " + nodeReg + ", reports.length=" + reports.length);
1553: Andrew Wang, debug, IfStmt, blockStateChangeLog.debug("*BLOCK* NameNode.cacheReport: " + "from " + nodeReg + " " + blockIds.size() + " blocks");
1568: Suresh Srinivas, debug, IfStmt, blockStateChangeLog.debug("*BLOCK* NameNode.blockReceivedAndDeleted: " + "from " + nodeReg + " " + receivedAndDeletedBlocks.length + " blocks.");
1599: Todd Lipcon, Error, IfStmt, LOG.info("Error report from " + dnName + ": " + msg);
1610: Todd Lipcon, Error, IfStmt, LOG.info("Error report from " + dnName + ": " + msg);
1607: Todd Lipcon, Fatal, IfStmt, LOG.warn("Fatal disk error on " + dnName + ": " + msg);
1605: Todd Lipcon, warn, IfStmt, LOG.warn("Disk error on " + dnName + ": " + msg);
1642: Tsz-wo Sze, warn, IfStmt, LOG.warn("Registration IDs mismatched: the " + nodeReg.getClass().getSimpleName() + " ID is " + id + " but the expected ID is " + expectedID);
1665: Zhe Zhang, info, MethodDeclaration, LOG.info("Refreshing all user-to-groups mappings. Requested by user: " + getRemoteUser().getShortUserName());
1673: Todd Lipcon, info, MethodDeclaration, LOG.info("Refreshing SuperUser proxy group mapping list ");
1681: Arpit Agarwal, info, MethodDeclaration, LOG.info("Refreshing call queue.");
1700: Todd Lipcon, debug, IfStmt, LOG.debug("Getting groups for user " + user);
1752: Aaron Myers, warn, IfStmt, LOG.warn(ive.getMessage() + " DN: " + dnReg);
1769: Aaron Myers, info, IfStmt, LOG.info(messagePrefix + ". Note: This is normal during a rolling upgrade.");
1766: Andrew Wang, warn, IfStmt, LOG.warn(ive.toString(), ive);
2142: Kai Zheng, trace, IfStmt, LOG.trace("No policy name is specified, " + "set the default policy name instead");
2145: Kai Zheng, trace, TryStmt, LOG.trace("Set erasure coding policy " + ecPolicyName + " on " + src);
2235: Andrew Wang, debug, CatchClause, LOG.debug("Tried to read from deleted or moved edit log segment", e);
2238: Andrew Wang, debug, CatchClause, LOG.debug("Tried to read from deleted edit log segment", e);
79: Arpit Agarwal, info, MethodDeclaration, LOG.info("{} is {}", FS_DEFAULT_NAME_KEY, nnAddr);
223: Xiaoyu Yao, warn, MethodDeclaration, LOG.warn("set restore failed storage to {}", val);
245: Todd Lipcon, info, SynchronizedStmt, LOG.info("NNStorage.attemptRestoreRemovedStorage: check removed(failed) " + "storage. removedStorages size = {}", removedStorageDirs.size());
249: Xiaoyu Yao, info, ForeachStmt, LOG.info("currently disabled dir {}; type={} ;canwrite={}", root.getAbsolutePath(), sd.getStorageDirType(), FileUtil.canWrite(root));
253: Xiaoyu Yao, info, IfStmt, LOG.info("restoring dir {}", sd.getRoot().getAbsolutePath());
350: Jitendra Nath Pandey, Error, CatchClause, LOG.warn("Error converting file to URI", ioe);
513: Xiaoyu Yao, warn, CatchClause, LOG.warn("writeTransactionIdToStorage failed on {}", sd, e);
583: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Storage directory {} has been successfully formatted.", sd.getRoot());
864: Xiaoyu Yao, Error, MethodDeclaration, LOG.error("Error reported on storage directory {}", sd);
868: Xiaoyu Yao, debug, IfStmt, LOG.debug("current list of storage dirs:{}", lsd);
871: Xiaoyu Yao, warn, MethodDeclaration, LOG.warn("About to remove corresponding storage: {}", sd.getRoot().getAbsolutePath());
876: Xiaoyu Yao, warn, CatchClause, LOG.warn("Unable to unlock bad storage directory: {}", sd.getRoot().getPath(), e);
886: Xiaoyu Yao, debug, IfStmt, LOG.debug("at the end current list of storage dirs:{}", lsd);
918: Xiaoyu Yao, warn, IfStmt, LOG.warn("Clusterid mismatch - current clusterid: {}, Ignoring " + "given clusterid: {}", getClusterID(), startOpt.getClusterId());
923: Xiaoyu Yao, info, IfStmt, LOG.info("Using clusterid: {}", getClusterID());
999: Xiaoyu Yao, warn, CatchClause, LOG.warn("this sd not available: {}", e.getLocalizedMessage());
992: Xiaoyu Yao, info, TryStmt, LOG.info("current cluster id for sd={};lv={};" + "cid={}", sd.getCurrentDir(), layoutVersion, cid);
1002: Todd Lipcon, warn, MethodDeclaration, LOG.warn("couldn't find any VERSION file containing valid ClusterId");
1016: Todd Lipcon, warn, CatchClause, LOG.warn("Could not find ip address of \"default\" inteface.");
1083: Akira Ajisaka, warn, IfStmt, FSImage.LOG.warn("Storage directory " + sd + " contains no VERSION file. Skipping...");
1159: Xiaoyu Yao, Error, CatchClause, LOG.warn("Error during write properties to the VERSION file to {}", sd, e);
203: Todd Lipcon, info, MethodDeclaration, LOG.info("Going to retain " + toRetain + " images with txid >= " + minTxId);
219: Aaron Myers, info, MethodDeclaration, LOG.info("Purging old edit log " + log);
225: Aaron Myers, info, MethodDeclaration, LOG.info("Purging old image " + image);
286: Kihwal Lee, info, WhileStmt, LOG.info("Deleting " + fileName);
290: Kihwal Lee, warn, IfStmt, LOG.warn("Failed to delete image file: " + fileToDelete);
58: Todd Lipcon, info, IfStmt, LOG.info("Storage directory " + sd.getRoot() + " does not contain previous fs state.");
90: Todd Lipcon, info, IfStmt, LOG.info("Directory " + prevDir + " does not exist.");
91: Todd Lipcon, info, IfStmt, LOG.info("Finalize upgrade for " + sd.getRoot() + " is not required.");
94: Todd Lipcon, info, MethodDeclaration, LOG.info("Finalizing upgrade of storage directory " + sd.getRoot());
101: Todd Lipcon, info, MethodDeclaration, LOG.info("Finalize upgrade for " + sd.getRoot() + " is complete.");
117: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting upgrade of storage directory " + sd.getRoot());
184: Todd Lipcon, info, MethodDeclaration, LOG.info("Performing upgrade of storage directory " + sd.getRoot());
200: Todd Lipcon, error, CatchClause, LOG.error("Unable to rename temp to previous for " + sd.getRoot(), ioe);
234: Todd Lipcon, info, MethodDeclaration, LOG.info("Rollback of " + sd.getRoot() + " is complete.");
177: Todd Lipcon, info, IfStmt, LOG.info("Fast-forwarding stream '" + streams[curIdx].getName() + "' to transaction ID " + (prevTxId + 1));
222: Todd Lipcon, error, SwitchStmt, LOG.error("Got error reading edit log input stream " + streams[curIdx].getName() + "; failing over to edit log " + streams[curIdx + 1].getName(), prevException);
238: Todd Lipcon, error, IfStmt, LOG.error("failing over to edit log " + streams[curIdx + 1].getName());
156: Xiao Chen, info, MethodDeclaration, LOG.info("Pausing re-encrypt handler for testing.");
163: Xiao Chen, info, MethodDeclaration, LOG.info("Resuming re-encrypt handler for testing.");
205: Xiao Chen, warn, IfStmt, LOG.warn("Re-encryption batch size is {}. It could cause edit log buffer " + "to be full and trigger a logSync within the writelock, greatly " + "impacting namenode throughput.", reencryptBatchSize);
212: Xiao Chen, info, ConstructorDeclaration, LOG.info("Configured throttleLimitHandlerRatio={} for re-encryption", throttleLimitHandlerRatio);
238: Xiao Chen, info, MethodDeclaration, LOG.info("Execution rejected, executing in current thread");
268: Xiao Chen, info, MethodDeclaration, LOG.info("Removing zone {} from re-encryption.", zoneId);
325: Xiao Chen, info, MethodDeclaration, LOG.info("Starting up re-encrypt thread with interval={} millisecond.", interval);
334: Xiao Chen, info, CatchClause, LOG.info("Re-encrypt handler interrupted. Exiting");
347: Xiao Chen, info, TryStmt, LOG.info("Executing re-encrypt commands on zone {}. Current zones:{}", zoneId, getReencryptionStatus());
358: Xiao Chen, info, CatchClause, LOG.info("Re-encryption caught exception, will retry", re);
361: Xiao Chen, warn, CatchClause, LOG.warn("IOException caught when re-encrypting zone {}", zoneId, ioe);
363: Xiao Chen, info, CatchClause, LOG.info("Re-encrypt handler interrupted. Exiting.");
367: Xiao Chen, error, CatchClause, LOG.error("Re-encrypt handler thread exiting. Exception caught when" + " re-encrypting zone {}.", zoneId, t);
395: Xiao Chen, info, IfStmt, LOG.info("Directory with id {} removed during re-encrypt, skipping", zoneId);
400: Xiao Chen, info, IfStmt, LOG.info("Cannot re-encrypt directory with id {} because it's not a" + " directory.", zoneId);
408: Xiao Chen, info, TryStmt, LOG.info("Re-encrypting zone {}(id={})", zoneNode.getFullPathName(), zoneId);
421: Xiao Chen, info, TryStmt, LOG.info("Submission completed of zone {} for re-encryption.", zoneId);
448: Xiao Chen, info, MethodDeclaration, LOG.info("Re-encryption completed on zone {}. Re-encrypted {} files," + " failures encountered: {}.", zoneNode.getFullPathName(), zs.getFilesReencrypted(), zs.getNumReencryptionFailures());
538: Xiao Chen, info, MethodDeclaration, LOG.info("Processing batched re-encryption for zone {}, batch size {}," + " start:{}", zoneNodeId, batch.size(), batch.getFirstFilePath());
551: Xiao Chen, info, MethodDeclaration, LOG.info("{} re-encrypting one batch of {} edeks from KMS," + " time consumed: {}, start: {}.", result, batch.size(), kmsSW.stop(), batch.getFirstFilePath());
569: Xiao Chen, warn, CatchClause, LOG.warn("Failed to re-encrypt one batch of {} edeks, start:{}", batch.size(), batch.getFirstFilePath(), ex);
589: Rakesh Radhakrishnan, debug, MethodDeclaration, LOG.debug("Notifying handler for new re-encryption command.");
617: Rakesh Radhakrishnan, info, WhileStmt, LOG.info("Sleeping in the re-encrypt handler for unit test.");
621: Rakesh Radhakrishnan, info, WhileStmt, LOG.info("Continuing re-encrypt handler after pausing.");
642: Rakesh Radhakrishnan, trace, IfStmt, LOG.trace("Processing {} for re-encryption", inode.getFullPathName());
650: Rakesh Radhakrishnan, warn, IfStmt, LOG.warn("File {} skipped re-encryption because it is not encrypted! " + "This is very likely a bug.", inode.getId());
658: Rakesh Radhakrishnan, debug, IfStmt, LOG.debug("File {} skipped re-encryption because edek's key version" + " name is not changed.", inode.getFullPathName());
718: Rakesh Radhakrishnan, info, MethodDeclaration, LOG.info("Submitted batch (start:{}, size:{}) of zone {} to re-encrypt.", currentBatch.getFirstFilePath(), currentBatch.size(), zoneId);
750: Rakesh Radhakrishnan, debug, IfStmt, LOG.debug("Re-encryption handler throttling because queue size {} is" + "larger than number of cores {}", taskQueue.size(), numCores);
762: Rakesh Radhakrishnan, debug, IfStmt, LOG.debug("Re-encryption handler throttling because total tasks pending" + " re-encryption updater is {}", numTasks);
778: Rakesh Radhakrishnan, debug, IfStmt, LOG.debug("Re-encryption handler throttling expect: {}, actual: {}," + " throttleTimerAll:{}", expect, actual, throttleTimerAll.now(TimeUnit.MILLISECONDS));
789: Rakesh Radhakrishnan, debug, IfStmt, LOG.debug("Throttling re-encryption, sleeping for {} ms", sleepMs);
815: Rakesh Radhakrishnan, info, IfStmt, LOG.info("{}({}) is a nested EZ, skipping for re-encryption", inode.getFullPathName(), inode.getId());
109: Xiao Chen, info, IfStmt, LOG.info("Cancelling {} re-encryption tasks", tasks.size());
195: Xiao Chen, info, MethodDeclaration, LOG.info("Pausing re-encrypt updater for testing.");
202: Xiao Chen, info, MethodDeclaration, LOG.info("Resuming re-encrypt updater for testing.");
266: Xiao Chen, warn, CatchClause, LOG.warn("Re-encryption updater thread interrupted. Exiting.");
271: Xiao Chen, warn, CatchClause, LOG.warn("Re-encryption updater thread exception.", e);
273: Xiao Chen, error, CatchClause, LOG.error("Re-encryption updater thread exiting.", t);
296: Xiao Chen, debug, IfStmt, LOG.debug("Updating file xattrs for re-encrypting zone {}," + " starting at {}", zoneNodePath, task.batch.getFirstFilePath());
304: Xiao Chen, trace, ForStmt, LOG.trace("Updating {} for re-encryption.", entry.getInodeId());
307: Xiao Chen, debug, IfStmt, LOG.debug("INode {} doesn't exist, skipping re-encrypt.", entry.getInodeId());
320: Xiao Chen, debug, IfStmt, LOG.debug("Inode {} EZ key changed, skipping re-encryption.", entry.getInodeId());
327: Xiao Chen, debug, IfStmt, LOG.debug("Inode {} EZ key version unchanged, skipping re-encryption.", entry.getInodeId());
335: Xiao Chen, debug, IfStmt, LOG.debug("Inode {} existing edek changed, skipping re-encryption", entry.getInodeId());
352: Xiao Chen, info, IfStmt, LOG.info("Updated xattrs on {}({}) files in zone {} for re-encryption," + " starting:{}.", task.numFilesUpdated, batchSize, zoneNodePath, task.batch.getFirstFilePath());
396: Xiao Chen, debug, WhileStmt, LOG.debug("Updating re-encryption checkpoint with completed task." + " last: {} size:{}.", task.lastFile, task.batch.size());
406: Xiao Chen, warn, CatchClause, LOG.warn("Failed to update re-encrypted progress to xattr for zone {}", zonePath, ie);
414: Xiao Chen, debug, IfStmt, LOG.debug("Removed re-encryption tracker for zone {} because it completed" + " with {} tasks.", zonePath, tracker.numCheckpointed);
427: Xiao Chen, debug, IfStmt, LOG.debug("Skipped a canceled re-encryption task");
441: Xiao Chen, info, CatchClause, LOG.info("Exception when processing re-encryption task for zone {}, " + "retrying...", task.zoneId, re);
446: Xiao Chen, warn, CatchClause, LOG.warn("Failure processing re-encryption task for zone {}", task.zoneId, ioe);
474: Xiao Chen, info, TryStmt, LOG.info("Processing returned re-encryption task for zone {}({}), " + "batch size {}, start:{}", zonePath, task.zoneId, task.batch.size(), task.batch.getFirstFilePath());
481: Xiao Chen, info, IfStmt, LOG.info("Re-encryption was canceled.");
512: Xiao Chen, info, WhileStmt, LOG.info("Sleeping in the re-encryption updater for unit test.");
514: Xiao Chen, info, WhileStmt, LOG.info("Continuing re-encryption updater after pausing.");
531: Xiao Chen, debug, IfStmt, LOG.debug("Re-encryption updater throttling expect: {}, actual: {}," + " throttleTimerAll:{}", expect, actual, throttleTimerAll.now(TimeUnit.MILLISECONDS));
543: Xiao Chen, debug, IfStmt, LOG.debug("Throttling re-encryption, sleeping for {} ms", sleepMs);
261: Jing Zhao, info, MethodDeclaration, LOG.info("Checkpoint Period   :" + checkpointConf.getPeriod() + " secs " + "(" + checkpointConf.getPeriod() / 60 + " min)");
263: Todd Lipcon, info, MethodDeclaration, LOG.info("Log Size Trigger    :" + checkpointConf.getTxnCount() + " txns");
274: Suresh Srinivas, debug, CatchClause, LOG.debug("Exception ", ie);
289: Eli Collins, info, CatchClause, LOG.info("Interrupted waiting to join on checkpointer thread");
299: Todd Lipcon, warn, CatchClause, LOG.warn("Exception shutting down SecondaryNameNode", e);
311: Jitendra Nath Pandey, warn, CatchClause, LOG.warn("Exception while closing CheckpointStorage", e);
365: Jitendra Nath Pandey, error, CatchClause, LOG.error("Exception in doCheckpoint", e);
370: Daryn Sharp, fatal, IfStmt, LOG.fatal("Merging failed " + checkpointImage.getMergeErrorCount() + " times.");
375: Eli Collins, fatal, CatchClause, LOG.fatal("Throwable Exception in doCheckpoint", e);
421: Aaron Myers, info, IfStmt, LOG.info("Image has changed. Downloading updated image from NN.");
419: Todd Lipcon, info, IfStmt, LOG.info("Image has not changed. Will not download image.");
462: Jing Zhao, debug, MethodDeclaration, LOG.debug("Will connect to NameNode at " + address);
500: Andrew Wang, info, MethodDeclaration, LOG.info("Web server init done");
585: Todd Lipcon, warn, MethodDeclaration, LOG.warn("Checkpoint done. New Image Size: " + dstStorage.getFsImageName(txid).length());
593: Kihwal Lee, warn, CatchClause, LOG.warn("Failed to write legacy OIV image: ", e);
645: Todd Lipcon, error, CatchClause, LOG.error(cmd + ": " + ex.getLocalizedMessage());
643: Todd Lipcon, error, TryStmt, LOG.error(cmd + ": " + content[0]);
652: Todd Lipcon, error, CatchClause, LOG.error(cmd + ": " + e.getLocalizedMessage());
679: Eli Collins, fatal, IfStmt, LOG.fatal("Failed to parse options");
706: Vinayakumar B, fatal, CatchClause, LOG.fatal("Failed to start secondary namenode", e);
880: Todd Lipcon, error, CatchClause, LOG.error(pe.getMessage());
987: Todd Lipcon, info, IfStmt, LOG.info("Formatting storage directory " + sd);
1067: Aaron Myers, warn, IfStmt, LOG.warn("Failed to delete temporary edits file: " + t.getAbsolutePath());
121: Todd Lipcon, info, MethodDeclaration, LOG.info("Downloaded file " + dstFiles.get(0).getName() + " size " + dstFiles.get(0).length() + " bytes.");
140: Andrew Wang, info, MethodDeclaration, LOG.info("Downloaded file " + dstFiles.get(0).getName() + " size " + dstFiles.get(0).length() + " bytes.");
164: Todd Lipcon, debug, IfStmt, LOG.debug("Dest file: " + f);
160: Todd Lipcon, info, IfStmt, LOG.info("Skipping download of remote edit log " + log + " since it already is stored locally at " + f);
174: Aaron Myers, info, MethodDeclaration, LOG.info("Downloaded file " + tmpFiles.get(0).getName() + " size " + finalFiles.get(0).length() + " bytes.");
185: Aaron Myers, debug, IfStmt, LOG.debug("Renaming " + tmpFile + " to " + finalizedFile);
189: Aaron Myers, warn, IfStmt, LOG.warn("Unable to rename edits file from " + tmpFile + " to " + finalizedFile);
240: Andrew Wang, info, MethodDeclaration, LOG.info("Uploaded image with txid " + txid + " to namenode at " + fsName + " in " + xferSec + " seconds");
396: Yongjun Zhang, info, IfStmt, LOG.info(reportStr);
394: Yongjun Zhang, info, IfStmt, LOG.info(reportStr, ioe);
372: Todd Lipcon, warn, IfStmt, LOG.warn("SIMULATING A CORRUPT BYTE IN IMAGE TRANSFER!");
415: Jing Zhao, info, MethodDeclaration, LOG.info("Opening connection to " + url);
435: Jing Zhao, info, IfStmt, LOG.info("Image Transfer timeout configured to " + timeout + " milliseconds");
176: Aaron T. Myers, warn, CatchClause, LOG.warn("Unable to fetch namespace information from remote NN at " + otherIpcAddress + ": " + ioe.getMessage());
179: Aaron T. Myers, debug, IfStmt, LOG.debug("Full exception trace", ioe);
185: Aaron T. Myers, fatal, IfStmt, LOG.fatal("Unable to fetch namespace information from any remote NN. Possible NameNodes: " + remoteNNs);
192: Tsz-wo Sze, fatal, IfStmt, LOG.fatal("Layout version on remote node (" + nsInfo.getLayoutVersion() + ") does not match " + "this node's layout version (" + HdfsServerConstants.NAMENODE_LAYOUT_VERSION + ")");
279: Jing Zhao, warn, CatchClause, LOG.warn("The storage directory is in an inconsistent state", e);
301: Jing Zhao, error, CatchClause, LOG.error("Failed to move aside pre-upgrade storage " + "in image directory " + sd.getRoot(), e);
385: Arpit Agarwal, fatal, CatchClause, LOG.fatal(msg, e);
417: Aaron T. Myers, info, ForeachStmt, LOG.info("Found nn: " + info.getNameNodeID() + ", ipc: " + info.getIpcAddress());
419: Aaron T. Myers, error, IfStmt, LOG.error("Could not determine valid IPC address for other NameNode (" + info.getNameNodeID() + ") , got: " + address);
172: Aaron Myers, info, IfStmt, LOG.info("Not going to trigger log rolls on active node because " + DFSConfigKeys.DFS_HA_LOGROLL_PERIOD_KEY + " is negative.");
169: Aaron T. Myers, info, IfStmt, LOG.info("Will roll logs on active node every " + (logRollPeriodMs / 1000) + " seconds.");
190: Aaron T. Myers, error, IfStmt, LOG.error("Specified a non-positive number of retries for the number of retries for the " + "namenode connection when manipulating the edit log (" + DFSConfigKeys.DFS_HA_TAILEDITS_ALL_NAMESNODES_RETRY_KEY + "), setting to default: " + DFSConfigKeys.DFS_HA_TAILEDITS_ALL_NAMESNODES_RETRY_DEFAULT);
205: Aaron Myers, debug, ConstructorDeclaration, LOG.debug("logRollPeriodMs=" + logRollPeriodMs + " sleepTime=" + sleepTimeMs);
220: Todd Lipcon, warn, CatchClause, LOG.warn("Edit log tailer thread exited with an exception");
270: Todd Lipcon, debug, IfStmt, LOG.debug("lastTxnId: " + lastTxnId);
285: Todd Lipcon, debug, IfStmt, LOG.debug("edit streams to load from: " + streams.size());
299: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug(String.format("Loaded %d edits starting from txid %d ", editsLoaded, lastTxnId));
348: Aaron T. Myers, info, MethodDeclaration, LOG.info("Triggering log roll on remote NameNode");
359: Harsh J, info, IfStmt, LOG.info("Skipping log roll. Remote node is not in Active state: " + ioe.getMessage().split("\n")[0]);
364: Lei Xu, warn, CatchClause, LOG.warn("Unable to trigger a roll of the active NN", e);
369: Lei Xu, warn, CatchClause, LOG.warn(String.format("Unable to finish rolling edits in %d ms", rollEditsTimeoutMs));
372: Lei Xu, warn, CatchClause, LOG.warn("Unable to trigger a roll of the active NN", e);
434: Aaron Myers, Error, CatchClause, LOG.warn("Error while reading edits from disk. Will try again.", elie);
439: Eli Collins, fatal, CatchClause, LOG.fatal("Unknown error encountered while tailing edits. " + "Shutting down standby NN.", t);
447: Todd Lipcon, warn, CatchClause, LOG.warn("Edit log tailer interrupted", e);
488: Aaron T. Myers, warn, IfStmt, LOG.warn("Failed to reach remote node: " + currentNN + ", retrying with remaining remote NNs");
518: Aaron T. Myers, info, CatchClause, LOG.info("Failed to reach " + currentNN, e);
139: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting standby checkpoint thread...\n" + "Checkpointing active NN to possible NNs: {}\n" + "Serving checkpoints at {}", activeNNAddresses, myNNAddress);
152: Todd Lipcon, warn, CatchClause, LOG.warn("Edit log tailer thread exited with an exception");
180: Todd Lipcon, info, IfStmt, LOG.info("A checkpoint was triggered but the Standby Node has not " + "received any transactions since the last checkpoint at txid {}. " + "Skipping...", thisCheckpointTxId);
205: Erik Krogen, warn, CatchClause, LOG.warn("Exception encountered while saving legacy OIV image; " + "continuing with other checkpointing steps", ioe);
445: Steve Loughran, info, CatchClause, LOG.info("Checkpoint was cancelled: {}", ce.getMessage());
448: Andrew Wang, info, CatchClause, LOG.info("Interrupted during checkpointing", ie);
452: Todd Lipcon, error, CatchClause, LOG.error("Exception in doCheckpoint", t);
410: Steve Loughran, info, IfStmt, LOG.info("Triggering checkpoint because it has been {} seconds " + "since the last checkpoint, which exceeds the configured " + "interval {}", secsSinceLast, checkpointConf.getPeriod());
404: Steve Loughran, info, IfStmt, LOG.info("Triggering checkpoint because there have been {} txns " + "since the last checkpoint, " + "which exceeds the configured threshold {}", uncheckpointed, checkpointConf.getTxnCount());
402: Jing Zhao, info, IfStmt, LOG.info("Triggering a rollback fsimage for rolling upgrade.");
419: Aaron T. Myers, info, IfStmt, LOG.info("But skipping this checkpoint since we are about to failover!");
442: Xiaoyu Yao, info, IfStmt, LOG.info("Checkpoint finished successfully.");
43: Tsz-Wo Nicholas Sze, info, IfStmt, log.info("SkipList is disabled");
39: Tsz-Wo Nicholas Sze, info, IfStmt, log.info("SkipList is enabled with skipInterval=" + skipInterval + ", maxLevels=" + maxLevels);
500: Arpit Agarwal, error, IfStmt, FSImage.LOG.error("FSImageFormatPBSnapshot: Missing referred INodeId " + ref.getId() + " for INodeReference index " + refIndex + "; path=" + ref.getFullPathName() + "; parent=" + (ref.getParent() == null ? "null" : ref.getParent().getFullPathName()));
609: Arpit Agarwal, error, IfStmt, FSImage.LOG.error("Name '" + d.getLocalName() + "' is repeated in the " + "'deleted' difflist of directory " + dir.getFullPathName() + ", INodeId=" + dir.getId());
627: Arpit Agarwal, error, IfStmt, FSImage.LOG.error("Misordered entries in the 'deleted' difflist of directory " + dir.getFullPathName() + ", INodeId=" + dir.getId() + ". The full list is " + Arrays.toString(deleted.toArray()));
124: Yongjun Zhang, info, ConstructorDeclaration, LOG.info("Loaded config captureOpenFiles: " + captureOpenFiles + ", skipCaptureAccessTimeOnlyChange: " + skipCaptureAccessTimeOnlyChange + ", snapshotDiffAllowSnapRootDescendant: " + snapshotDiffAllowSnapRootDescendant + ", maxSnapshotLimit: " + maxSnapshotLimit);
58: Andrew Wang, error, CatchClause, LOG.error("An error occurred while reflecting the event in top service, " + "event: (cmd={},userName={})", cmd, userName);
78: Andrew Wang, debug, IfStmt, LOG.debug("------------------- logged event for top service: " + sb);
76: Andrew Wang, info, MethodDeclaration, LOG.info("NNTop conf: " + DFSConfigKeys.NNTOP_BUCKETS_PER_WINDOW_KEY + " = " + conf.get(DFSConfigKeys.NNTOP_BUCKETS_PER_WINDOW_KEY));
78: Andrew Wang, info, MethodDeclaration, LOG.info("NNTop conf: " + DFSConfigKeys.NNTOP_NUM_USERS_KEY + " = " + conf.get(DFSConfigKeys.NNTOP_NUM_USERS_KEY));
80: Andrew Wang, info, MethodDeclaration, LOG.info("NNTop conf: " + DFSConfigKeys.NNTOP_WINDOWS_MINUTES_KEY + " = " + conf.get(DFSConfigKeys.NNTOP_WINDOWS_MINUTES_KEY));
135: Andrew Wang, debug, MethodDeclaration, LOG.debug("a metric is reported: cmd: {} user: {}", cmd, userName);
182: Andrew Wang, debug, IfStmt, LOG.debug("Sum: + " + sum + " Bucket: updateTime: " + timeStr + " (" + bucketTime + ") isStale " + stale + " at " + time);
192: Xiaoyu Yao, debug, MethodDeclaration, LOG.debug("iterating in reported metrics, size={} values={}", metricNames.size(), metricNames);
238: Andrew Wang, debug, IfStmt, LOG.debug("gc window of metric: {} userName: {}", metricName, userName);
243: Andrew Wang, debug, WhileStmt, LOG.debug("offer window of metric: {} userName: {} sum: {}", metricName, userName, windowSum);
247: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("topN users size for command {} is: {}", metricName, topN.size());
160: Tsz-wo Sze, trace, IfStmt, LOG.trace("HTTP " + op.getValue().getType() + ": " + op + ", " + path + ", ugi=" + ugi + ", " + username + ", " + doAsUser + Param.toSortedString(", ", parameters));
410: Tsz-wo Sze, trace, IfStmt, LOG.trace("redirectURI=" + uri);
156: Haohui Mai, debug, IfStmt, LOG.debug("Cancelled token for " + token.getService());
169: Haohui Mai, debug, IfStmt, LOG.debug("Renewed token for " + token.getService() + " until: " + new Date(result));
189: Vinayakumar B, debug, IfStmt, LOG.debug("Fetched token " + fs.getUri() + " for " + token.getService() + " into " + tokenFile);
2351: Aaron Myers, debug, IfStmt, LOG.debug("Exception encountered:", debugException);
74: Todd Lipcon, debug, IfStmt, LOG.debug("Using NN principal: " + nameNodePrincipal);
158: Todd Lipcon, info, ConstructorDeclaration, LOG.info("Failover controller configured for NameNode " + localTarget);
197: Arpit Agarwal, fatal, CatchClause, LOG.fatal("DFSZKFailOverController exiting due to earlier exception " + t);
209: Todd Lipcon, info, IfStmt, LOG.info("Allowed RPC access from " + ugi + " at " + Server.getRemoteAddress());
214: Todd Lipcon, warn, MethodDeclaration, LOG.warn(msg);
249: Akira Ajisaka, warn, CatchClause, LOG.warn("Can't get local NN thread dump due to " + e.getMessage());
246: Akira Ajisaka, info, TryStmt, LOG.info(localNNThreadDumpContent);
175: Anu Engineer, error, CatchClause, LOG.error(ex.toString());
76: Aaron Myers, debug, IfStmt, LOG.debug("Using NN principal: " + nameNodePrincipal);
84: Tsz-wo Sze, error, IfStmt, LOG.error("Got IOException at position " + inputStream.getPosition());
89: Tsz-wo Sze, error, CatchClause, LOG.error("Got IOException while reading stream!  Resyncing.", e);
94: Tsz-wo Sze, error, IfStmt, LOG.error("Got RuntimeException at position " + inputStream.getPosition());
99: Tsz-wo Sze, error, CatchClause, LOG.error("Got RuntimeException while reading stream!  Resyncing.", e);
117: Haohui Mai, info, MethodDeclaration, LOG.info("op=" + op + " target=" + path);
154: Andrew Wang, debug, IfStmt, LOG.debug("Loading section " + s.getName() + " length: " + s.getLength());
181: Haohui Mai, info, MethodDeclaration, LOG.info("Loading inode directory section");
203: Haohui Mai, info, MethodDeclaration, LOG.info("Loaded " + counter + " directories");
209: Haohui Mai, info, MethodDeclaration, LOG.info("Loading inode references");
222: Haohui Mai, info, MethodDeclaration, LOG.info("Loaded " + counter + " inode references");
230: Haohui Mai, info, MethodDeclaration, LOG.info("Loading " + s.getNumInodes() + " inodes.");
239: Haohui Mai, debug, MethodDeclaration, LOG.debug("Sorting inodes");
241: Haohui Mai, debug, MethodDeclaration, LOG.debug("Finished sorting inodes");
249: Haohui Mai, info, MethodDeclaration, LOG.info("Loading " + s.getNumEntry() + " strings");
223: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("Skipping XMLEvent of type " + ev.getEventType() + "(" + ev + ")");
397: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("Skipping XMLEvent " + ev);
425: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("loadNodeChildren(expected=" + expected + ", terminators=[" + StringUtils.join(",", terminators) + "]):" + parent.dump());
490: Colin Patrick Mccabe, debug, IfStmt, LOG.debug(SectionName.NS_INFO.name() + " writing header: {" + TextFormat.printToString(s) + "}");
1396: Colin Patrick Mccabe, debug, MethodDeclaration, LOG.debug("Processing SnapshotDiffSection");
1420: Colin Patrick Mccabe, debug, MethodDeclaration, LOG.debug("Processing dirDiffEntry");
1527: Colin Patrick Mccabe, debug, MethodDeclaration, LOG.debug("Processing fileDiffEntry");
1708: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Loaded <version> with onDiskVersion=" + onDiskVersion + ", layoutVersion=" + layoutVersion + ".");
1722: Colin Patrick Mccabe, debug, IfStmt, LOG.debug(SectionName.STRING_TABLE.name() + " writing header: {" + TextFormat.printToString(sectionHeader) + "}");
1736: Colin Patrick Mccabe, trace, IfStmt, LOG.trace("Writing string table entry: {" + TextFormat.printToString(stEntry) + "}");
1748: Colin Patrick Mccabe, debug, MethodDeclaration, LOG.debug("Loading <fsimage>.");
1798: Colin Patrick Mccabe, debug, IfStmt, LOG.debug("Writing FileSummary: {" + TextFormat.printToString(fileSummary) + "}");
145: Vinayakumar B, error, IfStmt, LOG.error("Failed to load image file.");
143: Vinayakumar B, error, IfStmt, LOG.error("image loading failed at offset " + tracker.getPos());
309: Andrew Wang, error, CatchClause, LOG.error("Failed to open LevelDBs", e);
470: Lei Xu, info, SwitchStmt, LOG.info("Loading string table");
507: Andrew Wang, debug, MethodDeclaration, LOG.debug("Time to output inodes: {}ms", timeTaken);
519: Andrew Wang, info, MethodDeclaration, LOG.info("Loading directories");
532: Andrew Wang, info, MethodDeclaration, LOG.info("Finished loading directories in {}ms", timeTaken);
539: Andrew Wang, info, MethodDeclaration, LOG.info("Loading INode directory section.");
552: Andrew Wang, info, MethodDeclaration, LOG.info("Finished loading INode directory section in {}ms", timeTaken);
560: Andrew Wang, info, MethodDeclaration, LOG.info("Loading directories in INode section.");
565: Andrew Wang, debug, IfStmt, LOG.debug("Scanned {} inodes.", i);
572: Andrew Wang, info, MethodDeclaration, LOG.info("Found {} directories in INode section.", numDirs);
589: Andrew Wang, debug, IfStmt, LOG.debug("Scanned {} directories.", count);
602: Andrew Wang, info, MethodDeclaration, LOG.info("Scanned {} INode directories to build namespace.", count);
607: Andrew Wang, info, MethodDeclaration, LOG.info("Found {} INodes in the INode section", s.getNumInodes());
622: Lei Xu, debug, IfStmt, LOG.debug("Exception caught, ignoring node:{}.", p.getId(), ioe);
618: Lei Xu, warn, IfStmt, LOG.warn("Exception caught, ignoring node:{}", p.getId(), ioe);
628: Andrew Wang, debug, IfStmt, LOG.debug("Outputted {} INodes.", i);
632: Lei Xu, warn, IfStmt, LOG.warn("Ignored {} nodes, including {} in snapshots. Please turn on" + " debug log for details", ignored, ignoredSnapshots);
635: Andrew Wang, info, MethodDeclaration, LOG.info("Outputted {} INodes.", s.getNumInodes());
641: Lei Xu, debug, IfStmt, LOG.debug("No snapshot name found for inode {}", inode);
77: Haohui Mai, info, CatchClause, LOG.info("Interrupted. Stopping the WebImageViewer.");
107: Haohui Mai, info, MethodDeclaration, LOG.info("WebImageViewer started. Listening on " + address.toString() + ". Press Ctrl+C to stop the viewer.");
96: Todd Lipcon, warn, IfStmt, LOG.warn("Unable to delete tmp file " + tmpFile);
111: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to abort file " + tmpFile, ioe);
114: Todd Lipcon, warn, IfStmt, LOG.warn("Unable to delete tmp file during abort " + tmpFile);
130: Andrew Wang, debug, IfStmt, LOG.debug("initial capacity=" + initialCapacity + ", max load factor= " + maxLoadFactor + ", min load factor= " + minLoadFactor);
162: Tsz-wo Sze, debug, IfStmt, LOG.debug("Saved MD5 " + digestString + " to " + md5File);
177: Tsz-wo Sze, warn, IfStmt, LOG.warn("deleting  " + fromFile.getAbsolutePath() + " FAILED");
73: Tsz-wo Sze, trace, IfStmt, LOG.trace("GOT EXCEPITION", e);
112: Tsz-wo Sze, ERROR, IfStmt, LOG.warn("INTERNAL_SERVER_ERROR", e);
97: Colin McCabe, info, MethodDeclaration, LOG.info("mlocking " + identifier);
698: Colin McCabe, info, IfStmt, LOG.info("replica " + replica + " has isAnchorable = " + slot.isAnchorable() + ", isAnchored = " + slot.isAnchored() + ".  Waiting for isAnchorable = " + expectedIsAnchorable + ", isAnchored = " + expectedIsAnchored);
40: Eli Collins, info, IfStmt, LOG.info("TestNativeCodeLoader: libhadoop.so testing is not required.");
49: Eli Collins, info, MethodDeclaration, LOG.info("TestHdfsNativeCodeLoader: libhadoop.so is loaded.");
119: Colin Patrick Mccabe, info, ForStmt, LOG.info("opening file " + i + "...");
371: Lei Xu, info, MethodDeclaration, LOG.info("Dir: {}, permission: {}", sbExplicitTestDir.getName(), hdfs.getFileStatus(sbExplicitTestDir).getPermission());
378: Lei Xu, info, MethodDeclaration, LOG.info("Dir: {}, permission: {}", sbOmittedTestDir.getName(), hdfs.getFileStatus(sbOmittedTestDir).getPermission());
385: Lei Xu, info, MethodDeclaration, LOG.info("Dir: {}, permission: {}", sbExplicitTestDir.getName(), hdfs.getFileStatus(sbExplicitTestDir).getPermission());
393: Lei Xu, info, MethodDeclaration, LOG.info("Dir: {}, permission: {}", sbOmittedTestDir.getName(), hdfs.getFileStatus(sbOmittedTestDir).getPermission());
294: Chris Douglas, info, MethodDeclaration, LOG.info("Starting testNflyWriteSimpleFailover");
170: Manoj Govindassamy, info, MethodDeclaration, LOG.info("BaseFileStat: " + baseFileStat);
173: Manoj Govindassamy, info, MethodDeclaration, LOG.info("BaseFileRelStat: " + baseFileRelStat);
180: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Level2FileStat: " + level2FileStat);
222: Manoj Govindassamy, info, MethodDeclaration, LOG.info("BaseFileStat: " + baseFileStat);
227: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Level2FileStat: " + level2FileStat);
171: Manoj Govindassamy, info, MethodDeclaration, LOG.info("File stat: " + stat);
142: Ming Ma, info, MethodDeclaration, LOG.info("Created file " + name + " with " + repl + " replicas.");
258: Ming Ma, info, MethodDeclaration, LOG.info("Taking node: " + Arrays.toString(dataNodeNames.toArray()) + " out of service");
297: Ming Ma, info, MethodDeclaration, LOG.info("Putting node: " + outOfServiceNode + " in service");
342: Ming Ma, info, WhileStmt, LOG.info("Waiting for node " + node + " to change state to " + state + " current state: " + node.getAdminState());
351: Ming Ma, info, ForeachStmt, LOG.info("node " + node + " reached the state " + state);
53: Todd Lipcon, info, InitializerDeclaration, LOG.info("seed=" + seed);
64: Todd Lipcon, info, SynchronizedStmt, LOG.info(Thread.currentThread().getName() + ": seed=" + seed);
79: Todd Lipcon, info, MethodDeclaration, LOG.info("seed=" + seed + ", size=" + size);
99: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("partition=" + Arrays.toString(p));
111: Todd Lipcon, info, CatchClause, LOG.info("ms=" + ms, e);
582: Andrew Wang, info, CatchClause, LOG.info("getFileStatus on path " + file + " failed!", e);
1598: Colin McCabe, info, IfStmt, LOG.info("verifyExpectedCacheUsage: have " + curCacheUsed + "/" + expectedCacheUsed + " bytes cached; " + curBlocks + "/" + expectedBlocks + " blocks cached. " + "memlock limit = " + NativeIO.POSIX.getCacheManipulator().getMemlockLimit() + ".  Waiting...");
1607: Colin McCabe, info, MethodDeclaration, LOG.info("verifyExpectedCacheUsage: got " + curCacheUsed + "/" + expectedCacheUsed + " bytes cached; " + curBlocks + "/" + expectedBlocks + " blocks cached. " + "memlock limit = " + NativeIO.POSIX.getCacheManipulator().getMemlockLimit());
1739: arp, info, IfStmt, LOG.info("verifyFileReplicasOnStorageType: file " + path + "does not exist");
1747: arp, info, IfStmt, LOG.info("verifyFileReplicasOnStorageType: for file " + path + ". Expect blk" + locatedBlock + " on Type: " + storageType + ". Actual Type: " + locatedBlock.getStorageTypes()[0]);
1979: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("failed to change length of block " + blk);
2275: Vinayakumar B, info, TryStmt, LOG.info("Waiting for " + metricName + " to reach value " + expectedValue + ", current value = " + currentValue);
2376: Andrew Wang, info, ForStmt, LOG.info("Closing file: " + entry.getKey());
2400: Yongjun Zhang, info, MethodDeclaration, LOG.info(report.toString());
2401: Yongjun Zhang, info, MethodDeclaration, LOG.info(inverseReport.toString() + "\n");
95: Todd Lipcon, info, ForStmt, LOG.info("Creating file " + p);
492: Arpit Agarwal, info, ConstructorDeclaration, LOG.info("starting cluster: numNameNodes=" + numNameNodes + ", numDataNodes=" + builder.numDataNodes);
869: Chris Nauroth, info, IfStmt, LOG.info("MiniDFSCluster disabling checkpointing in the Standby node " + "since no HTTP ports have been specified.");
875: Chris Nauroth, info, IfStmt, LOG.info("MiniDFSCluster disabling log-roll triggering in the " + "Standby node since no IPC ports have been specified.");
889: Chris Nauroth, error, CatchClause, LOG.error("IOE creating namenodes. Permissions dump:\n" + createPermissionsDiagnosisString(data_dir), ioe);
1258: Todd Lipcon, info, ForeachStmt, LOG.info("Copying namedir from primary node dir " + srcDir + " to " + dstDir);
1355: Steve Loughran, warn, CatchClause, NameNode.LOG.warn("unexpected URISyntaxException", e);
1389: Todd Lipcon, warn, TryStmt, LOG.warn("Waiting for namenode at " + nnIndex + " to start...");
1404: Todd Lipcon, warn, TryStmt, LOG.warn("Waiting for the Mini HDFS Cluster to start...");
1410: Jing Zhao, error, IfStmt, LOG.error(msg);
1627: Steve Loughran, info, ForStmt, LOG.info("Starting DataNode " + i + " with " + DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY + ": " + dnConf.get(DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY));
1632: Steve Loughran, info, IfStmt, LOG.info("Starting DataNode " + i + " with hostname set to: " + dnConf.get(DFSConfigKeys.DFS_DATANODE_HOST_NAME_KEY));
1637: Steve Loughran, info, IfStmt, LOG.info("Adding node with hostname : " + name + " to rack " + racks[i - curDatanodesNum]);
1692: Tsz-wo Sze, info, IfStmt, LOG.info("Adding node with service : " + service + " to rack " + racks[i - curDatanodesNum]);
1753: Arpit Agarwal, info, ForeachStmt, LOG.info("setCapacityForTesting " + storageCapacities[curDnIdx][j] + " for [" + volume.getStorageType() + "]" + volume.getStorageID());
1993: Steve Loughran, info, MethodDeclaration, LOG.info("Shutting down the Mini HDFS Cluster");
1996: Eli Collins, fatal, IfStmt, LOG.fatal("Test resulted in an unexpected exit", ExitUtil.getFirstExitException());
2007: Vinayakumar B, warn, CatchClause, LOG.warn("Exception while closing file system", ioe);
2041: Xiao Chen, info, MethodDeclaration, LOG.info("Shutting down DataNode " + dnIndex);
2074: cnauroth, info, MethodDeclaration, LOG.info("Shutting down the namenode");
2135: Steve Loughran, info, IfStmt, LOG.info("Restarted the namenode");
2275: Steve Loughran, info, MethodDeclaration, LOG.info("MiniDFSCluster Stopping DataNode " + dn.getDisplayName() + " from a total of " + (dataNodes.size() + 1) + " datanodes.");
2329: Kihwal Lee, info, MethodDeclaration, LOG.info("MiniDFSCluster Stopping DataNode " + dn.getDisplayName() + " from a total of " + (dataNodes.size() + 1) + " datanodes.");
2458: Steve Loughran, info, ForStmt, LOG.info("Restarted DataNode " + i);
2618: Todd Lipcon, info, TryStmt, LOG.info("Waiting for cluster to become active");
2665: Steve Loughran, warn, IfStmt, LOG.warn("Tried waitActive() " + failedCount + " time(s) and failed, giving up.  " + StringUtils.stringifyException(e));
2673: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Cluster is active");
2678: Aaron T. Myers, info, ForStmt, LOG.info("Have namenode " + i + ", info:" + getNN(i));
2679: Aaron T. Myers, info, ForStmt, LOG.info(" has namenode: " + getNN(i).nameNode);
2689: Aaron Myers, warn, IfStmt, LOG.warn("BPOfferService in datanode " + dn.datanode + " failed to connect to namenode at " + addr);
2697: Arpit Agarwal, Info, IfStmt, LOG.info("dnInfo.length != numDataNodes");
2704: Arpit Agarwal, info, IfStmt, LOG.info("!dn.datanode.isDatanodeFullyStarted()");
2713: Konstantin V Shvachko, info, IfStmt, LOG.info("No heartbeat from DataNode: " + dn.toString());
2721: Arpit Agarwal, info, IfStmt, LOG.info("DataNodeTestUtils.getFSDataset(dn.datanode) == null");
3219: Todd Lipcon, info, IfStmt, LOG.info("Adding datanode " + address + " to hosts file " + hostsFile);
131: Tsz-wo Sze, info, ForStmt, LOG.info("Starting DataNode " + i + " with " + DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY + ": " + dnConf.get(DFSConfigKeys.DFS_DATANODE_DATA_DIR_KEY));
136: Tsz-wo Sze, info, IfStmt, LOG.info("Starting DataNode " + i + " with hostname set to: " + dnConf.get(DFSConfigKeys.DFS_DATANODE_HOST_NAME_KEY));
146: Tsz-wo Sze, info, IfStmt, LOG.info("Adding node with hostname : " + name + " to serverGroup " + nodeGroups[i - curDatanodesNum] + " and rack " + racks[i - curDatanodesNum]);
142: Tsz-wo Sze, info, IfStmt, LOG.info("Adding node with hostname : " + name + " to rack " + racks[i - curDatanodesNum]);
181: Tsz-wo Sze, info, IfStmt, LOG.info("Adding node with IP:port : " + ipAddr + ":" + port + " to nodeGroup " + nodeGroups[i - curDatanodesNum] + " and rack " + racks[i - curDatanodesNum]);
176: Tsz-wo Sze, info, IfStmt, LOG.info("Adding node with IP:port : " + ipAddr + ":" + port + " to rack " + racks[i - curDatanodesNum]);
42: Sammi Chen, info, ConstructorDeclaration, LOG.info(schema.toString());
137: Andrew Wang, info, MethodDeclaration, LOG.info("verifyRead on path {}", testPath);
139: Andrew Wang, info, MethodDeclaration, LOG.info("verifyRead verifyLength on path {}", testPath);
141: Andrew Wang, info, MethodDeclaration, LOG.info("verifyRead verifyPread on path {}", testPath);
143: Andrew Wang, info, MethodDeclaration, LOG.info("verifyRead verifyStatefulRead on path {}", testPath);
146: Andrew Wang, info, MethodDeclaration, LOG.info("verifyRead verifyStatefulRead2 on path {}", testPath);
149: Andrew Wang, info, MethodDeclaration, LOG.info("verifyRead verifySeek on path {}", testPath);
160: Andrew Wang, info, MethodDeclaration, LOG.info("testReadWithDNFailure: file = " + src + ", fileSize = " + fileLength + ", dnFailureNum = " + dnFailureNum);
203: Andrew Wang, info, MethodDeclaration, LOG.info("testReadWithBlockCorrupted: file = " + src + ", dataBlkDelNum = " + dataBlkDelNum + ", parityBlkDelNum = " + parityBlkDelNum + ", deleteBlockFile? " + deleteBlockFile);
231: Andrew Wang, info, MethodDeclaration, LOG.info("corruptBlocks on path {}", srcPath);
262: Andrew Wang, info, IfStmt, LOG.info("Corrupting block file {}", delBlocks[i]);
258: Andrew Wang, info, IfStmt, LOG.info("Deleting block file {}", delBlocks[i]);
219: Zhe Zhang, info, MethodDeclaration, LOG.info("killDatanode " + dnIndex + ": " + datanode + ", pos=" + pos);
281: Jing Zhao, info, IfStmt, LOG.info("blockGroup " + lb.getBlock() + " of file " + src + " has reported internalBlocks " + reported + " (desired " + expected + "); locations " + Joiner.on(' ').join(lb.getLocations()));
290: Jing Zhao, info, IfStmt, LOG.info("All blockGroups of file " + src + " verified to have all internalBlocks.");
385: Jing Zhao, info, ForeachStmt, LOG.info(s);
425: Jing Zhao, info, ForStmt, LOG.info("i,j=" + i + ", " + j + ", numCellInBlock=" + numCellInBlock + ", blockSize=" + blockSize + ", lb=" + lb);
446: Jing Zhao, info, ForStmt, LOG.info("Internal blocks to check: " + checkSet);
527: Uma Maheswara Rao G, info, MethodDeclaration, LOG.info("Waiting for reconstruction to be finished for the file:" + file + ", groupSize:" + groupSize);
549: Kai Zheng, info, MethodDeclaration, LOG.info("Waiting for reconstruction to be finished for the file:" + file + ", expectedBlocks:" + expectedBlocks);
1644: Zhe Zhang, error, CatchClause, LOG.error("IOException thrown during doAs() operation", ex);
267: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("checkEverything");
436: Jing Zhao, error, MethodDeclaration, LOG.error("Worker " + name + " failed.", t);
452: Tsz-Wo Nicholas Sze, info, TryStmt, LOG.info(call());
51: Todd Lipcon, info, MethodDeclaration, LOG.info("Test testBlockMissingException started.");
69: Todd Lipcon, info, TryStmt, LOG.info("Remove first block of file");
79: Todd Lipcon, info, MethodDeclaration, LOG.info("Test testBlockMissingException completed.");
479: Kihwal Lee, error, CatchClause, LOG.error("Exception during write", e);
693: Yongjun Zhang, info, TryStmt, LOG.info("Number of nodes in pipeline: {} newNode {}", newNodes.length, newNode.getName());
700: Yongjun Zhang, info, ForStmt, LOG.info("shutdown {}", newNodes[i].getName());
224: Todd Lipcon, debug, ForStmt, LOG.debug("Corrupted block " + block.getBlockName() + " on data node " + dninfo);
272: Todd Lipcon, debug, CatchClause, LOG.debug("DfsClientReadFile caught ChecksumException.");
275: Todd Lipcon, debug, CatchClause, LOG.debug("DfsClientReadFile caught BlockMissingException.");
294: Todd Lipcon, debug, CatchClause, LOG.debug("DfsClientReadFile caught BlockMissingException.");
302: Todd Lipcon, info, MethodDeclaration, LOG.info(outStr);
311: Todd Lipcon, info, MethodDeclaration, LOG.info(outStr);
317: Todd Lipcon, info, MethodDeclaration, LOG.info("fsck -list-corruptfileblocks out: " + outStr);
60: Todd Lipcon, info, MethodDeclaration, LOG.info("Reading from file of size " + in.getFileLength() + " at offset " + in.getPos());
104: Todd Lipcon, info, MethodDeclaration, LOG.info("opened " + testFile.toString());
140: Kihwal Lee, info, CatchClause, DFSClient.LOG.info("Got expected exception", ioe);
187: Lei Xu, info, IfStmt, LOG.info("Deliberately truncating meta file for block " + eb + " to size " + newSize + " bytes.");
183: Lei Xu, info, IfStmt, LOG.info("Deliberately removing meta for block " + eb);
201: Lei Xu, info, TryStmt, LOG.info("All File still have a valid replica");
297: Todd Lipcon, info, CatchClause, DFSClient.LOG.info("Got expected exception", ioe);
260: Aaron Myers, info, CatchClause, LOG.info("Got expected exception", ive);
313: Aaron Myers, info, CatchClause, LOG.info("Got expected exception", ive);
129: Tsz-wo Sze, info, TryStmt, LOG.info("XXX shutdown datanode " + last.getDatanodeUuid());
104: Todd Lipcon, info, IfStmt, LOG.info("Testing : " + testDescription);
106: Todd Lipcon, info, TryStmt, LOG.info("Going to write:" + StringUtils.byteToHexString(sendBuf.toByteArray()));
124: Todd Lipcon, info, IfStmt, LOG.info("Got EOF as expected.");
132: Tsz-wo Sze, info, TryStmt, LOG.info("Received: " + received);
133: Tsz-wo Sze, info, TryStmt, LOG.info("Expected: " + expected);
126: Matthew Foley, info, IfStmt, LOG.info("Block " + blk.getBlock() + " replica on " + nodes[j] + " is decommissioned.");
137: Todd Lipcon, info, ForeachStmt, LOG.info("Block " + blk.getBlock() + " has " + hasdown + " decommissioned replica.");
187: Brandon Li, info, MethodDeclaration, LOG.info("Starting test testDecommission");
361: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting test testDecommission");
426: Chris Douglas, info, TryStmt, LOG.info("Starting test testRecommission");
482: Chris Douglas, info, MethodDeclaration, LOG.info(sb.toString());
483: Chris Douglas, info, MethodDeclaration, LOG.info("Count: " + count);
519: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting test testClusterStats");
595: Todd Lipcon, info, ForStmt, LOG.info("Waiting for datanode to be marked dead");
614: Jing Zhao, info, MethodDeclaration, LOG.info("Starting test testDecommissionWithOpenfile");
678: Manoj Govindassamy, info, MethodDeclaration, LOG.info(message + " - stdout: \n" + outStr);
695: Manoj Govindassamy, info, IfStmt, LOG.info("Open files that are not listed yet: " + openFilesNotListed);
757: Manoj Govindassamy, warn, CatchClause, LOG.warn("Unexpected exception: " + e);
770: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Starting test testDecommissionWithOpenfileReporting");
821: Manoj Govindassamy, info, MethodDeclaration, LOG.info("XXX Dn to decommission: " + dnToDecommission + ", max: " + maxDnOccurance);
849: Manoj Govindassamy, warn, CatchClause, LOG.warn("Encountered exception during redundancy monitor: " + e);
917: Masatake Iwasaki, info, MethodDeclaration, LOG.info("Starting test testCloseWhileDecommission");
970: Kihwal Lee, info, MethodDeclaration, LOG.info("Starting test testDecommissionWithNamenodeRestart");
1021: Ming Ma, info, MethodDeclaration, LOG.info("Starting test testDeadNodeCountAfterNamenodeRestart");
1084: Chris Douglas, info, MethodDeclaration, LOG.info("Waiting for DN to be marked as dead.");
1095: Chris Douglas, warn, CatchClause, LOG.warn("Failed to check dead DNs", e);
1110: Chris Douglas, info, MethodDeclaration, LOG.info("Waiting for DN to come back.");
1125: Chris Douglas, warn, CatchClause, LOG.warn("Failed to check dead DNs", e);
1433: Ming Ma, warn, CatchClause, LOG.warn("Check file: " + e);
1429: Ming Ma, warn, IfStmt, LOG.warn("Check file: " + errMsg);
161: Jing Zhao, info, MethodDeclaration, LOG.info("Starting test testFileFullBlockGroup");
167: Zhe Zhang, info, MethodDeclaration, LOG.info("Starting test testFileMultipleBlockGroups");
174: Jing Zhao, info, MethodDeclaration, LOG.info("Starting test testFileSmallerThanOneCell");
180: Jing Zhao, info, MethodDeclaration, LOG.info("Starting test testFileSmallerThanOneStripe");
186: Jing Zhao, info, MethodDeclaration, LOG.info("Starting test testDecommissionTwoNodes");
192: Jing Zhao, info, MethodDeclaration, LOG.info("Starting test testDecommissionWithURBlocksForSameBlockGroup");
225: Jing Zhao, info, IfStmt, LOG.info("stop datanode " + dn.getDatanodeId().getHostName());
241: Jing Zhao, error, CatchClause, LOG.error("Exception while decommissioning", e);
254: Jing Zhao, info, ForeachStmt, LOG.info("Restarts stopped datanode:{} to trigger block reconstruction", dnp.datanode);
259: Jing Zhao, info, MethodDeclaration, LOG.info("Waiting to finish decommissioning node:{}", decommisionNodes);
261: Jing Zhao, info, MethodDeclaration, LOG.info("Finished decommissioning node:{}", decommisionNodes);
292: Kai Zheng, info, MethodDeclaration, LOG.info("Starting test testFileChecksumAfterDecommission");
317: Kai Zheng, info, MethodDeclaration, LOG.info("fileChecksum1:" + fileChecksum1);
318: Kai Zheng, info, MethodDeclaration, LOG.info("fileChecksum2:" + fileChecksum2);
488: Jing Zhao, info, ForeachStmt, LOG.info("Decommissioning node: " + dn.getName());
510: Jing Zhao, info, WhileStmt, LOG.info("Waiting for node " + node + " to change state to " + state + " current state: " + node.getAdminState());
519: Jing Zhao, info, MethodDeclaration, LOG.info("node " + node + " reached the state " + state);
546: Jing Zhao, info, ForStmt, LOG.info("Block Locations size={}, locs={}, j=", nodes.length, nodes[j].toString(), j);
567: Jing Zhao, info, IfStmt, LOG.info("Block " + blk.getBlock() + " replica on " + nodes[j] + " is decommissioned.");
578: Jing Zhao, info, ForeachStmt, LOG.info("Block " + blk.getBlock() + " has " + hasdown + " decommissioned replica.");
220: Aaron Myers, info, CatchClause, LOG.info("got expected exception", ioe);
249: Todd Lipcon, info, CatchClause, LOG.info("Unable to spy on DNS. Skipping test.", t);
338: Todd Lipcon, info, CatchClause, DFSClient.LOG.info("Got expected exception", ioe);
347: Todd Lipcon, info, TryStmt, DFSClient.LOG.info("Starting test case for failure reset");
357: Todd Lipcon, info, TryStmt, DFSClient.LOG.info("First read successful after some failures.");
461: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("Called addBlock: " + Arrays.toString(invocation.getArguments()));
503: Todd Lipcon, info, IfStmt, LOG.info("Complete call returned false, not faking a retry RPC");
513: Todd Lipcon, error, CatchClause, LOG.error("Idempotent retry threw exception", t);
509: Todd Lipcon, info, TryStmt, LOG.info("Complete call returned true, faked second RPC. " + "Returned: " + ret);
568: Todd Lipcon, info, IfStmt, NameNode.LOG.info("FailNTimesAnswer injecting failure.");
571: Todd Lipcon, info, MethodDeclaration, NameNode.LOG.info("FailNTimesAnswer no longer failing.");
631: Todd Lipcon, warn, IfStmt, LOG.warn("Test 1 failed, but relax. Time spent: " + (timestamp2 - timestamp) / 1000.0 + " sec.");
629: Todd Lipcon, info, IfStmt, LOG.info("Test 1 succeeded! Time spent: " + (timestamp2 - timestamp) / 1000.0 + " sec.");
642: Todd Lipcon, info, MethodDeclaration, LOG.info("Test 2 succeeded! Time spent: " + (timestamp2 - timestamp) / 1000.0 + " sec.");
655: Todd Lipcon, warn, IfStmt, LOG.warn("Test 3 failed, but relax. Time spent: " + (timestamp2 - timestamp) / 1000.0 + " sec.");
653: Todd Lipcon, info, IfStmt, LOG.info("Test 3 succeeded! Time spent: " + (timestamp2 - timestamp) / 1000.0 + " sec.");
667: Todd Lipcon, info, MethodDeclaration, LOG.info("Test 4 succeeded! Time spent: " + (timestamp2 - timestamp) / 1000.0 + " sec.");
706: Todd Lipcon, info, TryStmt, LOG.info("Path : \"" + file1 + "\"");
833: Todd Lipcon, info, CatchClause, LOG.info("Bad - BlockMissingException is caught.");
830: Todd Lipcon, info, TryStmt, LOG.info("Thread correctly read the block.");
905: Matthew Foley, info, CatchClause, LOG.info("Got the expected Exception: SocketTimeoutException");
1159: Tsz-wo Sze, info, TryStmt, LOG.info("setPermission: " + nonExisting);
1164: Tsz-wo Sze, info, CatchClause, LOG.info("GOOD!", fnfe);
1224: Tsz-wo Sze, info, MethodDeclaration, LOG.info("input=" + s + ", parsed=" + r + ", expected=" + expected);
50: Haohui Mai, info, MethodDeclaration, LOG.info("If not specified, the auto tuned send buffer size is: {}", sendBufferSize);
70: Akira Ajisaka, info, MethodDeclaration, LOG.info("Large buf size is {}, small is {}", sendBufferSize1, sendBufferSize2);
85: Akira Ajisaka, info, MethodDeclaration, LOG.info("The auto tuned send buffer size is: {}", sendBufferSize);
96: Akira Ajisaka, info, TryStmt, LOG.info("MiniDFSCluster started.");
56: Todd Lipcon, info, MethodDeclaration, LOG.info("============================================================");
57: Todd Lipcon, info, MethodDeclaration, LOG.info("***TEST " + (testCounter++) + "*** " + label + ":" + " numDirs=" + numDirs);
190: Todd Lipcon, info, MethodDeclaration, LOG.info("Shutting down MiniDFSCluster");
154: Akira Ajisaka, info, TryStmt, LOG.info(re.toString());
168: Akira Ajisaka, info, TryStmt, LOG.info(re2.toString());
183: Akira Ajisaka, info, TryStmt, LOG.info(ce.toString());
195: Akira Ajisaka, info, TryStmt, LOG.info(ce2.toString());
206: Akira Ajisaka, info, TryStmt, LOG.info(append2.toString());
225: Akira Ajisaka, info, TryStmt, LOG.info(mue.toString());
238: Akira Ajisaka, info, TryStmt, LOG.info(mue2.toString());
250: Akira Ajisaka, info, TryStmt, LOG.info(ue2.toString());
265: Akira Ajisaka, info, TryStmt, LOG.info(ue.toString());
279: Akira Ajisaka, info, TryStmt, LOG.info(ce4.toString());
291: Akira Ajisaka, info, TryStmt, LOG.info(mue3.toString());
304: Akira Ajisaka, info, TryStmt, LOG.info(mue4.toString());
318: Akira Ajisaka, info, TryStmt, LOG.info(ce5.toString());
332: Akira Ajisaka, info, TryStmt, LOG.info(mue5.toString());
346: Akira Ajisaka, info, TryStmt, LOG.info(mue6.toString());
359: Akira Ajisaka, info, TryStmt, LOG.info(mue7.toString());
371: Akira Ajisaka, info, TryStmt, LOG.info(mue8.toString());
382: Akira Ajisaka, info, TryStmt, LOG.info(re3.toString());
395: Akira Ajisaka, info, TryStmt, LOG.info(et.toString());
511: Andrew Wang, error, CatchClause, LOG.error("Unable to create /dir", e);
116: Xiao Chen, info, MethodDeclaration, LOG.info("Current user is: " + UserGroupInformation.getCurrentUser() + " login user is:" + UserGroupInformation.getLoginUser());
123: Xiao Chen, info, TryStmt, LOG.info("mkdir /test success");
129: Xiao Chen, info, WhileStmt, LOG.info("txid: " + batch.getTxid());
134: Xiao Chen, info, TryStmt, LOG.info("Slept 6 seconds to make sure the TGT has expired.");
139: Xiao Chen, info, TryStmt, LOG.info("mkdir /test1 success");
91: Todd Lipcon, info, TryStmt, LOG.info("Random number generator uses seed " + seed);
92: Todd Lipcon, info, TryStmt, LOG.info("NUM_TEST_PERMISSIONS=" + NUM_TEST_PERMISSIONS);
789: Todd Lipcon, info, MethodDeclaration, LOG.info("required ancestor permission:" + Integer.toOctalString(requiredAncestorPermission));
791: Todd Lipcon, info, MethodDeclaration, LOG.info("ancestor permission: " + Integer.toOctalString(ancestorPermission));
793: Todd Lipcon, info, MethodDeclaration, LOG.info("required parent permission:" + Integer.toOctalString(requiredParentPermission));
795: Todd Lipcon, info, MethodDeclaration, LOG.info("parent permission: " + Integer.toOctalString(parentPermission));
796: Todd Lipcon, info, MethodDeclaration, LOG.info("required permission:" + Integer.toOctalString(requiredPermission));
798: Todd Lipcon, info, MethodDeclaration, LOG.info("permission: " + Integer.toOctalString(permission));
1131: Todd Lipcon, info, MethodDeclaration, LOG.info("dst ancestor permission: " + Integer.toOctalString(dstAncestorPermission));
1133: Todd Lipcon, info, MethodDeclaration, LOG.info("dst parent permission: " + Integer.toOctalString(dstParentPermission));
37: Todd Lipcon, info, MethodDeclaration, FileSystem.LOG.info("\n\n" + name);
39: Todd Lipcon, info, ForeachStmt, FileSystem.LOG.info("" + s.getPath());
44: Todd Lipcon, info, MethodDeclaration, FileSystem.LOG.info("\n\n" + name);
46: Todd Lipcon, info, ForeachStmt, FileSystem.LOG.info("" + s.getPath());
63: Todd Lipcon, info, MethodDeclaration, LOG.info("============================================================");
64: Todd Lipcon, info, MethodDeclaration, LOG.info("***TEST " + (testCounter++) + "*** " + label + ":" + " numDirs=" + numDirs);
348: Todd Lipcon, info, MethodDeclaration, LOG.info("Shutting down MiniDFSCluster");
373: Wei-Chiu Chuang, info, TryStmt, LOG.info("-du return is:\n" + returnString);
402: Wei-Chiu Chuang, info, TryStmt, LOG.info("-du -s return is:\n" + returnString);
419: Wei-Chiu Chuang, info, TryStmt, LOG.info("-du return is:\n" + returnString);
434: Wei-Chiu Chuang, info, TryStmt, LOG.info("-du -s -x return is:\n" + returnString);
451: Wei-Chiu Chuang, info, TryStmt, LOG.info("-du -x return is:\n" + returnString);
512: Wei-Chiu Chuang, info, TryStmt, LOG.info("-count return is:\n" + returnString);
532: Wei-Chiu Chuang, info, TryStmt, LOG.info("-count -x return is:\n" + returnString);
967: Mingliang Liu, error, CatchClause, LOG.error("Client that tails the test file fails", e);
1265: Todd Lipcon, info, MethodDeclaration, LOG.info(cmdline.toString());
1272: Todd Lipcon, error, CatchClause, LOG.error("RUN: " + args[0] + " IOException=" + e.getMessage());
1275: Todd Lipcon, error, CatchClause, LOG.error("RUN: " + args[0] + " RuntimeException=" + e.getMessage());
1278: Todd Lipcon, error, CatchClause, LOG.error("RUN: " + args[0] + " Exception=" + e.getMessage());
1269: Todd Lipcon, info, TryStmt, LOG.info("RUN: " + args[0] + " exit=" + exitCode);
1344: Tsz-wo Sze, info, IfStmt, LOG.info("Skipped sticky bit tests on Windows");
1320: Tsz-wo Sze, info, IfStmt, LOG.info("Testing sticky bit on: " + dir2);
1321: Tsz-wo Sze, info, IfStmt, LOG.info("Sticky bit directory initial mode: " + fs.getFileStatus(dir2).getPermission());
1360: Todd Lipcon, info, MethodDeclaration, LOG.info("Confirming permission change of " + toApply + " to " + expected);
1365: Todd Lipcon, info, MethodDeclaration, LOG.info("Permission change result: " + result);
57: Todd Lipcon, info, MethodDeclaration, LOG.info("============================================================");
58: Todd Lipcon, info, MethodDeclaration, LOG.info("***TEST*** " + label + ":" + testCaseLine + " nodeType=" + nodeType + " layoutVersion=" + sd.storageInfo.getLayoutVersion() + " namespaceID=" + sd.storageInfo.getNamespaceID() + " fsscTime=" + sd.storageInfo.getCTime() + " clusterID=" + sd.storageInfo.getClusterID() + " BlockPoolID=" + sd.blockPoolId);
189: Todd Lipcon, info, IfStmt, LOG.info("namespaceIDs are not equal: isVersionCompatible=false");
194: Todd Lipcon, info, IfStmt, LOG.info("clusterIDs are not equal: isVersionCompatible=false");
199: Todd Lipcon, info, IfStmt, LOG.info("blockPoolIDs are not equal: isVersionCompatible=false");
208: Todd Lipcon, info, IfStmt, LOG.info("layoutVersions and cTimes are equal: isVersionCompatible=true");
218: Todd Lipcon, info, IfStmt, LOG.info("softwareLayoutVersion is newer OR namenode cTime is newer: isVersionCompatible=true");
222: Todd Lipcon, info, MethodDeclaration, LOG.info("default case: isVersionCompatible=false");
284: Todd Lipcon, info, MethodDeclaration, LOG.info("Shutting down MiniDFSCluster");
111: Todd Lipcon, info, MethodDeclaration, LOG.info("============================================================");
112: Todd Lipcon, info, MethodDeclaration, LOG.info("***TEST " + (testCounter++) + "*** " + label + ":" + " numDirs=" + numDirs + " testCase=" + testCaseNum + " current=" + state[CURRENT_EXISTS] + " previous=" + state[PREVIOUS_EXISTS] + " previous.tmp=" + state[PREVIOUS_TMP_EXISTS] + " removed.tmp=" + state[REMOVED_TMP_EXISTS] + " should recover=" + state[SHOULD_RECOVER] + " current exists after=" + state[CURRENT_SHOULD_EXIST_AFTER_RECOVER] + " previous exists after=" + state[PREVIOUS_SHOULD_EXIST_AFTER_RECOVER]);
448: Todd Lipcon, info, MethodDeclaration, LOG.info("Setting up the directory structures.");
454: Todd Lipcon, info, MethodDeclaration, LOG.info("Shutting down MiniDFSCluster");
38: Jing Zhao, info, ConstructorDeclaration, LOG.info(ecPolicy);
60: Jing Zhao, info, MethodDeclaration, LOG.info("run testMultipleDatanodeFailureRandomLength with length index: " + lenIndex);
81: Jing Zhao, error, CatchClause, LOG.error("failed, dn=" + dn + ", length=" + length);
226: Jing Zhao, info, TryStmt, LOG.info("writing finished. Seek and read the file to verify.");
261: Andrew Wang, error, CatchClause, LOG.error(err);
253: Andrew Wang, info, TryStmt, LOG.info("runTestWithMultipleFailure2: length==" + length + ", killPos=" + Arrays.toString(killPos) + ", dnIndex=" + Arrays.toString(dnIndex));
294: Andrew Wang, error, CatchClause, LOG.error(err);
286: Andrew Wang, info, TryStmt, LOG.info("runTestWithShortStripe: length==" + length + ", killPos=" + Arrays.toString(killPos) + ", dnIndex=" + Arrays.toString(dnIndex));
247: Sammi Chen, error, CatchClause, LOG.error(err);
241: Sammi Chen, info, TryStmt, LOG.info("runTest: dn=" + dn + ", length=" + length);
268: Sammi Chen, error, CatchClause, LOG.error(err);
260: Sammi Chen, info, TryStmt, LOG.info("runTestWithMultipleFailure: length==" + length + ", killPos=" + Arrays.toString(killPos) + ", dnIndex=" + Arrays.toString(dnIndex));
287: Sammi Chen, warn, IfStmt, LOG.warn("killPos=" + Arrays.toString(killPos) + " <= FLUSH_POS=" + FLUSH_POS + ", length=" + length + ", dnIndex=" + Arrays.toString(dnIndex));
299: Sammi Chen, info, MethodDeclaration, LOG.info("fullPath=" + fullPath);
376: Sammi Chen, info, MethodDeclaration, LOG.info("getGenerationStamp returns " + gs);
410: Sammi Chen, info, MethodDeclaration, LOG.info("killDatanode " + dnIndex + ": " + datanode + ", pos=" + pos);
38: Andrew Wang, info, ConstructorDeclaration, LOG.info(schema);
38: Jing Zhao, info, ConstructorDeclaration, LOG.info(ecPolicy);
74: Todd Lipcon, info, MethodDeclaration, LOG.info("============================================================");
75: Todd Lipcon, info, MethodDeclaration, LOG.info("***TEST " + (testCounter++) + "*** " + label + ":" + " numDirs=" + numDirs);
88: Todd Lipcon, info, ForeachStmt, LOG.info("Checking namenode directory " + baseDir);
89: Todd Lipcon, info, ForeachStmt, LOG.info("==== Contents ====:\n  " + Joiner.on("  \n").join(new File(baseDir, "current").list()));
91: Todd Lipcon, info, ForeachStmt, LOG.info("==================");
184: Matthew Foley, info, CatchClause, LOG.info("Successfully detected expected NameNode startup failure.");
247: Tsz-wo Sze, info, CatchClause, LOG.info("The exception is expected.", re);
391: Tsz-wo Sze, info, CatchClause, LOG.info("The exception is expected.", re);
116: Todd Lipcon, info, MethodDeclaration, LOG.info("Unpacking " + tarFile);
155: Todd Lipcon, info, IfStmt, LOG.info("CRC info for reference file : " + path + " \t " + checksum);
188: Akira Ajisaka, info, TryStmt, LOG.info("Open failed. " + tries + " times. Retrying.");
611: Todd Lipcon, info, WhileStmt, LOG.info("Waiting for SafeMode to be OFF.");
690: Colin Patrick Mccabe, debug, IfStmt, FSImage.LOG.debug("");
803: Colin Patrick Mccabe, error, CatchClause, LOG.error("Child failed when calling mkdir", t);
837: Colin Patrick Mccabe, info, ForStmt, LOG.info(opCount.getName() + "\t" + opCount.getValue());
1094: Todd Lipcon, info, CatchClause, FileSystem.LOG.info("GOOD: getting an exception", ioe);
1501: Lei Xu, info, TryStmt, LOG.info("Test create an empty file");
40: Xiao Chen, info, ConstructorDeclaration, LOG.info("run {} with {}.", TestDistributedFileSystemWithECFileWithRandomECPolicy.class.getSuperclass().getSimpleName(), ecPolicy.getName());
316: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("Done sleeping.");
347: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Wait until encryption keys become invalid...");
363: Xiaoyu Yao, info, MethodDeclaration, LOG.info("The encryption key is invalid on all nodes now.");
406: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("Wait until encryption keys become invalid...");
422: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("The encryption key is invalid on all nodes now.");
1353: Alejandro Abdelnur, debug, MethodDeclaration, DistributedFileSystem.LOG.debug("Delegation tokens: " + Arrays.asList(tokens));
102: Andrew Wang, debug, MethodDeclaration, DistributedFileSystem.LOG.debug("Delegation tokens: " + Arrays.asList(tokens));
133: Xiao Chen, info, MethodDeclaration, LOG.info("Writing file " + path);
151: Xiao Chen, info, MethodDeclaration, LOG.info("Writing file " + path);
176: Andrew Wang, info, ForStmt, LOG.info("Writing file " + path);
201: Xiao Chen, info, MethodDeclaration, LOG.info("Rack count map is: {}", racksCount);
40: Lei Xu, info, ConstructorDeclaration, LOG.info("run {} with {}.", TestErasureCodingPoliciesWithRandomECPolicy.class.getSuperclass().getSimpleName(), ecPolicy.getName());
40: Lei Xu, info, ConstructorDeclaration, LOG.info("run {} with {}.", TestErasureCodingPolicyWithSnapshotWithRandomECPolicy.class.getSuperclass().getSimpleName(), ecPolicy.getName());
201: Lei Xu, info, ForStmt, LOG.info("ipos = " + ipos + ", contents.length = " + contents.length + ", nread = " + nread + ", len = " + len);
264: Lei Xu, error, MethodDeclaration, LOG.error("SyntheticReplicaAccessor error: " + text);
340: Tsz-wo Sze, info, CatchClause, AppendTestUtil.LOG.info("Got an exception:", re);
381: Jing Zhao, info, CatchClause, AppendTestUtil.LOG.info("Got an exception:", re);
423: Tsz-Wo Nicholas Sze, info, ForStmt, AppendTestUtil.LOG.info(i + ") fileLen=" + fileLen + ", appendLen=" + appendLen);
76: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("setUp()");
86: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("tearDown()");
235: Todd Lipcon, info, CatchClause, AppendTestUtil.LOG.info("GOOD: got an exception", ioe);
244: Jing Zhao, info, CatchClause, AppendTestUtil.LOG.info("GOOD: got an exception", ioe);
274: Jing Zhao, info, CatchClause, AppendTestUtil.LOG.info("GOOD: got an exception", ioe);
281: Jing Zhao, info, CatchClause, AppendTestUtil.LOG.info("GOOD: got an exception", ioe);
107: Todd Lipcon, info, MethodDeclaration, LOG.info("Recovering File Lease");
123: Todd Lipcon, info, CatchClause, LOG.info("Failed open for append, waiting on lease recovery");
120: Haohui Mai, info, TryStmt, LOG.info("Successfully opened for append");
137: Todd Lipcon, info, MethodDeclaration, LOG.info("Past out lease recovery");
176: Todd Lipcon, info, TryStmt, LOG.info("Waiting for close to get to latch...");
189: Todd Lipcon, info, TryStmt, LOG.info("Recovering file");
192: Todd Lipcon, info, TryStmt, LOG.info("Telling close to proceed.");
194: Todd Lipcon, info, TryStmt, LOG.info("Waiting for close to finish.");
196: Todd Lipcon, info, TryStmt, LOG.info("Close finished.");
247: Todd Lipcon, info, TryStmt, LOG.info("Waiting for close to get to latch...");
260: Todd Lipcon, info, TryStmt, LOG.info("Recovering file");
263: Todd Lipcon, info, TryStmt, LOG.info("Opening file for append from new fs");
266: Todd Lipcon, info, TryStmt, LOG.info("Writing some data from new appender");
269: Todd Lipcon, info, TryStmt, LOG.info("Telling old close to proceed.");
271: Todd Lipcon, info, TryStmt, LOG.info("Waiting for close to finish.");
273: Todd Lipcon, info, TryStmt, LOG.info("Close finished.");
377: Konstantin Boudnik, info, CatchClause, LOG.info("Expected exception: ", e);
207: Uma Maheswara Rao G, info, MethodDeclaration, LOG.info("stripedFileChecksum1:" + stripedFileChecksum1);
208: Uma Maheswara Rao G, info, MethodDeclaration, LOG.info("stripedFileChecksum2:" + stripedFileChecksum2);
209: Uma Maheswara Rao G, info, MethodDeclaration, LOG.info("stripedFileChecksum3:" + stripedFileChecksum3);
259: Kai Zheng, info, MethodDeclaration, LOG.info("stripedFileChecksum1:" + stripedFileChecksum1);
260: Kai Zheng, info, MethodDeclaration, LOG.info("stripedFileChecksumRecon:" + stripedFileChecksumRecon);
276: Kai Zheng, info, MethodDeclaration, LOG.info("stripedFileChecksum1:" + stripedFileChecksum1);
277: Kai Zheng, info, MethodDeclaration, LOG.info("stripedFileChecksum2:" + stripedFileChecksum1);
278: Kai Zheng, info, MethodDeclaration, LOG.info("stripedFileChecksum2Recon:" + stripedFileChecksum2Recon);
290: Kai Zheng, info, MethodDeclaration, LOG.info("Checksum file:{}, requested length:{}", stripedFile, requestedLen);
298: Kai Zheng, info, MethodDeclaration, LOG.info("stripedFileChecksum1:" + stripedFileChecksum1);
299: Kai Zheng, info, MethodDeclaration, LOG.info("stripedFileChecksumRecon:" + stripedFileChecksumRecon);
229: Todd Lipcon, error, CatchClause, LOG.warn("error in writer", e);
234: Todd Lipcon, error, CatchClause, LOG.error("unable to close file");
368: Todd Lipcon, error, CatchClause, LOG.error("error in writer", e);
362: Suresh Srinivas, error, CatchClause, LOG.error("error writing to file", e);
396: Todd Lipcon, error, CatchClause, LOG.error("error in tailer", e);
384: Todd Lipcon, error, CatchClause, LOG.error(String.format("error tailing file %s", file), e);
413: Todd Lipcon, info, CatchClause, LOG.info("interrupted waiting for writer or tailer to complete");
424: Todd Lipcon, error, IfStmt, LOG.error(String.format("at position [%d], got [%d] and expected [%d]", startPos, buf[i], expected));
443: Todd Lipcon, info, WhileStmt, LOG.info(String.format("read %d bytes", read));
446: Todd Lipcon, error, IfStmt, LOG.error(String.format("invalid bytes: [%s]\n", Arrays.toString(buf)));
92: Lei Xu, info, ForeachStmt, LOG.info("Deliberately removing block {}", brr.getBlockName());
121: Lei Xu, info, TryStmt, LOG.info("A ChecksumException is expected to be logged.");
693: Tsz-wo Sze, info, CatchClause, FileSystem.LOG.info("GOOD!", ioe);
1309: Konstantin V Shvachko, info, CatchClause, FileSystem.LOG.info("Caught Expected FileNotFoundException: ", e);
47: Tsz-wo Sze, error, IfStmt, LeaseManager.LOG.error("t=" + t, e);
40: Xiao Chen, info, ConstructorDeclaration, LOG.info("run {} with {}.", TestFileStatusWithRandomECPolicy.class.getSuperclass().getSimpleName(), ecPolicy.getName());
109: Chris Nauroth, info, MethodDeclaration, LOG.info("Running test {} for RPC server {}.  Found server protocols {} " + "and policy provider protocols {}.", testName.getMethodName(), rpcServerClass.getName(), serverProtocols, policyProviderProtocols);
82: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to determine hostname.  May interfere with obtaining " + "valid test results.");
346: Todd Lipcon, info, TryStmt, LOG.info("= Starting 1 on: " + conf2.get(DFSConfigKeys.DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY));
353: Todd Lipcon, info, TryStmt, LOG.info("= Starting 2 on: " + conf2.get(DFSConfigKeys.DFS_NAMENODE_SECONDARY_HTTP_ADDRESS_KEY));
378: Arpit Agarwal, info, TryStmt, LOG.info("= Starting 1 on: " + backup_config.get(DFSConfigKeys.DFS_NAMENODE_BACKUP_HTTP_ADDRESS_KEY));
387: Arpit Agarwal, info, TryStmt, LOG.info("= Starting 2 on: " + backup_config.get(DFSConfigKeys.DFS_NAMENODE_BACKUP_HTTP_ADDRESS_KEY));
65: Todd Lipcon, info, MethodDeclaration, LOG.info("Checking for block replication for " + filename);
71: Todd Lipcon, info, ForStmt, LOG.info("Checking for block:" + (i + 1));
78: Todd Lipcon, info, IfStmt, LOG.info("Got enough replicas for " + (i + 1) + "th block " + block.getBlock() + ", got " + actual + ".");
82: Todd Lipcon, info, WhileStmt, LOG.info("Not enough replicas for " + (i + 1) + "th block " + block.getBlock() + " yet. Expecting " + expected + ", got " + actual + ".");
61: Todd Lipcon, info, MethodDeclaration, LOG.info("createFile: Created " + name + " with " + repl + " replica.");
146: Todd Lipcon, debug, WhileStmt, LOG.debug("Before update: to read: " + bytesToRead + "; read already: " + thisread);
149: Todd Lipcon, debug, WhileStmt, LOG.debug("After  update: to read: " + bytesToRead + "; read already: " + thisread);
185: Todd Lipcon, info, TryStmt, LOG.info("File " + file1 + " created with file size " + fileSize + " blocksize " + blockSize);
195: Todd Lipcon, info, TryStmt, LOG.info("File " + file1 + " written to.");
199: Todd Lipcon, info, TryStmt, LOG.info("File " + file1 + " closed.");
112: Kihwal Lee, info, TryStmt, LOG.info("Write worked beyond the soft limit as expected.");
128: Tsz-wo Sze, info, CatchClause, LOG.info("Write failed as expected. ", e);
146: Tsz-wo Sze, error, CatchClause, LOG.error("Read failed with ", e);
156: Tsz-wo Sze, error, CatchClause, LOG.error("Write failed with ", e);
184: Tsz-wo Sze, info, TryStmt, LOG.info("DMS: rename file into dir");
195: Tsz-wo Sze, info, TryStmt, LOG.info("DMS: rename parent dir");
124: cnauroth, info, MethodDeclaration, DataNode.LOG.info("newblocks=" + lastblock);
129: cnauroth, info, MethodDeclaration, DataNode.LOG.info("dfs.dfs.clientName=" + dfs.dfs.clientName);
178: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("filestr=" + filestr);
184: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("size=" + size);
188: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("hflush");
192: Todd Lipcon, info, IfStmt, AppendTestUtil.LOG.info("leasechecker.interruptAndJoin()");
205: Todd Lipcon, info, WhileStmt, AppendTestUtil.LOG.info("sleep " + 5000 + "ms");
221: Todd Lipcon, info, ForStmt, AppendTestUtil.LOG.info("i=" + i);
230: Suresh Srinivas, warn, CatchClause, AppendTestUtil.LOG.warn("UNEXPECTED ", ioe);
231: Todd Lipcon, info, CatchClause, AppendTestUtil.LOG.info("sleep " + 5000 + "ms");
254: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("Lease for file " + filepath + " is recovered. " + "Validating its contents now...");
284: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("filestr=" + filestr);
292: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("size=" + size);
296: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("hflush");
300: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("leasechecker.interruptAndJoin()");
324: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("File size is good. Now validating sizes from datanodes...");
351: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("filestr=" + filestr);
359: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("size=" + size);
363: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("hflush");
365: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("leasechecker.interruptAndJoin()");
383: Todd Lipcon, info, ForStmt, AppendTestUtil.LOG.info("i=" + i);
390: Todd Lipcon, info, CatchClause, AppendTestUtil.LOG.info("GOOD! got " + ex.getMessage());
392: Todd Lipcon, warn, CatchClause, AppendTestUtil.LOG.warn("UNEXPECTED IOException", ioe);
396: Todd Lipcon, info, IfStmt, AppendTestUtil.LOG.info("sleep " + 5000 + "ms");
403: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("Lease for file " + filepath + " is recovered. " + "Validating its contents now...");
412: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("File size is good. " + "Now validating data and sizes from datanodes...");
454: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("filestr=" + fileStr);
461: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("size=" + size);
472: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("hflush");
488: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("leasechecker.interruptAndJoin()");
546: Tsz-wo Sze, info, CatchClause, LOG.info("Expceted exception on write/hflush", e);
553: Todd Lipcon, info, CatchClause, LOG.info("Expected exception on close", e);
557: Todd Lipcon, info, MethodDeclaration, AppendTestUtil.LOG.info("File size is good. Now validating sizes from datanodes...");
178: Andrew Wang, info, MethodDeclaration, LOG.info("blockLengthsSuite: " + Arrays.toString(blockLengthsSuite));
257: Andrew Wang, info, ForStmt, LOG.info("Waiting for block stream idx {} to reach length {}", i, blockLengths[i]);
236: Andrew Wang, info, ForeachStmt, LOG.info("Stopping block stream idx {} at file offset {} block " + "length {}", index, pos, blockLengths[index]);
92: Ming Ma, info, MethodDeclaration, LOG.info("Setting testMaintenanceMinReplConfigRange");
101: Ming Ma, info, CatchClause, LOG.info("Expected exception: " + e);
115: Ming Ma, info, CatchClause, LOG.info("Expected exception: " + e);
125: Ming Ma, info, MethodDeclaration, LOG.info("Starting testTakeNodeOutOfEnteringMaintenance");
154: Ming Ma, info, MethodDeclaration, LOG.info("Starting testEnteringMaintenanceExpiration");
178: Ming Ma, info, MethodDeclaration, LOG.info("Starting testInvalidExpiration");
200: Ming Ma, info, MethodDeclaration, LOG.info("Starting testPutDeadNodeToMaintenance");
234: Ming Ma, info, MethodDeclaration, LOG.info("Starting testPutDeadNodeToMaintenanceWithExpiration");
271: Ming Ma, info, MethodDeclaration, LOG.info("Starting testTransitionFromDecommissioned");
294: Ming Ma, info, MethodDeclaration, LOG.info("Starting testTransitionFromDecommissionedAndExpired");
325: Ming Ma, info, MethodDeclaration, LOG.info("Starting testNodeDeadWhenInEnteringMaintenance");
371: Ming Ma, info, MethodDeclaration, LOG.info("Starting testExpectedReplications");
415: Ming Ma, info, MethodDeclaration, LOG.info("Starting testZeroMinMaintenanceReplication");
439: Ming Ma, info, MethodDeclaration, LOG.info("Starting testZeroMinMaintenanceReplicationWithExpiration");
504: Ming Ma, info, MethodDeclaration, LOG.info("Starting testLargerMinMaintenanceReplication - maintMinRepl: " + maintenanceMinRepl + ", numDNs: " + numDataNodes + ", numNewDNs: " + numNewDataNodes + ", fileRepl: " + fileBlockRepl);
507: Ming Ma, info, MethodDeclaration, LOG.info("Setting maintenance minimum replication: " + maintenanceMinRepl);
541: Ming Ma, info, MethodDeclaration, LOG.info("Starting testTransitionToDecommission");
585: Ming Ma, info, MethodDeclaration, LOG.info("Starting testTransitionFromDecommissioning");
718: Ming Ma, info, MethodDeclaration, LOG.info("Starting testChangeReplicationFactor {} {} {}", oldFactor, newFactor, expectedLiveReplicas);
764: Ming Ma, info, MethodDeclaration, LOG.info("Starting testTakeDeadNodeOutOfMaintenance");
820: Ming Ma, info, MethodDeclaration, LOG.info("Starting testWithNNAndDNRestart");
878: Ming Ma, info, MethodDeclaration, LOG.info("Starting testWriteAfterMaintenance");
910: Ming Ma, info, MethodDeclaration, LOG.info("Starting testEnterMaintenanceWhenFileOpen");
929: Ming Ma, info, MethodDeclaration, LOG.info("Starting testInvalidation");
961: Masatake Iwasaki, info, MethodDeclaration, LOG.info("Starting testFileCloseAfterEnteringMaintenance");
1047: Ming Ma, info, IfStmt, LOG.info(output);
1040: Ming Ma, info, IfStmt, LOG.info(output);
1064: Ming Ma, info, IfStmt, LOG.info(output);
1088: Ming Ma, info, IfStmt, LOG.info(output);
1082: Ming Ma, info, IfStmt, LOG.info(output);
1145: Yiqun Lin, info, MethodDeclaration, LOG.info("Starting testReportMaintenanceNodes");
95: Todd Lipcon, info, TryStmt, LOG.info("Waiting for missing blocks count to increase...");
115: Todd Lipcon, info, TryStmt, LOG.info("Waiting for missing blocks count to be zero...");
74: Todd Lipcon, info, MethodDeclaration, LOG.info("Random seed: " + seed);
236: Todd Lipcon, error, CatchClause, LOG.error(getName() + ": Error while testing read at " + startOff + " length " + len, t);
358: Todd Lipcon, info, ForeachStmt, LOG.info("--- Report: " + worker.getName() + " read " + nread + " B; " + "average " + nread / ReadWorker.N_ITERATIONS + " B per read");
368: Todd Lipcon, info, MethodDeclaration, LOG.info("=== Report: " + nWorkers + " threads read " + totalReadKB + " KB (across " + nFiles + " file(s)) in " + timeTakenSec + "s; average " + totalReadKB / timeTakenSec + " KB/s");
92: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + METHOD_NAME);
98: Todd Lipcon, debug, IfStmt, LOG.debug("Invoking append but doing nothing otherwise...");
142: Todd Lipcon, debug, IfStmt, LOG.debug("Written: " + bytesToWriteNext + "; Total: " + written);
577: John Zhuge, info, IfStmt, LOG.info("-------------- throw Checksum Exception");
688: Vinayakumar B, info, ForeachStmt, DFSClient.LOG.info(locatedBlock.getBlock() + " " + Arrays.toString(locations));
752: Vinayakumar B, error, CatchClause, DFSClient.LOG.error("Problem in getting block locations", e);
746: Vinayakumar B, info, TryStmt, DFSClient.LOG.info("Source :" + source + ", destination: " + destination);
748: Vinayakumar B, info, TryStmt, DFSClient.LOG.info("Got updated locations :" + locations);
760: Vinayakumar B, info, TryStmt, DFSClient.LOG.info("Starting read");
768: Vinayakumar B, info, TryStmt, DFSClient.LOG.info("Read completed");
1551: Xiao Chen, info, MethodDeclaration, LOG.info("LeaseRenewer: {}", leaseRenewer);
100: yliu, info, MethodDeclaration, LOG.info("Deliberately corrupting file " + blkFile.getName());
99: Andrew Wang, error, CatchClause, LOG.error("Failed to read file with DN failure:" + " fileType = " + fileType + ", dnFailureNum = " + dnFailureNum);
109: Jing Zhao, info, MethodDeclaration, LOG.info("readFileWithMissingBlocks: (" + missingDataNum + "," + missingParityNum + ")");
160: Jing Zhao, info, IfStmt, LOG.info("stop datanode " + failedDNIdx);
89: Todd Lipcon, info, TryStmt, AppendTestUtil.LOG.info("leasechecker.interruptAndJoin()");
126: Todd Lipcon, info, IfStmt, AppendTestUtil.LOG.info("Will sleep and retry, i=" + i + ", p=" + p, re);
276: Jing Zhao, info, IfStmt, LOG.info("Note: corrupt data on " + target.getValue().getDisplayName() + " with internal block " + target.getKey());
271: Jing Zhao, info, IfStmt, LOG.info("Note: stop DataNode " + target.getValue().getDisplayName() + " with internal block " + target.getKey());
325: Jing Zhao, info, MethodDeclaration, LOG.info("Note: indices == " + Arrays.toString(indices) + ". Generate errors on datanodes: " + Arrays.toString(dead));
353: Jing Zhao, info, ForStmt, LOG.info("replica " + i + " locates in file: " + replicas[i]);
386: zhezhang, info, ForStmt, LOG.info("replica after reconstruction " + replicaAfterReconstruction);
390: Jing Zhao, info, ForStmt, LOG.info("replica before " + replicas[i]);
40: Chris Douglas, info, ConstructorDeclaration, LOG.info("run {} with {}.", TestReconstructStripedFileWithRandomECPolicy.class.getSuperclass().getSimpleName(), ecPolicy.getName());
221: Brahma Reddy Battula, info, MethodDeclaration, LOG.info("Verify the file");
223: Brahma Reddy Battula, info, ForStmt, LOG.info(slowwriters[i].filepath + ": length=" + fs.getFileStatus(slowwriters[i].filepath).getLen());
243: Brahma Reddy Battula, info, MethodDeclaration, LOG.info("Wait " + waittime + " seconds");
272: Brahma Reddy Battula, info, CatchClause, LOG.info(getName() + " interrupted:" + e);
276: Brahma Reddy Battula, info, TryStmt, LOG.info(getName() + " terminated: i=" + i);
266: Brahma Reddy Battula, info, ForStmt, LOG.info(getName() + " writes " + i);
286: Brahma Reddy Battula, info, MethodDeclaration, LOG.info(getName() + " join and close");
179: Todd Lipcon, info, TryStmt, LOG.info("Verify the file");
181: Todd Lipcon, info, ForStmt, LOG.info(slowwriters[i].filepath + ": length=" + fs.getFileStatus(slowwriters[i].filepath).getLen());
210: cnauroth, warn, CatchClause, LOG.warn("IOException is thrown while getting the file block " + "replication factor", e);
220: Todd Lipcon, info, MethodDeclaration, LOG.info("Wait " + waittime + " seconds");
252: Todd Lipcon, info, CatchClause, LOG.info(getName() + " interrupted:" + e);
256: Todd Lipcon, info, TryStmt, LOG.info(getName() + " terminated: i=" + i);
245: Todd Lipcon, info, ForStmt, LOG.info(getName() + " writes " + i);
266: Todd Lipcon, info, MethodDeclaration, LOG.info(getName() + " join and close");
289: Tsz-wo Sze, info, BlockStmt, LOG.info("create an empty file " + f);
299: Tsz-wo Sze, info, BlockStmt, LOG.info("append " + bytes.length + " bytes to " + f);
310: Tsz-wo Sze, info, BlockStmt, LOG.info("append another " + bytes.length + " bytes to " + f);
318: Tsz-wo Sze, info, CatchClause, LOG.info("This exception is expected", ioe);
342: Colin Patrick Mccabe, info, BlockStmt, LOG.info("write " + bytes.length + " bytes to " + f);
353: Colin Patrick Mccabe, info, BlockStmt, LOG.info("append another " + bytes.length + " bytes to " + f);
130: Eli Collins, info, ForStmt, LOG.info("datanode " + i + ": " + datanodes[i]);
197: Todd Lipcon, info, TryStmt, LOG.info("Waiting until block is marked as corrupt...");
305: Todd Lipcon, info, MethodDeclaration, LOG.info("Checking for block replication for " + filename);
322: Tsz-wo Sze, info, IfStmt, LOG.info("Not enough replicas for " + block.getBlock() + " yet. Expecting " + expected + ", got " + actual + ".");
401: Lei Xu, info, IfStmt, LOG.info("Corrupting file " + replica);
397: Lei Xu, info, IfStmt, LOG.info("Deleting block " + replica);
555: Jing Zhao, info, MethodDeclaration, LOG.info("Test block replication when blockReceived is late");
634: Jing Zhao, info, MethodDeclaration, LOG.info("Test block replication in under construction");
169: Tsz-wo Sze, info, MethodDeclaration, LOG.info("nn1Dir=" + nn1Dir);
170: Tsz-wo Sze, info, MethodDeclaration, LOG.info("nn2Dir=" + nn2Dir);
219: Tsz-wo Sze, info, BlockStmt, LOG.info("START\n" + info1);
247: Arpit Agarwal, info, TryStmt, LOG.info("RESTART cluster 2");
258: Tsz-wo Sze, info, CatchClause, LOG.info("The exception is expected.", e);
261: Arpit Agarwal, info, TryStmt, LOG.info("RESTART cluster 2 again");
273: Tsz-wo Sze, info, TryStmt, LOG.info("RESTART cluster 2 with regular startup option");
178: Arpit Agarwal, info, MethodDeclaration, LOG.info("Starting testInitializeReplQueuesEarly");
187: Arpit Agarwal, info, MethodDeclaration, LOG.info("Creating files");
190: Arpit Agarwal, info, MethodDeclaration, LOG.info("Stopping all DataNodes");
199: Arpit Agarwal, info, MethodDeclaration, LOG.info("Restarting NameNode");
213: Arpit Agarwal, info, MethodDeclaration, LOG.info("Restarting one DataNode");
238: Arpit Agarwal, info, WhileStmt, LOG.info("UnderReplicatedBlocks expected=" + (15 - safe) + ", actual=" + underReplicatedBlocks);
40: Andrew Wang, info, ConstructorDeclaration, LOG.info("run {} with {}.", TestSafeModeWithStripedFileWithRandomECPolicy.class.getSuperclass().getSimpleName(), ecPolicy.getName());
71: Todd Lipcon, info, MethodDeclaration, LOG.info("initJunitModeTest");
99: Todd Lipcon, info, MethodDeclaration, LOG.info("initClusterModeTest");
115: Todd Lipcon, info, MethodDeclaration, LOG.info("Summary status from test1: status= " + stat);
215: Todd Lipcon, info, BlockStmt, LOG.info("reader begin: position: " + pos + " ; currentOffset = " + currentPosition + " ; bufferSize =" + buffer.length + " ; Filename = " + fname);
235: Todd Lipcon, info, IfStmt, LOG.info("reader: Number of byte read: " + byteRead + " ; totalByteRead = " + totalByteRead + " ; currentPosition=" + currentPosition + " ; chunkNumber =" + chunkNumber + "; File name = " + fname);
251: Todd Lipcon, info, BlockStmt, LOG.info("reader end:   position: " + pos + " ; currentOffset = " + currentPosition + " ; totalByteRead =" + totalByteRead + " ; Filename = " + fname);
309: Todd Lipcon, info, IfStmt, LOG.info("File already exists of size " + fileLengthBeforeOpen + " File open for Append mode: " + path);
304: Todd Lipcon, info, IfStmt, LOG.info("File already exists. File open with Truncate mode: " + path);
338: Todd Lipcon, info, IfStmt, LOG.info("TestReadWrite - Written " + chunkSize + ". Total written = " + totalByteWritten + ". TotalByteVisible = " + totalByteVisible + " to file " + fname);
361: Todd Lipcon, info, ForStmt, LOG.info(readmsg);
387: Todd Lipcon, info, IfStmt, LOG.info(readmsg);
435: Todd Lipcon, info, MethodDeclaration, LOG.info("Usage: [-useSeqRead | -usePosRead] [-append|truncate]" + " -chunkSize nn -loop ntimes  -f filename");
445: Todd Lipcon, info, MethodDeclaration, LOG.info("  Option setting: filenameOption = " + filenameOption);
446: Todd Lipcon, info, MethodDeclaration, LOG.info("  Option setting: chunkSizeOption = " + chunkSizeOption);
447: Todd Lipcon, info, MethodDeclaration, LOG.info("  Option setting: loopOption = " + loopOption);
448: Todd Lipcon, info, MethodDeclaration, LOG.info("  Option setting: posReadOption = " + positionReadOption);
449: Todd Lipcon, info, MethodDeclaration, LOG.info("  Option setting: truncateOption = " + truncateOption);
450: Todd Lipcon, info, MethodDeclaration, LOG.info("  Option setting: verboseOption = " + verboseOption);
511: Todd Lipcon, info, CatchClause, LOG.info("#### Exception in Main");
223: Zhe Zhang, info, IfStmt, LOG.info("stop DataNode " + dnIndex);
88: Zhe Zhang, error, CatchClause, LOG.error("Failed to write file with DN failure:" + " fileType = " + fileType + ", dataDelNum = " + dataDelNum + ", parityDelNum = " + parityDelNum);
115: Zhe Zhang, info, MethodDeclaration, LOG.info("writeFileWithDNFailure: file = " + src + ", fileType = " + fileType + ", dataDNFailureNum = " + dataDNFailureNum + ", parityDNFailureNum = " + parityDNFailureNum);
165: Todd Lipcon, info, WhileStmt, DFSClient.LOG.info("So far read " + nRead + " - going to read more.");
172: Todd Lipcon, info, IfStmt, DFSClient.LOG.info("Done reading, expect EOF for next read.");
230: Colin McCabe, error, CatchClause, LOG.error("readerRunnable error", e);
329: Colin McCabe, error, CatchClause, LOG.error("getBlockReader failure", t);
322: Colin McCabe, error, CatchClause, LOG.error("error trying to retrieve a block reader " + "the second time.", t);
403: Weiwei Yang, info, TryStmt, LOG.info("Unbuffering");
418: Weiwei Yang, info, TryStmt, LOG.info("Reading {} again.", testFile);
636: Jing Zhao, error, CatchClause, LOG.error("getBlockReader failure", t);
627: Jing Zhao, info, CatchClause, LOG.info("got the expected ClosedByInterruptException", e);
633: Jing Zhao, info, WhileStmt, LOG.info("read another " + TEST_FILE_LEN + " bytes.");
109: Todd Lipcon, info, ForeachStmt, DFSClient.LOG.info("Testing startOffset = " + startOffset + " and " + " len=" + length);
175: Arpit Agarwal, info, MethodDeclaration, LOG.info("total time: {} avg time: {} avg trials: {}", totalMs, totalMs / OP_NUM, (float) totalTrials / OP_NUM);
196: Arpit Agarwal, info, MethodDeclaration, LOG.info("total time: {} avg time: {}", totalMs, totalMs / OP_NUM);
247: Arpit Agarwal, info, MethodDeclaration, LOG.info("total time: {} avg time: {} avg trials: {}", totalMs, totalMs / OP_NUM, (float) totalTrials / OP_NUM);
267: Arpit Agarwal, info, MethodDeclaration, LOG.info("total time: {} avg time: {}", totalMs, totalMs / OP_NUM);
311: Arpit Agarwal, info, MethodDeclaration, LOG.info("total time: {} avg time: {} avg trials: {}", totalMs, totalMs / OP_NUM, (float) totalTrials / OP_NUM);
328: Arpit Agarwal, info, MethodDeclaration, LOG.info("total time: {} avg time: {}", totalMs, totalMs / OP_NUM);
386: Arpit Agarwal, info, MethodDeclaration, LOG.info("total time: {} avg time: {} avg trials: {}", totalMs, totalMs / OP_NUM, (float) totalTrials / OP_NUM);
406: Arpit Agarwal, info, MethodDeclaration, LOG.info("total time: {} avg time: {}", totalMs, totalMs / OP_NUM);
461: Arpit Agarwal, info, MethodDeclaration, LOG.info("total time: {} avg time: {} avg trials: {}", totalMs, totalMs / OP_NUM, (float) totalTrials / OP_NUM);
490: Arpit Agarwal, info, MethodDeclaration, LOG.info(sb.toString());
43: Andrew Wang, info, CatchClause, LOG.info("Expected exception:", e);
95: Todd Lipcon, info, ConstructorDeclaration, LOG.info("Starting MiniJournalCluster with " + b.numJournalNodes + " journal nodes");
109: Todd Lipcon, debug, IfStmt, LOG.debug("Fully deleting JN directory " + dir);
129: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Setting logger addresses to: " + addrsVal);
157: Jing Zhao, warn, CatchClause, LOG.warn("Unable to stop journal node " + info.node, e);
254: Colin Patrick Mccabe, warn, CatchClause, LOG.warn("Thread interrupted when waiting for node start", ite);
142: Arpit Agarwal, info, CatchClause, LOG.info("MiniQJMHACluster port conflicts, retried " + retryCount + " times");
105: Yongjun Zhang, info, TryStmt, LOG.info("Set MiniQJMHACluster basePort to " + basePort);
97: Todd Lipcon, info, ForStmt, LOG.info("Created epoch " + newEpoch);
123: Todd Lipcon, info, TryStmt, LOG.info("Max IPC count = " + ret);
149: Todd Lipcon, info, ForStmt, LOG.info("\n\n-------------------------------------------\n" + "Beginning test, failing at " + injectionStr + "\n" + "-------------------------------------------\n\n");
166: Todd Lipcon, info, IfStmt, LOG.info("Failed after injecting failures at " + injectionStr + ". This is expected since we injected a failure in the " + "majority.");
222: Todd Lipcon, info, IfStmt, LOG.info("Using seed specified in system property");
232: Todd Lipcon, info, MethodDeclaration, LOG.info("Random seed: " + seed);
251: Todd Lipcon, info, ForStmt, LOG.info("Starting writer " + i + "\n-------------------");
259: Todd Lipcon, info, CatchClause, LOG.info("Failed recovery", t);
279: Todd Lipcon, info, IfStmt, LOG.info("Failed write", thrown.held);
338: Todd Lipcon, info, CatchClause, LOG.info("Failed to write at txid " + lastAcked, qe);
373: Todd Lipcon, info, IfStmt, LOG.info("transitioned " + addr + " to " + (isUp ? "up" : "down"));
457: Todd Lipcon, info, IfStmt, LOG.info("IPC call #" + rpcCount + ": " + callStr);
453: Todd Lipcon, info, IfStmt, LOG.info("Injecting code before IPC #" + rpcCount + ": " + callStr);
91: Inigo Goiri, info, MethodDeclaration, LOG.info("Testing without " + DFS_JOURNALNODE_RPC_BIND_HOST_KEY);
101: Inigo Goiri, info, MethodDeclaration, LOG.info("Testing with " + DFS_JOURNALNODE_RPC_BIND_HOST_KEY);
117: Inigo Goiri, info, MethodDeclaration, LOG.info("Testing without " + DFS_JOURNALNODE_HTTP_BIND_HOST_KEY);
128: Inigo Goiri, info, MethodDeclaration, LOG.info("Testing with " + DFS_JOURNALNODE_HTTP_BIND_HOST_KEY);
171: Inigo Goiri, info, MethodDeclaration, LOG.info("Testing behavior without " + DFS_JOURNALNODE_HTTPS_BIND_HOST_KEY);
186: Inigo Goiri, info, MethodDeclaration, LOG.info("Testing behavior with " + DFS_JOURNALNODE_HTTPS_BIND_HOST_KEY);
115: Todd Lipcon, info, MethodDeclaration, LOG.info("Sleep to expire the token");
126: Todd Lipcon, info, MethodDeclaration, LOG.info("Sleep beyond the max lifetime");
301: Todd Lipcon, info, MethodDeclaration, LOG.info("========= entering safemode again");
334: Daryn Sharp, info, MethodDeclaration, LOG.info("A valid token should have non-null password, and should be renewed successfully");
92: Todd Lipcon, info, MethodDeclaration, LOG.info("Local Ip addresses: " + builder.toString());
151: Tsz-wo Sze, info, MethodDeclaration, WebHdfsTestUtil.LOG.info("START: testWebHdfsDoAs()");
152: Tsz-wo Sze, info, MethodDeclaration, WebHdfsTestUtil.LOG.info("ugi.getShortUserName()=" + ugi.getShortUserName());
162: Tsz-wo Sze, info, BlockStmt, WebHdfsTestUtil.LOG.info("responsePath=" + responsePath);
173: Tsz-wo Sze, info, BlockStmt, WebHdfsTestUtil.LOG.info("status.getOwner()=" + status.getOwner());
183: Tsz-wo Sze, info, BlockStmt, WebHdfsTestUtil.LOG.info("status.getOwner()=" + status.getOwner());
184: Tsz-wo Sze, info, BlockStmt, WebHdfsTestUtil.LOG.info("status.getLen()  =" + status.getLen());
150: Todd Lipcon, info, ForeachStmt, LOG.info("Got: " + id.toString());
402: Todd Lipcon, info, WhileStmt, LOG.info("Num open fds:" + countOpenFileDescriptors());
819: cnauroth, info, MethodDeclaration, LOG.info("capacities = " + long2String(capacities));
820: Zhe Zhang, info, MethodDeclaration, LOG.info("racks      = " + Arrays.asList(racks));
821: Zhe Zhang, info, MethodDeclaration, LOG.info("newCapacity= " + newCapacity);
822: Zhe Zhang, info, MethodDeclaration, LOG.info("newRack    = " + newRack);
823: Jing Zhao, info, MethodDeclaration, LOG.info("useTool    = " + useTool);
836: Konstantin V Shvachko, info, IfStmt, LOG.info("Using Spy Namesystem");
956: Lei Xu, info, WhileStmt, LOG.info("  .");
967: Lei Xu, warn, CatchClause, LOG.warn("The cluster has not balanced yet, retry...");
984: Jing Zhao, info, MethodDeclaration, LOG.info("namenodes  = " + namenodes);
985: Jing Zhao, info, MethodDeclaration, LOG.info("parameters = " + p);
986: Jing Zhao, info, MethodDeclaration, LOG.info("Print stack trace", new Throwable());
1079: Suresh Srinivas, info, MethodDeclaration, LOG.info("Rebalancing with default ctor.");
1792: Vinayakumar B, info, MethodDeclaration, LOG.info("capacities = " + long2String(capacities));
1793: Vinayakumar B, info, MethodDeclaration, LOG.info("racks      = " + Arrays.asList(racks));
1794: Vinayakumar B, info, MethodDeclaration, LOG.info("newCapacity= " + newCapacity);
1795: Vinayakumar B, info, MethodDeclaration, LOG.info("newRack    = " + newRack);
1796: Vinayakumar B, info, MethodDeclaration, LOG.info("useTool    = " + false);
1877: cnauroth, info, MethodDeclaration, LOG.info("capacities    = " + Arrays.toString(capacities));
1878: cnauroth, info, MethodDeclaration, LOG.info("totalUsedSpace= " + totalUsed);
1879: cnauroth, info, MethodDeclaration, LOG.info("lengths       = " + Arrays.toString(lengths) + ", #=" + lengths.length);
2100: Konstantin V Shvachko, info, MethodDeclaration, LOG.info("Balancer executed " + numGetBlocksCalls + " getBlocks in " + d + " msec.");
151: Todd Lipcon, info, MethodDeclaration, LOG.info("WAIT expectedUsedSpace=" + expectedUsedSpace + ", expectedTotalSpace=" + expectedTotalSpace);
161: Todd Lipcon, warn, IfStmt, LOG.warn("WAIT i=" + i + ", s=[" + s[0] + ", " + s[1] + "]");
172: Todd Lipcon, info, MethodDeclaration, LOG.info("BALANCER 0: totalUsed=" + totalUsed + ", totalCapacity=" + totalCapacity + ", avg=" + avg);
176: Todd Lipcon, info, MethodDeclaration, LOG.info("BALANCER 1");
188: Todd Lipcon, info, MethodDeclaration, LOG.info("BALANCER 2");
190: Todd Lipcon, info, MethodDeclaration, LOG.info("BALANCER 3");
210: Todd Lipcon, warn, IfStmt, LOG.warn("datanodes[" + d + "]: getDfsUsed()=" + datanodes[d].getDfsUsed() + ", getCapacity()=" + datanodes[d].getCapacity());
252: Tsz-Wo Nicholas Sze, warn, IfStmt, LOG.warn("datanodes " + d + " is not yet balanced: " + "used=" + used[d] + ", cap=" + cap[d] + ", avg=" + avg);
254: Tsz-Wo Nicholas Sze, warn, IfStmt, LOG.warn("sum(used)=" + TestBalancer.sum(used) + ", sum(cap)=" + TestBalancer.sum(cap));
234: Tsz-Wo Nicholas Sze, warn, IfStmt, LOG.warn("datanodes " + d + " is not yet balanced: " + "block pool used=" + bpUsed[d][k] + ", cap=" + cap[d] + ", avg=" + avg);
237: Tsz-Wo Nicholas Sze, warn, IfStmt, LOG.warn("sum(blockpoolUsed)=" + TestBalancer.sum(bpUsed[k]) + ", sum(cap)=" + TestBalancer.sum(cap));
264: Todd Lipcon, info, MethodDeclaration, LOG.info("BALANCER 6");
295: Ming Ma, info, IfStmt, LOG.info("Comparision of datanode pool usage pre/post balancer run. " + "PrePoolUsage: " + getTotalPoolUsage(preReport) + ", PostPoolUsage: " + getTotalPoolUsage(postReport));
340: Ming Ma, info, IfStmt, LOG.info("Tracking usage of blockpool id: " + s.cluster.getNamesystem(i).getBlockPoolId());
346: Ming Ma, info, MethodDeclaration, LOG.info("Tracking " + reports.size() + " blockpool(s) for pre/post balancer usage.");
355: Todd Lipcon, error, CatchClause, LOG.error(e);
380: Todd Lipcon, info, MethodDeclaration, LOG.info("UNEVEN 0");
397: Todd Lipcon, info, BlockStmt, LOG.info("UNEVEN 1");
405: Todd Lipcon, info, BlockStmt, LOG.info("UNEVEN 2");
409: Todd Lipcon, info, TryStmt, LOG.info("UNEVEN 3");
412: Todd Lipcon, info, TryStmt, LOG.info("UNEVEN 4");
426: Todd Lipcon, info, BlockStmt, LOG.info("UNEVEN 10");
434: Todd Lipcon, info, BlockStmt, LOG.info("UNEVEN 11");
437: Todd Lipcon, info, TryStmt, LOG.info("UNEVEN 12");
456: Todd Lipcon, info, ForStmt, LOG.info("UNEVEN 13: n=" + n);
461: Todd Lipcon, info, TryStmt, LOG.info("UNEVEN 14");
463: Todd Lipcon, info, TryStmt, LOG.info("UNEVEN 15");
467: Todd Lipcon, info, BlockStmt, LOG.info("UNEVEN 16");
491: Todd Lipcon, info, MethodDeclaration, LOG.info("nNameNodes=" + nNameNodes + ", nDataNodes=" + nDataNodes);
494: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("RUN_TEST -1: start a cluster with nNameNodes=" + nNameNodes + ", nDataNodes=" + nDataNodes);
504: Todd Lipcon, info, MethodDeclaration, LOG.info("RUN_TEST 0");
509: Todd Lipcon, info, TryStmt, LOG.info("RUN_TEST 1");
531: Tsz-Wo Nicholas Sze, info, TryStmt, LOG.info("RUN_TEST 2: create files");
539: Tsz-Wo Nicholas Sze, info, TryStmt, LOG.info("RUN_TEST 3: " + newRack.length + " new datanodes");
548: Tsz-Wo Nicholas Sze, info, TryStmt, LOG.info("RUN_TEST 4: run Balancer");
551: Todd Lipcon, info, TryStmt, LOG.info("RUN_TEST 5");
555: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("RUN_TEST 6: done");
182: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Rebalancing with default factor.");
196: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Rebalancing with default factor.");
1363: Andrew Wang, info, MethodDeclaration, LOG.info("Starting testPlacementPolicySatisfied.");
1402: Andrew Wang, info, TryStmt, LOG.info("Adding 3 new hosts in the existing racks.");
1408: Andrew Wang, info, TryStmt, LOG.info("Waiting for EC reconstruction to complete.");
1415: Andrew Wang, info, TryStmt, LOG.info("Adding 3 new hosts in 3 new racks.");
1449: Andrew Wang, info, MethodDeclaration, LOG.info("Block " + blockInfo + " storages: ");
1452: Andrew Wang, info, WhileStmt, LOG.info(" Rack: " + dn.getDatanodeDescriptor().getNetworkLocation() + ", DataNode: " + dn.getDatanodeDescriptor().getXferAddr());
52: Colin Patrick Mccabe, error, MethodDeclaration, LOG.error("Test error: " + what);
84: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Incoming full block report from " + nodeID + ".  Lease ID = 0x" + Long.toHexString(context.getLeaseId()));
98: Colin Patrick Mccabe, info, SynchronizedStmt, LOG.info("Proceeding with full block report from " + nodeID + ".  Lease ID = 0x" + Long.toHexString(context.getLeaseId()));
113: Colin Patrick Mccabe, info, SynchronizedStmt, LOG.info("requestBlockReportLease(node=" + node + ", leaseId=0x" + Long.toHexString(leaseId) + ").  " + "expectedFbrDns = " + Joiner.on(", ").join(expectedFbrDns));
124: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("removeBlockReportLease(node=" + node + ", leaseId=0x" + Long.toHexString(leaseId) + ")");
138: Colin Patrick Mccabe, info, ForStmt, LOG.info("Waiting for " + n + " datanode(s) to report in.");
108: Colin McCabe, info, IfStmt, LOG.info("Removing in pseudo-random order");
102: Colin McCabe, info, IfStmt, LOG.info("Removing via iterator");
155: Chris Nauroth, info, MethodDeclaration, LOG.info("Using seed " + seed + " for testing");
208: Chris Nauroth, info, IfStmt, LOG.info("Registering node storageID: " + dr.getDatanodeUuid() + ", version: " + dr.getSoftwareVersion() + ", IP address: " + dr.getXferAddr());
174: Chris Nauroth, info, IfStmt, LOG.info("Removing node " + toRemove.getDatanodeUuid() + " ip " + toRemove.getXferAddr() + " version : " + toRemove.getSoftwareVersion());
234: Chris Nauroth, info, ForeachStmt, LOG.info("Still in map: " + entry.getKey() + " has " + entry.getValue());
274: Chris Nauroth, info, CatchClause, LOG.info("Expected - topology is not resolved and " + "registration is rejected.");
248: Andrew Wang, info, TryStmt, LOG.info("waiting for the datanode to remove " + storageIdToRemove);
259: Andrew Wang, info, IfStmt, LOG.info("Still found storage " + storageIdToRemove + " on " + info + ".");
352: Colin Patrick Mccabe, info, IfStmt, LOG.info("Expected to find a storage for " + block.getBlockName() + ", but nothing was found.  " + "Continuing to wait.");
359: Colin Patrick Mccabe, info, IfStmt, LOG.info("Expected " + block.getBlockName() + " to " + "be in storage id " + newStorageId + ", but it " + "was in " + info.getStorageID() + ".  Continuing " + "to wait.");
365: Colin Patrick Mccabe, info, TryStmt, LOG.info("Successfully found " + block.getBlockName() + " in " + "be in storage id " + newStorageId);
107: Kihwal Lee, info, IfStmt, LOG.info("Live Replicas after corruption: " + liveReplicas);
119: Kihwal Lee, info, IfStmt, LOG.info("Live Replicas after Rereplication: " + liveReplicas);
129: Tsz-wo Sze, info, IfStmt, LOG.info("Corrupt Replicas becomes 0");
120: Jing Zhao, info, IfStmt, LOG.info("stop datanode " + dn.getDatanodeId().getHostName());
146: Jing Zhao, info, MethodDeclaration, LOG.info("cluster hosts: {}, racks: {}", Arrays.asList(hosts), Arrays.asList(racks));
129: Konstantin Shvachko, info, MethodDeclaration, NameNode.LOG.info("Done working on it");
128: Walter Su, info, ForStmt, LOG.info("BlockGrp" + i + " id is " + nextBlockGrpId);
74: Tsz-wo Sze, info, TryStmt, LOG.info("Block0 id is " + blocks.get(0).getBlock().getBlockId());
80: Tsz-wo Sze, info, ForStmt, LOG.info("Block" + i + " id is " + nextBlockId);
225: Arpit Agarwal, info, MethodDeclaration, LOG.info("Got JSON: {}", json);
94: Zhe Zhang, info, MethodDeclaration, LOG.info("Starting test testSortWithMultipleDecommnDatanodes");
147: Zhe Zhang, info, MethodDeclaration, LOG.info("Starting test testTwoDatanodesWithSameBlockIndexAreDecommn");
203: Zhe Zhang, info, MethodDeclaration, LOG.info("Starting test testSmallerThanOneStripeWithDecommn");
262: Zhe Zhang, info, MethodDeclaration, LOG.info("Starting test testTargetDecommnDatanodeDoesntExists");
326: Zhe Zhang, info, MethodDeclaration, LOG.info("Starting test testWithMultipleInServiceAndDecommnDatanodes");
392: Zhe Zhang, info, ForStmt, LOG.info("Block Locations size={}, locs={}, j=", nodes.length, dnInfo.toString(), j);
57: Todd Lipcon, info, MethodDeclaration, LOG.info("Uri: " + u);
83: Todd Lipcon, info, MethodDeclaration, LOG.info("Testing correct Unix URI: " + URI_UNIX);
85: Todd Lipcon, info, MethodDeclaration, LOG.info("Uri: " + u);
90: Todd Lipcon, info, MethodDeclaration, LOG.info("Testing correct windows URI: " + URI_WINDOWS);
92: Todd Lipcon, info, MethodDeclaration, LOG.info("Uri: " + u);
183: Kihwal Lee, info, IfStmt, LOG.info("Corrupted the length for block ID " + block);
174: Kihwal Lee, info, IfStmt, LOG.info("Corrupted the GS for block ID " + block);
220: Todd Lipcon, debug, IfStmt, LOG.debug("Number of blocks allocated " + blocks.size());
227: Todd Lipcon, debug, IfStmt, LOG.debug("Block " + b.getBlockName() + " before\t" + "Size " + b.getNumBytes());
232: Todd Lipcon, debug, IfStmt, LOG.debug("Setting new length");
237: Todd Lipcon, debug, IfStmt, LOG.debug("Block " + b.getBlockName() + " after\t " + "Size " + b.getNumBytes());
252: Todd Lipcon, debug, IfStmt, LOG.debug("After mods: Number of blocks allocated " + blocksAfterReport.size());
275: Todd Lipcon, info, MethodDeclaration, LOG.info("Running test " + METHOD_NAME);
303: Todd Lipcon, debug, IfStmt, LOG.debug("Number of blocks allocated " + lBlocks.size());
309: Todd Lipcon, debug, IfStmt, LOG.debug("Removing the block " + b.getBlockName());
317: Arpit Agarwal, debug, IfStmt, LOG.debug("Deleted file " + f.toString());
315: Todd Lipcon, warn, IfStmt, LOG.warn("Couldn't delete " + b.getBlockName());
667: Vinitha Reddy Gankidi, info, MethodDeclaration, LOG.info("Block pool id: " + poolId);
707: Todd Lipcon, debug, IfStmt, LOG.debug("Wait for datanode " + DN_N1 + " to appear");
713: Todd Lipcon, debug, IfStmt, LOG.debug("Total number of DNs " + cluster.getDataNodes().size());
729: Todd Lipcon, debug, IfStmt, LOG.debug("Has been waiting for " + waiting_period + " ms.");
738: Todd Lipcon, debug, IfStmt, LOG.debug("Replica state before the loop " + state.getValue());
745: Todd Lipcon, debug, IfStmt, LOG.debug("Keep waiting for " + bl.getBlockName() + " is in state " + state.getValue());
753: Todd Lipcon, debug, IfStmt, LOG.debug("Replica state after the loop " + state.getValue());
768: Todd Lipcon, debug, IfStmt, LOG.debug("Caught exception ", e);
777: Todd Lipcon, debug, IfStmt, LOG.debug("Before next DN start: " + cluster.getDataNodes().size());
786: Todd Lipcon, debug, IfStmt, LOG.debug("New datanode " + cluster.getDataNodes().get(lastDn).getDisplayName() + " has been started");
798: Todd Lipcon, info, MethodDeclaration, LOG.info("Running test " + METHOD_NAME);
811: Todd Lipcon, debug, IfStmt, LOG.debug("Missing " + cluster.getNamesystem().getMissingBlocksCount());
812: Todd Lipcon, debug, IfStmt, LOG.debug("Corrupted " + cluster.getNamesystem().getCorruptReplicaBlocks());
813: Todd Lipcon, debug, IfStmt, LOG.debug("Under-replicated " + cluster.getNamesystem().getUnderReplicatedBlocks());
815: Todd Lipcon, debug, IfStmt, LOG.debug("Pending delete " + cluster.getNamesystem().getPendingDeletionBlocks());
817: Todd Lipcon, debug, IfStmt, LOG.debug("Pending replications " + cluster.getNamesystem().getPendingReplicationBlocks());
819: Todd Lipcon, debug, IfStmt, LOG.debug("Excess " + cluster.getNamesystem().getExcessBlocks());
820: Todd Lipcon, debug, IfStmt, LOG.debug("Total " + cluster.getNamesystem().getBlocksTotal());
830: Todd Lipcon, debug, IfStmt, LOG.debug(i + " block to be omitted");
251: Yiqun Lin, info, MethodDeclaration, LOG.info("Starting to wait for datanode to detect disk failure.");
250: Todd Lipcon, error, IfStmt, DataNode.LOG.error("Null oStream on unfinalized block - bug");
255: Todd Lipcon, warn, IfStmt, DataNode.LOG.warn("Size passed to finalize (" + finalSize + ")does not match what was written:" + oStream.getLength());
265: Todd Lipcon, warn, IfStmt, DataNode.LOG.warn("Lack of free storage on a block alloc");
778: Erik Krogen, error, CatchClause, DataNode.LOG.error("Exception while getting block reports", ioe);
966: Todd Lipcon, warn, IfStmt, DataNode.LOG.warn("Invalidate: Missing block");
1347: Todd Lipcon, Error, CatchClause, DataNode.LOG.warn("Error registering FSDatasetState MBean", e);
1350: Todd Lipcon, info, MethodDeclaration, DataNode.LOG.info("Registered FSDatasetState MBean");
167: Tsz-Wo Nicholas Sze, info, TryStmt, LOG.info("ibrInterval=" + ibrInterval + " (" + toConfString(DFS_BLOCKREPORT_INCREMENTAL_INTERVAL_MSEC_KEY, conf) + "), numBlockCreated=" + numBlockCreated);
170: Tsz-Wo Nicholas Sze, info, TryStmt, LOG.info("duration=" + toSecondString(testEndTime - testStartTime) + ", createFileTime=" + toSecondString(createFileTime.get()) + ", verifyFileTime=" + toSecondString(verifyFileTime.get()));
173: Tsz-Wo Nicholas Sze, info, TryStmt, LOG.info("NUM_FILES=" + NUM_FILES + ", MAX_BLOCK_NUM=" + MAX_BLOCK_NUM + ", BLOCK_SIZE=" + BLOCK_SIZE + ", NUM_THREADS=" + NUM_THREADS + ", NUM_DATANODES=" + NUM_DATANODES);
199: Tsz-Wo Nicholas Sze, info, ForeachStmt, LOG.info(dn.getDisplayName() + ": " + name + "=" + ibr);
253: Tsz-Wo Nicholas Sze, error, CatchClause, LOG.error("Failed to verify file " + f);
94: Todd Lipcon, info, SynchronizedStmt, LOG.info(string);
109: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Got subdir {}", blockFileSubdir);
110: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Generated file path {}", testFilePath);
136: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Generated deleted file path {}", deletedFilePath);
274: Walter Su, warn, CatchClause, LOG.warn("InterruptedException while waiting to see active NN", e);
290: Todd Lipcon, error, CatchClause, LOG.error("Cannot close: ", e);
337: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
376: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
418: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
460: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
484: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
508: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
546: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
570: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
597: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
637: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
659: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
684: Todd Lipcon, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
785: Yongjun Zhang, debug, IfStmt, LOG.debug("Running " + GenericTestUtils.getMethodName());
961: Colin Patrick Mccabe, debug, MethodDeclaration, LOG.debug("Running " + currentTestName.getMethodName());
994: Colin Patrick Mccabe, error, CatchClause, LOG.error("slowWriter got exception", t);
984: Colin Patrick Mccabe, debug, TryStmt, LOG.debug("slowWriter creating rbw");
988: Colin Patrick Mccabe, debug, TryStmt, LOG.debug("slowWriter created rbw");
992: Colin Patrick Mccabe, debug, TryStmt, LOG.debug("slowWriter exiting");
1014: Colin Patrick Mccabe, error, CatchClause, LOG.error("stopWriterThread got unexpected exception for " + tswr.opName(), t);
1010: Colin Patrick Mccabe, debug, TryStmt, LOG.debug("initiating " + tswr.opName());
1012: Colin Patrick Mccabe, debug, TryStmt, LOG.debug("finished " + tswr.opName());
177: Eli Collins, info, TryStmt, LOG.info("Testcase 2: Destination " + proxies.get(1) + " contains the block " + b);
181: Eli Collins, info, TryStmt, LOG.info("Testcase 3: Source=" + source + " Proxy=" + proxies.get(0) + " Destination=" + newNode);
254: Uma Maheswara Rao G, info, ForStmt, LOG.info("Simulate block pinning in datanode " + dn);
339: Eli Collins, info, IfStmt, LOG.info("Block is not located at " + node);
332: Todd Lipcon, info, IfStmt, LOG.info("Expected replication factor is " + replFactor + " but the real replication factor is " + nodes.length);
351: Todd Lipcon, info, IfStmt, LOG.info("Expected replica nodes are: " + expectedNodesList);
352: Todd Lipcon, info, IfStmt, LOG.info("Current actual replica nodes are: " + currentNodesList);
358: Todd Lipcon, info, MethodDeclaration, LOG.info("Achieved expected replication values in " + (Time.now() - starttime) + " msec.");
446: Kihwal Lee, info, TryStmt, LOG.info("replaceBlock:  " + replaceBlock(block, (DatanodeInfo) sourceDnDesc, (DatanodeInfo) sourceDnDesc, (DatanodeInfo) destDnDesc));
194: Colin Patrick Mccabe, info, WhileStmt, LOG.info("BlockIterator for {} found block {}, blocksProcessed = {}", volume, block, blocksProcessed);
210: Colin Patrick Mccabe, info, IfStmt, LOG.info("Processed {} blocks out of {}.  Saving iterator.", blocksProcessed, numFiles);
219: Colin Patrick Mccabe, info, IfStmt, LOG.info("Processed {} blocks out of {}.  Rewinding iterator.", blocksProcessed, numFiles);
227: Colin Patrick Mccabe, info, IfStmt, LOG.info("Processed {} blocks out of {}.  Loading iterator.", blocksProcessed, numFiles);
238: Colin Patrick Mccabe, info, IfStmt, LOG.info("Starting again at the beginning...");
244: Colin Patrick Mccabe, info, IfStmt, LOG.info("Starting again at the load point...");
316: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("about to start scanning.");
325: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("starting scanning.");
330: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("handling block {} (exception {})", block, e);
395: Colin Patrick Mccabe, info, SynchronizedStmt, LOG.info("numFoundBlocks = {}.  blocksScanned = {}. Found blocks {}", numFoundBlocks, info.blocksScanned, foundBlocksBld.toString());
582: Colin Patrick Mccabe, info, IfStmt, LOG.info("Waiting for blocksScanned to reach 9.  It is at {}", info.blocksScanned);
646: Colin Patrick Mccabe, info, IfStmt, LOG.info("Waiting for scansSinceRestart to reach 3 (it is {})", stats.scansSinceRestart);
651: Colin Patrick Mccabe, info, IfStmt, LOG.info("Waiting for eof.");
730: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Waiting for the first 4 blocks to be scanned.");
739: Colin Patrick Mccabe, info, IfStmt, LOG.info("info = {}.  Waiting for blockScanned to reach 4.", info);
736: Colin Patrick Mccabe, info, IfStmt, LOG.info("info = {}.  blockScanned has now reached 4.", info);
763: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Waiting for 2 more blocks to be scanned.");
772: Colin Patrick Mccabe, info, IfStmt, LOG.info("info = {}.  Waiting for blockScanned to reach 2.", info);
769: Colin Patrick Mccabe, info, IfStmt, LOG.info("info = {}.  blockScanned has now reached 2.", info);
793: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Waiting for 5 more blocks to be scanned.");
802: Colin Patrick Mccabe, info, IfStmt, LOG.info("info = {}.  Waiting for blockScanned to reach 5.", info);
799: Colin Patrick Mccabe, info, IfStmt, LOG.info("info = {}.  blockScanned has now reached 5.", info);
848: Kihwal Lee, info, MethodDeclaration, LOG.info("Waiting for the blocks to be scanned.");
858: Kihwal Lee, info, IfStmt, LOG.info("info = {}.  Waiting for blockScanned to reach " + (NUM_FILES - 1), info);
854: Kihwal Lee, info, IfStmt, LOG.info("info = {}.  blockScanned has now reached " + info.blocksScanned, info);
947: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("Waiting for the first 1 blocks to be scanned.");
956: Wei-Chiu Chuang, info, IfStmt, LOG.info("info = {}.  Waiting for blockScanned to reach 1.", info);
953: Wei-Chiu Chuang, info, IfStmt, LOG.info("info = {}.  blockScanned has now reached 1.", info);
493: Suresh Srinivas, info, CatchClause, LOG.info("waiting on block report: " + t.getMessage());
519: Andrew Wang, info, CatchClause, LOG.info("waiting on block report: " + t.getMessage());
198: Arpit Agarwal, info, MethodDeclaration, LOG.info("Using now = " + now);
84: Inigo Goiri, debug, MethodDeclaration, LOG.debug("got fadvise(offset={}, len={}, flags={})", offset, len, flags);
177: Colin McCabe, error, CatchClause, LOG.error("ioexception", e);
205: Colin McCabe, error, CatchClause, LOG.error("ioexception", e);
217: Colin McCabe, info, MethodDeclaration, LOG.info("testFadviseAfterWriteThenRead");
258: Colin McCabe, info, MethodDeclaration, LOG.info("testClientDefaults");
299: Colin McCabe, info, MethodDeclaration, LOG.info("testFadviseSkippedForSmallReads");
345: Colin McCabe, info, MethodDeclaration, LOG.info("testNoFadviseAfterWriteThenRead");
378: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("testSeekAfterSetDropBehind");
80: Arpit Agarwal, info, CatchClause, DataNode.LOG.info("The exception is expected.", iae);
197: Kai Zheng, info, MethodDeclaration, LOG.info("Datanode to be corrupted: " + toCorruptDn);
229: Kai Zheng, info, MethodDeclaration, LOG.info("Computed datanode work: " + workCount + ", retries: " + retries);
162: Xiaoyu Yao, info, TryStmt, LOG.info("delay info: " + mdnFaultInjector.getDelayMs() + ":" + datanodeSlowLogThresholdMs);
502: Lei Xu, Error, CatchClause, LOG.error("Error listing storage: " + e);
530: Lei Xu, Error, CatchClause, LOG.error("Error adding volume: " + throwable);
760: Colin Patrick Mccabe, warn, CatchClause, LOG.warn(e);
1002: Lei Xu, info, MethodDeclaration, LOG.info("reconfiguring DN ");
67: Arpit Agarwal, info, ConstructorDeclaration, LOG.info("Assigned DatanodeUuid is " + storage.getDatanodeUuid());
310: Chris Nauroth, info, MethodDeclaration, LOG.info("Awaiting, remaining latch count is {}.", latch.getCount());
332: Chris Nauroth, info, MethodDeclaration, LOG.info("Countdown, remaining latch count is {}.", latch.getCount());
296: Akira Ajisaka, error, CatchClause, LOG.error("Caught IOException while ingesting DN metrics", ioe);
107: Vinayakumar B, error, CatchClause, LOG.error("Cannot close: ", e);
86: Todd Lipcon, info, TryStmt, LOG.info("nn1: lv=" + lv1 + ";cid=" + cid1 + ";bpid=" + bpid1 + ";uri=" + nn1.getNameNodeAddress());
88: Todd Lipcon, info, TryStmt, LOG.info("nn2: lv=" + lv2 + ";cid=" + cid2 + ";bpid=" + bpid2 + ";uri=" + nn2.getNameNodeAddress());
97: Tsz-wo Sze, info, ForeachStmt, LOG.info("vol " + i++ + ") " + e.getKey() + ": " + e.getValue());
105: Suresh Srinivas, info, ForeachStmt, LOG.info("BP: " + bpos);
157: Todd Lipcon, info, TryStmt, LOG.info("nn1: lv=" + lv1 + ";cid=" + cid1 + ";bpid=" + bpid1 + ";uri=" + nn1.getNameNodeAddress());
166: Tsz-wo Sze, info, ForeachStmt, LOG.info("vol " + i++ + ") " + e.getKey() + ": " + e.getValue());
174: Eli Collins, info, ForeachStmt, LOG.info("reg: bpid=" + "; name=" + bpos.bpRegistration + "; sid=" + bpos.bpRegistration.getDatanodeUuid() + "; nna=" + getNNSocketAddress(bpos));
210: Arpit Agarwal, info, TryStmt, LOG.info("dn bpos len (should be 2):" + bposs.size());
217: Arpit Agarwal, info, TryStmt, LOG.info("dn bpos len (should be 3):" + bposs.size());
228: Arpit Agarwal, info, TryStmt, LOG.info("dn bpos len (still should be 3):" + bposs.size());
144: Akira Ajisaka, Info, TryStmt, LOG.info("bpActorInfo is " + bpActorInfo);
156: Akira Ajisaka, info, TryStmt, LOG.info("maxDataLength is " + maxDataLength);
157: Akira Ajisaka, info, TryStmt, LOG.info("maxBlockReportSize is " + maxBlockReportSize);
122: cnauroth, error, CatchClause, LOG.error("Cannot close: ", e);
146: cnauroth, info, CatchClause, LOG.info("waiting on block report: " + t.getMessage());
182: cnauroth, info, IfStmt, LOG.info("mockito succeeded " + datanodeRegistration);
175: cnauroth, info, IfStmt, LOG.info("mockito exception " + i);
206: cnauroth, info, IfStmt, LOG.info("mockito heartbeatResponse " + i);
200: cnauroth, info, IfStmt, LOG.info("mockito heartbeatResponse registration " + i);
216: Arpit Agarwal, error, CatchClause, LOG.error("Cannot close: ", e);
100: Aaron Myers, info, CatchClause, LOG.info("Got expected exception", ive);
136: Arpit Agarwal, info, MethodDeclaration, LOG.info("Deleting file " + pathToDelete + " during rolling upgrade");
170: Arpit Agarwal, info, MethodDeclaration, LOG.info("Starting rolling upgrade");
181: Arpit Agarwal, info, MethodDeclaration, LOG.info("Finalizing rolling upgrade");
205: arp, info, MethodDeclaration, LOG.info("The cluster is active after rollback");
361: arp, info, TryStmt, LOG.info("Shutting down the Datanode");
366: arp, info, TryStmt, LOG.info("Restarting the DataNode");
371: arp, info, TryStmt, LOG.info("The DN has been restarted");
422: arp, info, TryStmt, LOG.info("Shutting down the Datanode");
427: arp, info, TryStmt, LOG.info("Restarting the DataNode");
432: arp, info, TryStmt, LOG.info("The DN has been restarted");
81: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Socket factory is " + defaultFactory.getClass().getName());
109: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Socket factory is " + defaultFactory.getClass().getName());
171: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Checking " + sockets.size() + " sockets for TCP_NODELAY");
186: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Creating new socket");
195: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Creating socket for " + host);
206: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Creating socket for " + host);
215: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Creating socket for " + addr);
226: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Creating socket for " + addr);
435: Yiqun Lin, info, MethodDeclaration, LOG.info("There is no under replicated block after volume failure.");
516: Brahma Reddy Battula, info, MethodDeclaration, LOG.info("Setting dfs.datanode.data.dir for new DataNode as {}", newDirs);
658: Lei Xu, info, MethodDeclaration, LOG.info(strBuilder.toString());
144: Xiaoyu Yao, info, MethodDeclaration, LOG.info("TotalMetadataOperations : " + metrics.getTotalMetadataOperations());
146: Xiaoyu Yao, info, MethodDeclaration, LOG.info("TotalDataFileIos : " + metrics.getTotalDataFileIos());
147: Xiaoyu Yao, Error, MethodDeclaration, LOG.info("TotalFileIoErrors : " + metrics.getTotalFileIoErrors());
149: Xiaoyu Yao, info, MethodDeclaration, LOG.info("MetadataOperationSampleCount : " + metrics.getMetadataOperationSampleCount());
151: Xiaoyu Yao, info, MethodDeclaration, LOG.info("MetadataOperationMean : " + metrics.getMetadataOperationMean());
152: Xiaoyu Yao, info, MethodDeclaration, LOG.info("MetadataFileIoStdDev : " + metrics.getMetadataOperationStdDev());
155: Xiaoyu Yao, info, MethodDeclaration, LOG.info("DataFileIoSampleCount : " + metrics.getDataFileIoSampleCount());
156: Xiaoyu Yao, info, MethodDeclaration, LOG.info("DataFileIoMean : " + metrics.getDataFileIoMean());
157: Xiaoyu Yao, info, MethodDeclaration, LOG.info("DataFileIoStdDev : " + metrics.getDataFileIoStdDev());
159: Xiaoyu Yao, info, MethodDeclaration, LOG.info("flushIoSampleCount : " + metrics.getFlushIoSampleCount());
160: Xiaoyu Yao, info, MethodDeclaration, LOG.info("flushIoMean : " + metrics.getFlushIoMean());
161: Xiaoyu Yao, info, MethodDeclaration, LOG.info("flushIoStdDev : " + metrics.getFlushIoStdDev());
163: Xiaoyu Yao, info, MethodDeclaration, LOG.info("syncIoSampleCount : " + metrics.getSyncIoSampleCount());
164: Xiaoyu Yao, info, MethodDeclaration, LOG.info("syncIoMean : " + metrics.getSyncIoMean());
165: Xiaoyu Yao, info, MethodDeclaration, LOG.info("syncIoStdDev : " + metrics.getSyncIoStdDev());
167: Xiaoyu Yao, info, MethodDeclaration, LOG.info("readIoSampleCount : " + metrics.getReadIoMean());
168: Xiaoyu Yao, info, MethodDeclaration, LOG.info("readIoMean : " + metrics.getReadIoMean());
169: Xiaoyu Yao, info, MethodDeclaration, LOG.info("readIoStdDev : " + metrics.getReadIoStdDev());
171: Xiaoyu Yao, info, MethodDeclaration, LOG.info("writeIoSampleCount : " + metrics.getWriteIoSampleCount());
172: Xiaoyu Yao, info, MethodDeclaration, LOG.info("writeIoMean : " + metrics.getWriteIoMean());
173: Xiaoyu Yao, info, MethodDeclaration, LOG.info("writeIoStdDev : " + metrics.getWriteIoStdDev());
175: Xiaoyu Yao, Error, MethodDeclaration, LOG.info("fileIoErrorSampleCount : " + metrics.getFileIoErrorSampleCount());
177: Xiaoyu Yao, Error, MethodDeclaration, LOG.info("fileIoErrorMean : " + metrics.getFileIoErrorMean());
178: Xiaoyu Yao, Error, MethodDeclaration, LOG.info("fileIoErrorStdDev : " + metrics.getFileIoErrorStdDev());
127: Sean Mackrory, info, CatchClause, LOG.info("Exception in NullServer: " + e + "; " + e.getMessage());
125: Sean Mackrory, info, TryStmt, LOG.info("Client connection accepted by NullServer");
136: Chris Nauroth, info, TryStmt, LOG.info("Truncated block file " + f.getAbsolutePath());
155: Todd Lipcon, info, IfStmt, LOG.info("Deleting block file " + f.getAbsolutePath());
169: Lei Xu, info, IfStmt, LOG.info("Deleting metadata " + b.getMetadataURI());
215: Colin Patrick Mccabe, info, IfStmt, LOG.info("Copied " + sourceBlock + " ==> " + destBlock);
216: Colin Patrick Mccabe, info, IfStmt, LOG.info("Copied " + sourceMeta + " ==> " + destMeta);
254: Colin Patrick Mccabe, info, IfStmt, LOG.info("Created block file " + file.getName());
270: Colin Patrick Mccabe, info, IfStmt, LOG.info("Created metafile " + file.getName());
288: Colin Patrick Mccabe, info, IfStmt, LOG.info("Created block file " + file.getName());
297: Colin Patrick Mccabe, info, IfStmt, LOG.info("Created extraneous file " + name1);
302: Colin Patrick Mccabe, info, IfStmt, LOG.info("Created extraneous file " + name2);
307: Colin Patrick Mccabe, info, IfStmt, LOG.info("Created metafile " + file.getName());
622: Colin Patrick Mccabe, info, TryStmt, LOG.info("RATIO: " + ratio);
640: Colin Patrick Mccabe, info, TryStmt, LOG.info("RATIO: " + ratio);
659: Colin Patrick Mccabe, info, TryStmt, LOG.info("RATIO: " + ratio);
710: Lei Xu, info, IfStmt, LOG.info("Scanner took " + (Time.monotonicNow() - finalMs) + "ms to shutdown");
725: Colin Patrick Mccabe, info, TryStmt, LOG.info("RATIO: " + ratio);
273: Colin McCabe, info, MethodDeclaration, LOG.info("beginning testCacheAndUncacheBlock");
326: Colin McCabe, info, MethodDeclaration, LOG.info("finishing testCacheAndUncacheBlock");
350: Colin McCabe, info, IfStmt, LOG.info("mlocking " + identifier);
363: Colin McCabe, info, MethodDeclaration, LOG.info("beginning testFilesExceedMaxLockedMemory");
421: Colin McCabe, info, MethodDeclaration, LOG.info("finishing testFilesExceedMaxLockedMemory");
426: Colin McCabe, info, MethodDeclaration, LOG.info("beginning testUncachingBlocksBeforeCachingFinishes");
453: Colin McCabe, info, MethodDeclaration, LOG.info("An mlock operation is starting on " + identifier);
475: Colin McCabe, info, MethodDeclaration, LOG.info("finishing testUncachingBlocksBeforeCachingFinishes");
587: Colin McCabe, info, IfStmt, LOG.info("waiting for " + TOTAL_BLOCKS_PER_CACHE + " to " + "be cached.   Right now only " + blocksCached + " blocks are cached.");
591: Colin McCabe, info, MethodDeclaration, LOG.info(TOTAL_BLOCKS_PER_CACHE + " blocks are now cached.");
620: Colin McCabe, info, IfStmt, LOG.info("waiting for directive " + shortCacheDirectiveId + " to be cached.  stats = " + entry.getStats());
624: Colin McCabe, info, TryStmt, LOG.info("directive " + shortCacheDirectiveId + " has been cached.");
183: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("removing cache directive {}", cacheDirectiveId);
185: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("finished removing cache directive {}", cacheDirectiveId);
220: Arpit Agarwal, info, MethodDeclaration, LOG.info("Triggering report after deleting blocks");
64: Chris Nauroth, WARN, MethodDeclaration, DFSTestUtil.setNameNodeLogLevel(Level.WARN);
65: Chris Nauroth, WARN, MethodDeclaration, FsDatasetImplTestUtils.setFsDatasetImplLogLevel(Level.WARN);
39: Konstantin V Shvachko, info, ForeachStmt, LOG.info("Sending block report for storage " + report.getStorage().getStorageID());
37: Arpit Agarwal, info, MethodDeclaration, LOG.info("Sending combined block reports for " + dnR);
73: Virajith Jalaparti, info, IfStmt, LOG.info("Created provided file " + newFile + " of length " + newFile.length());
83: Virajith Jalaparti, info, MethodDeclaration, LOG.info("Creating " + numReplicas + " provided replicas");
152: Virajith Jalaparti, info, MethodDeclaration, LOG.info("All replica contents verified");
65: Todd Lipcon, info, ForStmt, LOG.info("wait since replicas.size() == 0; i=" + i);
86: Todd Lipcon, info, TryStmt, LOG.info("size = " + size);
105: Todd Lipcon, info, BlockStmt, LOG.info("oldrbw = " + oldrbw);
134: Todd Lipcon, info, TryStmt, LOG.info("newrbw = " + newrbw);
139: Todd Lipcon, info, TryStmt, LOG.info("DONE");
98: Arpit Agarwal, info, MethodDeclaration, LOG.info("Executing {}", testName.getMethodName());
140: Arpit Agarwal, info, MethodDeclaration, LOG.info("Executing {}", testName.getMethodName());
150: Arpit Agarwal, info, MethodDeclaration, LOG.info("Got back {} failed volumes", failedVolumes.size());
179: Arpit Agarwal, info, CatchClause, LOG.info("check routine threw exception " + e);
99: Hanisha Koneru, info, MethodDeclaration, LOG.info("Executing {}", testName.getMethodName());
81: Hanisha Koneru, info, MethodDeclaration, LOG.info("Executing {}", testName.getMethodName());
131: Hanisha Koneru, info, MethodDeclaration, LOG.info("Executing {}", testName.getMethodName());
175: Hanisha Koneru, info, MethodDeclaration, LOG.info("Executing {}", testName.getMethodName());
123: Lei Xu, info, MethodDeclaration, LOG.info("Corrupting block file: " + blockFile);
139: Lei Xu, info, MethodDeclaration, LOG.info("Corrupting block file with new content: " + blockFile);
147: Lei Xu, info, MethodDeclaration, LOG.info("Truncating block file: " + blockFile);
153: Lei Xu, info, MethodDeclaration, LOG.info("Deleting block file: " + blockFile);
160: Lei Xu, info, MethodDeclaration, LOG.info("Corrupting meta file: " + metaFile);
172: Lei Xu, info, MethodDeclaration, LOG.info("Deleting metadata file: " + metaFile);
178: Lei Xu, info, MethodDeclaration, LOG.info("Truncating metadata file: " + metaFile);
230: Lei Xu, error, CatchClause, LOG.error("Block file for " + block + " does not existed:", e);
49: Lei Xu, warn, CatchClause, FsDatasetImpl.LOG.warn(String.format("Replica with id %d was not found in block pool %s.", bid, bpid), e);
114: Colin Patrick Mccabe, warn, CatchClause, FsDatasetImpl.LOG.warn(String.format("I/O error releasing file lock %s.", lockFile.getAbsolutePath()), e);
79: Arpit Agarwal, DEBUG, InitializerDeclaration, DFSTestUtil.setNameNodeLogLevel(Level.DEBUG);
135: cnauroth, info, MethodDeclaration, LOG.info("Ensure path: " + path + " is on StorageType: " + storageType);
152: Arpit Agarwal, warn, CatchClause, LOG.warn("Exception got in ensureFileReplicasOnStorageType()", ioe);
325: cnauroth, info, MethodDeclaration, LOG.info("Cluster startup complete");
336: Arpit Agarwal, info, MethodDeclaration, LOG.info("LazyPersistTestCase: faking mlock of " + identifier + " bytes.");
341: Arpit Agarwal, info, MethodDeclaration, LOG.info("LazyPersistTestCase: fake return " + Long.MAX_VALUE);
347: Arpit Agarwal, info, MethodDeclaration, LOG.info("LazyPersistTestCase: fake return " + true);
447: cnauroth, warn, IfStmt, LOG.warn("blockFile: " + blockFile.getAbsolutePath() + " exists after deletion.");
455: cnauroth, warn, IfStmt, LOG.warn("metaFile: " + metaFile.getAbsolutePath() + " exists after deletion.");
466: cnauroth, info, MethodDeclaration, LOG.info("Verifying replica has no saved copy after deletion.");
219: Lei Xu, info, ForStmt, LOG.info("expectedVolumes " + i + " is " + new File(pathUri).getAbsolutePath());
232: Lei Xu, info, ForStmt, LOG.info("actualVolume " + i + " is " + volumeName);
569: Xiao Chen, info, CatchClause, LOG.info("Unexpected exception when waiting for vol removal:", e);
571: Lei Xu, info, MethodDeclaration, LOG.info("Getting block report");
573: Lei Xu, info, MethodDeclaration, LOG.info("Successfully received block report");
600: Lei Xu, warn, CatchClause, LOG.warn("Exception caught. This should not affect the test", e);
582: Xiao Chen, info, TryStmt, LOG.info("CreateRbw finished");
591: Xiao Chen, info, CatchClause, LOG.info("Ignoring ", ie);
598: Xiao Chen, info, TryStmt, LOG.info("FinalizeBlock finished");
611: Arpit Agarwal, info, CatchClause, LOG.info("Problem preparing volumes to remove: ", e);
615: Arpit Agarwal, info, MethodDeclaration, LOG.info("Removing volume " + volumesToRemove);
618: Arpit Agarwal, info, MethodDeclaration, LOG.info("Removed volume " + volumesToRemove);
794: Anu Engineer, info, CatchClause, LOG.info("Exception in testMoveBlockFailure ", ex);
785: Anu Engineer, info, TryStmt, LOG.info("GenerationStamp of old replica: {}", block.getGenerationStamp());
787: Anu Engineer, info, TryStmt, LOG.info("GenerationStamp of new replica: {}", fsDataSetImpl.getReplicaInfo(block.getBlockPoolId(), newReplicaInfo.getBlockId()).getGenerationStamp());
824: Anu Engineer, info, CatchClause, LOG.info("Exception in testMoveBlockSuccess ", ex);
901: Arpit Agarwal, info, TryStmt, LOG.info("Reading partial data for block {} before moving it: ", blk.getBlock().toString());
128: Todd Lipcon, info, MethodDeclaration, DataNode.LOG.info("blocks.size()=" + blocks.size());
195: Todd Lipcon, info, TryStmt, InterDatanodeProtocol.LOG.info("b=" + b + ", " + b.getClass());
62: arp, info, CatchClause, LOG.info("Got expected exception ", t);
82: Arpit Agarwal, info, CatchClause, LOG.info("Got expected exception ", t);
205: arp, error, CatchClause, LOG.error("readerRunnable error", e);
299: arp, error, CatchClause, LOG.error("Writer exception: writer id:" + id + " testfile: " + paths[i].toString() + " " + e);
193: Arpit Agarwal, info, MethodDeclaration, LOG.info("cacheUsed=" + cacheUsed + ", waiting for it to be " + expectedLockedBytes);
171: Arpit Agarwal, info, CatchClause, LOG.info("Got expected exception ", t);
48: Arpit Agarwal, info, MethodDeclaration, LOG.info("Restarting the DataNode");
69: Arpit Agarwal, info, MethodDeclaration, LOG.info("Restarting the DataNode");
52: Arpit Agarwal, info, MethodDeclaration, LOG.info("Verifying copy was saved to lazyPersist/");
150: Arpit Agarwal, info, ForStmt, LOG.info("Touching file " + paths[indexes.get(i)]);
141: Virajith Jalaparti, info, TryStmt, LOG.info("Creating file for blkid " + currentCount);
143: Virajith Jalaparti, info, TryStmt, LOG.info("Block id " + currentCount + " corresponds to file " + newFile.getAbsolutePath());
384: Virajith Jalaparti, info, CatchClause, LOG.info("Expected exception: " + e);
646: Virajith Jalaparti, info, CatchClause, LOG.info("Expected exception " + e);
521: arp, info, MethodDeclaration, LOG.info("Stress test created " + filesCreated + " files and hit " + numFailures + " failures");
662: Brahma Reddy Battula, info, MethodDeclaration, LOG.info("dn " + dn.getDisplayName() + " space : " + volume.getReservedForReplicas());
680: Vinayakumar B, info, MethodDeclaration, LOG.info("dn " + dn.getDisplayName() + " space : " + volume.getReservedForReplicas() + ", Expected ReservedSpace :" + expectedReserved);
99: Arpit Agarwal, info, MethodDeclaration, LOG.info("Got back outlier nodes: {}", outliers);
135: Arpit Agarwal, info, ForStmt, LOG.info("Generating stats for node {}", nodeName);
250: Arpit Agarwal, info, ForeachStmt, LOG.info("Verifying set {}", entry.getKey());
264: Inigo Goiri, info, IfStmt, LOG.info("Block Pool Id:  {}, blockCount: {}", blockPoolID, blockCount);
552: Anu Engineer, info, MethodDeclaration, LOG.info("FSDataSet: " + node.getFSDataset());
576: Anu Engineer, info, MethodDeclaration, LOG.info("Waiting for the disk removal!");
580: Anu Engineer, info, CatchClause, LOG.info("Encountered " + e);
582: Anu Engineer, info, MethodDeclaration, LOG.info("Got disk removal notification, resuming copyBlocks!");
597: Anu Engineer, info, MethodDeclaration, LOG.info("Reconfigure newDirs:" + newDirs);
601: Anu Engineer, info, TryStmt, LOG.info("Waiting for work plan creation!");
603: Anu Engineer, info, TryStmt, LOG.info("Work plan created. Removing disk!");
609: Anu Engineer, info, TryStmt, LOG.info("Removed disk!");
626: Anu Engineer, info, TryStmt, LOG.info("Work Status: " + diskBalancer.queryWorkStatus().toJsonString());
660: Inigo Goiri, info, ForeachStmt, LOG.info("{} : Block Count : {}", refs, DiskBalancerTestUtil.getBlockCount(volume, true));
410: Anu Engineer, error, CatchClause, LOG.error(ex.toString());
464: Anu Engineer, info, SynchronizedStmt, LOG.info("Run count : " + runCount);
430: Arpit Agarwal, info, MethodDeclaration, LOG.info("Number of steps are : %d%n", newPlan.getVolumeSetPlans().size());
248: Tsz-Wo Nicholas Sze, error, CatchClause, LOG.error("Exception while getting located blocks", e);
257: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("Archive replica count, expected={} and actual={}", expectedDiskCount, diskCount);
421: Zhe Zhang, error, CatchClause, LOG.error("Exception while getting located blocks", e);
430: Zhe Zhang, info, MethodDeclaration, LOG.info("Archive replica count, expected={} and actual={}", expectedArchiveCount, archiveCount);
969: Uma Maheswara Rao G, info, ForStmt, LOG.info("Simulate block pinning in datanode {}", dn);
1107: Uma Maheswara Rao G, info, IfStmt, LOG.info("Simulate block pinning in datanode {}", datanodeInfo);
461: Tsz-Wo Nicholas Sze, info, IfStmt, LOG.info("rename " + src + " to " + dst);
474: Jing Zhao, info, MethodDeclaration, LOG.info("testMigrateFileToArchival");
489: Jing Zhao, info, MethodDeclaration, LOG.info("\n\n\n\n================================================\n" + string + "\n" + "==================================================\n\n");
499: Jing Zhao, info, MethodDeclaration, LOG.info("testMoveSpecificPaths");
535: Jing Zhao, info, MethodDeclaration, LOG.info("testMigrateOpenFileToArchival");
562: Jing Zhao, info, TryStmt, LOG.info("Locations: " + lbs);
575: Jing Zhao, info, TryStmt, LOG.info("Locations: " + lbs);
598: Jing Zhao, info, MethodDeclaration, LOG.info("testHotWarmColdDirs");
617: Kai Zheng, info, MethodDeclaration, LOG.info("Waiting for replicas count " + expectedReplicaNum + ", file name: " + file);
643: Colin Patrick Mccabe, error, CatchClause, LOG.error("Unexpected exception by closing FsVolumeReference", e);
637: Colin Patrick Mccabe, info, IfStmt, LOG.info("setCapacity to 0 for [" + volume.getStorageType() + "]" + volume.getStorageID());
652: Jing Zhao, info, MethodDeclaration, LOG.info("testNoSpaceDisk");
712: Jing Zhao, info, MethodDeclaration, LOG.info("testNoSpaceArchive");
489: Aaron Myers, info, ForeachStmt, LOG.info("examining name dir with files: " + Joiner.on(",").join(nameDir.listFiles()));
492: Aaron Myers, info, ForeachStmt, LOG.info("Examining storage dir " + nameDir + " with contents: " + StringUtils.join(nameDir.listFiles(), ", "));
566: Todd Lipcon, info, MethodDeclaration, LOG.info("current storages and corresponding sizes:");
569: Todd Lipcon, info, ForeachStmt, LOG.info("In directory " + curDir);
573: Todd Lipcon, info, ForeachStmt, LOG.info("  file " + f.getAbsolutePath() + "; len = " + f.length());
148: Todd Lipcon, fatal, MethodDeclaration, LOG.fatal("Log level = " + logLevel.toString());
262: Todd Lipcon, info, TryStmt, LOG.info("Starting " + numOpsRequired + " " + getOpName() + "(s).");
373: Todd Lipcon, info, MethodDeclaration, LOG.info("--- " + getOpName() + " stats  ---");
374: Todd Lipcon, info, MethodDeclaration, LOG.info("# operations: " + getNumOpsExecuted());
375: Todd Lipcon, info, MethodDeclaration, LOG.info("Elapsed Time: " + getElapsedTime());
376: Todd Lipcon, info, MethodDeclaration, LOG.info(" Ops per sec: " + getOpsPerSecond());
377: Todd Lipcon, info, MethodDeclaration, LOG.info("Average Time: " + getAverageTime());
407: Todd Lipcon, error, CatchClause, LOG.error("StatsDaemon " + daemonId + " failed: \n" + StringUtils.stringifyException(ex));
496: Todd Lipcon, info, MethodDeclaration, LOG.info("--- " + getOpName() + " inputs ---");
497: Todd Lipcon, info, MethodDeclaration, LOG.info("Remove directory " + BASE_DIR_NAME);
558: Todd Lipcon, info, MethodDeclaration, LOG.info("Generate " + numOpsRequired + " intputs for " + getOpName());
605: Todd Lipcon, info, MethodDeclaration, LOG.info("--- " + getOpName() + " inputs ---");
606: Todd Lipcon, info, MethodDeclaration, LOG.info("nrFiles = " + numOpsRequired);
607: Todd Lipcon, info, MethodDeclaration, LOG.info("nrThreads = " + numThreads);
608: Todd Lipcon, info, MethodDeclaration, LOG.info("nrFilesPerDir = " + nameGenerator.getFilesPerDirectory());
663: Konstantin Shvachko, info, MethodDeclaration, LOG.info("Generate " + numOpsRequired + " inputs for " + getOpName());
697: Konstantin Shvachko, info, MethodDeclaration, LOG.info("--- " + getOpName() + " inputs ---");
698: Konstantin Shvachko, info, MethodDeclaration, LOG.info("nrDirs = " + numOpsRequired);
699: Konstantin Shvachko, info, MethodDeclaration, LOG.info("nrThreads = " + numThreads);
700: Konstantin Shvachko, info, MethodDeclaration, LOG.info("nrDirsPerDir = " + nameGenerator.getFilesPerDirectory());
756: Todd Lipcon, info, IfStmt, LOG.info("useExisting = true. Assuming " + numOpsRequired + " files have been created before.");
754: Todd Lipcon, info, IfStmt, LOG.info("Created " + numOpsRequired + " files.");
964: Todd Lipcon, debug, IfStmt, LOG.debug("sendHeartbeat Name-node reply: " + cmd.getAction());
973: Todd Lipcon, debug, IfStmt, LOG.debug("Cannot add block: datanode capacity = " + blocks.size());
1134: Arpit Agarwal, info, MethodDeclaration, LOG.info("Creating " + nrFiles + " files with " + blocksPerFile + " blocks each.");
1201: Masatake Iwasaki, warn, CatchClause, LOG.warn("interrupted while retrying addBlock.", ie);
1238: Todd Lipcon, info, MethodDeclaration, LOG.info("--- " + getOpName() + " inputs ---");
1239: Todd Lipcon, info, MethodDeclaration, LOG.info("reports = " + numOpsRequired);
1240: Todd Lipcon, info, MethodDeclaration, LOG.info("datanodes = " + numThreads + " " + blockDistribution);
1241: Todd Lipcon, info, MethodDeclaration, LOG.info("blocksPerReport = " + blocksPerReport);
1242: Todd Lipcon, info, MethodDeclaration, LOG.info("blocksPerFile = " + blocksPerFile);
1351: Eli Collins, info, ForStmt, LOG.info("Datanode " + dn + " is decommissioned.");
1388: Todd Lipcon, info, MethodDeclaration, LOG.info("--- " + getOpName() + " inputs ---");
1389: Todd Lipcon, info, MethodDeclaration, LOG.info("numOpsRequired = " + numOpsRequired);
1390: Todd Lipcon, info, MethodDeclaration, LOG.info("datanodes = " + numDatanodes + " " + blockDistribution);
1391: Todd Lipcon, info, MethodDeclaration, LOG.info("decommissioned datanodes = " + nodesToDecommission);
1392: Todd Lipcon, info, MethodDeclaration, LOG.info("datanode replication limit = " + nodeReplicationLimit);
1393: Todd Lipcon, info, MethodDeclaration, LOG.info("total blocks = " + totalBlocks);
1395: Todd Lipcon, info, MethodDeclaration, LOG.info("decommissioned blocks = " + numDecommissionedBlocks);
1396: Todd Lipcon, info, MethodDeclaration, LOG.info("pending replications = " + numPendingBlocks);
1397: Todd Lipcon, info, MethodDeclaration, LOG.info("replications per sec: " + getBlocksPerSecond());
1539: Todd Lipcon, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
1489: Xiaoyu Yao, warn, IfStmt, LOG.warn("The replication test is ignored as it does not support " + "standalone namenode in another process or on another host. ");
1505: Konstantin V Shvachko, info, IfStmt, LOG.info("Remote NameNode is not specified. Creating one.");
1529: Todd Lipcon, info, ForeachStmt, LOG.info("Starting benchmark: " + op.getOpName());
1535: Todd Lipcon, info, ForeachStmt, LOG.info("");
129: Todd Lipcon, info, MethodDeclaration, LOG.info("Creating edits by performing fs operations");
91: Konstantin Shvachko, info, MethodDeclaration, LOG.info("Starting first addBlock for " + src);
108: Konstantin V Shvachko, info, MethodDeclaration, LOG.info("Starting second addBlock for " + src);
162: Jing Zhao, info, MethodDeclaration, LOG.info("Starting first addBlock for " + src);
97: Todd Lipcon, info, IfStmt, LOG.info("Stopping mini cluster");
113: Todd Lipcon, info, MethodDeclaration, LOG.info("--starting mini cluster");
127: Todd Lipcon, info, MethodDeclaration, LOG.info("Mini cluster created OK");
142: Todd Lipcon, info, CatchClause, LOG.info("Expected failure: " + StringUtils.stringifyException(e));
143: Todd Lipcon, info, CatchClause, LOG.info("Done verifying format will fail with allowformat false");
146: Todd Lipcon, info, MethodDeclaration, LOG.info("Verifying format will succeed with allowformat true");
149: Todd Lipcon, info, MethodDeclaration, LOG.info("Done verifying format will succeed with allowformat true");
76: Vinayakumar B, INFO, MethodDeclaration, DefaultAuditLogger logger = makeSpyLogger(Level.INFO, Optional.of(Arrays.asList(DUMMY_COMMAND_1)));
85: Vinayakumar B, DEBUG, MethodDeclaration, DefaultAuditLogger logger = makeSpyLogger(Level.DEBUG, Optional.of(Arrays.asList(DUMMY_COMMAND_1)));
94: Vinayakumar B, INFO, MethodDeclaration, DefaultAuditLogger logger = makeSpyLogger(Level.INFO, Optional.of(Arrays.asList(DUMMY_COMMAND_1)));
103: Vinayakumar B, INFO, MethodDeclaration, DefaultAuditLogger logger = makeSpyLogger(Level.INFO, Optional.of(Arrays.asList(DUMMY_COMMAND_1, DUMMY_COMMAND_2)));
114: Vinayakumar B, DEBUG, MethodDeclaration, DefaultAuditLogger logger = makeSpyLogger(Level.DEBUG, Optional.of(Arrays.asList(DUMMY_COMMAND_1, DUMMY_COMMAND_2)));
125: Vinayakumar B, INFO, MethodDeclaration, DefaultAuditLogger logger = makeSpyLogger(Level.INFO, Optional.<List<String>>absent());
257: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
268: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
280: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
291: Arpit Agarwal, info, TryStmt, LOG.info("Set empty caller context");
301: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
328: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
355: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
366: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
376: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
387: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
396: Jitendra Pandey, info, TryStmt, LOG.info("Set current caller context as {}", CallerContext.getCurrent());
123: Todd Lipcon, info, TryStmt, LOG.info("Waiting checkpoint to complete... " + "checkpoint txid should increase above " + txid);
172: Yongjun Zhang, info, CatchClause, LOG.info("IOException is thrown creating name node");
188: cnauroth, info, CatchClause, LOG.info("IOException thrown.", e);
290: Todd Lipcon, info, TryStmt, LOG.info("Shutting down...");
309: Todd Lipcon, info, ForStmt, LOG.info("Creating " + src + " on NN");
316: Todd Lipcon, info, MethodDeclaration, LOG.info("Checking for " + src + " on BN");
389: Todd Lipcon, Error, CatchClause, LOG.error("Error in TestBackupNode:", e);
473: Todd Lipcon, Error, CatchClause, LOG.error("Error in TestBackupNode:", e);
446: Konstantin Shvachko, info, CatchClause, LOG.info("Write to " + backup.getRole() + " failed as expected: ", eio);
456: Konstantin Shvachko, info, CatchClause, LOG.info("Read from " + backup.getRole() + " failed: ", eio);
497: Konstantin Shvachko, Error, CatchClause, LOG.error("Error in TestBackupNode: ", e);
551: Konstantin Shvachko, Error, CatchClause, LOG.error("Error in TestBackupNode: ", e);
737: Colin McCabe, info, MethodDeclaration, LOG.info("Waiting for " + expectedCachedBlocks + " blocks with " + expectedCachedReplicas + " replicas.");
759: Andrew Wang, info, MethodDeclaration, LOG.info(logString + " cached blocks: have " + numCachedBlocks + " / " + expectedCachedBlocks + ".  " + "cached replicas: have " + numCachedReplicas + " / " + expectedCachedReplicas);
781: Andrew Wang, info, MethodDeclaration, LOG.info("Polling listCacheDirectives " + ((filter == null) ? "ALL" : filter.toString()) + " for " + targetBytesNeeded + " targetBytesNeeded, " + targetBytesCached + " targetBytesCached, " + targetFilesNeeded + " targetFilesNeeded, " + targetFilesCached + " targetFilesCached");
807: Andrew Wang, info, IfStmt, LOG.info(infoString + ": " + "filesNeeded: " + stats.getFilesNeeded() + "/" + targetFilesNeeded + ", filesCached: " + stats.getFilesCached() + "/" + targetFilesCached + ", bytesNeeded: " + stats.getBytesNeeded() + "/" + targetBytesNeeded + ", bytesCached: " + stats.getBytesCached() + "/" + targetBytesCached);
827: Andrew Wang, info, MethodDeclaration, LOG.info("Polling listCachePools " + pool.toString() + " for " + targetBytesNeeded + " targetBytesNeeded, " + targetBytesCached + " targetBytesCached, " + targetFilesNeeded + " targetFilesNeeded, " + targetFilesCached + " targetFilesCached");
866: Andrew Wang, info, IfStmt, LOG.info(infoString + ": " + "filesNeeded: " + stats.getFilesNeeded() + "/" + targetFilesNeeded + ", filesCached: " + stats.getFilesCached() + "/" + targetFilesCached + ", bytesNeeded: " + stats.getBytesNeeded() + "/" + targetBytesNeeded + ", bytesCached: " + stats.getBytesCached() + "/" + targetBytesCached);
905: Andrew Wang, info, MethodDeclaration, LOG.info("Found " + numCachedBlocks + " of " + expectedBlocks + " blocks");
906: Andrew Wang, info, MethodDeclaration, LOG.info("Found " + numCachedReplicas + " of " + expectedReplicas + " replicas");
163: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting testNameDirError");
199: Todd Lipcon, info, MethodDeclaration, LOG.info("Check IOException handled correctly by writeTransactionIdFile");
337: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting testSecondaryNamenodeError1");
409: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting testSecondaryNamenodeError2");
481: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting testSecondaryNamenodeError3");
572: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting testSecondaryFailsToReturnImage");
658: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting testNameNodeImageSendFailWrongSize");
673: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting testNameNodeImageSendFailWrongDigest");
830: Todd Lipcon, info, TryStmt, LOG.info("===> Shutting down first 2NN");
834: Todd Lipcon, info, TryStmt, LOG.info("===> Locking a dir, starting second 2NN");
836: Todd Lipcon, info, TryStmt, LOG.info("Trying to lock" + savedSd);
965: Todd Lipcon, info, MethodDeclaration, LOG.info("Trying to import checkpoint when the NameNode already " + "contains an image. This should fail.");
981: Todd Lipcon, info, MethodDeclaration, LOG.info("Removing NN storage contents");
984: Todd Lipcon, info, ForeachStmt, LOG.info("Cleaning " + dir);
988: Todd Lipcon, info, MethodDeclaration, LOG.info("Trying to import checkpoint");
1210: Todd Lipcon, info, ForeachStmt, LOG.info("Files in " + curDir + ":\n  " + Joiner.on("\n  ").join(curDir.list()));
1316: Todd Lipcon, info, CatchClause, LOG.info("Got expected failure", ioe);
1325: Todd Lipcon, info, CatchClause, LOG.info("Got expected failure", ioe);
1416: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting testSecondaryImageDownload");
1959: Todd Lipcon, info, CatchClause, LOG.info("Got expected failure", ioe);
2195: Todd Lipcon, info, MethodDeclaration, LOG.info("Waiting for checkpoint txn id to go to 2");
2208: Todd Lipcon, info, MethodDeclaration, LOG.info("Waiting for checkpoint txn id to go > 2");
2423: Suresh Srinivas, warn, CatchClause, LOG.warn("Encountered ", e);
2430: Suresh Srinivas, warn, CatchClause, LOG.warn("Encountered ", e);
2480: Todd Lipcon, warn, CatchClause, LOG.warn("Could not shut down secondary namenode", e);
2490: Suresh Srinivas, warn, CatchClause, LOG.warn("Could not shutdown MiniDFSCluster ", e);
75: Todd Lipcon, info, MethodDeclaration, LOG.info("successfully formated : sd=" + sd.getCurrentDir() + ";cid=" + cid);
89: Todd Lipcon, info, MethodDeclaration, LOG.info("hdfsdir is " + hdfsDir.getAbsolutePath());
384: Kihwal Lee, info, MethodDeclaration, LOG.info("Shutdown dn1");
394: Kihwal Lee, info, MethodDeclaration, LOG.info("Shutdown dn0");
404: Kihwal Lee, info, MethodDeclaration, LOG.info("Decommissioning nodes");
418: Kihwal Lee, info, MethodDeclaration, LOG.info("Bring back dn0");
430: Kihwal Lee, info, MethodDeclaration, LOG.info("Bring back dn1");
446: Kihwal Lee, info, MethodDeclaration, LOG.info("Starting two more nodes");
174: Jing Zhao, info, CatchClause, LOG.info(e);
163: Jing Zhao, info, TryStmt, LOG.info("Deleting" + path);
172: Jing Zhao, info, TryStmt, LOG.info("Deleted" + path);
199: Colin McCabe, info, CatchClause, LOG.info(e);
194: Colin McCabe, info, TryStmt, LOG.info("Renaming " + from + " to " + to);
197: Colin McCabe, info, TryStmt, LOG.info("Renamed " + from + " to " + to);
243: Andrew Wang, info, MethodDeclaration, LOG.info("Start testing, hasSnapshot: " + hasSnapshot);
277: Kihwal Lee, info, ForeachStmt, LOG.info("test on " + testPath + " mkSameDir: " + mkSameDir + " snapshot: " + hasSnapshot);
286: Andrew Wang, info, ForeachStmt, LOG.info("test on " + testPath + " created " + fPath);
304: Andrew Wang, info, ForeachStmt, LOG.info("Expecting block recovery to be triggered on DN " + expectedPrimary);
329: Andrew Wang, info, ForeachStmt, LOG.info("Waiting for commitBlockSynchronization call from primary");
332: Andrew Wang, info, ForeachStmt, LOG.info("Deleting recursively " + grandestNonRootParent);
335: Kihwal Lee, info, IfStmt, LOG.info("Recreate dir " + grandestNonRootParent + " testpath: " + testPath);
340: Andrew Wang, info, ForeachStmt, LOG.info("Now wait for result");
344: Andrew Wang, info, IfStmt, LOG.info("Result exception (snapshot: " + hasSnapshot + "): " + t);
347: Andrew Wang, info, TryStmt, LOG.info("Now check we can restart");
349: Andrew Wang, info, TryStmt, LOG.info("Restart finished");
392: Xiao Chen, info, TryStmt, LOG.info("test on " + testPath);
433: Xiao Chen, info, TryStmt, LOG.info("Now check we can restart");
435: Xiao Chen, info, TryStmt, LOG.info("Restart finished");
468: Todd Lipcon, error, CatchClause, LOG.error("Couldn't shut down cleanly", t);
648: Todd Lipcon, debug, ForeachStmt, LOG.debug("Corrupting Log File: " + editFile + " len: " + fileLen);
699: Todd Lipcon, info, TryStmt, LOG.info("\n===========================================\n" + "Starting empty cluster");
719: Todd Lipcon, info, TryStmt, LOG.info("Copying data directory aside to a hot backup");
723: Todd Lipcon, info, TryStmt, LOG.info("Shutting down cluster #1");
746: Todd Lipcon, info, TryStmt, LOG.info("\n===========================================\n" + "Starting same cluster after simulated crash");
884: Todd Lipcon, info, IfStmt, LOG.info("Should have succeeded in starting cluster, but failed", ioe);
1266: Jitendra Nath Pandey, info, ForeachStmt, LOG.info("Loading edits " + edits + " read " + read);
1446: Todd Lipcon, error, CatchClause, LOG.error("edit log failover didn't work", e);
1480: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Corrupting Log File: " + files[0] + " len: " + fileLen);
1496: Todd Lipcon, error, CatchClause, LOG.error("edit log failover didn't work", e);
1550: Todd Lipcon, info, MethodDeclaration, LOG.info(String.format("loaded %d edit log segments in %.2f seconds", NUM_EDIT_LOG_ROLLS, delta));
116: Arpit Agarwal, info, CatchClause, LOG.info("Set up MiniDFSCluster failed due to port conflicts, retry " + retryCount + " times");
92: Colin Patrick Mccabe, debug, MethodDeclaration, LOG.debug("Creating test edit log file: " + editLog);
121: Colin Patrick Mccabe, debug, MethodDeclaration, LOG.debug("Corrupting last 4 bytes of edit log file " + editLog + ", whose length is " + fileLen);
134: Colin Patrick Mccabe, debug, MethodDeclaration, LOG.debug("Read transaction 1 from " + editLog);
139: Colin Patrick Mccabe, debug, CatchClause, LOG.debug("Caught expected checksum error when reading corrupt " + "transaction 2", e);
169: Todd Lipcon, warn, CatchClause, LOG.warn("Got error in transaction thread", e);
239: Todd Lipcon, info, ForStmt, LOG.info("Starting roll " + i + ".");
320: Todd Lipcon, info, ForStmt, LOG.info("Save " + i + ": entering safe mode");
331: Todd Lipcon, info, ForStmt, LOG.info("Save " + i + ": saving namespace");
333: Todd Lipcon, info, ForStmt, LOG.info("Save " + i + ": leaving safemode");
348: Todd Lipcon, info, ForStmt, LOG.info("Save " + i + ": complete");
479: Haohui Mai, info, TryStmt, LOG.info("Closing nn");
421: Todd Lipcon, fatal, CatchClause, LOG.fatal("Got exception", ioe);
415: Todd Lipcon, info, TryStmt, LOG.info("Starting mkdirs");
419: Todd Lipcon, info, TryStmt, LOG.info("mkdirs complete");
431: Todd Lipcon, info, MethodDeclaration, LOG.info("Flush called");
433: Todd Lipcon, info, IfStmt, LOG.info("edit thread: Telling main thread we made it to flush section...");
436: Todd Lipcon, info, IfStmt, LOG.info("edit thread: sleeping for " + BLOCK_TIME + "secs");
438: Todd Lipcon, info, IfStmt, LOG.info("Going through to flush. This will allow the main thread to continue.");
441: Todd Lipcon, info, MethodDeclaration, LOG.info("Flush complete");
449: Todd Lipcon, info, TryStmt, LOG.info("Main thread: waiting to enter flush...");
452: Todd Lipcon, info, TryStmt, LOG.info("Main thread: detected that logSync is in unsynchronized section.");
453: Todd Lipcon, info, TryStmt, LOG.info("Trying to enter safe mode.");
454: Todd Lipcon, info, TryStmt, LOG.info("This should block for " + BLOCK_TIME + "sec, since flush will sleep that long");
459: Todd Lipcon, info, TryStmt, LOG.info("Entered safe mode");
466: Todd Lipcon, info, TryStmt, LOG.info("Joining on edit thread...");
563: Haohui Mai, info, TryStmt, LOG.info("Closing nn");
523: Todd Lipcon, fatal, CatchClause, LOG.fatal("Got exception", ioe);
510: Jing Zhao, info, TryStmt, LOG.info("Starting setOwner");
518: Jing Zhao, info, TryStmt, LOG.info("edit thread: sleeping for " + BLOCK_TIME + "secs");
521: Jing Zhao, info, TryStmt, LOG.info("edit thread: logSync complete");
531: Todd Lipcon, info, TryStmt, LOG.info("Main thread: waiting to just before logSync...");
534: Todd Lipcon, info, TryStmt, LOG.info("Main thread: detected that logSync about to be called.");
535: Todd Lipcon, info, TryStmt, LOG.info("Trying to enter safe mode.");
540: Jing Zhao, info, TryStmt, LOG.info("Entered safe mode after " + (et - st) + "ms");
550: Todd Lipcon, info, TryStmt, LOG.info("Joining on edit thread...");
127: Wei-Chiu Chuang, info, CatchClause, EditsDoubleBuffer.LOG.info("Exception expected: ", ioe);
102: Chris Nauroth, info, IfStmt, LOG.info("getNumberOfTransactions: detected gap at txId " + fromTxId);
143: Tsz-Wo Nicholas Sze, info, ForStmt, LOG.info("fileLength=" + fileLength + ", newLength=" + newLength + ", toTruncate=" + toTruncate + ", isReady=" + isReady);
176: Tsz-Wo Nicholas Sze, info, ForStmt, LOG.info("newLength=" + newLength + ", isReady=" + isReady);
209: Konstantin V Shvachko, info, MethodDeclaration, LOG.info("newLength=" + newLength + ", isReady=" + isReady);
176: Lei Xu, info, MethodDeclaration, LOG.info("OUTPUT = " + bStream.toString());
438: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("WATERMELON: outStr = " + outStr);
521: Wei-Chiu Chuang, info, IfStmt, LOG.info("Corrupted block file " + blockFile);
1002: Lei Xu, warn, CatchClause, LOG.warn("Unexpected exception: " + e);
1057: Lei Xu, warn, CatchClause, LOG.warn("Unexpected exception: " + e);
1665: Lei Xu, warn, CatchClause, LOG.warn("Unexpected exception: " + e);
1691: Lei Xu, warn, CatchClause, LOG.warn("Unexpected exception: " + e);
1980: Lei Xu, warn, CatchClause, LOG.warn("Unexpected exception: " + e);
2005: Lei Xu, warn, CatchClause, LOG.warn("Unexpected exception: " + e);
2193: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("Created files: " + Arrays.toString(fileNames));
2229: Wei-Chiu Chuang, error, CatchClause, LOG.error("Exception caught", e);
2237: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("Moving blocks to lost+found");
2247: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("Items in lost+found: " + retVal);
2453: Wei-Chiu Chuang, error, CatchClause, LOG.error("Exception caught", e);
97: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("nNameNodes=" + nNameNodes + ", nDataNodes=" + nDataNodes);
99: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("RUN_TEST -1");
105: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("RUN_TEST 0");
110: Tsz-Wo Nicholas Sze, info, TryStmt, LOG.info("RUN_TEST 1");
116: Tsz-Wo Nicholas Sze, info, TryStmt, LOG.info("RUN_TEST 2");
120: Tsz-Wo Nicholas Sze, info, ForStmt, LOG.info("urls[" + i + "]=" + urls[i]);
122: Tsz-Wo Nicholas Sze, info, ForStmt, LOG.info("result=" + result);
137: Gera Shegalov, info, ForStmt, LOG.info("vurls[" + i + "]=" + vurls[i]);
139: Gera Shegalov, info, ForStmt, LOG.info("result=" + result);
145: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("RUN_TEST 6");
124: Suresh Srinivas, info, MethodDeclaration, LOG.info("Original tree");
269: Andrew Wang, info, WhileStmt, LOG.info("Currently have " + numExpectedXAttrs + " xattrs");
280: Andrew Wang, info, WhileStmt, LOG.info("Attempting to add " + toAdd.size() + " XAttrs");
282: Andrew Wang, info, ForStmt, LOG.info("Will add XAttr " + toAdd.get(i));
293: Andrew Wang, info, WhileStmt, LOG.info("Currently have " + numExpectedXAttrs + " xattrs");
304: Andrew Wang, info, WhileStmt, LOG.info("Attempting to remove " + expectedNumToRemove + " XAttrs");
126: Lei Xu, info, TryStmt, LOG.info("adding '" + name + "' to decommission");
304: Yongjun Zhang, info, MethodDeclaration, LOG.info("Test not bypassing provider");
311: Yongjun Zhang, info, MethodDeclaration, LOG.info("Test bypassing provider");
320: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Path '/' is owned by: " + status.getOwner() + ":" + status.getGroup());
151: Andrew Wang, info, CatchClause, LOG.info("Expected exception: ", iae);
161: Andrew Wang, info, CatchClause, LOG.info("Expected exception: ", iae);
172: Andrew Wang, info, CatchClause, LOG.info("Expected exception: ", iae);
183: Andrew Wang, info, CatchClause, LOG.info("Expected exception: ", iae);
632: Suresh Srinivas, info, MethodDeclaration, LOG.info("Inode path is " + p);
891: Suresh Srinivas, info, CatchClause, LOG.info("Expected exception thrown " + expected);
106: Todd Lipcon, info, CatchClause, LOG.info("createFile exception ", ex);
130: Todd Lipcon, info, CatchClause, LOG.info("lockOperation exception ", ex);
145: Todd Lipcon, info, MethodDeclaration, LOG.info("Deletion took " + (end - start) + "msecs");
146: Todd Lipcon, info, MethodDeclaration, LOG.info("createOperations " + createOps);
147: Todd Lipcon, info, MethodDeclaration, LOG.info("lockOperations " + lockOps);
171: Todd Lipcon, warn, CatchClause, LOG.warn(throwable);
206: Todd Lipcon, debug, IfStmt, LOG.debug("Ignoring " + e, e);
107: Colin McCabe, info, TryStmt, LOG.info("Deliberately corrupting file " + metaFile.getName() + " at offset " + position + " length " + length);
122: Todd Lipcon, info, TryStmt, LOG.info("Namenode has bad files. " + badFiles.size());
250: Todd Lipcon, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
187: Colin McCabe, info, TryStmt, LOG.info("Deliberately corrupting file " + metaFile.getName() + " at offset " + position + " length " + length);
204: Todd Lipcon, info, TryStmt, LOG.info("Namenode has bad files. " + badFiles.size());
216: Todd Lipcon, info, TryStmt, LOG.info("waiting for replication queues");
236: Todd Lipcon, info, TryStmt, LOG.info("Namenode has bad files. " + badFiles.size());
297: Colin McCabe, info, ForeachStmt, LOG.info("Deliberately removing file " + blockFile.getName());
299: Colin McCabe, info, ForeachStmt, LOG.info("Deliberately removing file " + metadataFile.getName());
320: Todd Lipcon, info, TryStmt, LOG.info("Namenode has bad files. " + numCorrupt);
362: Todd Lipcon, info, WhileStmt, LOG.info("PATH: " + iter.next().toUri().getPath());
408: Colin McCabe, info, ForeachStmt, LOG.info("Deliberately removing file " + blockFile.getName());
410: Colin McCabe, info, ForeachStmt, LOG.info("Deliberately removing file " + metadataFile.getName());
428: Todd Lipcon, info, TryStmt, LOG.info("Namenode has bad files. " + numCorrupt);
477: Todd Lipcon, info, ForStmt, LOG.info("Removing files from " + data_dir);
505: Todd Lipcon, info, WhileStmt, LOG.info("# of corrupt files is: " + badFiles.size());
512: Todd Lipcon, info, TryStmt, LOG.info("Namenode has bad files. " + badFiles.size());
572: Andrew Wang, info, ForeachStmt, LOG.info("Deliberately removing file " + blockFile.getName());
574: Andrew Wang, info, ForeachStmt, LOG.info("Deliberately removing file " + metadataFile.getName());
591: Andrew Wang, info, TryStmt, LOG.info("Namenode has bad files. " + numCorrupt);
150: Andrew Wang, info, ForStmt, LOG.info("OpenFile: " + filePath);
226: Andrew Wang, Error, CatchClause, LOG.info("Error listing open files: ", e);
238: Andrew Wang, info, TryStmt, LOG.info("Shutting down Active NN0!");
240: Andrew Wang, info, TryStmt, LOG.info("Transitioning NN1 to Active!");
347: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: cluster start failed due to bad configuration" + iae);
536: Aaron Myers, info, CatchClause, LOG.info("EXPECTED: cluster start failed due to missing " + "latest edits dir", e);
98: Todd Lipcon, info, ForeachStmt, LOG.info("Datanode configCapacity " + configCapacity + " used " + used + " non DFS used " + nonDFSUsed + " remaining " + remaining + " perentUsed " + percentUsed + " percentRemaining " + percentRemaining);
138: Todd Lipcon, info, TryStmt, LOG.info("Data node directory " + cluster.getDataDirectory());
140: Todd Lipcon, info, TryStmt, LOG.info("Name node diskCapacity " + diskCapacity + " configCapacity " + configCapacity + " reserved " + reserved + " used " + used + " remaining " + remaining + " nonDFSUsed " + nonDFSUsed + " remaining " + remaining + " percentUsed " + percentUsed + " percentRemaining " + percentRemaining + " bpUsed " + bpUsed + " percentBpUsed " + percentBpUsed);
431: Ming Ma, info, MethodDeclaration, LOG.info("Starting testMaintenanceNodes");
463: Ming Ma, info, TryStmt, LOG.info("Live Nodes: " + liveNodesInfo);
490: Ming Ma, info, IfStmt, LOG.info("Waiting for a node to Enter Maintenance state!");
494: Ming Ma, info, WhileStmt, LOG.info("Nodes entering Maintenance: " + enteringMaintenanceNodesInfo);
125: Eli Collins, debug, WhileStmt, LOG.debug("read txid " + op.txid);
590: Todd Lipcon, info, MethodDeclaration, LOG.info("corrupting edit log file '" + editFile + "'");
607: Todd Lipcon, error, IfStmt, LOG.error("Got unexpected failure with " + corruptor.getName() + corruptor, e);
597: Eli Collins, debug, TryStmt, LOG.debug("trying to start normally (this should fail)...");
622: Eli Collins, debug, TryStmt, LOG.debug("running recovery...");
639: Eli Collins, debug, TryStmt, LOG.debug("starting cluster normally after recovery...");
642: Todd Lipcon, debug, TryStmt, LOG.debug("successfully recovered the " + corruptor.getName() + " corrupted edit log");
82: Arpit Agarwal, info, MethodDeclaration, LOG.info("Testing without " + DFS_NAMENODE_RPC_BIND_HOST_KEY);
98: Arpit Agarwal, info, MethodDeclaration, LOG.info("Testing with " + DFS_NAMENODE_RPC_BIND_HOST_KEY);
122: Arpit Agarwal, info, MethodDeclaration, LOG.info("Testing without " + DFS_NAMENODE_SERVICE_RPC_BIND_HOST_KEY);
140: Arpit Agarwal, info, MethodDeclaration, LOG.info("Testing with " + DFS_NAMENODE_SERVICE_RPC_BIND_HOST_KEY);
164: cnauroth, info, MethodDeclaration, LOG.info("Testing without " + DFS_NAMENODE_LIFELINE_RPC_BIND_HOST_KEY);
182: cnauroth, info, MethodDeclaration, LOG.info("Testing with " + DFS_NAMENODE_LIFELINE_RPC_BIND_HOST_KEY);
206: Arpit Agarwal, info, MethodDeclaration, LOG.info("Testing without " + DFS_NAMENODE_HTTP_BIND_HOST_KEY);
223: Arpit Agarwal, info, MethodDeclaration, LOG.info("Testing with " + DFS_NAMENODE_HTTP_BIND_HOST_KEY);
272: Arpit Agarwal, info, MethodDeclaration, LOG.info("Testing behavior without " + DFS_NAMENODE_HTTPS_BIND_HOST_KEY);
297: Arpit Agarwal, info, MethodDeclaration, LOG.info("Testing behavior with " + DFS_NAMENODE_HTTPS_BIND_HOST_KEY);
145: Chris Douglas, info, IfStmt, LOG.info("verifyFileReplicasOnStorageType: file {} does not exist", path);
160: Chris Douglas, info, MethodDeclaration, LOG.info("Found {}/{} blocks on StorageType {}", foundBlocks, numBlocks, storageType);
145: Todd Lipcon, info, TryStmt, LOG.info("Shutting down...");
84: Todd Lipcon, info, TryStmt, LOG.info("After first save, images 0 and 2 should exist in both dirs");
97: Todd Lipcon, info, TryStmt, LOG.info("After second save, image 0 should be purged, " + "and image 4 should exist in both.");
110: Todd Lipcon, info, TryStmt, LOG.info("Failing first storage dir by chmodding it");
113: Todd Lipcon, info, TryStmt, LOG.info("Restoring accessibility of first storage dir");
116: Todd Lipcon, info, TryStmt, LOG.info("nothing should have been purged in first storage dir");
123: Todd Lipcon, info, TryStmt, LOG.info("fsimage_2 should be purged in second storage dir");
130: Todd Lipcon, info, TryStmt, LOG.info("On next save, we should purge logs from the failed dir," + " but not images, since the image directory is in failed state.");
153: Todd Lipcon, info, MethodDeclaration, LOG.info("Saving namespace...");
245: Arpit Agarwal, info, TryStmt, LOG.info("Running {}", testMatrixEntry);
256: Arpit Agarwal, info, CatchClause, LOG.info("Got expected exception ", t);
307: Arpit Agarwal, info, CatchClause, LOG.info("Got expected exception ", t);
362: Arpit Agarwal, info, CatchClause, LOG.info("Got expected exception ", t);
400: Arpit Agarwal, info, CatchClause, LOG.info("Got expected exception ", t);
428: Arpit Agarwal, info, CatchClause, LOG.info("Got expected exception ", t);
537: Arpit Agarwal, info, CatchClause, LOG.info("Got expected exception ", t);
853: Mingliang Liu, info, CatchClause, LOG.info("Got expected exception ", e);
892: Mingliang Liu, info, CatchClause, LOG.info("Got expected exception ", e);
41: Andrew Wang, info, ConstructorDeclaration, LOG.info("run {} with {}.", TestQuotaWithStripedBlocksWithRandomECPolicy.class.getSuperclass().getSimpleName(), ecPolicy.getName());
226: Xiao Chen, info, CatchClause, LOG.info("Expected exception caught.", expected);
236: Xiao Chen, info, CatchClause, LOG.info("Expected exception caught.", expected);
246: Xiao Chen, info, CatchClause, LOG.info("Expected exception caught.", expected);
257: Xiao Chen, info, CatchClause, LOG.info("Expected exception caught.", expected);
1267: Xiao Chen, info, CatchClause, LOG.info("Expected exception", expected);
1287: Xiao Chen, info, MethodDeclaration, LOG.info("Waiting for re-encrypted zones to be {}", expected);
1296: Xiao Chen, info, TryStmt, LOG.info("Re-encrypted zones = {} ", getReencryptionStatus().getNumZonesReencrypted());
1303: Xiao Chen, info, MethodDeclaration, LOG.info("Waiting for queued zones for re-encryption to be {}", expected);
1314: Xiao Chen, info, MethodDeclaration, LOG.info("Waiting for queued zones for re-encryption to be {}", expected);
1325: Xiao Chen, info, MethodDeclaration, LOG.info("Waiting for re-encryption zone {} to complete.", zone);
1333: Xiao Chen, error, CatchClause, LOG.error("Exception caught", ex);
1355: Xiao Chen, info, MethodDeclaration, LOG.info("Waiting for total re-encrypted file count to be {}", expected);
1439: Xiao Chen, info, CatchClause, LOG.info("Expected exception caught.", expected);
1449: Xiao Chen, info, CatchClause, LOG.info("Expected exception caught.", expected);
1460: Xiao Chen, info, CatchClause, LOG.info("Expected exception caught.", expected);
1486: Xiao Chen, info, CatchClause, LOG.info("Fault injector interrupted", ie);
1519: Xiao Chen, info, MethodDeclaration, LOG.info("Waiting for re-encrypt callables to run");
186: Xiao Chen, info, CatchClause, LOG.info("removeTaskThread interrupted.");
198: Wei-Chiu Chuang, info, MethodDeclaration, LOG.info("Throttle completed, consumed {}", sw.now(TimeUnit.MILLISECONDS));
102: Todd Lipcon, info, IfStmt, LOG.info("Injecting fault for sd: " + sd);
109: Todd Lipcon, info, MethodDeclaration, LOG.info("Not injecting fault for sd: " + sd);
129: Andrew Wang, info, IfStmt, LOG.info("Injecting fault for sd: " + sd);
132: Andrew Wang, info, MethodDeclaration, LOG.info("Not injecting fault for sd: " + sd);
218: Todd Lipcon, info, IfStmt, LOG.info("Test caught expected exception", e);
328: Todd Lipcon, fatal, CatchClause, LOG.fatal("Failed to shut down", t);
283: Todd Lipcon, info, TryStmt, LOG.info("First savenamespace sucessful.");
297: Todd Lipcon, warn, TryStmt, LOG.warn("Second savenamespace sucessful.");
305: Todd Lipcon, info, TryStmt, LOG.info("Shutting down fsimage.");
316: Todd Lipcon, info, TryStmt, LOG.info("Checking reloaded image.");
318: Todd Lipcon, info, TryStmt, LOG.info("Reloaded image is good.");
421: Todd Lipcon, info, CatchClause, LOG.info("Got expected exception", ioe);
460: Todd Lipcon, warn, TryStmt, LOG.warn("Checkpoint signature: " + sig);
590: Todd Lipcon, info, TryStmt, LOG.info("Successfully cancelled a saveNamespace");
110: Todd Lipcon, info, MethodDeclaration, LOG.info("--hdfsdir is " + hdfsDir.getAbsolutePath());
142: Todd Lipcon, info, MethodDeclaration, LOG.info("--starting mini cluster");
180: Aaron Myers, info, TryStmt, LOG.info("--cluster shutdown");
153: Todd Lipcon, info, TryStmt, LOG.info("--starting Secondary Node");
166: Aaron Myers, info, ForStmt, LOG.info("--file " + p.toString() + " created");
167: Aaron Myers, info, ForStmt, LOG.info("--doing checkpoint");
169: Aaron Myers, info, ForStmt, LOG.info("--done checkpoint");
229: Todd Lipcon, info, MethodDeclaration, LOG.info("--removed dir " + dir + ";len was =" + this.fsimageLength);
244: Todd Lipcon, info, MethodDeclaration, LOG.info("--removed dir and recreated " + dir + ";len was =" + this.editsLength);
256: Todd Lipcon, info, MethodDeclaration, LOG.info("-- about to start DFS cluster");
265: Todd Lipcon, info, TryStmt, LOG.info("--NN started with checkpoint option");
293: Todd Lipcon, info, IfStmt, LOG.info("-- edits file " + edf.getAbsolutePath() + "; len = " + edf.length() + "; expected = " + expectedEditsSize);
288: Todd Lipcon, info, IfStmt, LOG.info("--image file " + imf.getAbsolutePath() + "; len = " + imf.length() + "; expected = " + expectedImgSize);
308: Todd Lipcon, info, MethodDeclaration, LOG.info("--starting checkpointStartup2 - same directory for checkpoint");
335: Todd Lipcon, info, MethodDeclaration, LOG.info("--starting testStartup Recovery");
360: Todd Lipcon, info, MethodDeclaration, LOG.info("--starting SecondNN startup test");
372: Todd Lipcon, info, MethodDeclaration, LOG.info("--starting NN ");
385: Todd Lipcon, info, TryStmt, LOG.info("--starting SecondNN");
389: Todd Lipcon, info, TryStmt, LOG.info("--doing checkpoint");
391: Todd Lipcon, info, TryStmt, LOG.info("--done checkpoint");
403: Todd Lipcon, info, TryStmt, LOG.info("--image file " + imf.getAbsolutePath() + "; len = " + imf.length());
404: Todd Lipcon, info, TryStmt, LOG.info("--edits file " + edf.getAbsolutePath() + "; len = " + edf.length());
436: Todd Lipcon, info, MethodDeclaration, LOG.info("Test compressing image.");
448: Todd Lipcon, info, MethodDeclaration, LOG.info("Create an uncompressed fsimage");
461: Todd Lipcon, info, MethodDeclaration, LOG.info("Read an uncomressed image and store it compressed using default codec.");
466: Todd Lipcon, info, MethodDeclaration, LOG.info("Read a compressed image and store it using a different codec.");
472: Haohui Mai, info, MethodDeclaration, LOG.info("Read a compressed image and store it as uncompressed.");
477: Todd Lipcon, info, MethodDeclaration, LOG.info("Read an uncompressed image and store it as uncompressed.");
494: Todd Lipcon, info, MethodDeclaration, LOG.info("Test uncompressed image checksum");
496: Todd Lipcon, info, MethodDeclaration, LOG.info("Test compressed image checksum");
507: Todd Lipcon, info, TryStmt, LOG.info("\n===========================================\n" + "Starting empty cluster");
519: Todd Lipcon, info, TryStmt, LOG.info("Shutting down cluster #1");
532: Todd Lipcon, info, TryStmt, LOG.info("\n===========================================\n" + "Starting same cluster after simulated crash");
116: Aaron Myers, info, IfStmt, LOG.info("causing IO error on " + sd.getRoot());
270: Todd Lipcon, info, TryStmt, LOG.info("Restore is " + restore);
133: Andrew Wang, info, CatchClause, LOG.info("Expected exception: ", iae);
143: Andrew Wang, info, CatchClause, LOG.info("Expected exception: ", iae);
154: Andrew Wang, info, CatchClause, LOG.info("Expected exception: ", iae);
165: Andrew Wang, info, CatchClause, LOG.info("Expected exception: ", iae);
124: Todd Lipcon, info, MethodDeclaration, LOG.info("Waiting for NN to issue block deletions to DNs");
160: Aaron T. Myers, info, ForStmt, LOG.info("Checking namenode: " + i);
311: Zhe Zhang, info, CatchClause, LOG.info(e.getMessage());
324: Zhe Zhang, info, CatchClause, LOG.info("Encountered expected timeout.");
332: Aaron T. Myers, info, ForeachStmt, LOG.info("Removing standby dir " + dir);
165: Jing Zhao, info, TryStmt, LOG.info("The editlog tailer is waiting to catchup...");
220: Jing Zhao, error, CatchClause, LOG.error("Transition nn1 to active failed", e);
233: Jing Zhao, info, CatchClause, LOG.info("Got expected exception", e);
300: Todd Lipcon, info, MethodDeclaration, LOG.info("Tokens:\n" + Joiner.on("\n").join(tokens));
535: Aaron Myers, info, ForeachStmt, LOG.info("creating previous tmp dir: " + prevTmp);
298: Todd Lipcon, info, WhileStmt, LOG.info("Getting more replication work computed");
492: Jing Zhao, info, MethodDeclaration, LOG.info("Expect " + numQueued + " and got: " + cluster.getNameNode(1).getNamesystem().getPendingDataNodeMessageCount());
579: Todd Lipcon, info, MethodDeclaration, LOG.info("\n\n\n\n================================================\n" + string + "\n" + "==================================================\n\n");
160: Eli Collins, error, TryStmt, LOG.error("editLogFile = " + editLogFile);
217: Todd Lipcon, info, IfStmt, LOG.info("Checking for following edit files in " + editDir + ": " + Joiner.on(",").join(files));
215: Todd Lipcon, info, IfStmt, LOG.info("Checking no edit files exist in " + editDir);
146: Yongjun Zhang, info, CatchClause, LOG.info("SHARED_DIR_HA: MiniQJMHACluster port conflicts, retried " + retryCount + " times " + e);
131: Yongjun Zhang, info, TryStmt, LOG.info("Set SHARED_DIR_HA cluster's basePort to " + basePort);
135: Jing Zhao, info, MethodDeclaration, LOG.info("enter safemode");
147: Jing Zhao, info, CatchClause, LOG.info("Got Exception while calling mkdir", e);
141: Jing Zhao, info, TryStmt, LOG.info("mkdir finished, result is " + mkdir);
159: Jing Zhao, info, MethodDeclaration, LOG.info("leave safemode");
753: Todd Lipcon, info, MethodDeclaration, LOG.info("\n\n\n\n================================================\n" + string + "\n" + "==================================================\n\n");
182: Jitendra Nath Pandey, info, MethodDeclaration, LOG.info("Starting with NN 0 active in namespace " + nsIndex);
186: Jitendra Nath Pandey, info, MethodDeclaration, LOG.info("Failing over to NN 1 in namespace " + nsIndex);
192: Jitendra Nath Pandey, info, MethodDeclaration, LOG.info("Failing over to NN 0 in namespace " + nsIndex);
199: Todd Lipcon, info, MethodDeclaration, LOG.info("Removing test file");
203: Jitendra Nath Pandey, info, MethodDeclaration, LOG.info("Failing over to NN 1 in namespace " + nsIndex);
305: Todd Lipcon, info, TryStmt, LOG.info("Starting with NN 0 active");
323: Todd Lipcon, info, TryStmt, LOG.info("Failing over to NN 1");
358: Jitendra Nath Pandey, info, TryStmt, LOG.info("Failing over to NN 1");
602: Todd Lipcon, info, MethodDeclaration, LOG.info("\n\n\n\n================================================\n" + string + "\n" + "==================================================\n\n");
98: Aaron Myers, info, CatchClause, LOG.info("Got expected exception", ioe);
106: Aaron Myers, info, CatchClause, LOG.info("Got expected exception", ioe);
93: Aaron T. Myers, info, InitializerDeclaration, LOG.info("Using random seed: " + FAILOVER_SEED + " for selecting active target NN during failover");
159: Todd Lipcon, info, TryStmt, LOG.info("Starting with NN 0 active");
170: Aaron T. Myers, info, TryStmt, LOG.info("Failing over to another NN");
232: Todd Lipcon, info, TryStmt, LOG.info("Starting with NN 0 active");
252: Aaron T. Myers, info, TryStmt, LOG.info("Failing back from NN " + nextActive + " to NN 0");
291: Todd Lipcon, info, TryStmt, LOG.info("Starting with NN 0 active");
299: Todd Lipcon, info, TryStmt, LOG.info("Failing over to NN 1");
342: Todd Lipcon, info, TryStmt, LOG.info("Starting with NN 0 active");
357: Todd Lipcon, info, TryStmt, LOG.info("Expecting block recovery to be triggered on DN " + expectedPrimary);
380: Todd Lipcon, info, TryStmt, LOG.info("Waiting for commitBlockSynchronization call from primary");
383: Todd Lipcon, info, TryStmt, LOG.info("Failing over to NN 1");
451: Anu Engineer, Error, CatchClause, LOG.warn("Error when running '" + scmd_str + "'", e);
449: Anu Engineer, info, TryStmt, LOG.info("'" + scmd_str + "' output:\n" + sce.getOutput());
455: Yongjun Zhang, info, MethodDeclaration, LOG.info("HDFS-6694 Debug Data END");
526: Aaron T. Myers, info, MethodDeclaration, LOG.info("Failing over to a standby NN:" + nextActive + " from NN " + activeIndex);
612: Todd Lipcon, info, IfStmt, LOG.info("Waiting to recover lease successfully");
1316: Jing Zhao, info, CatchClause, LOG.info("Got Exception while calling " + op.name, e);
1310: Jing Zhao, info, TryStmt, LOG.info("Operation " + op.name + " finished");
1332: Suresh Srinivas, info, MethodDeclaration, LOG.info("Setting block to false");
1339: Jing Zhao, info, SynchronizedStmt, LOG.info("Got the result of " + op.name + ": " + results.get(op.name));
173: Aaron T. Myers, info, MethodDeclaration, LOG.info("Writing next file: " + nextPath);
71: Jing Zhao, info, TryStmt, LOG.info("==================================");
75: Jing Zhao, info, TryStmt, LOG.info("==================================");
111: Arpit Agarwal, info, CatchClause, LOG.info("Set up MiniDFSCluster failed due to port conflicts, retry " + retryCount + " times");
352: Andrew Wang, info, IfStmt, LOG.info("Checking for following edit files in " + editDir + ": " + Joiner.on(",").join(files));
350: Andrew Wang, info, IfStmt, LOG.info("Checking no edit files exist in " + editDir);
90: Todd Lipcon, info, TryStmt, LOG.info("Waiting for block locations to appear on standby node");
99: Todd Lipcon, info, TryStmt, LOG.info("Changing replication to 1");
107: Todd Lipcon, info, TryStmt, LOG.info("Waiting for lowered replication to show up on standby");
111: Todd Lipcon, info, TryStmt, LOG.info("Changing replication to 3");
117: Todd Lipcon, info, TryStmt, LOG.info("Waiting for higher replication to show up on standby");
225: Todd Lipcon, warn, CatchClause, LOG.warn("No block locations yet: " + e.getMessage());
218: Todd Lipcon, info, TryStmt, LOG.info("Got " + numReplicas + " locs: " + locs);
840: Harsh J, warn, CatchClause, LOG.warn("Unable to set up HA cluster, exception thrown: " + e);
81: Tsz-Wo Nicholas Sze, Info, MethodDeclaration, GenericTestUtils.disableLog(LoggerFactory.getLogger(UserGroupInformation.class));
133: Tsz-wo Sze, info, MethodDeclaration, LOG.info("createSnapshot " + snapshotName + " for " + snapshotRoot);
196: Tsz-wo Sze, info, CatchClause, LOG.info("FAILED compareDumpedTreeInFile(" + file1 + ", " + file2 + ")", t);
158: Tsz-Wo Nicholas Sze, info, MethodDeclaration, DiffListBySkipList.LOG.info("run " + root);
177: Tsz-Wo Nicholas Sze, info, MethodDeclaration, DiffListBySkipList.LOG.info("run " + root);
222: Tsz-Wo Nicholas Sze, info, MethodDeclaration, DiffListBySkipList.LOG.info("skipList: " + skipList);
252: Tsz-Wo Nicholas Sze, info, MethodDeclaration, DiffListBySkipList.LOG.info("run " + root);
261: Tsz-Wo Nicholas Sze, debug, ForStmt, DiffListBySkipList.LOG.debug("i={}: {}", i, skipList);
301: Tsz-Wo Nicholas Sze, info, ForStmt, DiffListBySkipList.LOG.info("change from level " + level);
320: Tsz-Wo Nicholas Sze, info, MethodDeclaration, DiffListBySkipList.LOG.info("remove " + i + ", snapshotId=" + expected.getSnapshotId());
226: Tsz-wo Sze, info, CatchClause, SnapshotTestHelper.LOG.info("The exception is expected.", ioe);
662: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Open file status in snap: " + fs.getFileStatus(new Path(snap1Dir, hbaseFileName)));
740: Manoj Govindassamy, warn, CatchClause, LOG.warn("Writer error: " + e);
734: Manoj Govindassamy, info, IfStmt, LOG.info("Write pos: " + flumeOutputStream.getPos() + ", size: " + fs.getFileStatus(flumeFile).getLen() + ", loop: " + (i + 1));
751: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Snap1 file status: " + fs.getFileStatus(flumeS1Path));
752: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Current file status: " + fs.getFileStatus(flumeFile));
755: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Snap1 file status: " + fs.getFileStatus(flumeS1Path));
756: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Current file status: " + fs.getFileStatus(flumeFile));
209: Manoj Govindassamy, info, MethodDeclaration, LOG.info("testRandomOperationsWithSnapshots, seed to be used: " + seed);
228: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of iterations: " + numberOfIterations);
232: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of FileSystem operations: " + numberFileSystemOperations);
236: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of Snapshot operations: " + numberSnapshotOperations);
259: Manoj Govindassamy, info, ForStmt, LOG.info("fsOperation: " + fsOperation);
295: Manoj Govindassamy, info, ForStmt, LOG.info("snapshotOperation: " + snapshotOperation);
335: Manoj Govindassamy, info, ForeachStmt, LOG.info("Directory created: " + newDir);
360: Manoj Govindassamy, info, ForeachStmt, LOG.info("Directory removed: " + deleteDir);
391: Manoj Govindassamy, info, ForeachStmt, LOG.info("Renamed directory:" + oldDir + " to directory: " + newDir);
405: Manoj Govindassamy, info, IfStmt, LOG.info("createSnapshot, directory: " + randomDir + ", snapshot name: " + snapshotName);
429: Manoj Govindassamy, info, IfStmt, LOG.info("deleteSnapshot, directory: " + snapshotPath + ", snapshot name: " + snapshotNameToBeDeleted);
459: Manoj Govindassamy, info, IfStmt, LOG.info("renameSnapshot, directory:" + snapshotPath + ", snapshot name:" + snapshotOldName + " to " + snapshotNewName);
486: Manoj Govindassamy, info, ForeachStmt, LOG.info("createTestFile, file created: " + newFile);
510: Manoj Govindassamy, info, ForeachStmt, LOG.info("deleteTestFile, file deleted: " + deleteFile);
541: Manoj Govindassamy, info, ForeachStmt, LOG.info("Renamed file: " + oldFile + " to file: " + newFile);
557: Manoj Govindassamy, info, MethodDeclaration, LOG.info("checkClusterHealth, number of entries verified.");
580: Manoj Govindassamy, info, MethodDeclaration, LOG.info("checkClusterHealth, metadata verified.");
584: Manoj Govindassamy, info, IfStmt, LOG.info("checkClusterHealth, doing a checkpoint on NN.");
591: Manoj Govindassamy, info, MethodDeclaration, LOG.info("checkClusterHealth, restarting NN.");
603: Manoj Govindassamy, info, MethodDeclaration, LOG.info("checkClusterHealth, cluster is healthy.");
620: Manoj Govindassamy, info, CatchClause, LOG.info("createFile, exception setting snapshotable directory: " + e.getMessage());
643: Manoj Govindassamy, info, ForStmt, LOG.info("createFiles, file: " + filename + "was created");
650: Manoj Govindassamy, info, ForStmt, LOG.info("createFiles, file: " + witnessFile + "was created");
659: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Original string: " + originalString);
660: Manoj Govindassamy, info, MethodDeclaration, LOG.info("New string: " + str);
665: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Operation statistics for this iteration: ");
667: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of files created: " + numberFileCreated);
668: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of files deleted: " + numberFileDeleted);
669: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of files renamed: " + numberFileRenamed);
671: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of directories created: " + numberDirectoryCreated);
672: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of directories deleted: " + numberDirectoryDeleted);
673: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of directories renamed: " + numberDirectoryRenamed);
675: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of snapshots created: " + numberSnapshotCreated);
676: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of snapshots deleted: " + numberSnapshotDeleted);
677: Manoj Govindassamy, info, MethodDeclaration, LOG.info("Number of snapshots renamed: " + numberSnapshotRenamed);
231: Tsz-wo Sze, info, MethodDeclaration, LOG.info("DiffList is " + diffReport.toString());
239: Tsz-wo Sze, info, MethodDeclaration, LOG.info("DiffList is " + diffReport.toString());
247: Tsz-wo Sze, info, MethodDeclaration, LOG.info("DiffList is " + diffReport.toString());
273: Tsz-wo Sze, info, MethodDeclaration, LOG.info("DiffList is \n\"" + diffReport.toString() + "\"");
299: Tsz-wo Sze, info, MethodDeclaration, LOG.info("DiffList is \n\"" + diffReport.toString() + "\"");
2376: Jing Zhao, info, MethodDeclaration, LOG.info("DiffList is \n\"" + report.toString() + "\"");
239: Tsz-wo Sze, info, CatchClause, SnapshotTestHelper.LOG.info("FAILED", t);
1344: Xiaoyu Yao, info, ForStmt, LOG.info("Snapshot Diff s{} to ss : {}", i, sdr);
226: Yongjun Zhang, info, MethodDeclaration, LOG.info(report.toString());
230: Yongjun Zhang, info, MethodDeclaration, LOG.info(report.toString());
234: Yongjun Zhang, info, MethodDeclaration, LOG.info(report.toString());
240: Yongjun Zhang, info, MethodDeclaration, LOG.info(report.toString());
753: Manoj Govindassamy, Info, TryStmt, LOG.info("SnapshotDiffInfo: " + sdi.getFrom() + " - " + sdi.getTo());
764: Manoj Govindassamy, Info, TryStmt, LOG.info("SnapshotDiffInfo: " + sdi.getFrom() + " - " + sdi.getTo());
1160: Yongjun Zhang, info, MethodDeclaration, LOG.info("Access time " + path + ": " + getAccessTimeStr(path) + " " + ssPath + ": " + getAccessTimeStr(ssPath));
1247: Yongjun Zhang, info, MethodDeclaration, LOG.info("\nsnapshotDiff s0 -> s1:");
1248: Yongjun Zhang, info, MethodDeclaration, LOG.info(hdfs.getSnapshotDiffReport(root, "s0", "s1").toString());
1249: Yongjun Zhang, info, MethodDeclaration, LOG.info("\nsnapshotDiff s1 -> s2:");
1250: Yongjun Zhang, info, MethodDeclaration, LOG.info(hdfs.getSnapshotDiffReport(root, "s1", "s2").toString());
1403: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info(report.toString());
1404: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info(inverseReport.toString() + "\n");
76: Andrew Wang, info, MethodDeclaration, LOG.info(uri.toString());
78: Tsz-wo Sze, info, MethodDeclaration, LOG.info("nDataNodes=" + nDataNodes + ", racks=" + Arrays.asList(racks));
91: Tsz-wo Sze, info, TryStmt, LOG.info("dm=" + dm);
162: Tsz-wo Sze, info, MethodDeclaration, LOG.info("nDataNodes=" + nDataNodes + ", racks=" + Arrays.asList(racks) + ", hosts=" + Arrays.asList(hosts));
175: Tsz-wo Sze, info, TryStmt, LOG.info("dm=" + dm);
476: Colin McCabe, error, CatchClause, LOG.error("error running visitor", e);
625: Colin McCabe, error, CatchClause, LOG.error("error running visitor", e);
720: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Setting failure injector and performing a read which " + "should fail...");
746: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Clearing failure injector and performing another read...");
495: Todd Lipcon, error, CatchClause, DFSClient.LOG.error("caught exception ", e);
149: Yongjun Zhang, info, TryStmt, LOG.info(resNonVerbose);
150: Yongjun Zhang, info, TryStmt, LOG.info(DelegationTokenFetcher.printTokensToString(conf, p, true));
409: Arpit Agarwal, error, CatchClause, LOG.error(String.format("call getReconfigurationStatus on %s[%s] failed.", nodeType, address), e);
594: Manoj Govindassamy, info, TryStmt, LOG.info("Replica block located on: " + locatedDataNode);
628: Manoj Govindassamy, info, TryStmt, LOG.info("Shutting down: " + dataNodeToShutdown);
812: Andrew Wang, info, MethodDeclaration, LOG.info("dfsadmin -listOpenFiles output: \n" + out);
420: Eli Collins, info, MethodDeclaration, LOG.info("Running: DFSHAAdmin " + Joiner.on(" ").join(args));
424: Suresh Srinivas, info, MethodDeclaration, LOG.info("Err_output:\n" + errOutput + "\nOutput:\n" + output);
257: Suresh Srinivas, info, MethodDeclaration, LOG.info("Running: DFSHAAdmin " + Joiner.on(" ").join(args));
260: Suresh Srinivas, info, MethodDeclaration, LOG.info("Output:\n" + errOutput);
105: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Generated edits=" + edits);
123: Jing Zhao, info, MethodDeclaration, LOG.info("Comparing generated file " + editsReparsed + " with reference file " + edits);
200: Todd Lipcon, info, MethodDeclaration, LOG.info("Running oev [" + inFilename + "] [" + outFilename + "]");
224: Jing Zhao, info, MethodDeclaration, LOG.info("Statistics for " + inFilename + "\n" + visitor.getStatisticsString());
236: Todd Lipcon, info, IfStmt, LOG.info("Opcode " + opCode + " not tested in " + inFilename);
345: Yiqun Lin, info, MethodDeclaration, LOG.info("Generated edits=" + edits);
220: Eli Collins, debug, ForeachStmt, LOG.debug("got token " + t);
308: Eli Collins, debug, TryStmt, LOG.debug("original FS image file is " + originalFsimage);
707: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Creating reverseImage.xml=" + reverseImageXml.getAbsolutePath() + ", reverseImage=" + reverseImage.getAbsolutePath() + ", reverseImage2Xml=" + reverseImage2Xml.getAbsolutePath());
160: Haohui Mai, debug, TryStmt, LOG.debug("original FS image file is " + originalFsimage);
113: Akira Ajisaka, debug, TryStmt, LOG.debug("original FS image file is " + originalFsimage);
99: Akira Ajisaka, debug, TryStmt, LOG.debug("original FS image file is " + originalFsimage);
63: Todd Lipcon, info, MethodDeclaration, LOG.info("Test empty basic");
69: Todd Lipcon, info, MethodDeclaration, LOG.info("Test empty - DONE");
74: Todd Lipcon, info, MethodDeclaration, LOG.info("Test one element basic");
87: Todd Lipcon, info, MethodDeclaration, LOG.info("Test one element basic - DONE");
92: Todd Lipcon, info, MethodDeclaration, LOG.info("Test multi element basic");
124: Todd Lipcon, info, MethodDeclaration, LOG.info("Test multi element basic - DONE");
129: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove one");
147: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove one - DONE");
152: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove multi");
169: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove multi - DONE");
174: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove all");
190: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove all - DONE");
195: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Test remove all via iterator");
217: Colin Patrick Mccabe, info, MethodDeclaration, LOG.info("Test remove all via iterator - DONE");
222: Todd Lipcon, info, MethodDeclaration, LOG.info("Test poll all");
243: Todd Lipcon, info, MethodDeclaration, LOG.info("Test poll all - DONE");
248: Todd Lipcon, info, MethodDeclaration, LOG.info("Test pollN multi");
284: Todd Lipcon, info, MethodDeclaration, LOG.info("Test pollN multi - DONE");
289: Todd Lipcon, info, MethodDeclaration, LOG.info("Test pollN multi array");
348: Todd Lipcon, info, MethodDeclaration, LOG.info("Test clear");
363: Todd Lipcon, info, MethodDeclaration, LOG.info("Test clear - DONE");
368: Todd Lipcon, info, MethodDeclaration, LOG.info("Test capacity");
403: Todd Lipcon, info, MethodDeclaration, LOG.info("Test capacity - DONE");
408: Todd Lipcon, info, MethodDeclaration, LOG.info("Test other");
454: Todd Lipcon, info, MethodDeclaration, LOG.info("Test other - DONE");
60: Todd Lipcon, info, MethodDeclaration, LOG.info("Test empty basic");
72: Todd Lipcon, info, MethodDeclaration, LOG.info("Test empty - DONE");
77: Todd Lipcon, info, MethodDeclaration, LOG.info("Test one element basic");
90: Todd Lipcon, info, MethodDeclaration, LOG.info("Test one element basic - DONE");
95: Todd Lipcon, info, MethodDeclaration, LOG.info("Test multi element basic");
124: Todd Lipcon, info, MethodDeclaration, LOG.info("Test multi element basic - DONE");
129: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove one");
152: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove one - DONE");
157: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove multi");
182: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove multi - DONE");
187: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove all");
203: Todd Lipcon, info, MethodDeclaration, LOG.info("Test remove all - DONE");
208: Todd Lipcon, info, MethodDeclaration, LOG.info("Test poll one element");
212: Todd Lipcon, info, MethodDeclaration, LOG.info("Test poll one element - DONE");
217: Todd Lipcon, info, MethodDeclaration, LOG.info("Test poll multi");
256: Todd Lipcon, info, MethodDeclaration, LOG.info("Test poll multi - DONE");
261: Todd Lipcon, info, MethodDeclaration, LOG.info("Test poll all");
277: Todd Lipcon, info, MethodDeclaration, LOG.info("Test poll all - DONE");
282: Todd Lipcon, info, MethodDeclaration, LOG.info("Test pollN one");
287: Todd Lipcon, info, MethodDeclaration, LOG.info("Test pollN one - DONE");
292: Todd Lipcon, info, MethodDeclaration, LOG.info("Test pollN multi");
317: Todd Lipcon, info, MethodDeclaration, LOG.info("Test pollN multi - DONE");
322: Todd Lipcon, info, MethodDeclaration, LOG.info("Test clear");
351: Todd Lipcon, info, MethodDeclaration, LOG.info("Test clear - DONE");
356: Todd Lipcon, info, MethodDeclaration, LOG.info("Test other");
372: Todd Lipcon, info, MethodDeclaration, LOG.info("Test capacity - DONE");
377: Kihwal Lee, info, MethodDeclaration, LOG.info("Test getBookmark returns proper iterator");
394: Kihwal Lee, info, MethodDeclaration, LOG.info("Test that the bookmark advances if we remove its element.");
408: Kihwal Lee, info, MethodDeclaration, LOG.info("Test bookmark is set after adding to previously empty set.");
147: Tsz-wo Sze, info, ConstructorDeclaration, LOG.info(String.format("\n\n%s START: %s\n", name, String.format(format, args)));
156: Tsz-wo Sze, info, IfStmt, LOG.info(String.format("\n\n%s %.2f min) %s %s\n", name, mintues, String.format(format, args), toMpsString(nBytes, now)));
164: Tsz-wo Sze, info, MethodDeclaration, LOG.info(String.format("\n\n%s END: duration=%.2fs %s\n", name, seconds, toMpsString(nBytes, now)));
253: Tsz-wo Sze, info, MethodDeclaration, LOG.info("XXX SEEK: offset=" + offset + ", remaining=" + remaining);
277: Tsz-wo Sze, info, MethodDeclaration, LOG.info("XXX PREAD: offset=" + offset + ", remaining=" + remaining);
1282: Allen Wittenauer, info, MethodDeclaration, LOG.info("Response was : " + response);
1312: Allen Wittenauer, info, TryStmt, LOG.info("Started cluster");
1318: Allen Wittenauer, info, TryStmt, LOG.info("Sending create request " + url);
1333: Allen Wittenauer, info, TryStmt, LOG.info("Sending open request " + url);
1340: Allen Wittenauer, info, TryStmt, LOG.info("Sending getfilechecksum request " + url);
1346: Allen Wittenauer, info, TryStmt, LOG.info("Sending append request " + url);
169: Tsz-wo Sze, info, MethodDeclaration, WebHdfsFileSystem.LOG.info("url      = " + url);
172: Tsz-wo Sze, info, MethodDeclaration, WebHdfsFileSystem.LOG.info("replaced = " + replaced);
181: Tsz-wo Sze, info, ForStmt, WebHdfsFileSystem.LOG.info("> " + line);
196: Tsz-wo Sze, info, CatchClause, WebHdfsFileSystem.LOG.info("This is expected.", fnfe);
268: Tsz-wo Sze, info, MethodDeclaration, WebHdfsFileSystem.LOG.info("null url=" + url);
286: Tsz-wo Sze, info, CatchClause, WebHdfsFileSystem.LOG.info("This is expected.", e);
295: Tsz-wo Sze, info, CatchClause, WebHdfsFileSystem.LOG.info("This is expected.", e);
487: Tsz-wo Sze, info, BlockStmt, WebHdfsFileSystem.LOG.info("redirect = " + redirect);
491: Tsz-wo Sze, info, BlockStmt, WebHdfsFileSystem.LOG.info("modified = " + modified);
512: Tsz-wo Sze, info, CatchClause, WebHdfsFileSystem.LOG.info("GOOD", ioe);
572: Andrew Wang, info, ForeachStmt, WebHdfsFileSystem.LOG.info("redirect = " + redirect);
575: Andrew Wang, info, ForeachStmt, WebHdfsFileSystem.LOG.info("modified = " + modified);
135: Tsz-wo Sze, debug, CatchClause, LOG.debug("Exception in closing " + serverSocket, e);
330: Tsz-wo Sze, error, CatchClause, LOG.error("unexpected IOException in server thread", e);
70: Todd Lipcon, info, MethodDeclaration, LOG.info("nNameNodes=" + nNameNodes + ", nDataNodes=" + nDataNodes);
105: Todd Lipcon, info, ForStmt, LOG.info(name + "[" + i + "] = " + strings[i]);
85: Tsz-wo Sze, info, MethodDeclaration, WebHdfsTestUtil.LOG.info("url=" + url);
60: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
79: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
98: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
119: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
140: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
155: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
177: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
186: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
193: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
200: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
215: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
240: Tsz-wo Sze, info, CatchClause, LOG.info("EXPECTED: " + e);
328: Chris Nauroth, info, CatchClause, LOG.info("EXPECTED: " + e);
338: Chris Nauroth, info, CatchClause, LOG.info("EXPECTED: " + e);
345: Chris Nauroth, info, CatchClause, LOG.info("EXPECTED: " + e);
352: Chris Nauroth, info, CatchClause, LOG.info("EXPECTED: " + e);
454: Haohui Mai, info, CatchClause, LOG.info("EXPECTED: " + e);
461: Haohui Mai, info, CatchClause, LOG.info("EXPECTED: " + e);
468: Haohui Mai, info, CatchClause, LOG.info("EXPECTED: " + e);
475: Haohui Mai, info, CatchClause, LOG.info("EXPECTED: " + e);
482: Haohui Mai, info, CatchClause, LOG.info("EXPECTED: " + e);
489: Haohui Mai, info, CatchClause, LOG.info("EXPECTED: " + e);
332: Xiao Chen, info, MethodDeclaration, LOG.info("Result:" + frequency);
452: Aaron Myers, info, TryStmt, LOG.info("datanode " + validIdx + " came up with network location " + info[0].getNetworkLocation());
466: Aaron Myers, info, IfStmt, LOG.info("got one valid DN: " + info[0].getHostName() + " (at " + info[0].getNetworkLocation() + ")");
464: Aaron Myers, info, IfStmt, LOG.info("got no valid DNs");
516: Xiao Chen, info, MethodDeclaration, LOG.info("Excluded nodes are: {}", excludedNodes);
519: Xiao Chen, info, ForStmt, LOG.info("Verifying node {}", n);
536: Xiao Chen, info, MethodDeclaration, LOG.info("No node is excluded.");
74: Todd Lipcon, info, MethodDeclaration, LOG.info(s.getPath() + ": " + s.isDirectory() + " " + s.getPermission() + ":" + s.getOwner() + ":" + s.getGroup());
188: Todd Lipcon, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
193: Todd Lipcon, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
214: Todd Lipcon, info, CatchClause, LOG.info("GOOD: got " + e);
127: Aaron Myers, info, IfStmt, LOG.info("Cluster is no longer up, exiting");
149: Steve Loughran, info, MethodDeclaration, LOG.info("Started MiniDFSCluster -- namenode on port {}", dfs.getNameNodePort());
183: Steve Loughran, warn, CatchClause, LOG.warn("options parsing failed", e);
195: Steve Loughran, error, ForeachStmt, LOG.error("Unrecognized option: {}", arg);
239: Steve Loughran, warn, IfStmt, LOG.warn("Ignoring -D option {}", prop);
243: Steve Loughran, info, MethodDeclaration, LOG.info("Updated {} configuration settings from command line.", num_confs_updated);
257: Steve Loughran, error, CatchClause, LOG.error("Couldn't parse value ({}) for option {}. " + "Using default: {}", o, argName, defaultValue);
199: Colin McCabe, warn, IfStmt, LOG.warn("Existing client context '" + name + "' does not match " + "requested configuration.  Existing: " + existing + ", Requested: " + requested);
249: Haohui Mai, debug, MethodDeclaration, LOG.debug("Connecting to datanode {}", dnAddr);
261: Haohui Mai, debug, MethodDeclaration, LOG.debug("Send buf size {}", sock.getSendBufferSize());
298: Walter Su, trace, IfStmt, LOG.trace("Got Exception while checking, " + DataStreamer.this, new Throwable(thrown));
391: Jing Zhao, info, MethodDeclaration, LOG.info(message);
454: Jing Zhao, warn, IfStmt, LOG.warn("Datanode " + i + " did not restart within " + datanodeRestartTimeout + "ms: " + nodes[i]);
627: Lei Xu, debug, IfStmt, LOG.debug("nodes {} storageTypes {} storageIDs {}", Arrays.toString(nodes), Arrays.toString(storageTypes), Arrays.toString(storageIDs));
638: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("Closing old block {}", block);
826: Jing Zhao, warn, IfStmt, LOG.warn("DataStreamer Exception", e);
824: Jing Zhao, debug, IfStmt, LOG.debug("DataStreamer Quota Exception", e);
683: Jing Zhao, warn, CatchClause, LOG.warn("Caught exception", e);
698: Jing Zhao, warn, CatchClause, LOG.warn("Caught exception", e);
712: Walter Su, debug, IfStmt, LOG.debug("stage=" + stage + ", " + this);
719: Haohui Mai, debug, IfStmt, LOG.debug("Append to block {}", block);
715: Akira Ajisaka, debug, IfStmt, LOG.debug("Allocating new block: {}", this);
741: Jing Zhao, warn, CatchClause, LOG.warn("Caught exception", e);
769: Akira Ajisaka, debug, TryStmt, LOG.debug("{} sending {}", this, one);
876: Jing Zhao, debug, TryStmt, LOG.debug("{} waiting for ack for: {}", this, seqno);
899: Xiao Chen, warn, IfStmt, LOG.warn("Slow waitForAckedSeqno took {}ms (threshold={}ms). File being" + " written: {}, block: {}, Write pipeline datanodes: {}.", duration, dfsclientSlowLogThresholdMs, src, block, nodes);
988: Jing Zhao, warn, CatchClause, LOG.warn("Caught exception", e);
1196: Jing Zhao, warn, IfStmt, LOG.warn("Exception for " + block, e);
1092: Kihwal Lee, info, IfStmt, LOG.info("Slow ReadProcessor read fields for block " + block + " took " + duration + "ms (threshold=" + dfsclientSlowLogThresholdMs + "ms); ack: " + ack + ", targets: " + Arrays.asList(targets));
1101: Haohui Mai, debug, IfStmt, LOG.debug("DFSClient {}", ack);
1229: Jing Zhao, debug, MethodDeclaration, LOG.debug("start process datanode/external error, {}", this);
1231: Jing Zhao, Error, IfStmt, LOG.info("Error Recovery for " + block + " waiting for responder to exit. ");
1248: Kihwal Lee, Error, IfStmt, LOG.warn("Error recovering pipeline for writing " + block + ". Already retried 5 times for the same packet.");
1323: Haohui Mai, debug, MethodDeclaration, DataTransferProtocol.LOG.debug("lastAckedSeqno = {}", lastAckedSeqno);
1388: Brahma Reddy Battula, warn, IfStmt, DFSClient.LOG.warn("Failed to find a new datanode to add to the write pipeline, " + " continue to write to the pipeline with " + nodes.length + " nodes since it's no less than minimum replication: " + dfsClient.dtpReplaceDatanodeOnFailureReplication + " configured by " + BlockWrite.ReplaceDatanodeOnFailure.MIN_REPLICATION + ".", ioe);
1410: Kihwal Lee, Error, CatchClause, DFSClient.LOG.warn("Error transferring data from " + src + " to " + nodes[d] + ": " + ioe.getMessage());
1476: Jing Zhao, warn, IfStmt, LOG.warn(msg);
1571: Jing Zhao, Error, IfStmt, LOG.warn("Error Recovery for " + block + " in pipeline " + Arrays.toString(nodes) + ": datanode " + badNodeIndex + "(" + nodes[badNodeIndex] + ") is " + reason);
1603: Jing Zhao, warn, CatchClause, LOG.warn("Failed to replace datanode." + " Continue with the remaining datanodes since " + BlockWrite.ReplaceDatanodeOnFailure.BEST_EFFORT_KEY + " is set to true.", ioe);
1683: Yongjun Zhang, warn, IfStmt, LOG.warn("Abandoning " + block);
1688: Yongjun Zhang, warn, IfStmt, LOG.warn("Excluding datanode " + badNode);
1706: Jing Zhao, info, IfStmt, LOG.info("nodes are empty for write pipeline of " + block);
1712: Walter Su, debug, IfStmt, LOG.debug("pipeline = " + Arrays.toString(nodes) + ", " + this);
1789: Walter Su, info, IfStmt, LOG.info("Exception in createBlockOutputStream " + this, ie);
1793: Jing Zhao, info, IfStmt, LOG.info("Will fetch a new encryption key and retry, " + "encryption key was invalid when connecting to " + nodes[0] + " : " + ie);
1849: Haohui Mai, debug, ForStmt, LOG.debug("{} was chosen by name node (favored={}).", nodes[i].getXferAddrWithHostname(), pinnings[i]);
1854: Jing Zhao, warn, IfStmt, LOG.warn("These favored nodes were specified but not chosen: " + favoredSet + " Specified favored nodes: " + Arrays.toString(favoredNodes));
1894: Jing Zhao, info, IfStmt, LOG.info(sb.toString());
1953: Akira Ajisaka, debug, SynchronizedStmt, LOG.debug("Queued {}, {}", packet, this);
1976: Jing Zhao, info, MethodDeclaration, LOG.info("Removing node " + notification.getKey() + " from the excluded nodes list");
315: Brahma Reddy Battula, debug, IfStmt, LOG.debug("Sets " + HdfsClientConfigKeys.BlockWrite.ReplaceDatanodeOnFailure.MIN_REPLICATION + " to " + dtpReplaceDatanodeOnFailureReplication);
334: Haohui Mai, warn, IfStmt, LOG.warn(DFS_CLIENT_TEST_DROP_NAMENODE_RESPONSE_NUM_KEY + " is set to " + numResponseToDrop + ", this hacked client will proactively drop responses");
363: Eli Collins, debug, IfStmt, LOG.debug("Using local interfaces [" + Joiner.on(',').join(localInterfaces) + "] with addresses [" + Joiner.on(',').join(localInterfaceAddrs) + "]");
447: Haohui Mai, debug, MethodDeclaration, LOG.debug("Using local interface {}", addr);
573: Tsz-wo Sze, warn, IfStmt, LOG.warn("Failed to renew lease for " + clientName + " for " + (elapsed / 1000) + " seconds (>= hard-limit =" + (HdfsConstants.LEASE_HARDLIMIT_PERIOD / 1000) + " seconds.) " + "Closing all files being written ...", e);
614: Vinayakumar B, error, CatchClause, LOG.error("Failed to " + (abort ? "abort" : "close") + " file: " + out.getSrc() + " with inode: " + inodeId, ie);
655: Jitendra Nath Pandey, warn, CatchClause, LOG.warn("Problem getting block size", ie);
699: yliu, info, IfStmt, LOG.info("Cannot get delegation token from " + renewer);
697: yliu, info, IfStmt, LOG.info("Created " + DelegationTokenIdentifier.stringifyToken(token));
715: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Renewing " + DelegationTokenIdentifier.stringifyToken(token));
735: Tsz-wo Sze, info, MethodDeclaration, LOG.info("Cancelling " + DelegationTokenIdentifier.stringifyToken(token));
779: Haohui Mai, info, MethodDeclaration, LOG.info("Cancelling " + DelegationTokenIdentifier.stringifyToken(delToken));
1204: Haohui Mai, debug, MethodDeclaration, LOG.debug("{}: masked={}", src, masked);
1342: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("NameNode is on an older version, request file " + "info with additional RPC call for file: {}", src);
1721: Aaron Myers, debug, MethodDeclaration, LOG.debug("Clearing encryption key");
1743: Aaron Myers, debug, IfStmt, LOG.debug("Getting new encryption token from NN");
2397: Haohui Mai, debug, MethodDeclaration, LOG.debug("{}: masked={}", src, absPermission);
2448: Kihwal Lee, debug, IfStmt, LOG.debug("The version of namenode doesn't support getQuotaUsage API." + " Fall back to use getContentSummary API.");
2558: Jitendra Nath Pandey, info, CatchClause, LOG.info("Found corruption while reading " + file + ". Error repairing corrupt blocks. Bad blocks remain.", ie);
2958: Haohui Mai, info, MethodDeclaration, LOG.info("Execution rejected, Executing in current thread");
2965: Haohui Mai, debug, MethodDeclaration, LOG.debug("Using hedged reads; pool threads={}", num);
100: yliu, debug, IfStmt, LOG.debug("poll(): lastReadTxid is -1, reading current txid from NN");
120: yliu, debug, IfStmt, LOG.debug("poll(): read no edits from the NN when requesting edits " + "after txid {}", lastReadTxid);
183: yliu, debug, IfStmt, LOG.debug("timed poll(): timed out");
190: yliu, debug, WhileStmt, LOG.debug("timed poll(): poll() returned null, sleeping for {} ms", nextWait);
216: yliu, debug, WhileStmt, LOG.debug("take(): poll() returned null, sleeping for {} ms", sleepTime);
208: stack, warn, IfStmt, DFSClient.LOG.warn("Last block locations not available. " + "Datanodes might not have reported blocks completely." + " Will retry for " + retriesForLastBlockLength + " times");
242: Haohui Mai, Info, MethodDeclaration, DFSClient.LOG.debug("newInfo = {}", newInfo);
319: Haohui Mai, debug, CatchClause, DFSClient.LOG.debug("Failed to getReplicaVisibleLength from datanode {}" + " for block {}", datanode, locatedblock.getBlock(), ioe);
596: Ravi Prakash, warn, IfStmt, DFSClient.LOG.warn("Failed to connect to {} for block {}, " + "add to deadNodes and continue. ", targetAddr, targetBlock.getBlock(), ex);
585: Zhe Zhang, info, IfStmt, DFSClient.LOG.info("Will fetch a new encryption key and retry, " + "encryption key was invalid when connecting to " + targetAddr + " : " + ex);
578: Steve Loughran, info, IfStmt, DFSClient.LOG.info("Successfully connected to " + targetAddr + " for " + targetBlock.getBlock());
610: Jing Zhao, debug, IfStmt, DFSClient.LOG.debug("The reading thread has been interrupted.", e);
653: Colin Patrick Mccabe, debug, IfStmt, DFSClient.LOG.debug("DFSInputStream has been closed already");
668: Chris Nauroth, warn, IfStmt, DFSClient.LOG.warn("closing file " + src + ", but there are still " + "unreleased ByteBuffers allocated by read().  " + "Please release " + builder.toString() + ".");
707: Todd Lipcon, warn, CatchClause, DFSClient.LOG.warn("Found Checksum error for " + getCurrentBlock() + " from " + currentNode + " at " + ce.getPos());
716: Todd Lipcon, warn, IfStmt, DFSClient.LOG.warn("Exception while reading from " + getCurrentBlock() + " of " + src + " from " + currentNode, e);
780: Jitendra Nath Pandey, warn, IfStmt, DFSClient.LOG.warn("DFS Read", e);
876: John Zhuge, warn, IfStmt, DFSClient.LOG.warn(description + errMsg + ". Throwing a BlockMissingException");
884: John Zhuge, info, IfStmt, DFSClient.LOG.info("No node available for " + blockInfo);
886: John Zhuge, info, MethodDeclaration, DFSClient.LOG.info("Could not obtain " + block.getBlock() + " from any node: " + errMsg + ". Will get new block locations from namenode and retry...");
905: John Zhuge, warn, TryStmt, DFSClient.LOG.warn("DFS chooseDataNode: got # " + (failures + 1) + " IOException, will wait for " + waitTime + " msec.");
952: Haohui Mai, debug, MethodDeclaration, DFSClient.LOG.debug("Connecting to datanode {}", dnAddr);
963: Kai Zheng, warn, MethodDeclaration, DFSClient.LOG.warn("No live nodes contain block " + lostBlock.getBlock() + " after checking nodes = " + Arrays.toString(nodes) + ", ignoredNodes = " + ignoredNodes);
1084: Michael Stack, warn, CatchClause, DFSClient.LOG.warn(msg);
1108: Michael Stack, warn, IfStmt, DFSClient.LOG.warn("Connection failure: " + msg, e);
1092: Zhe Zhang, info, IfStmt, DFSClient.LOG.info("Will fetch a new encryption key and retry, " + "encryption key was invalid when connecting to " + datanode.addr + " : " + e);
1213: Haohui Mai, debug, CatchClause, DFSClient.LOG.debug("Failed getting node for hedged read: {}", ioe.getMessage());
1178: Haohui Mai, debug, TryStmt, DFSClient.LOG.debug("Waited {}ms to read from {}; spawning hedged " + "read", conf.getHedgedReadThresholdMillis(), chosenNode.info);
1299: Akira Ajisaka, debug, IfStmt, DFSClient.LOG.debug("Access token was invalid when connecting to {}: {}", targetAddr, ex);
1487: Haohui Mai, debug, CatchClause, DFSClient.LOG.debug("Exception while seek to {} from {} of {} from " + "{}", targetPos, getCurrentBlock(), src, currentNode, e);
1483: Kihwal Lee, warn, IfStmt, DFSClient.LOG.warn(errMsg);
1616: Colin McCabe, error, CatchClause, DFSClient.LOG.error("error closing blockReader", e);
1706: Haohui Mai, debug, IfStmt, DFSClient.LOG.debug("Unable to perform a zero-copy read from offset {}" + " of {}; {} bytes left in block. blockPos={}; curPos={};" + "curEnd={}", curPos, src, length63, blockPos, curPos, curEnd);
1712: Haohui Mai, debug, IfStmt, DFSClient.LOG.debug("Reducing read length from {} to {} to avoid going " + "more than one byte past the end of the block.  blockPos={}; " + " curPos={}; curEnd={}", maxLength, length63, blockPos, curPos, curEnd);
1735: Haohui Mai, debug, IfStmt, DFSClient.LOG.debug("Reducing read length from {} to {} to avoid 31-bit " + "limit.  blockPos={}; curPos={}; curEnd={}", maxLength, length, blockPos, curPos, curEnd);
1741: Haohui Mai, debug, IfStmt, DFSClient.LOG.debug("unable to perform a zero-copy read from offset {} of" + " {}; BlockReader#getClientMmap returned null.", curPos, src);
1754: Haohui Mai, debug, TryStmt, DFSClient.LOG.debug("readZeroCopy read {} bytes from offset {} via the " + "zero-copy read path.  blockEnd = {}", length, curPos, blockEnd);
205: Haohui Mai, debug, IfStmt, DFSClient.LOG.debug("Set non-null progress callback on DFSOutputStream " + "{}", src);
232: Xiaoyu Yao, warn, IfStmt, LOG.warn("Configured write packet exceeds {} bytes as max," + " using {} bytes.", PacketReceiver.MAX_PACKET_SIZE, PacketReceiver.MAX_PACKET_SIZE);
407: Haohui Mai, debug, MethodDeclaration, DFSClient.LOG.debug("computePacketChunkSize: src={}, chunkSize={}, " + "chunksPerPacket={}, packetSize={}", src, chunkSize, chunksPerPacket, packetSize);
472: Zhe Zhang, debug, IfStmt, DFSClient.LOG.debug("WriteChunk allocating new packet seqno={}," + " src={}, packetSize={}, chunksPerPacket={}, bytesCurBlock={}", currentPacket.getSeqno(), src, packetSize, chunksPerPacket, getStreamer().getBytesCurBlock() + ", " + this);
485: Andrew Wang, debug, MethodDeclaration, LOG.debug("enqueue full {}, src={}, bytesCurBlock={}, blockSize={}," + " appendChunk={}, {}", currentPacket, src, getStreamer().getBytesCurBlock(), blockSize, getStreamer().getAppendChunk(), getStreamer());
729: Todd Lipcon, Error, CatchClause, DFSClient.LOG.warn("Error while syncing", e);
706: Haohui Mai, warn, CatchClause, DFSClient.LOG.warn("Unable to persist blocks in hflush for " + src, ioe);
855: Xiao Chen, debug, IfStmt, LOG.debug("Closing an already closed stream. [Stream:{}, streamer:{}]", closed, getStreamer().streamerClosed());
955: Haohui Mai, info, IfStmt, DFSClient.LOG.info(msg);
970: Suresh Srinivas, warn, CatchClause, DFSClient.LOG.warn("Caught exception ", ie);
967: Suresh Srinivas, info, IfStmt, DFSClient.LOG.info("Could not complete " + src + " retrying...");
1096: Jing Zhao, info, IfStmt, LOG.info("Exception while adding a block", e);
1099: Jing Zhao, info, IfStmt, LOG.info("Waiting for replication for " + (elapsed / 1000) + " seconds");
1108: Jing Zhao, warn, CatchClause, LOG.warn("Caught exception", ie);
1103: Jing Zhao, warn, TryStmt, LOG.warn("NotReplicatedYetException sleeping " + src + " retries left " + retries);
110: Jing Zhao, debug, IfStmt, DFSClient.LOG.debug("Creating an striped input stream for file " + src);
275: Kai Zheng, warn, IfStmt, DFSClient.LOG.warn("Failed to connect to " + dnInfo.addr + " for " + "block" + block.getBlock(), e);
264: Kai Zheng, info, IfStmt, DFSClient.LOG.info("Will fetch a new encryption key and retry, " + "encryption key was invalid when connecting to " + dnInfo.addr + " : " + e);
446: Jing Zhao, debug, IfStmt, DFSClient.LOG.debug("refreshLocatedBlock for striped blocks, offset=" + block.getStartOffset() + ". Obtained block " + lb + ", idx=" + idx);
504: Kai Zheng, warn, IfStmt, DFSClient.LOG.warn(Arrays.toString(nodes) + " are unavailable and " + "all striping blocks on them are lost. " + "IgnoredNodes = " + ignoredNodes);
292: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Creating DFSStripedOutputStream for " + src);
389: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("checkStreamers: " + streamers);
390: Jing Zhao, debug, IfStmt, LOG.debug("healthy streamer count=" + (numAllBlocks - failCount));
391: Jing Zhao, debug, IfStmt, LOG.debug("original failed streamers: " + failedStreamers);
392: Jing Zhao, debug, IfStmt, LOG.debug("newly failed streamers: " + newFailed);
410: Tsz-Wo Nicholas Sze, warn, MethodDeclaration, LOG.warn("Failed: " + err + ", " + this, e);
424: Jing Zhao, info, IfStmt, LOG.info("replacing previously failed streamer " + oldStreamer);
471: Jing Zhao, debug, MethodDeclaration, LOG.debug("Excluding DataNodes when allocating new block: " + Arrays.asList(excludedNodes));
477: Jing Zhao, debug, MethodDeclaration, LOG.debug("Allocating new block group. The previous block group: " + currentBlockGroup);
575: Jing Zhao, debug, MethodDeclaration, LOG.debug("enqueue full {}, src={}, bytesCurBlock={}, blockSize={}," + " appendChunk={}, {}", currentPacket, src, getStreamer().getBytesCurBlock(), blockSize, getStreamer().getAppendChunk(), getStreamer());
731: Jing Zhao, info, IfStmt, LOG.info("close the slow stream " + streamer);
1089: Uma Mahesh, debug, IfStmt, LOG.debug("Skips encoding and writing parity cells as there are " + "no healthy parity data streamers: " + streamers);
1268: Jing Zhao, warn, CatchClause, LOG.warn("Caught ExecutionException while waiting all streamer flush, ", ee);
1296: Zhe Zhang, warn, ForeachStmt, LOG.warn(sb.toString());
439: Haohui Mai, warn, IfStmt, LOG.warn("Namenode for {} remains unresolved for ID {}. Check your " + "hdfs-site.xml file to ensure namenodes are configured " + "properly.", nsId, nnId);
561: Haohui Mai, trace, IfStmt, LOG.trace("Address {} is {} local", targetAddr, (cached ? "" : "not"));
567: Haohui Mai, trace, MethodDeclaration, LOG.trace("Address {} is {} local", targetAddr, (local ? "" : "not"));
798: Uma Maheswara Rao G, debug, TryStmt, LOG.debug("Connecting to datanode {}", dnAddr);
883: Lei Xu, info, MethodDeclaration, LOG.info(threadNamePrefix + " task is rejected by " + "ThreadPoolExecutor. Executing it in current thread.");
3006: Lei Xu, warn, CatchClause, DFSClient.LOG.warn("Exception while checking whether encryption zone is " + "supported", ioe);
3020: Zhe Zhang, warn, CatchClause, DFSClient.LOG.warn("Exception in checking the encryption zone for the " + "path " + parentSrc + ". " + e.getMessage());
3064: Zhe Zhang, warn, CatchClause, DFSClient.LOG.warn("Cannot get all encrypted trash roots", e);
315: Xiao Chen, debug, ForStmt, LOG.debug("Added blockCrc 0x{} for block index {} of size {}", Integer.toString(blockCrc, 16), i, block.getBlockSize());
327: Xiao Chen, warn, IfStmt, LOG.warn("Last block length {} is less than reportedLastBlockSize {}", length - sumBlockLengths, reportedLastBlockSize);
337: Xiao Chen, debug, MethodDeclaration, LOG.debug("Added lastBlockCrc 0x{} for block index {} of size {}", Integer.toString(lastBlockCrc, 16), locatedBlocks.size() - 1, consumedLastBlockLength);
389: Xiao Chen, warn, IfStmt, LOG.warn("Current bytesPerCRC={} doesn't match next bpc={}, but " + "continuing anyway because we're using COMPOSITE_CRC. " + "If trying to preserve CHECKSUMTYPE, only the current " + "bytesPerCRC will be preserved.", getBytesPerCRC(), bpc);
411: Xiao Chen, debug, IfStmt, LOG.debug("Retrieving checksum from an earlier-version DataNode: " + "inferring checksum by reading first byte");
430: Xiao Chen, debug, IfStmt, LOG.debug("set bytesPerCRC={}, crcPerBlock={}", getBytesPerCRC(), getCrcPerBlock());
537: Uma Maheswara Rao G, debug, IfStmt, LOG.debug("Got access token error in response to OP_BLOCK_CHECKSUM " + "for file {} for block {} from datanode {}. Will retry " + "the block once.", getSrc(), block, datanodes[j]);
548: Xiaoyu Yao, debug, IfStmt, LOG.debug("Got invalid encryption key error in response to " + "OP_BLOCK_CHECKSUM for file {} for block {} from " + "datanode {}. Will retry " + "the block once.", getSrc(), block, datanodes[j]);
558: Uma Maheswara Rao G, warn, CatchClause, LOG.warn("src={}" + ", datanodes[{}]={}", getSrc(), j, datanodes[j], ie);
577: Uma Maheswara Rao G, debug, TryStmt, LOG.debug("write to {}: {}, block={}", datanode, Op.BLOCK_CHECKSUM, block);
598: Xiao Chen, debug, TryStmt, LOG.debug("got reply from {}: blockChecksum={}, blockChecksumType={}", datanode, blockChecksumForDebug, getBlockChecksumType());
669: Uma Maheswara Rao G, debug, IfStmt, LOG.debug("Got access token error in response to OP_BLOCK_CHECKSUM " + "for file {} for block {} from datanode {}. Will retry " + "the block once.", getSrc(), block, datanodes[j]);
679: Uma Maheswara Rao G, warn, CatchClause, LOG.warn("src={}" + ", datanodes[{}]={}", getSrc(), j, datanodes[j], ie);
698: Uma Maheswara Rao G, debug, TryStmt, LOG.debug("write to {}: {}, blockGroup={}", datanode, Op.BLOCK_GROUP_CHECKSUM, blockGroup);
718: Xiao Chen, debug, TryStmt, LOG.debug("got reply from {}: blockChecksum={}, blockChecksumType={}", datanode, blockChecksumForDebug, getBlockChecksumType());
145: Andrew Wang, debug, IfStmt, LOG.debug("No HA service delegation token found for logical URI " + haUri);
139: Andrew Wang, debug, IfStmt, LOG.debug("Mapped HA service delegation token for logical URI " + haUri + " to namenode " + singleNNAddr);
61: Colin Patrick Mccabe, Error, CatchClause, LOG.error("Error closing KeyProvider with uri [" + notification.getKey() + "]", e);
83: Andrew Wang, error, CatchClause, LOG.error("Could not create KeyProvider for DFSClient !!", e);
93: Colin Patrick Mccabe, error, IfStmt, LOG.error("Could not find uri with key [" + CommonConfigurationKeysPublic.HADOOP_SECURITY_KEY_PROVIDER_PATH + "] to create a keyProvider !!");
102: Colin Patrick Mccabe, error, CatchClause, LOG.error("KeyProvider URI string is invalid [" + providerUriStr + "]!!", e.getCause());
206: Haohui Mai, warn, IfStmt, LOG.warn("Currently creating proxy using " + "LossyRetryInvocationHandler requires NN HA setup");
250: Haohui Mai, debug, CatchClause, LOG.debug(message, e);
103: Haohui Mai, debug, IfStmt, LOG.debug("SocketCache disabled.");
172: Colin McCabe, warn, CatchClause, LOG.warn("got IOException closing stale peer " + peer + ", which is " + ageMs + " ms old");
112: Yongjun Zhang, warn, IfStmt, LOG.warn("Excluding datanode " + badNode);
246: Kai Zheng, warn, CatchClause, DFSClient.LOG.warn("Found Checksum error for " + currentBlock + " from " + currentNode + " at " + ce.getPos());
253: Kai Zheng, warn, CatchClause, DFSClient.LOG.warn("Exception while reading from " + currentBlock + " of " + dfsStripedInputStream.getSrc() + " from " + currentNode, e);
375: Kai Zheng, error, CatchClause, DFSClient.LOG.error(err);
346: Kai Zheng, debug, IfStmt, DFSClient.LOG.debug("Read task returned: " + r + ", for stripe " + alignedStripe);
79: Tsz-wo Sze, debug, IfStmt, LOG.debug("Got an exception for uri=" + uri, e);
71: Tsz-wo Sze, debug, IfStmt, LOG.debug("Is namenode in safemode? " + safemode + "; uri=" + uri);
385: Jitendra Pandey, debug, CatchClause, LOG.debug("Block read failed. Getting remote block reader using TCP", e);
371: Jitendra Pandey, trace, IfStmt, LOG.trace("{}: returning new block reader local.", this);
365: Jitendra Pandey, trace, IfStmt, LOG.trace("{}: returning new legacy block reader local.", this);
379: Jitendra Pandey, trace, IfStmt, LOG.trace("{}: returning new remote block reader using UNIX domain " + "socket on {}", this, pathInfo.getPath());
424: Lei Xu, warn, CatchClause, LOG.warn("Failed to construct new object of type " + cls.getName(), t);
418: Haohui Mai, trace, IfStmt, LOG.trace("{}: No ReplicaAccessor created by {}", this, cls.getName());
438: Haohui Mai, trace, MethodDeclaration, LOG.trace("{}: trying to construct BlockReaderLocalLegacy", this);
440: Haohui Mai, trace, IfStmt, LOG.trace("{}: can't construct BlockReaderLocalLegacy because the address" + "{} is not local", this, inetSocketAddress);
445: Haohui Mai, debug, IfStmt, PerformanceAdvisory.LOG.debug("{}: can't construct " + "BlockReaderLocalLegacy because " + "disableLegacyBlockReaderLocal is set.", this);
470: Colin McCabe, warn, MethodDeclaration, LOG.warn(this + ": error creating legacy BlockReaderLocal.  " + "Disabling legacy local reads.", ioe);
477: Haohui Mai, trace, MethodDeclaration, LOG.trace("{}: trying to construct a BlockReaderLocal for short-circuit " + " reads.", this);
484: Andrew Wang, debug, IfStmt, PerformanceAdvisory.LOG.debug("{}: {} is not usable for short circuit; " + "giving up on BlockReaderLocal.", this, pathInfo);
494: Haohui Mai, trace, IfStmt, LOG.trace("{}: got InvalidToken exception while trying to construct " + "BlockReaderLocal via {}", this, pathInfo.getPath());
499: Andrew Wang, debug, IfStmt, PerformanceAdvisory.LOG.debug("{}: failed to get " + "ShortCircuitReplica. Cannot construct " + "BlockReaderLocal via {}", this, pathInfo.getPath());
532: Haohui Mai, trace, MethodDeclaration, LOG.trace("{}: trying to create ShortCircuitReplicaInfo.", this);
547: Haohui Mai, trace, IfStmt, LOG.trace("{}: allocShmSlot used up our previous socket {}.  " + "Allocating a new one...", this, peer.getDomainSocket());
616: Haohui Mai, trace, IfStmt, LOG.trace("Sending receipt verification byte for slot {}", slot);
640: Colin McCabe, warn, IfStmt, LOG.warn("short-circuit read access for the file " + fileName + " is disabled for DataNode " + datanode + ".  reason: " + resp.getMessage());
635: Colin McCabe, warn, IfStmt, LOG.warn("short-circuit read access is disabled for " + "DataNode " + datanode + ".  reason: " + resp.getMessage());
649: Haohui Mai, debug, SwitchStmt, LOG.debug("{}:{}", this, msg);
658: Weiwei Yang, warn, SwitchStmt, LOG.warn("{}: unknown response code {} while attempting to set up " + "short-circuit access. {}. Short-circuit read for " + "DataNode {} is {} based on {}.", this, resp.getStatus(), resp.getMessage(), datanode, disableMsg, DFS_DOMAIN_SOCKET_DISABLE_INTERVAL_SECOND_KEY);
684: Andrew Wang, debug, IfStmt, PerformanceAdvisory.LOG.debug("{}: not trying to create a " + "remote block reader because the UNIX domain socket at {}" + " is not usable.", this, pathInfo);
689: Haohui Mai, trace, MethodDeclaration, LOG.trace("{}: trying to create a remote block reader from the UNIX domain " + "socket at {}", this, pathInfo.getPath());
704: Haohui Mai, trace, IfStmt, LOG.trace("{}: got security exception while constructing a remote " + " block reader from the unix domain socket at {}", this, pathInfo.getPath(), ioe);
746: Haohui Mai, trace, MethodDeclaration, LOG.trace("{}: trying to create a remote block reader from a TCP socket", this);
760: Haohui Mai, trace, IfStmt, LOG.trace("{}: got security exception while constructing a remote " + "block reader from {}", this, peer, ioe);
771: Colin McCabe, warn, IfStmt, LOG.warn("I/O error constructing remote block reader.", ioe);
801: Haohui Mai, trace, IfStmt, LOG.trace("nextDomainPeer: reusing existing peer {}", peer);
823: Haohui Mai, trace, IfStmt, LOG.trace("nextTcpPeer: reusing existing peer {}", peer);
833: Haohui Mai, trace, CatchClause, LOG.trace("nextTcpPeer: failed to create newConnectedPeer connected to" + "{}", datanode);
830: Haohui Mai, trace, TryStmt, LOG.trace("nextTcpPeer: created newConnectedPeer {}", peer);
434: Haohui Mai, trace, TryStmt, LOG.trace(traceFormatStr + ": starting", buf.remaining(), block, filename, canSkipChecksum);
444: Haohui Mai, trace, CatchClause, LOG.trace(traceFormatStr + ": I/O error", buf.remaining(), block, filename, canSkipChecksum, e);
448: Haohui Mai, trace, TryStmt, LOG.trace(traceFormatStr + ": returning {}", buf.remaining(), block, filename, canSkipChecksum, nRead);
501: Haohui Mai, trace, MethodDeclaration, LOG.trace("loaded {} bytes into bounce buffer from offset {} of {}", dataBuf.remaining(), oldDataPos, block);
576: Haohui Mai, trace, TryStmt, LOG.trace(traceFormatStr + ": starting", arr.length, off, len, filename, block, canSkipChecksum);
585: Haohui Mai, trace, CatchClause, LOG.trace(traceFormatStr + ": I/O error", arr.length, off, len, filename, block, canSkipChecksum, e);
589: Haohui Mai, trace, TryStmt, LOG.trace(traceFormatStr + ": returning {}", arr.length, off, len, filename, block, canSkipChecksum, nRead);
634: Haohui Mai, trace, MethodDeclaration, LOG.trace("skip(n={}, block={}, filename={}): discarded {} bytes from " + "dataBuf and advanced dataPos by {}", n, block, filename, discardedFromBuf, remaining);
651: Haohui Mai, trace, MethodDeclaration, LOG.trace("close(filename={}, block={})", filename, block);
699: Haohui Mai, trace, IfStmt, LOG.trace("can't get an mmap for {} of {} since SKIP_CHECKSUMS was not " + "given, we aren't skipping checksums, and the block is not " + "mlocked.", block, filename);
123: Todd Lipcon, warn, CatchClause, LOG.warn("encountered exception ", e);
251: Haohui Mai, warn, CatchClause, LOG.warn("BlockReaderLocalLegacy: Removing " + blk + " from cache because local file " + pathinfo.getBlockPath() + " could not be opened.");
228: Haohui Mai, debug, TryStmt, LOG.debug("New BlockReaderLocalLegacy for file {} of size {} startOffset " + "{} length {} short circuit checksum {}", blkfile, blkfile.length(), startOffset, length, !skipChecksumCheck);
298: Haohui Mai, debug, IfStmt, LOG.debug("Cached location of block {} as {}", blk, pathinfo);
612: Haohui Mai, trace, MethodDeclaration, LOG.trace("read off {} len {}", off, len);
631: Haohui Mai, debug, MethodDeclaration, LOG.debug("skip {}", n);
136: Kai Zheng, Trace, MethodDeclaration, UUID randomId = (LOG.isTraceEnabled() ? UUID.randomUUID() : null);
137: Kai Zheng, trace, MethodDeclaration, LOG.trace("Starting read #{} file {} from datanode {}", randomId, filename, datanodeID.getHostName());
148: Kai Zheng, trace, MethodDeclaration, LOG.trace("Finishing read #{}", randomId);
193: Kai Zheng, trace, MethodDeclaration, LOG.trace("DFSClient readNextPacket got header {}", curHeader);
266: Kai Zheng, trace, MethodDeclaration, LOG.trace("Reading empty packet at end of read");
335: Kai Zheng, info, CatchClause, LOG.info("Could not send read status (" + statusCode + ") to datanode " + peer.getRemoteAddressString() + ": " + e.getMessage());
288: Lei Xu, warn, CatchClause, LOG.warn("Unable to load " + className, t);
301: Haohui Mai, warn, CatchClause, LOG.warn("Bad checksum type: {}. Using default {}", checksum, DFS_CHECKSUM_TYPE_DEFAULT);
316: Xiao Chen, warn, CatchClause, LOG.warn("Bad checksum combine mode: {}. Using default {}", mode, DFS_CHECKSUM_COMBINE_MODE_DEFAULT);
673: Haohui Mai, debug, ConstructorDeclaration, LOG.debug(DFS_CLIENT_USE_LEGACY_BLOCKREADERLOCAL + " = {}", useLegacyBlockReaderLocal);
675: Haohui Mai, debug, ConstructorDeclaration, LOG.debug(Read.ShortCircuit.KEY + " = {}", shortCircuitLocalReads);
677: Haohui Mai, debug, ConstructorDeclaration, LOG.debug(DFS_CLIENT_DOMAIN_SOCKET_DATA_TRAFFIC + " = {}", domainSocketDataTraffic);
679: Haohui Mai, debug, ConstructorDeclaration, LOG.debug(DFS_DOMAIN_SOCKET_PATH_KEY + " = {}", domainSocketPath);
309: Haohui Mai, debug, CatchClause, LOG.debug("LeaseRenewer is interrupted.", e);
315: Todd Lipcon, debug, IfStmt, LOG.debug("Lease renewer daemon for " + clientsString() + " with renew id " + id + " exited");
304: Todd Lipcon, debug, IfStmt, LOG.debug("Lease renewer daemon for " + clientsString() + " with renew id " + id + " started");
374: Haohui Mai, debug, IfStmt, LOG.debug("Wait for lease checker to terminate");
396: Haohui Mai, debug, IfStmt, LOG.debug("Did not renew lease for client {}", c);
400: Haohui Mai, debug, IfStmt, LOG.debug("Lease renewed for client {}", previousName);
422: Todd Lipcon, warn, CatchClause, LOG.warn("Failed to renew lease for " + clientsString() + " for " + (elapsed / 1000) + " seconds.  Aborting ...", ie);
438: Todd Lipcon, warn, CatchClause, LOG.warn("Failed to renew lease for " + clientsString() + " for " + (elapsed / 1000) + " seconds.  Will retry shortly ...", ie);
417: Todd Lipcon, debug, IfStmt, LOG.debug("Lease renewer daemon for " + clientsString() + " with renew id " + id + " executed");
450: Haohui Mai, debug, IfStmt, LOG.debug("Lease renewer daemon for " + clientsString() + " with renew id " + id + " expired");
447: Todd Lipcon, debug, IfStmt, LOG.debug("Lease renewer daemon for " + clientsString() + " with renew id " + id + " is not current");
82: Arpit Agarwal, warn, IfStmt, LOG.warn(String.format("The Short Circuit Local Read latency, %d ms, " + "is higher then the threshold (%d ms). Suppressing further warnings" + " for this BlockReaderLocal.", latency, SLOW_READ_WARNING_THRESHOLD_MS));
161: Haohui Mai, warn, IfStmt, LOG.warn("Failed to place enough replicas: expected size is {}" + " but only {} storage types can be selected (replication={}," + " selected={}, unavailable={}" + ", removed={}" + ", policy={}" + ")", expectedSize, storageTypes.size(), replication, storageTypes, unavailables, removed, this);
88: Xiao Chen, info, MethodDeclaration, LOG.info("Zone {} will retry re-encryption", zoneId);
95: Xiao Chen, info, MethodDeclaration, LOG.info("Zone {} starts re-encryption processing", zoneId);
102: Xiao Chen, info, MethodDeclaration, LOG.info("Zone {} completed re-encryption.", zoneId);
129: Xiao Chen, debug, IfStmt, LOG.debug("Adding zone {} for re-encryption status", zoneId);
172: Xiao Chen, debug, MethodDeclaration, LOG.debug("Removing re-encryption status of zone {} ", zoneId);
150: Haohui Mai, trace, MethodDeclaration, LOG.trace("readNextPacket: dataPlusChecksumLen={}, headerLen={}", dataPlusChecksumLen, headerLen);
79: Haohui Mai, trace, MethodDeclaration, LOG.trace("Sending DataTransferOp {}: {}", proto.getClass().getSimpleName(), proto);
102: Chris Nauroth, debug, MethodDeclaration, LOG.debug("Verifying QOP, requested QOP = {}, negotiated QOP = {}", requestedQop, negotiatedQop);
182: Chris Nauroth, debug, IfStmt, LOG.debug("DataTransferProtocol not using SaslPropertiesResolver, no " + "QOP found in configuration for {}", DFS_DATA_TRANSFER_PROTECTION_KEY);
199: Chris Nauroth, debug, MethodDeclaration, LOG.debug("DataTransferProtocol using SaslPropertiesResolver, configured " + "QOP {} = {}, configured class {} = {}", DFS_DATA_TRANSFER_PROTECTION_KEY, qops, DFS_DATA_TRANSFER_SASL_PROPS_RESOLVER_CLASS_KEY, resolverClass);
339: Haohui Mai, debug, MethodDeclaration, LOG.debug("Creating IOStreamPair of CryptoInputStream and " + "CryptoOutputStream.");
208: Xiaoyu Yao, debug, MethodDeclaration, LOG.debug("SASL encryption trust check: localHostTrusted = {}, " + "remoteHostTrusted = {}", localTrusted, remoteTrusted);
218: Chris Nauroth, debug, IfStmt, LOG.debug("SASL client skipping handshake on trusted connection for addr = {}, " + "datanodeId = {}", addr, datanodeId);
264: Chris Nauroth, debug, IfStmt, LOG.debug("SASL client doing general handshake for addr = {}, datanodeId = {}", addr, datanodeId);
258: Chris Nauroth, debug, IfStmt, LOG.debug("SASL client skipping handshake in secured configuration with " + "unsecured cluster for addr = {}, datanodeId = {}", addr, datanodeId);
252: Chris Nauroth, debug, IfStmt, LOG.debug("SASL client skipping handshake in secured configuration with " + "privileged port for addr = {}, datanodeId = {}", addr, datanodeId);
248: Haohui Mai, debug, IfStmt, LOG.debug("SASL client skipping handshake in unsecured configuration for " + "addr = {}, datanodeId = {}", addr, datanodeId);
243: Haohui Mai, debug, IfStmt, LOG.debug("SASL client doing encrypted handshake for addr = {}, " + "datanodeId = {}", addr, datanodeId);
296: Chris Nauroth, debug, MethodDeclaration, LOG.debug("Client using encryption algorithm {}", encryptionKey.encryptionAlgorithm);
500: cnauroth, debug, IfStmt, LOG.debug("Client using cipher suite {} with server {}", cipherOption.getCipherSuite().getName(), addr.toString());
495: cnauroth, debug, IfStmt, LOG.debug("Client accepts cipher suites {}, " + "but server {} does not accept any of them", cipherSuites, addr.toString());
148: Haohui Mai, debug, ConstructorDeclaration, LOG.debug("Connecting to datanode {} addr={}", dnAddr, addr);
160: Haohui Mai, debug, MethodDeclaration, LOG.debug("Connecting to datanode {} addr={}", dnAddr, addr);
101: cnauroth, warn, IfStmt, LOG.warn("Unexpected meta-file version for " + name + ": version in file is " + header.getVersion() + " but expected version is " + VERSION);
130: Aaron Myers, error, CatchClause, LOG.error("Failed to create RPC proxy to NameNode", e);
91: Inigo Goiri, trace, CatchClause, LOG.trace("Unsuccessful invocation on [{}]", currentUsedProxy.proxyInfo);
85: Inigo Goiri, debug, TryStmt, LOG.debug("Invocation successful on [{}]", currentUsedProxy.proxyInfo);
171: Andrew Wang, trace, IfStmt, LOG.trace("Shutting down threadpool executor");
106: Arpit Agarwal, trace, IfStmt, LOG.trace("No valid proxies left");
121: Tsz-Wo Nicholas Sze, trace, CatchClause, LOG.trace("Unsuccessful invocation on [{}]", currentUsedProxy.proxyInfo);
115: Tsz-Wo Nicholas Sze, debug, TryStmt, LOG.debug("Invocation successful on [{}]", currentUsedProxy.proxyInfo);
133: Andrew Wang, trace, MethodDeclaration, LOG.trace("Invoking method {} on proxy {}", method, pEntry.getValue().proxyInfo);
157: Andrew Wang, trace, CatchClause, LOG.trace("Unsuccessful invocation on [{}]", tProxyInfo.proxyInfo);
149: Andrew Wang, debug, TryStmt, LOG.debug("Invocation successful on [{}]", currentUsedProxy.proxyInfo);
225: Tsz-Wo Nicholas Sze, warn, IfStmt, LOG.warn("Invocation returned exception on [{}]", proxyInfo, ex);
223: Tsz-Wo Nicholas Sze, debug, IfStmt, LOG.debug("Invocation returned standby exception on [{}]", proxyInfo, ex);
137: Haohui Mai, trace, IfStmt, LOG.trace("{}: pulled slot {} out of {}", this, slot.getSlotIdx(), shm);
131: Haohui Mai, trace, IfStmt, LOG.trace("{}: pulled the last slot {} out of {}", this, slot.getSlotIdx(), shm);
190: Haohui Mai, debug, CatchClause, LOG.debug("Exception in closing " + fis[0], e);
184: Haohui Mai, trace, TryStmt, LOG.trace("{}: createNewShm: created {}", this, shm);
229: Haohui Mai, trace, IfStmt, LOG.trace("{}: the DfsClientShmManager has been closed.", this);
233: Haohui Mai, trace, IfStmt, LOG.trace("{}: shared memory segment access is disabled.", this);
244: Haohui Mai, trace, IfStmt, LOG.trace("{}: waiting for loading to finish...", this);
296: Haohui Mai, trace, IfStmt, LOG.trace("{}: freeing empty stale {}", this, shm);
365: Colin McCabe, warn, CatchClause, LOG.warn(this + ": error shutting down shm: got IOException calling " + "shutdown(SHUT_RDWR)", e);
410: Colin McCabe, trace, IfStmt, LOG.trace(this + ": the DfsClientShmManager isclosed.");
486: Haohui Mai, debug, CatchClause, LOG.debug("Exception in closing " + domainSocketWatcher, e);
119: Tsz-wo Sze, debug, IfStmt, LOG.debug(feature + " is enabled.");
116: Tsz-wo Sze, warn, IfStmt, LOG.warn(feature + " cannot be used because " + DomainSocket.getLoadingFailureReason());
109: Colin Patrick Mccabe, debug, IfStmt, PerformanceAdvisory.LOG.debug("Both short-circuit local reads and UNIX domain socket are disabled.");
172: Todd Lipcon, error, CatchClause, LOG.warn("error creating DomainSocket", e);
107: Haohui Mai, debug, TryStmt, LOG.debug("{}: cache cleaner running at {}", this, curMs);
126: Haohui Mai, trace, IfStmt, LOG.trace("CacheCleaner: purging " + replica + ": " + StringUtils.getStackTrace(Thread.currentThread()));
133: Haohui Mai, debug, TryStmt, LOG.debug("{}: finishing cache cleaner run started at {}. Demoted {} " + "mmapped replicas; purged {} replicas.", this, curMs, numDemoted, numPurged);
190: Haohui Mai, trace, MethodDeclaration, LOG.trace("{}: about to release {}", ShortCircuitCache.this, slot);
210: Colin McCabe, error, CatchClause, LOG.error(ShortCircuitCache.this + ": failed to release " + "short-circuit shared memory slot " + slot + " by sending " + "ReleaseShortCircuitAccessRequestProto to " + path + ".  Closing shared memory segment.", e);
207: Haohui Mai, trace, TryStmt, LOG.trace("{}: released {}", this, slot);
362: Colin McCabe, error, CatchClause, LOG.error("failed to create ShortCircuitShmManager", e);
403: Colin McCabe, trace, IfStmt, LOG.trace(this + ": replica  refCount " + (replica.refCount - 1) + " -> " + replica.refCount + StringUtils.getStackTrace(Thread.currentThread()));
396: Colin McCabe, trace, IfStmt, LOG.trace(this + ": " + removedFrom + " no longer contains " + replica + ".  refCount " + (replica.refCount - 1) + " -> " + replica.refCount + StringUtils.getStackTrace(Thread.currentThread()));
435: Haohui Mai, debug, IfStmt, LOG.debug("{}: {}", this, purgeReason);
470: Colin McCabe, trace, IfStmt, LOG.trace(this + ": unref replica " + replica + ": " + addedString + " refCount " + (newRefCount + 1) + " -> " + newRefCount + StringUtils.getStackTrace(Thread.currentThread()));
517: Colin McCabe, trace, IfStmt, LOG.trace("demoteOldEvictable: demoting " + replica + ": " + rationale + ": " + StringUtils.getStackTrace(Thread.currentThread()));
554: Colin McCabe, trace, IfStmt, LOG.trace(this + ": trimEvictionMaps is purging " + replica + StringUtils.getStackTrace(Thread.currentThread()));
662: Colin McCabe, trace, IfStmt, LOG.trace(builder.toString());
688: Haohui Mai, trace, IfStmt, LOG.trace("{}: can't fethchOrCreate {} because the cache is closed.", this, key);
698: Haohui Mai, debug, CatchClause, LOG.debug("{}: retrying {}", this, e.getMessage());
732: Colin McCabe, info, CatchClause, LOG.info(this + ": interrupted while waiting for " + key);
729: Haohui Mai, trace, TryStmt, LOG.trace("{}: found waitable for {}", this, key);
737: Colin Patrick Mccabe, info, IfStmt, LOG.info(this + ": could not get " + key + " due to InvalidToken " + "exception.", info.getInvalidTokenException());
743: Colin McCabe, warn, IfStmt, LOG.warn(this + ": failed to get " + key);
754: Colin McCabe, info, IfStmt, LOG.info(this + ": got stale replica " + replica + ".  Removing " + "this replica from the replicaInfoMap and retrying.");
774: Colin McCabe, warn, CatchClause, LOG.warn(this + ": failed to load " + key, e);
771: Haohui Mai, trace, TryStmt, LOG.trace("{}: loading {}", this, key);
795: Colin McCabe, warn, IfStmt, LOG.warn(this + ": failed to load " + key);
792: Colin Patrick Mccabe, info, IfStmt, LOG.info(this + ": could not load " + key + " due to InvalidToken " + "exception.", info.getInvalidTokenException());
781: Haohui Mai, trace, IfStmt, LOG.trace("{}: successfully loaded {}", this, info.getReplica());
813: Haohui Mai, debug, IfStmt, LOG.debug("{}: starting cache cleaner thread which will run every {} ms", this, rateMs);
832: Haohui Mai, trace, IfStmt, LOG.trace("{}: can't create client mmap for {} because we failed to" + " create one just {}ms ago.", this, replica, delta);
836: Haohui Mai, trace, IfStmt, LOG.trace("{}: retrying client mmap for {}, {} ms after the previous " + "failure.", this, replica, delta);
879: Colin McCabe, info, TryStmt, LOG.info(this + ": closing");
918: Colin Patrick Mccabe, error, CatchClause, LOG.error("Interrupted while waiting for SlotReleaserThreadPool " + "to terminate", e);
912: Colin Patrick Mccabe, error, IfStmt, LOG.error("Forcing SlotReleaserThreadPool to shutdown!");
931: Colin Patrick Mccabe, error, CatchClause, LOG.error("Interrupted while waiting for CleanerThreadPool " + "to terminate", e);
925: Colin Patrick Mccabe, error, IfStmt, LOG.error("Forcing CleanerThreadPool to shutdown!");
966: Haohui Mai, debug, TryStmt, LOG.debug("visiting {} with outstandingMmapCount={}, replicas={}, " + "failedLoads={}, evictable={}, evictableMmapped={}", visitor.getClass().getName(), outstandingMmapCount, replicas, failedLoads, evictable, evictableMmapped);
167: Haohui Mai, trace, IfStmt, LOG.trace("{} is not stale because it's only {} ms old " + "and staleThresholdMs={}", this, deltaMs, staleThresholdMs);
163: Haohui Mai, trace, IfStmt, LOG.trace("{} is stale because it's {} ms old and staleThreadholdMS={}", this, deltaMs, staleThresholdMs);
156: Haohui Mai, trace, IfStmt, LOG.trace("{}: checked shared memory segment.  isStale={}", this, stale);
190: Haohui Mai, trace, MethodDeclaration, LOG.trace("{}: {} no-checksum anchor to slot {}", this, result ? "added" : "could not add", slot);
254: Haohui Mai, trace, MethodDeclaration, LOG.trace("closed {}{}", this, suffix);
285: Colin McCabe, warn, CatchClause, LOG.warn(this + ": mmap error", e);
288: Colin McCabe, warn, CatchClause, LOG.warn(this + ": mmap error", e);
282: Haohui Mai, trace, TryStmt, LOG.trace("{}: created mmap of size {}", this, channel.size());
65: Colin McCabe, error, CatchClause, LOG.error("failed to load misc.Unsafe", e);
487: Haohui Mai, trace, ConstructorDeclaration, LOG.trace("creating {}(shmId={}, mmappedLength={}, baseAddress={}, " + "slots.length={})", this.getClass().getSimpleName(), shmId, mmappedLength, String.format("%x", baseAddress), slots.length);
546: Colin McCabe, trace, IfStmt, LOG.trace(this + ": allocAndRegisterSlot " + idx + ": allocatedSlots=" + allocatedSlots + StringUtils.getStackTrace(Thread.currentThread()));
596: Colin McCabe, trace, IfStmt, LOG.trace(this + ": registerSlot " + slotIdx + ": allocatedSlots=" + allocatedSlots + StringUtils.getStackTrace(Thread.currentThread()));
614: Haohui Mai, trace, MethodDeclaration, LOG.trace("{}: unregisterSlot {}", this, slotIdx);
632: Colin McCabe, warn, CatchClause, LOG.warn(this + ": failed to munmap", e);
634: Colin McCabe, trace, MethodDeclaration, LOG.trace(this + ": freed");
48: Tsz-Wo Nicholas Sze, debug, MethodDeclaration, LOG.debug(b.toString());
82: Ming Ma, warn, CatchClause, LOG.warn("{} has invalid JSON format." + "Try the old format without top-level token defined.", hostsFile);
66: Kai Zheng, warn, IfStmt, LOG.warn("Not found any EC policy file");
87: Kai Zheng, info, MethodDeclaration, LOG.info("Loading EC policy file " + policyFile);
204: Kai Zheng, warn, IfStmt, LOG.warn("Repetitive policies in EC policy configuration file: " + policy.toString());
308: Kai Zheng, warn, IfStmt, LOG.warn("Invalid tagName: " + tagName);
41: Haohui Mai, debug, IfStmt, log.debug("Exception in closing " + c, e);
265: Jing Zhao, debug, CatchClause, LOG.debug("Exception during striped read task", e);
269: Jing Zhao, debug, CatchClause, LOG.debug("Exception during striped read task", e);
137: Haohui Mai, debug, IfStmt, LOG.debug("Created new DT for {}", token.getService());
150: Haohui Mai, debug, IfStmt, LOG.debug("Found existing DT for {}", token.getService());
108: Kihwal Lee, warn, CatchClause, LOG.warn("Cannot load customized ssl related configuration. Fallback to" + " system-generic settings.", e);
196: Andrew Wang, error, CatchClause, LOG.error("Open connection {} failed", url, e);
221: Haohui Mai, debug, IfStmt, LOG.debug("open URL connection");
215: Haohui Mai, debug, IfStmt, LOG.debug("open AuthenticatedURL connection {}", url);
234: cnauroth, debug, IfStmt, LOG.debug("Not enabling OAuth2 in WebHDFS");
230: cnauroth, debug, IfStmt, LOG.debug("Enabling OAuth2 in WebHDFS");
367: Allen Wittenauer, debug, IfStmt, LOG.debug("Fetched new token: {}", token);
361: Haohui Mai, debug, IfStmt, LOG.debug("Using UGI token: {}", token);
383: Haohui Mai, debug, IfStmt, LOG.debug("Replaced expired token: {}", token);
428: Jakob Homan, error, CatchClause, LOG.error("Unable to get HomeDirectory from original File System", e);
515: Benoy Antony, trace, IfStmt, LOG.trace("Detected StandbyException", re);
575: Haohui Mai, trace, MethodDeclaration, LOG.trace("url={}", url);
612: Sean Mackrory, trace, CatchClause, LOG.trace("Cannot decode URL encoded file", ex);
634: Haohui Mai, trace, MethodDeclaration, LOG.trace("url={}", url);
873: Tsz-wo Sze, warn, CatchClause, LOG.warn("Original exception is ", ioe);
861: Mingliang Liu, info, IfStmt, LOG.info("Retrying connect to namenode: {}. Already retried {}" + " time(s); retry policy is {}, delay {}ms.", nnAddr, retry, retryPolicy, a.delayMillis);
963: Haohui Mai, debug, CatchClause, LOG.debug("Response decoding failure.", e);
1512: Haohui Mai, debug, CatchClause, LOG.debug("Token cancel failed: ", ioe);
1771: Xiao Chen, warn, CatchClause, LOG.warn("Cannot find trash root of " + path, e);
2272: Kihwal Lee, debug, IfStmt, LOG.debug("open file: " + conn.getURL());
168: Jitendra Pandey, error, CatchClause, LOG.error("Child failed when calling mkdir", t);
160: Todd Lipcon, warn, CatchClause, LeaseRenewer.LOG.warn("Not yet satisfied", err);
82: Colin McCabe, info, MethodDeclaration, LOG.info("allocated " + numSlots + " slots before running out.");
334: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("randomRecycler start");
345: Tsz-Wo Nicholas Sze, info, IfStmt, LOG.info("randomRecycler sleep, i=" + i);
349: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info("randomRecycler done");
373: Tsz-Wo Nicholas Sze, Error, ForeachStmt, LOG.error("AssertionError " + i, e);
870: Xiao Chen, warn, CatchClause, LOG.warn("Cannot find trash root of " + fullPath, ex);
94: Alejandro Abdelnur, warn, MethodDeclaration, AUDIT_LOG.warn("FAILED [{}:{}] response [{}] {}", new Object[] { method, path, status, message });
95: Alejandro Abdelnur, warn, MethodDeclaration, LOG.warn("[{}:{}] response [{}] {}", new Object[] { method, path, status, message }, throwable);
235: Andrew Wang, info, CatchClause, LOG.info("Open interrupted.", ie);
240: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] offset [{}] len [{}]", new Object[] { path, offset, len });
250: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}]", path);
259: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] filter [{}]", path, (filter != null) ? filter : "-");
267: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("");
289: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}]", path);
297: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}]", path);
308: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("ACL status for [{}]", path);
320: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("XAttrs for [{}]", path);
327: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("XAttr names for [{}]", path);
342: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] token [{}]", path, token);
349: Xiao Chen, info, SwitchEntryStmt, AUDIT_LOG.info("[{}]", path);
357: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}]", path);
365: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}]", path);
410: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] recursive [{}]", path, recursive);
423: Wei-Chiu Chuang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] deleted snapshot [{}]", path, snapshotName);
480: Alejandro Abdelnur, info, IfStmt, AUDIT_LOG.info("[{}]", path);
492: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}]", path);
502: yliu, info, SwitchEntryStmt, AUDIT_LOG.info("Truncate [{}] to length [{}]", path, newLength);
510: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("Unset storage policy [{}]", path);
594: Alejandro Abdelnur, info, IfStmt, AUDIT_LOG.info("[{}] permission [{}] override [{}] " + "replication [{}] blockSize [{}] unmaskedpermission [{}]", new Object[] { path, permission, override, replication, blockSize, unmaskedPermission });
609: Wei-Chiu Chuang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] snapshot created as [{}]", path, snapshotName);
624: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] to xAttr [{}]", path, xattrName);
637: Wei-Chiu Chuang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] renamed snapshot [{}] to [{}]", path, oldSnapshotName, snapshotName);
647: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] removed xAttr [{}]", path, xattrName);
659: Xiao Chen, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] permission [{}] unmaskedpermission [{}]", path, permission, unmaskedPermission);
669: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] to [{}]", path, toPath);
679: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] to (O/G)[{}]", path, owner + ":" + group);
689: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] to [{}]", path, permission);
699: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] to [{}]", path, replication);
711: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] to (M/A)[{}]", path, modifiedTime + ":" + accessTime);
722: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] to acl [{}]", path, aclSpec);
730: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] removed acl", path);
740: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] modify acl entry with [{}]", path, aclSpec);
750: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] remove acl entry [{}]", path, aclSpec);
758: Alejandro Abdelnur, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] remove default acl", path);
768: Andrew Wang, info, SwitchEntryStmt, AUDIT_LOG.info("[{}] to policy [{}]", path, policyName);
102: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("Connects to Namenode [{}]", get().get(FileSystemAccess.class).getFileSystemConfiguration().get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY));
125: John Zhuge, warn, MethodDeclaration, LOG.warn("Environment variable {} is deprecated and overriding" + " property {}', please set the property in {} instead.", varName, propName, confFile);
276: Alejandro Abdelnur, error, CatchClause, log.error("Service [{}] exception during status change to [{}] -server shutting down-,  {}", new Object[] { service.getInterface().getSimpleName(), status, ex.getMessage(), ex });
359: Alejandro Abdelnur, info, MethodDeclaration, log.info("++++++++++++++++++++++++++++++++++++++++++++++++++++++");
360: Alejandro Abdelnur, info, MethodDeclaration, log.info("Server [{}] starting", name);
361: Alejandro Abdelnur, info, MethodDeclaration, log.info("  Built information:");
362: Alejandro Abdelnur, info, MethodDeclaration, log.info("    Version           : {}", serverInfo.getProperty(name + ".version", "undef"));
363: Alejandro Abdelnur, info, MethodDeclaration, log.info("    Source Repository : {}", serverInfo.getProperty(name + ".source.repository", "undef"));
364: Alejandro Abdelnur, info, MethodDeclaration, log.info("    Source Revision   : {}", serverInfo.getProperty(name + ".source.revision", "undef"));
365: Alejandro Abdelnur, info, MethodDeclaration, log.info("    Built by          : {}", serverInfo.getProperty(name + ".build.username", "undef"));
366: Alejandro Abdelnur, info, MethodDeclaration, log.info("    Built timestamp   : {}", serverInfo.getProperty(name + ".build.timestamp", "undef"));
367: Alejandro Abdelnur, info, MethodDeclaration, log.info("  Runtime information:");
368: Alejandro Abdelnur, info, MethodDeclaration, log.info("    Home   dir: {}", homeDir);
369: Alejandro Abdelnur, info, MethodDeclaration, log.info("    Config dir: {}", (config == null) ? configDir : "-");
370: Alejandro Abdelnur, info, MethodDeclaration, log.info("    Log    dir: {}", logDir);
371: Alejandro Abdelnur, info, MethodDeclaration, log.info("    Temp   dir: {}", tempDir);
373: Alejandro Abdelnur, debug, MethodDeclaration, log.debug("Loading services");
380: Alejandro Abdelnur, error, CatchClause, log.error("Services initialization failure, destroying initialized services");
376: Alejandro Abdelnur, debug, TryStmt, log.debug("Initializing services");
378: Alejandro Abdelnur, info, TryStmt, log.info("Services initialized");
386: Alejandro Abdelnur, info, MethodDeclaration, log.info("Server [{}] started!, status [{}]", name, status);
433: Alejandro Abdelnur, warn, IfStmt, log.warn("Log4j [{}] configuration file not found, using default configuration from classpath", log4jFile);
450: Alejandro Abdelnur, warn, IfStmt, log.warn("Default configuration file not available in classpath [{}]", defaultConfig);
472: Alejandro Abdelnur, debug, TryStmt, log.debug("Loading site configuration from [{}]", siteFile);
465: Alejandro Abdelnur, warn, IfStmt, log.warn("Site configuration file [{}] not found in config directory", siteFile);
492: Andrew Wang, info, IfStmt, log.info("System property sets  {}: {}", name, redacted);
496: Alejandro Abdelnur, debug, MethodDeclaration, log.debug("Loaded Configuration:");
497: Alejandro Abdelnur, debug, MethodDeclaration, log.debug("------------------------------------------------------");
502: Andrew Wang, debug, ForeachStmt, log.debug("  {}: {}", entry.getKey(), redacted);
504: Alejandro Abdelnur, debug, MethodDeclaration, log.debug("------------------------------------------------------");
520: Alejandro Abdelnur, debug, TryStmt, log.debug("Loading service [{}] implementation [{}]", service.getInterface(), service.getClass());
554: Alejandro Abdelnur, debug, IfStmt, log.debug("Replacing service [{}] implementation [{}]", service.getInterface(), service.getClass());
579: Alejandro Abdelnur, debug, ForeachStmt, log.debug("Initializing service [{}]", service.getInterface());
617: Alejandro Abdelnur, error, CatchClause, log.error("Could not destroy service [{}], {}", new Object[] { service.getInterface(), ex.getMessage(), ex });
614: Alejandro Abdelnur, debug, TryStmt, log.debug("Destroying service [{}]", service.getInterface());
621: Alejandro Abdelnur, info, MethodDeclaration, log.info("Services destroyed");
633: Alejandro Abdelnur, info, MethodDeclaration, log.info("Server [{}] shutdown!", name);
634: Alejandro Abdelnur, info, MethodDeclaration, log.info("======================================================");
765: Alejandro Abdelnur, error, CatchClause, log.error("Could not set service [{}] programmatically -server shutting down-, {}", klass, ex);
758: Alejandro Abdelnur, error, CatchClause, log.error("Could not destroy service [{}], {}", new Object[] { oldService.getInterface(), ex.getMessage(), ex });
149: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("Using FileSystemAccess JARs version [{}]", VersionInfo.getVersion());
176: Alejandro Abdelnur, info, IfStmt, LOG.info("Using FileSystemAccess simple/pseudo authentication, principal [{}]", System.getProperty("user.name"));
171: Alejandro Abdelnur, info, IfStmt, LOG.info("Using FileSystemAccess Kerberos authentication, principal [{}] keytab [{}]", principal, keytab);
195: Alejandro Abdelnur, debug, MethodDeclaration, LOG.debug("FileSystemAccess FileSystem configuration:");
197: Alejandro Abdelnur, debug, ForeachStmt, LOG.debug("  {} = {}", entry.getKey(), entry.getValue());
250: Alejandro Abdelnur, Error, CatchClause, LOG.warn("Error while purging filesystem, " + ex.toString(), ex);
253: Alejandro Abdelnur, debug, MethodDeclaration, LOG.debug("Purged [{}} filesystem instances", count);
59: Alejandro Abdelnur, debug, MethodDeclaration, LOG.debug("Scheduler started");
78: Alejandro Abdelnur, warn, CatchClause, LOG.warn(ex.getMessage(), ex);
68: Alejandro Abdelnur, debug, WhileStmt, LOG.debug("Waiting for scheduler to shutdown");
70: Alejandro Abdelnur, warn, IfStmt, LOG.warn("Gave up waiting for scheduler to shutdown");
75: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Scheduler shutdown");
96: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Scheduling callable [{}], interval [{}] seconds, delay [{}] in [{}]", new Object[] { callable, delay, interval, unit });
107: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Executing [{}]", callable);
114: Alejandro Abdelnur, Error, CatchClause, LOG.error("Error executing [{}], {}", new Object[] { callable, ex.getMessage(), ex });
104: Alejandro Abdelnur, debug, IfStmt, LOG.debug("Skipping [{}], server status [{}]", callable, getServer().getStatus());
83: Aaron Myers, warn, CatchClause, log.warn("Request remote address could not be resolved, {0}", ex.toString(), ex);
79: Aaron Myers, warn, IfStmt, log.warn("Request remote address is NULL");
51: Alejandro Abdelnur, debug, MethodDeclaration, LOG.debug("{}", throwable.getMessage(), throwable);
90: Todd Lipcon, debug, MethodDeclaration, LOG.debug("EXEC " + cmd);
101: Todd Lipcon, debug, MethodDeclaration, LOG.debug("EXEC " + cmd);
107: Todd Lipcon, debug, MethodDeclaration, LOG.debug("EXEC " + cmd);
113: Todd Lipcon, debug, MethodDeclaration, LOG.debug("EXEC " + cmd);
153: Eli Collins, error, WhileStmt, LOG.error("FUSE_LINE:" + line);
173: Todd Lipcon, debug, MethodDeclaration, LOG.debug("LD_LIBRARY_PATH=" + lp);
208: Eli Collins, info, MethodDeclaration, LOG.info("now mounting with:" + cmdStr);
105: Jitendra Pandey, info, ForeachStmt, LOG.info("FS:" + fs.getScheme() + " adding export Path:" + exportPath + " with URI: " + exportURI.toString());
114: Brandon Li, debug, IfStmt, LOG.debug("MOUNT NULLOP : " + " client: " + client);
134: Brandon Li, debug, IfStmt, LOG.debug("MOUNT MNT path: " + path + " client: " + client);
139: Brandon Li, debug, IfStmt, LOG.debug("Got host: " + host + " path: " + path);
143: Brandon Li, info, IfStmt, LOG.info("Path " + path + " is not shared.");
152: Jitendra Pandey, error, CatchClause, LOG.error("Can't get handle for export:" + path, e);
164: Brandon Li, error, CatchClause, LOG.error("Can't get handle for export:" + path, e);
170: Jitendra Pandey, info, MethodDeclaration, LOG.info("Giving handle (fileHandle:" + handle.dumpFileHandle() + " file URI: " + exportURI + ") to client for export " + path);
183: Brandon Li, debug, IfStmt, LOG.debug("MOUNT NULLOP : " + " client: " + client);
195: Brandon Li, debug, IfStmt, LOG.debug("MOUNT UMNT path: " + path + " client: " + client);
207: Brandon Li, debug, IfStmt, LOG.debug("MOUNT UMNTALL : " + " client: " + client);
70: Brandon Li, debug, IfStmt, LOG.debug("Current active thread number: " + executor.getActiveCount() + " queue size: " + executor.getQueue().size() + " scheduled task number: " + executor.getTaskCount());
85: Brandon Li, info, IfStmt, LOG.info("Shutting down all async data service threads...");
90: Brandon Li, info, IfStmt, LOG.info("All async data service threads have been shut down");
83: Brandon Li, warn, IfStmt, LOG.warn("AsyncDataService has already shut down.");
99: Brandon Li, debug, IfStmt, LOG.debug("Scheduling write back task for fileId: " + openFileCtx.getLatestAttr().getFileId());
136: yliu, error, CatchClause, LOG.error("Async data service got error: ", t);
180: Jitendra Pandey, error, IfStmt, LOG.error(msg);
172: Steve Loughran, info, IfStmt, LOG.info("Added export: {} FileSystem URI: {} with namenodeId: {}", exportPath, exportPath, namenodeId);
197: Steve Loughran, info, CatchClause, LOG.info("DFSClientCache.closeAll() threw an exception", e);
272: Steve Loughran, debug, MethodDeclaration, LOG.debug("Created ugi: {} for username: {}", ugi, effectiveUser);
285: Brandon Li, warn, CatchClause, LOG.warn(String.format("IOException when closing the DFSClient(%s), cause: %s", client, e));
329: Steve Loughran, error, CatchClause, LOG.error("Failed to create DFSClient for user: {}", userName, e);
342: Steve Loughran, warn, CatchClause, LOG.warn("Failed to create DFSInputStream for user: {}", userName, e);
142: Brandon Li, info, IfStmt, RpcProgramNfs3.LOG.info("Null channel should only happen in tests. Do nothing.");
148: Brandon Li, debug, IfStmt, RpcProgramNfs3.LOG.debug(WRITE_RPC_END + xid);
156: Brandon Li, debug, IfStmt, RpcProgramNfs3.LOG.debug("Commit done:" + xid);
213: Steve Loughran, debug, MethodDeclaration, LOG.debug("Update nonSequentialWriteInMemory by {} new value: {}", count, newValue);
274: Steve Loughran, debug, IfStmt, LOG.debug("Do nothing, dump is disabled.");
285: Steve Loughran, debug, IfStmt, LOG.debug("Asking dumper to dump...");
309: Steve Loughran, info, IfStmt, LOG.info("Create dump file: {}", dumpFilePath);
319: Steve Loughran, error, CatchClause, LOG.error("Got failure when creating dump stream {}", dumpFilePath, e);
326: Steve Loughran, error, CatchClause, LOG.error("Can't close dump stream {}", dumpFilePath, e);
338: Steve Loughran, error, CatchClause, LOG.error("Can't get random access to file {}", dumpFilePath);
345: Steve Loughran, debug, MethodDeclaration, LOG.debug("Start dump. Before dump, nonSequentialWriteInMemory == {}", nonSequentialWriteInMemory.get());
363: Steve Loughran, error, CatchClause, LOG.error("Dump data failed: {} OpenFileCtx state: {}", writeCtx, activeState, e);
371: Steve Loughran, debug, MethodDeclaration, LOG.debug("After dump, nonSequentialWriteInMemory == {}", nonSequentialWriteInMemory.get());
401: Steve Loughran, info, CatchClause, LOG.info("Dumper got Throwable. dumpFilePath: {}", OpenFileCtx.this.dumpFilePath, t);
389: Steve Loughran, info, CatchClause, LOG.info("Dumper is interrupted, dumpFilePath = {}", OpenFileCtx.this.dumpFilePath);
387: Steve Loughran, debug, TryStmt, LOG.debug("Dumper woke up");
394: Steve Loughran, debug, TryStmt, LOG.debug("Dumper checking OpenFileCtx activeState: {} " + "enabledDump: {}", activeState, enabledDump);
418: Steve Loughran, warn, IfStmt, LOG.warn("Got a repeated request, same range, with a different xid: " + "{} xid in old request: {}", xid, writeCtx.getXid());
453: Steve Loughran, debug, IfStmt, LOG.debug("Repeated write request which is already served: xid={}" + ", resend response.", xid);
450: Steve Loughran, debug, IfStmt, LOG.debug("Repeated write request which hasn't been served: " + "xid={}, drop it.", xid);
431: Steve Loughran, info, IfStmt, LOG.info("OpenFileCtx is inactive, fileId: {}", request.getHandle().dumpFileHandle());
475: Steve Loughran, debug, MethodDeclaration, LOG.debug("Got overwrite with appended data [{}-{})," + " current offset {}," + " drop the overlapped section [{}-{})" + " and append new data [{}-{}).", offset, (offset + count), cachedOffset, offset, cachedOffset, cachedOffset, (offset + count));
498: Yongjun Zhang, debug, IfStmt, LOG.debug(String.format("Trim request [%d-%d)," + " current offset %d," + " drop the overlapped section [%d-%d)" + " and write new data [%d-%d)", offset, (offset + count), currentOffset, offset, (currentOffset), currentOffset, (offset + count)));
522: Steve Loughran, debug, MethodDeclaration, LOG.debug("requested offset={} and current offset={}", offset, cachedOffset);
527: Yongjun Zhang, warn, IfStmt, LOG.warn(String.format("Got overwrite [%d-%d) smaller than" + " current offset %d," + " drop the request.", offset, (offset + count), cachedOffset));
547: Brandon Li, warn, IfStmt, LOG.warn("Modify this write to write only the appended data");
568: Steve Loughran, debug, IfStmt, LOG.debug("Add new write to the list with nextOffset {}" + " and requested offset={}", cachedOffset, offset);
582: Steve Loughran, warn, IfStmt, LOG.warn("Got a repeated request, same range, with xid: " + "{} nextOffset {} req offset={}", xid, cachedOffset, offset);
578: Steve Loughran, debug, IfStmt, LOG.debug("New write buffered with xid {} nextOffset {}" + "req offset={} mapsize={}", xid, cachedOffset, offset, pendingWrites.size());
558: Steve Loughran, warn, IfStmt, LOG.warn("(offset,count,nextOffset): ({},{},{})", offset, count, nextOffset);
603: Steve Loughran, debug, IfStmt, LOG.debug("Process perfectOverWrite");
599: Brandon Li, warn, IfStmt, LOG.warn("Treat this jumbo write as a real random write, no support.");
634: Steve Loughran, debug, IfStmt, LOG.debug("The write back thread is working.");
628: Steve Loughran, debug, IfStmt, LOG.debug("Trigger the write back task. Current nextOffset: {}", nextOffset.get());
666: Steve Loughran, info, IfStmt, LOG.info("Have to change stable write to unstable write: {}", request.getStableHow());
671: Steve Loughran, debug, IfStmt, LOG.debug("UNSTABLE write request, send response for offset: {}", writeCtx.getOffset());
705: Brandon Li, info, CatchClause, LOG.info("The FSDataOutputStream has been closed. " + "Continue processing the perfect overwrite.");
708: Steve Loughran, info, CatchClause, LOG.info("hsync failed when processing possible perfect overwrite, " + "path={} error: {}", path, e.toString());
724: Steve Loughran, info, CatchClause, LOG.info("Read failed when processing possible perfect overwrite, " + "path={}", path, e);
718: Steve Loughran, error, IfStmt, LOG.error("Can't read back {} bytes, partial read size: {}", count, readCount);
739: Brandon Li, info, IfStmt, LOG.info("Perfect overwrite has same content," + " updating the mtime, then return success");
746: Steve Loughran, info, CatchClause, LOG.info("Got error when processing perfect overwrite, path={} " + "error: {}", path, e.toString());
735: Brandon Li, info, IfStmt, LOG.info("Perfect overwrite has different content");
780: Steve Loughran, debug, MethodDeclaration, LOG.debug("Got commit status: {}", ret.name());
796: Steve Loughran, error, CatchClause, LOG.error("Got stream error during data sync", e);
835: Steve Loughran, debug, MethodDeclaration, LOG.debug("return COMMIT_SPECIAL_WAIT");
852: Steve Loughran, debug, MethodDeclaration, LOG.debug("getFlushedOffset={} commitOffset={} nextOffset={}", flushed, commitOffset, nextOffset.get());
862: Steve Loughran, debug, IfStmt, LOG.debug("get commit while still writing to the requested offset," + " with empty queue");
889: Steve Loughran, debug, IfStmt, LOG.debug("return COMMIT_SPECIAL_SUCCESS");
882: Steve Loughran, debug, IfStmt, LOG.debug("get commit while still writing to the requested offset");
951: Steve Loughran, debug, IfStmt, LOG.debug("stream can be closed for fileId: {}", handle.dumpFileHandle());
967: Steve Loughran, debug, IfStmt, LOG.debug("The async write task has no pending writes, fileId: {}", latestAttr.getFileId());
985: Steve Loughran, trace, MethodDeclaration, LOG.trace("range.getMin()={} nextOffset={}", range.getMin(), nextOffset);
1008: Steve Loughran, debug, IfStmt, LOG.debug("Remove write {} from the list", range);
1013: Steve Loughran, debug, IfStmt, LOG.debug("Change nextOffset to {}", nextOffset.get());
999: Steve Loughran, warn, IfStmt, LOG.warn("Got an overlapping write {}, nextOffset={}. " + "Remove and trim it", range, offset);
1005: Steve Loughran, debug, IfStmt, LOG.debug("Change nextOffset (after trim) to {}", nextOffset.get());
994: Steve Loughran, debug, IfStmt, LOG.debug("Remove write {} which is already written from the list", range);
990: Steve Loughran, debug, IfStmt, LOG.debug("The next sequential write has not arrived yet");
1047: Steve Loughran, info, IfStmt, LOG.info("Another async task is already started before this one " + "is finalized. fileId: {} asyncStatus: {} " + "original startOffset: {} " + "new startOffset: {}. Won't change asyncStatus here.", latestAttr.getFileId(), asyncStatus, startOffset, asyncWriteBackStartOffset);
1038: Steve Loughran, debug, IfStmt, LOG.debug("The openFileCtx is not active anymore, fileId: {}", latestAttr.getFileId());
1075: Steve Loughran, error, IfStmt, LOG.error("Can't sync for fileId: {}. " + "Channel closed with writes pending", latestAttr.getFileId(), cce);
1080: yliu, error, CatchClause, LOG.error("Got stream error during data sync: ", e);
1090: Brandon Li, error, CatchClause, LOG.error("Can't get new file attr, fileId: " + latestAttr.getFileId(), e);
1095: Steve Loughran, error, IfStmt, LOG.error("After sync, the expect file size: {}, " + "however actual file size is: {}", offset, latestAttr.getSize());
1115: Steve Loughran, debug, IfStmt, LOG.debug("FileId: {} Service time: {}ns. " + "Sent response for commit: {}", latestAttr.getFileId(), Nfs3Utils.getElapsedTime(commit.startTime), commit);
1133: Steve Loughran, debug, IfStmt, LOG.debug("do write, fileHandle {} offset: {} length: {} stableHow: {}", handle.dumpFileHandle(), offset, count, stableHow.name());
1203: Steve Loughran, Error, CatchClause, LOG.error("Error writing to fileHandle {} at offset {} and length {}", handle.dumpFileHandle(), offset, count, e);
1212: Steve Loughran, info, CatchClause, LOG.info("Clean up open file context for fileId: {}", latestAttr.getFileId());
1158: Steve Loughran, debug, IfStmt, LOG.debug("After writing {} at offset {}, " + "updated the memory count, new value: {}", handle.dumpFileHandle(), offset, nonSequentialWriteInMemory.get());
1169: Steve Loughran, info, IfStmt, LOG.info("Do sync for stable write: {}", writeCtx);
1180: Steve Loughran, error, CatchClause, LOG.error("hsync failed with writeCtx: {}", writeCtx, e);
1188: Steve Loughran, warn, IfStmt, LOG.warn("Return original count: {} instead of real data count: {}", writeCtx.getOriginalCount(), count);
1220: Jing Zhao, info, IfStmt, LOG.info("Current OpenFileCtx is already inactive, no need to cleanup.");
1240: Steve Loughran, info, CatchClause, LOG.info("Can't close stream for fileId: {}, error: {}", latestAttr.getFileId(), e.toString());
1245: Steve Loughran, info, MethodDeclaration, LOG.info("There are {} pending writes.", pendingWrites.size());
1249: Steve Loughran, info, WhileStmt, LOG.info("Fail pending write: {}, nextOffset={}", key, nextOffset.get());
1267: Steve Loughran, error, CatchClause, LOG.error("Failed to close outputstream of dump file {}", dumpFilePath, e);
1272: Steve Loughran, error, IfStmt, LOG.error("Failed to delete dumpfile: {}", dumpFile);
1279: Brandon Li, error, CatchClause, LOG.error("Got exception when closing input stream of dump file.", e);
54: Brandon Li, info, ConstructorDeclaration, LOG.info("Maximum open streams is " + maxStreams);
72: Arpit Agarwal, trace, IfStmt, LOG.trace("openFileMap size:" + size());
82: Brandon Li, debug, IfStmt, LOG.debug("Got one inactive stream: " + ctx);
107: Brandon Li, debug, IfStmt, LOG.debug("idlest stream's idle time:" + idleTime);
109: Brandon Li, warn, IfStmt, LOG.warn("All opened streams are busy, can't remove any from cache.");
100: Brandon Li, warn, IfStmt, LOG.warn("No eviction candidate. All streams have pending work.");
129: Brandon Li, debug, IfStmt, LOG.debug("Evict stream ctx: " + pairs.getValue());
152: Arpit Agarwal, trace, IfStmt, LOG.trace("openFileMap size:" + size());
170: Jitendra Pandey, debug, IfStmt, LOG.debug("After remove stream " + handle.dumpFileHandle() + ", the stream number:" + size());
204: Arpit Agarwal, trace, IfStmt, LOG.trace("openFileMap size:" + size());
265: Brandon Li, info, CatchClause, LOG.info("StreamMonitor got interrupted");
257: Brandon Li, trace, IfStmt, LOG.trace("StreamMonitor can still have a sleep:" + ((rotation - workedTime) / 1000));
64: Jitendra Pandey, error, CatchClause, LOG.error("Init failed for port=" + clientPort, e);
207: Steve Loughran, info, ConstructorDeclaration, LOG.info("Configured HDFS superuser is {}", superuser);
233: Steve Loughran, info, IfStmt, LOG.info("Delete current dump directory {}", writeDumpDir);
239: Steve Loughran, info, MethodDeclaration, LOG.info("Create new dump directory {}", writeDumpDir);
257: Brandon Li, error, CatchClause, LOG.error("failed to start web server", e);
274: Brandon Li, warn, CatchClause, LOG.warn("Exception shutting down web server", e);
301: Steve Loughran, debug, MethodDeclaration, LOG.debug("NFS NULL");
324: Brandon Li, error, CatchClause, LOG.error("Invalid GETATTR request");
332: Steve Loughran, debug, IfStmt, LOG.debug("GETATTR for fileHandle: {} client: {}", handle.dumpFileHandle(), remoteAddress);
346: Steve Loughran, warn, CatchClause, LOG.warn("Exception", r);
357: Steve Loughran, info, CatchClause, LOG.info("Can't get file attribute, fileId={}", handle.getFileId(), e);
363: Steve Loughran, error, IfStmt, LOG.error("Can't get path for fileId: {}", handle.getFileId());
378: Steve Loughran, debug, IfStmt, LOG.debug("set new mode: {}", newAttr.getMode());
396: Steve Loughran, debug, IfStmt, LOG.debug("set atime: {} mtime: {}", atime, mtime);
415: Brandon Li, error, CatchClause, LOG.error("Invalid SETATTR request");
423: Steve Loughran, debug, IfStmt, LOG.debug("NFS SETATTR fileHandle: {} client: {}", handle.dumpFileHandle(), remoteAddress);
434: Steve Loughran, error, IfStmt, LOG.error("Setting file size is not supported when setattr, fileId: {}", handle.getFileId());
469: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
475: Steve Loughran, info, CatchClause, LOG.info("Can't get postOpAttr for fileIdPath: {}", fileIdPath, e1);
445: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fileId: {}", handle.getFileId());
502: Brandon Li, error, CatchClause, LOG.error("Invalid LOOKUP request");
510: Steve Loughran, debug, IfStmt, LOG.debug("NFS LOOKUP dir fileHandle: {} name: {} client: {}", dirHandle.dumpFileHandle(), fileName, remoteAddress);
544: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
524: Steve Loughran, debug, IfStmt, LOG.debug("NFS LOOKUP fileId: {} name: {} does not exist", dirHandle.getFileId(), fileName);
535: Steve Loughran, info, IfStmt, LOG.info("Can't get path for dir fileId: {}", dirHandle.getFileId());
569: Brandon Li, error, CatchClause, LOG.error("Invalid ACCESS request");
584: Steve Loughran, debug, IfStmt, LOG.debug("NFS ACCESS fileHandle: {} client: {}", handle.dumpFileHandle(), remoteAddress);
607: Steve Loughran, warn, CatchClause, LOG.warn("Exception", r);
618: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
592: Steve Loughran, error, IfStmt, LOG.error("Can't get path for fileId: {}", handle.getFileId());
644: Brandon Li, error, CatchClause, LOG.error("Invalid READLINK request");
651: Steve Loughran, debug, IfStmt, LOG.debug("NFS READLINK fileHandle: {} client: {}", handle.dumpFileHandle(), remoteAddress);
693: Steve Loughran, warn, CatchClause, LOG.warn("Readlink error", e);
668: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fileId: {}", handle.getFileId());
672: Steve Loughran, error, IfStmt, LOG.error("Not a symlink, fileId: {}", handle.getFileId());
676: Steve Loughran, error, IfStmt, LOG.error("Symlink target should not be null, fileId: {}", handle.getFileId());
683: Steve Loughran, error, IfStmt, LOG.error("Link size: {} is larger than max transfer size: {}", target.getBytes(Charset.forName("UTF-8")).length, rtmax);
720: Brandon Li, error, CatchClause, LOG.error("Invalid READ request");
730: Steve Loughran, debug, IfStmt, LOG.debug("NFS READ fileHandle: {} offset: {} count: {} client: {}", handle.dumpFileHandle(), offset, count, remoteAddress);
748: Steve Loughran, debug, CatchClause, LOG.debug("Get error accessing file, fileId: {}", handle.getFileId(), e);
753: Steve Loughran, debug, IfStmt, LOG.debug("Can't get path for fileId: {}", handle.getFileId());
772: Steve Loughran, warn, IfStmt, LOG.warn("commitBeforeRead didn't succeed with ret={}. " + "Read may not get most recent data.", ret);
825: Steve Loughran, warn, CatchClause, LOG.warn("Read error. Offset: {} count: {}", offset, count, e);
813: Steve Loughran, info, IfStmt, LOG.info("Partial read. Asked offset: {} count: {} and read back: {} " + "file size: {}", offset, count, readCount, attrs.getSize());
851: Brandon Li, error, CatchClause, LOG.error("Invalid WRITE request");
860: Brandon Li, error, IfStmt, LOG.error("Invalid argument, data size is less than count in request");
867: Steve Loughran, debug, IfStmt, LOG.debug("NFS WRITE fileHandle: {} offset: {} length: {} " + "stableHow: {} xid: {} client: {}", handle.dumpFileHandle(), offset, count, stableHow.getValue(), xid, remoteAddress);
899: Steve Loughran, Error, CatchClause, LOG.info("Error writing to fileId {} at offset {} and length {}", handle.getFileId(), offset, data.length, e);
906: Steve Loughran, info, CatchClause, LOG.info("Can't get postOpAttr for fileId: {}", e1);
883: Steve Loughran, error, IfStmt, LOG.error("Can't get path for fileId: {}", handle.getFileId());
893: Steve Loughran, debug, TryStmt, LOG.debug("requested offset={} and current filesize={}", offset, preOpAttr.getSize());
934: Brandon Li, error, CatchClause, LOG.error("Invalid CREATE request");
942: Steve Loughran, debug, IfStmt, LOG.debug("NFS CREATE dir fileHandle: {} filename: {} client: {}", dirHandle.dumpFileHandle(), fileName, remoteAddress);
956: Steve Loughran, error, IfStmt, LOG.error("Setting file size is not supported when creating file: {} " + "dir fileId: {}", fileName, dirHandle.getFileId());
1026: Brandon Li, error, CatchClause, LOG.error("Exception", e);
1031: Steve Loughran, error, CatchClause, LOG.error("Can't close stream for dirFileId: {} filename: {}", dirHandle.getFileId(), fileName, e1);
1040: Steve Loughran, error, CatchClause, LOG.error("Can't get postOpDirAttr for dirFileId: {}", dirHandle.getFileId(), e1);
970: Steve Loughran, error, IfStmt, LOG.error("Can't get path for dirHandle: {}", dirHandle);
1021: Steve Loughran, debug, IfStmt, LOG.debug("Opened stream for file: {}, fileId: {}", fileName, fileHandle.getFileId());
1016: Brandon Li, warn, IfStmt, LOG.warn("Can't add more stream, close it." + " Future write will become append");
1068: Brandon Li, error, CatchClause, LOG.error("Invalid MKDIR request");
1083: Steve Loughran, debug, IfStmt, LOG.debug("NFS MKDIR dirHandle: {} filename: {} client: {}", dirHandle.dumpFileHandle(), fileName, remoteAddress);
1087: Steve Loughran, error, IfStmt, LOG.error("Setting file size is not supported when mkdir: " + "{} in dirHandle {}", fileName, dirHandle);
1135: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
1141: Steve Loughran, info, CatchClause, LOG.info("Can't get postOpDirAttr for {}", dirFileIdPath, e);
1100: Steve Loughran, info, IfStmt, LOG.info("Can't get path for dir fileId: {}", dirHandle.getFileId());
1171: Brandon Li, error, CatchClause, LOG.error("Invalid REMOVE request");
1179: Steve Loughran, debug, IfStmt, LOG.debug("NFS REMOVE dir fileHandle: {} fileName: {} client: {}", dirHandle.dumpFileHandle(), fileName, remoteAddress);
1223: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
1229: Steve Loughran, info, CatchClause, LOG.info("Can't get postOpDirAttr for {}", dirFileIdPath, e1);
1195: Steve Loughran, info, IfStmt, LOG.info("Can't get path for dir fileId: {}", dirHandle.getFileId());
1254: Brandon Li, error, CatchClause, LOG.error("Invalid RMDIR request");
1261: Steve Loughran, debug, IfStmt, LOG.debug("NFS RMDIR dir fileHandle: {} fileName: {} client: {}", dirHandle.dumpFileHandle(), fileName, remoteAddress);
1309: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
1315: Steve Loughran, info, CatchClause, LOG.info("Can't get postOpDirAttr for {}", dirFileIdPath, e1);
1277: Steve Loughran, info, IfStmt, LOG.info("Can't get path for dir fileId: {}", dirHandle.getFileId());
1340: Brandon Li, error, CatchClause, LOG.error("Invalid RENAME request");
1351: Steve Loughran, debug, IfStmt, LOG.debug("NFS RENAME from: {}/{} to: {}/{} client: {}", fromHandle.dumpFileHandle(), fromName, toHandle.dumpFileHandle(), toName, remoteAddress);
1409: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
1418: Steve Loughran, info, CatchClause, LOG.info("Can't get postOpDirAttr for {} or {}", fromDirFileIdPath, toDirFileIdPath, e1);
1377: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fromHandle fileId: {}", fromHandle.getFileId());
1384: Steve Loughran, info, IfStmt, LOG.info("Can't get path for toHandle fileId: {}", toHandle.getFileId());
1446: Brandon Li, error, CatchClause, LOG.error("Invalid SYMLINK request");
1459: Steve Loughran, debug, MethodDeclaration, LOG.debug("NFS SYMLINK, target: {} link: {} namenodeId: {} client: {}", symData, linkIdPath, namenodeId, remoteAddress);
1488: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
1515: Steve Loughran, info, CatchClause, LOG.info("Cookie couldn't be found: {}, do listing from beginning", new String(startAfter, Charset.forName("UTF-8")));
1541: Brandon Li, error, CatchClause, LOG.error("Invalid READDIR request");
1549: Steve Loughran, error, IfStmt, LOG.error("Invalid READDIR request, with negative cookie: {}", cookie);
1554: Steve Loughran, info, IfStmt, LOG.info("Nonpositive count in invalid READDIR request: {}", count);
1559: Steve Loughran, debug, IfStmt, LOG.debug("NFS READDIR fileHandle: {} cookie: {} count: {} client: {}", handle.dumpFileHandle(), cookie, count, remoteAddress);
1639: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
1577: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fileId: {}", handle.getFileId());
1581: Steve Loughran, error, IfStmt, LOG.error("Can't readdir for regular file, fileId: {}", handle.getFileId());
1601: Steve Loughran, error, IfStmt, LOG.error("CookieVerf mismatch. request cookieVerf: {} " + "dir cookieVerf: {}", cookieVerf, dirStatus.getModificationTime());
1635: Steve Loughran, error, IfStmt, LOG.error("Can't get path for fileId: {}", handle.getFileId());
1705: Brandon Li, error, CatchClause, LOG.error("Invalid READDIRPLUS request");
1713: Steve Loughran, error, IfStmt, LOG.error("Invalid READDIRPLUS request, with negative cookie: {}", cookie);
1719: Steve Loughran, info, IfStmt, LOG.info("Nonpositive dircount in invalid READDIRPLUS request: {}", dirCount);
1725: Steve Loughran, info, IfStmt, LOG.info("Nonpositive maxcount in invalid READDIRPLUS request: {}", maxCount);
1731: Steve Loughran, debug, IfStmt, LOG.debug("NFS READDIRPLUS fileHandle: {} cookie: {} dirCount: {} " + "maxCount: {} client: {}", handle.dumpFileHandle(), cookie, dirCount, maxCount, remoteAddress);
1811: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
1750: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fileId: {}", handle.getFileId());
1754: Steve Loughran, error, IfStmt, LOG.error("Can't readdirplus for regular file, fileId: {}", handle.getFileId());
1772: Steve Loughran, error, IfStmt, LOG.error("cookieverf mismatch. request cookieverf: {} " + "dir cookieverf: {}", cookieVerf, dirStatus.getModificationTime());
1807: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fileId: {}", handle.getFileId());
1856: Steve Loughran, error, CatchClause, LOG.error("Can't get file attributes for fileId: {}", fileId, e);
1839: Steve Loughran, error, CatchClause, LOG.error("Can't get file attributes for fileId: {}", fileId, e);
1890: Brandon Li, error, CatchClause, LOG.error("Invalid FSSTAT request");
1897: Steve Loughran, debug, IfStmt, LOG.debug("NFS FSSTAT fileHandle: {} client: {}", handle.dumpFileHandle(), remoteAddress);
1930: Steve Loughran, warn, CatchClause, LOG.warn("Exception", r);
1941: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
1915: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fileId: {}", handle.getFileId());
1966: Brandon Li, error, CatchClause, LOG.error("Invalid FSINFO request");
1973: Steve Loughran, debug, IfStmt, LOG.debug("NFS FSINFO fileHandle: {} client: {}", remoteAddress, handle.dumpFileHandle(), remoteAddress);
2007: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
1997: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fileId: {}", handle.getFileId());
2032: Brandon Li, error, CatchClause, LOG.error("Invalid PATHCONF request");
2041: Steve Loughran, debug, IfStmt, LOG.debug("NFS PATHCONF fileHandle: {} client: {}", handle.dumpFileHandle(), remoteAddress);
2062: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
2055: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fileId: {}", handle.getFileId());
2086: Brandon Li, error, CatchClause, LOG.error("Invalid COMMIT request");
2094: Steve Loughran, debug, IfStmt, LOG.debug("NFS COMMIT fileHandle: {} offset={} count={} client: {}", handle.dumpFileHandle(), request.getOffset(), request.getCount(), remoteAddress);
2128: Steve Loughran, warn, CatchClause, LOG.warn("Exception", e);
2133: Steve Loughran, info, CatchClause, LOG.info("Can't get postOpAttr for fileId: {}", handle.getFileId(), e1);
2110: Steve Loughran, info, IfStmt, LOG.info("Can't get path for fileId: {}", handle.getFileId());
2175: Steve Loughran, info, IfStmt, LOG.info("Wrong RPC AUTH flavor, {} is not AUTH_SYS or RPCSEC_GSS.", credentials.getFlavor());
2201: Steve Loughran, info, IfStmt, LOG.info("Retransmitted request, transaction still in progress {}", xid);
2196: Steve Loughran, info, IfStmt, LOG.info("Sending the cached reply to retransmitted request {}", xid);
2237: Steve Loughran, debug, IfStmt, LOG.debug("{}{}", Nfs3Utils.WRITE_RPC_START, xid);
2232: Steve Loughran, debug, IfStmt, LOG.debug("{}{}", Nfs3Utils.READ_RPC_START, xid);
2234: Steve Loughran, debug, IfStmt, LOG.debug("{}{}", Nfs3Utils.READ_RPC_END, xid);
2288: Steve Loughran, debug, IfStmt, LOG.debug("No sync response, expect an async response for request XID={}", rpcCall.getXid());
108: Yongjun Zhang, debug, IfStmt, LOG.debug("Trim write request by delta:" + delta + " " + toString());
154: Brandon Li, trace, IfStmt, LOG.trace("No need to dump with status(replied,dataState):" + "(" + replied + "," + dataState + ")");
167: Brandon Li, debug, IfStmt, LOG.debug("After dump, new dumpFileOffset:" + dumpFileOffset);
263: Xiaoyu Yao, error, CatchClause, LOG.error("Failed to get request data offset:" + getPlainOffset() + " " + "count:" + count + " error:" + e1);
92: Brandon Li, info, ConstructorDeclaration, LOG.info("Stream timeout is " + streamTimeout + "ms.");
94: Brandon Li, info, IfStmt, LOG.info("Reset stream timeout to minimum value " + NfsConfigKeys.DFS_NFS_STREAM_TIMEOUT_MIN_DEFAULT + "ms.");
100: Brandon Li, info, ConstructorDeclaration, LOG.info("Maximum open streams is " + maxStreams);
135: Brandon Li, debug, IfStmt, LOG.debug("handleWrite " + request);
142: Jitendra Pandey, info, IfStmt, LOG.info("No opened stream for fileHandle: " + fileHandle.dumpFileHandle());
160: yliu, warn, IfStmt, LOG.warn("Can't append file: " + fileIdPath + ". Possibly the file is being closed. Drop the request: " + request + ", wait for the client to retry...");
167: yliu, error, CatchClause, LOG.error("Can't append to file: " + fileIdPath, e);
188: Brandon Li, info, IfStmt, LOG.info("Can't add new stream. Close it. Tell client to retry.");
192: Jitendra Pandey, error, CatchClause, LOG.error("Can't close stream for fileHandle: " + handle.dumpFileHandle(), e);
206: Jitendra Pandey, debug, IfStmt, LOG.debug("Opened stream for appending file: " + fileHandle.dumpFileHandle());
260: yliu, error, SwitchStmt, LOG.error("Should not get commit return code: " + ret.name());
226: Jitendra Pandey, debug, IfStmt, LOG.debug("No opened stream for fileId: " + fileHandle.dumpFileHandle() + " commitOffset=" + commitOffset + ". Return success in this case.");
302: yliu, error, SwitchStmt, LOG.error("Should not get commit return code: " + ret.name());
276: Jitendra Pandey, info, IfStmt, LOG.info("No opened stream for fileId: " + fileHandle.dumpFileHandle() + " commitOffset=" + commitOffset + ". Return success in this case.");
315: Brandon Li, info, CatchClause, LOG.info("Can't get postOpAttr for fileId: " + preOpAttr.getFileId(), e1);
107: Brandon Li, info, IfStmt, LOG.info("rsp length is zero, why?");
110: Brandon Li, info, MethodDeclaration, LOG.info("rsp length=" + rsp.getBytes().length);
120: Brandon Li, error, IfStmt, LOG.error("Create failed, status =" + status);
123: Brandon Li, info, MethodDeclaration, LOG.info("Create succeeded");
169: Brandon Li, info, MethodDeclaration, LOG.info("Send write1 request");
126: Inigo Goiri, info, TryStmt, LOG.info("Registered Router MBean: {}", this.beanName);
137: Inigo Goiri, error, IfStmt, LOG.error("State store not available");
190: Inigo Goiri, error, CatchClause, LOG.error("Enable to fetch json representation of namenodes {}", e.getMessage());
220: Inigo Goiri, error, CatchClause, LOG.error("Cannot retrieve nameservices for JMX: {}", e.getMessage());
268: Inigo Goiri, error, CatchClause, LOG.error("Cannot generate JSON of mount table from store: {}", e.getMessage());
308: Inigo Goiri, error, CatchClause, LOG.error("Cannot get Routers JSON from the State Store", e);
299: Inigo Goiri, error, IfStmt, LOG.error("Cannot get State Store versions");
358: Inigo Goiri, error, CatchClause, LOG.error("Cannot fetch number of expired registrations from the store: {}", e.getMessage());
375: Inigo Goiri, error, CatchClause, LOG.error("Cannot retrieve numNamenodes for JMX: {}", e.getMessage());
391: Inigo Goiri, error, CatchClause, LOG.error("Cannot retrieve numExpiredNamenodes for JMX: {}", e.getMessage());
459: Yiqun Lin, error, CatchClause, LOG.error("Cannot get the live nodes: {}", e.getMessage());
552: Inigo Goiri, error, CatchClause, LOG.error("Cannot fetch cluster ID metrics: {}", e.getMessage());
564: Inigo Goiri, error, CatchClause, LOG.error("Cannot fetch block pool ID metrics: {}", e.getMessage());
603: Inigo Goiri, error, CatchClause, LOG.error("Unable to extract metrics: {}", e.getMessage());
619: Inigo Goiri, error, CatchClause, LOG.error("Unable to extract metrics: {}", e.getMessage());
726: Inigo Goiri, error, CatchClause, LOG.error("Cannot execute getter {} on {}", m.getName(), record);
746: Inigo Goiri, error, CatchClause, LOG.error("Cannot get field {} on {}", fieldName, record);
89: Inigo Goiri, info, TryStmt, LOG.info("Registered FederationRPCMBean: {}", registeredBean);
117: Inigo Goiri, info, TryStmt, LOG.info("Registered FSNamesystem MBean: {}", this.fsBeanName);
126: Inigo Goiri, info, TryStmt, LOG.info("Registered FSNamesystemState MBean: {}", this.fsStateBeanName);
134: Inigo Goiri, info, TryStmt, LOG.info("Registered NameNodeInfo MBean: {}", this.nnInfoBeanName);
143: Inigo Goiri, info, TryStmt, LOG.info("Registered NameNodeStatus MBean: {}", this.nnStatusBeanName);
358: Yiqun Lin, error, CatchClause, LOG.error("Cannot get the DN storage report for {}", type, e);
399: Inigo Goiri, error, CatchClause, LOG.error("Cannot get {} nodes, Router in safe mode", type);
401: Yiqun Lin, error, CatchClause, LOG.error("Cannot get {} nodes, subclusters timed out responding", type);
403: Inigo Goiri, error, CatchClause, LOG.error("Cannot get " + type + " nodes", e);
413: Inigo Goiri, error, CatchClause, LOG.error("Cannot fetch cluster ID metrics {}", e.getMessage());
424: Inigo Goiri, error, CatchClause, LOG.error("Cannot fetch block pool ID metrics {}", e.getMessage());
129: Inigo Goiri, error, CatchClause, LOG.error("Cannot update membership from the State Store", e);
166: Inigo Goiri, error, CatchClause, LOG.error("Cannot update {} as active, State Store unavailable", address);
188: Yiqun Lin, error, CatchClause, LOG.error("Cannot get active NN for {}, State Store unavailable", nsId);
192: Yiqun Lin, error, IfStmt, LOG.error("Cannot locate eligible NNs for {}", nsId);
210: Yiqun Lin, error, CatchClause, LOG.error("Cannot get disabled name services, State Store unavailable");
201: Yiqun Lin, error, IfStmt, LOG.error("Cannot get disabled name services");
240: Inigo Goiri, error, CatchClause, LOG.error("Cannot get active NN for {}, State Store unavailable", bpId);
234: Inigo Goiri, error, IfStmt, LOG.error("Cannot locate eligible NNs for {}", bpId);
255: Inigo Goiri, warn, IfStmt, LOG.warn("Cannot register namenode, router ID is not known {}", report);
365: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Selected most recent NN {} for query", priorityList);
157: Inigo Goiri, error, CatchClause, LOG.error("Cannot find default name service, setting it to the first");
160: Inigo Goiri, info, CatchClause, LOG.info("Default name service: {}", this.defaultNameService);
229: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Invalidating {} from {}", path, locationCache);
250: Inigo Goiri, debug, IfStmt, LOG.debug("Removing default cache {}", dest);
244: Inigo Goiri, debug, IfStmt, LOG.debug("Removing {}", src);
256: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Location cache after invalidation: {}", locationCache);
289: Inigo Goiri, info, IfStmt, LOG.info("Removed stale mount point {} from resolver", srcPath);
305: Inigo Goiri, info, IfStmt, LOG.info("Entry has changed from \"{}\" to \"{}\"", existingEntry, entry);
309: Inigo Goiri, info, IfStmt, LOG.info("Updated mount point {} in resolver", srcPath);
300: Inigo Goiri, info, IfStmt, LOG.info("Added new mount point {} to resolver", srcPath);
337: Inigo Goiri, error, CatchClause, LOG.error("Cannot fetch mount table entries from State Store", e);
347: Inigo Goiri, info, MethodDeclaration, LOG.info("Clearing all mount location caches");
505: Inigo Goiri, error, IfStmt, LOG.error("Cannot build location, {} not a child of {}", path, srcPath);
107: Inigo Goiri, error, IfStmt, LOG.error("Cannot get main namespace for path {} with order {}", path, order);
104: Inigo Goiri, debug, IfStmt, LOG.debug("Ordered locations following {} are {}", order, mountTableResult);
95: Inigo Goiri, error, IfStmt, LOG.error("Cannot find resolver for order {}", order);
89: Inigo Goiri, error, IfStmt, LOG.error("The {} cannot find a location for {}", super.getClass().getSimpleName(), path);
123: Inigo Goiri, debug, IfStmt, LOG.debug("Cannot find location with namespace {} in {}", nsId, original);
73: Yiqun Lin, warn, IfStmt, LOG.warn("The balancer preference value is less than 0.5. That means more" + " files will be allocated in cluster with lower available space.");
110: Yiqun Lin, error, CatchClause, LOG.error("Cannot get Namenodes from the State Store.", ioe);
106: Yiqun Lin, error, CatchClause, LOG.error("Cannot get stats info for {}: {}.", nn, e.getMessage());
32: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Only using the first part of the path: {} -> {}", path, trimmedPath);
85: Inigo Goiri, error, IfStmt, LOG.error("Cannot find subcluster for {} ({} -> {})", srcPath, path, finalPath);
88: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Namespace for {} ({}) is {}", path, finalPath, hashedSubcluster);
132: Inigo Goiri, debug, IfStmt, LOG.debug("Extracted {} from {}", ret, input);
111: Inigo Goiri, error, IfStmt, LOG.error("Cannot get node mapping when resolving {} at {} from {}", path, loc, clientAddr);
108: Inigo Goiri, error, IfStmt, LOG.error("Cannot get local namespace for {}", clientAddr);
106: Inigo Goiri, debug, IfStmt, LOG.debug("Local namespace for {} is {}", clientAddr, localSubcluster);
133: Inigo Goiri, error, IfStmt, LOG.error("Cannot access the Router RPC server");
164: Inigo Goiri, error, CatchClause, LOG.error("Cannot get Datanodes from the Namenodes: {}", e.getMessage());
149: Inigo Goiri, error, CatchClause, LOG.error("Cannot get the datanodes from the RPC server", e);
184: Inigo Goiri, error, CatchClause, LOG.error("Cannot get local host name");
213: Yiqun Lin, error, CatchClause, LOG.error("Cannot get Namenodes from the State Store", ioe);
209: Inigo Goiri, error, CatchClause, LOG.error("Cannot get address for {}: {}", nn, e.getMessage());
55: Inigo Goiri, error, IfStmt, LOG.error("Cannot get namespaces for {}", loc);
105: Yiqun Lin, error, IfStmt, LOG.error("Cannot access the Membership store.");
121: Yiqun Lin, error, CatchClause, LOG.error("Cannot wait for the updater to finish");
118: Yiqun Lin, debug, TryStmt, LOG.debug("Wait to get the mapping for the first time");
116: Inigo Goiri, info, ConstructorDeclaration, LOG.info("Cleaning connection pools every {} seconds", TimeUnit.MILLISECONDS.toSeconds(this.poolCleanupPeriodMs));
121: Inigo Goiri, info, ConstructorDeclaration, LOG.info("Cleaning connections every {} seconds", TimeUnit.MILLISECONDS.toSeconds(this.connectionCleanupPeriodMs));
135: Inigo Goiri, info, MethodDeclaration, LOG.info("Cleaning every {} seconds", TimeUnit.MILLISECONDS.toSeconds(recyleTimeMs));
178: Inigo Goiri, error, IfStmt, LOG.error("Cannot get a connection to {} because the manager isn't running", nnAddress);
215: Inigo Goiri, error, IfStmt, LOG.error("Cannot add more than {} connections at the same time", MAX_NEW_CONNECTIONS);
221: Inigo Goiri, error, IfStmt, LOG.error("We got a closed connection from {}", pool);
332: Inigo Goiri, debug, IfStmt, LOG.debug("Removed connection {} used {} seconds ago. " + "Pool has {}/{} connections", pool.getConnectionPoolId(), TimeUnit.MILLISECONDS.toSeconds(timeSinceLastActive), pool.getNumConnections(), pool.getMaxSize());
367: Inigo Goiri, debug, IfStmt, LOG.debug("Cleaning up {}", pool);
361: Inigo Goiri, debug, IfStmt, LOG.debug("Closing and removing stale pool {}", pool);
423: Inigo Goiri, error, CatchClause, LOG.error("The connection creator was interrupted");
420: Inigo Goiri, error, CatchClause, LOG.error("Cannot create a new connection", e);
416: Inigo Goiri, debug, IfStmt, LOG.debug("Cannot add more than {} connections to {}", pool.getMaxSize(), pool);
120: Inigo Goiri, debug, ConstructorDeclaration, LOG.debug("Created connection pool \"{}\" with {} connections", this.connectionPoolId, this.minSize);
220: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Shutting down connection pool \"{}\" used {} seconds ago", this.connectionPoolId, timeSinceLastActive);
325: Yiqun Lin, error, IfStmt, LOG.error(msg);
72: Inigo Goiri, error, CatchClause, LOG.error("Failed to start router", e);
89: Inigo Goiri, error, CatchClause, LOG.error("Cannot read JMX bean {} from server {}: {}", beanQuery, webAddress, e.getMessage());
92: Inigo Goiri, error, CatchClause, LOG.error("Cannot parse JMX output for {} from server {}: {}", beanQuery, webAddress, e.getMessage());
95: Inigo Goiri, error, CatchClause, LOG.error("Cannot parse JMX output for {} from server {}: {}", beanQuery, webAddress, e);
102: Inigo Goiri, error, CatchClause, LOG.error("Problem closing {}", webAddress, e);
153: Inigo Goiri, error, CatchClause, LOG.error("Could not instantiate: {}", clazz.getSimpleName(), e);
124: Inigo Goiri, info, MethodDeclaration, LOG.info("{} RPC address: {}", nnDesc, rpcAddress);
130: Inigo Goiri, error, IfStmt, LOG.error("Cannot locate RPC service address for NN {}, " + "using RPC address {}", nnDesc, this.rpcAddress);
134: Inigo Goiri, info, MethodDeclaration, LOG.info("{} Service RPC address: {}", nnDesc, serviceAddress);
142: Inigo Goiri, info, MethodDeclaration, LOG.info("{} Lifeline RPC address: {}", nnDesc, lifelineAddress);
147: Inigo Goiri, info, MethodDeclaration, LOG.info("{} Web address: {}", nnDesc, webAddress);
215: Inigo Goiri, debug, IfStmt, LOG.debug("Reporting non-HA namenode as operational: " + getNamenodeDesc());
211: Inigo Goiri, debug, IfStmt, LOG.debug("Received service state: {} from HA namenode: {}", report.getState(), getNamenodeDesc());
208: Inigo Goiri, error, IfStmt, LOG.error("Namenode is not operational: {}", getNamenodeDesc());
227: Inigo Goiri, info, CatchClause, LOG.info("Cannot register namenode in the State Store");
229: Inigo Goiri, error, CatchClause, LOG.error("Unhandled exception updating NN registration for {}", getNamenodeDesc(), ex);
224: Inigo Goiri, warn, IfStmt, LOG.warn("Cannot register namenode {}", report);
299: Inigo Goiri, error, CatchClause, LOG.error("Cannot communicate with {}: {}", getNamenodeDesc(), e.getMessage());
303: Inigo Goiri, error, CatchClause, LOG.error("Unexpected exception while communicating with {}: {}", getNamenodeDesc(), e.getMessage(), e);
243: Inigo Goiri, debug, TryStmt, LOG.debug("Probing NN at service address: {}", serviceAddress);
273: Inigo Goiri, error, CatchClause, LOG.error("Cannot fetch safemode state for {}", getNamenodeDesc(), e);
293: Inigo Goiri, error, IfStmt, LOG.error("Cannot fetch HA status for {}: {}", getNamenodeDesc(), e.getMessage(), e);
289: Inigo Goiri, error, IfStmt, LOG.error("HA for {} is not enabled", getNamenodeDesc());
359: Inigo Goiri, error, CatchClause, LOG.error("Cannot get stat from {} using JMX", getNamenodeDesc(), e);
141: Inigo Goiri, info, MethodDeclaration, LOG.info("Starting periodic service {}", this.serviceName);
148: Inigo Goiri, info, MethodDeclaration, LOG.info("Stopping periodic service {}", this.serviceName);
157: Inigo Goiri, info, IfStmt, LOG.info("{} is shutting down", this.serviceName);
173: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Running {} update task", serviceName);
183: Inigo Goiri, warn, CatchClause, LOG.warn(serviceName + " service threw an exception", ex);
75: Yiqun Lin, debug, ForeachStmt, LOG.debug("Set quota for path: nsId: {}, dest: {}.", loc.getNameserviceId(), loc.getDest());
171: Yiqun Lin, debug, IfStmt, LOG.debug("Get quota usage for path: nsId: {}, dest: {}," + " nsCount: {}, ssCount: {}.", loc.getNameserviceId(), loc.getDest(), usage.getFileAndDirectoryCount(), usage.getSpaceConsumed());
144: Yiqun Lin, error, CatchClause, LOG.error("Cannot get method {} with types {} from {}", methodName, Arrays.toString(types), protocol.getSimpleName(), e);
148: Yiqun Lin, error, CatchClause, LOG.error("Cannot access method {} with types {} from {}", methodName, Arrays.toString(types), protocol.getSimpleName(), e);
206: Inigo Goiri, error, IfStmt, LOG.error("Heartbeat is enabled but there are no namenodes to monitor");
332: Inigo Goiri, error, CatchClause, LOG.error("Cannot set unique router ID, address not resolvable {}", this.rpcAddress);
444: Inigo Goiri, error, IfStmt, LOG.error("Wrong Namenode to monitor: {}", namenode);
471: Inigo Goiri, error, IfStmt, LOG.error("Cannot find namenode id for local {}", nsId);
488: Inigo Goiri, info, MethodDeclaration, LOG.info("Creating heartbeat service for Namenode {} in {}", nnId, nsId);
128: Inigo Goiri, info, ConstructorDeclaration, LOG.info("Admin server binding to {}:{}", bindHost, confRpcAddress.getPort());
298: Yiqun Lin, error, IfStmt, LOG.error("Cannot disable {}, it does not exists", nsId);
331: Yiqun Lin, error, IfStmt, LOG.error("Cannot enable {}, it was not disabled", nsId);
82: Yiqun Lin, error, IfStmt, LOG.error("Cannot heartbeat for router: unknown router id");
106: Yiqun Lin, warn, IfStmt, LOG.warn("Cannot heartbeat router {}: State Store unavailable", routerId);
103: Yiqun Lin, error, CatchClause, LOG.error("Cannot heartbeat router {}", routerId, e);
100: Yiqun Lin, debug, IfStmt, LOG.debug("Router heartbeat for router {}", routerId);
98: Yiqun Lin, warn, IfStmt, LOG.warn("Cannot heartbeat router {}", routerId);
135: Yiqun Lin, error, CatchClause, LOG.error("Cannot get version for {}", clazz, e);
118: Yiqun Lin, error, IfStmt, LOG.error("Cannot get the remote user name");
77: Yiqun Lin, debug, MethodDeclaration, LOG.debug("Start to update quota cache.");
115: Yiqun Lin, error, CatchClause, LOG.error("Quota cache updated error.", e);
104: Yiqun Lin, debug, IfStmt, LOG.debug("Update quota usage entity of path: {}, nsCount: {}," + " nsQuota: {}, ssCount: {}, ssQuota: {}.", src, newQuota.getFileAndDirectoryCount(), newQuota.getQuota(), newQuota.getSpaceConsumed(), newQuota.getSpaceQuota());
261: Inigo Goiri, error, CatchClause, LOG.error("Cannot open NN client to address: {}", rpcAddress, ex);
258: Inigo Goiri, debug, TryStmt, LOG.debug("User {} NN {} is using connection {}", ugi.getUserName(), rpcAddress, connection);
317: Inigo Goiri, error, CatchClause, LOG.error("Re-throwing API exception, no more retries", ex);
410: Inigo Goiri, error, MethodDeclaration, LOG.error(msg);
421: Inigo Goiri, error, IfStmt, LOG.error("{} {} at {} error: \"{}\"", nsId, nnId, addr, ioe.getMessage());
419: Inigo Goiri, error, IfStmt, LOG.error("{} {} at {} is in Standby", nsId, nnId, addr);
449: Inigo Goiri, error, CatchClause, LOG.error("Unexpected exception while proxying API", e);
452: Inigo Goiri, error, CatchClause, LOG.error("Unexpected exception while proxying API", e);
563: Inigo Goiri, error, CatchClause, LOG.error("Could not create exception {}", ioeClass.getSimpleName(), e);
1127: Yiqun Lin, error, CatchClause, LOG.error(msg);
1131: Inigo Goiri, error, CatchClause, LOG.error("Unexpected error while invoking API: {}", ex.getMessage());
1083: Inigo Goiri, error, CatchClause, LOG.error(msg);
1088: Inigo Goiri, debug, CatchClause, LOG.debug("Canot execute {} in {}: {}", m.getName(), location, cause.getMessage());
271: Inigo Goiri, info, ConstructorDeclaration, LOG.info("RPC server binding to {} with {} handlers for Router {}", confRpcAddress, handlerCount, this.router.getRouterId());
330: Inigo Goiri, error, IfStmt, LOG.error("Cannot instantiate Router RPC metrics class");
342: Inigo Goiri, info, IfStmt, LOG.info("Router RPC up at: {}", this.getRpcAddress());
448: Inigo Goiri, debug, IfStmt, LOG.debug("Proxying operation: {}", methodName);
554: Yiqun Lin, debug, IfStmt, LOG.debug("Creating {} requires creating parent {}", src, parent);
559: Yiqun Lin, error, IfStmt, LOG.error("Couldn't create parents for {}", src);
1045: Inigo Goiri, Error, CatchClause, LOG.error("Error requesting file info for path {} while proxing mkdirs", src, ioe);
1091: Inigo Goiri, debug, IfStmt, LOG.debug("Cannot get listing from {}", location);
1318: Inigo Goiri, debug, IfStmt, LOG.debug("{} is in multiple subclusters", nodeId);
1569: Inigo Goiri, error, CatchClause, LOG.error("Cannot get content summary for mount {}: {}", childPath, e.getMessage());
2309: Yiqun Lin, error, CatchClause, LOG.error("Cannot get mount point", e);
2330: Yiqun Lin, error, CatchClause, LOG.error("Cannot get mount point", e);
2352: Yiqun Lin, error, CatchClause, LOG.error("Cannot get mount point", e);
2397: Inigo Goiri, error, CatchClause, LOG.error("Cannot get mount point", e);
2423: Inigo Goiri, error, CatchClause, LOG.error("Cannot get the remote user: {}", e.getMessage());
70: Yiqun Lin, info, MethodDeclaration, LOG.info("Entering safe mode");
83: Yiqun Lin, info, MethodDeclaration, LOG.info("Leaving safe mode after {} milliseconds", timeInSafemode);
86: Yiqun Lin, error, IfStmt, LOG.error("The Router metrics are not enabled");
108: Yiqun Lin, info, MethodDeclaration, LOG.info("Leave startup safe mode after {} ms", this.startupInterval);
114: Yiqun Lin, info, MethodDeclaration, LOG.info("Enter safe mode after {} ms without reaching the State Store", this.staleInterval);
130: Yiqun Lin, info, IfStmt, LOG.info("Delaying safemode exit for {} milliseconds...", this.startupInterval - delta);
406: weiy, info, IfStmt, LOG.info("We expected a redirection from the Namenode, not {}", responseCode);
422: weiy, error, CatchClause, LOG.error("Cannot parse redirect location {}", redirectLocation);
477: weiy, error, CatchClause, LOG.error("Cannot redirect request to {}", namenode, e);
537: weiy, trace, IfStmt, LOG.trace("redirectURI={}", uri);
556: weiy, error, CatchClause, LOG.error("Cannot get the datanodes from the RPC server", e);
127: Inigo Goiri, error, CatchClause, LOG.error("Cannot get \"{}\" records from the State Store", getRecordClass().getSimpleName());
177: Inigo Goiri, error, IfStmt, LOG.error("Cannot check overrides for record");
183: Inigo Goiri, info, IfStmt, LOG.info("Override State Store record {}: {}", recordName, record);
96: Inigo, error, CatchClause, LOG.error("Cannot create new instance for " + clazz, e);
67: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Updating State Store cache");
61: Inigo Goiri, debug, MethodDeclaration, LOG.debug("Checking state store connection");
63: Inigo Goiri, info, IfStmt, LOG.info("Attempting to open state store driver.");
189: Yiqun Lin, error, CatchClause, LOG.error("Failed to register State Store bean {}", e.getMessage());
185: Inigo Goiri, info, TryStmt, LOG.info("Registered StateStoreMBean: {}", registeredObject);
279: Inigo Goiri, error, IfStmt, LOG.error("Cannot initialize State Store driver {}", driverName);
275: Inigo Goiri, info, IfStmt, LOG.info("Connection to the State Store driver {} is open and ready", driverName);
404: Inigo Goiri, info, IfStmt, LOG.info("Skipping State Store cache update, driver is not ready.");
394: Inigo Goiri, Error, CatchClause, LOG.error("Error updating cache for {}", cacheName, e);
399: Inigo Goiri, error, IfStmt, LOG.error("Cache update failed for cache {}", cacheName);
60: Inigo Goiri, error, IfStmt, LOG.error("We went too far ({}) with {}", actualClazz, clazz);
71: Inigo, warn, IfStmt, LOG.warn("The identifier for the State Store connection is not set");
76: Arpit Agarwal, error, IfStmt, LOG.error("Cannot initialize driver for {}", getDriverName());
83: Inigo Goiri, error, IfStmt, LOG.error("Cannot initialize record store for {}", cls.getSimpleName());
199: Inigo, error, CatchClause, LOG.error("Cannot get local address", e);
165: Inigo Goiri, error, CatchClause, LOG.error("Cannot initialize filesystem using root directory {}", rootDir, ex);
153: Inigo Goiri, error, IfStmt, LOG.error("Invalid root directory, unable to initialize driver.");
160: Inigo Goiri, error, IfStmt, LOG.error("Cannot create State Store root directory {}", rootDir);
188: Inigo Goiri, error, CatchClause, LOG.error("Cannot create data directory {}", dataDirPath, ex);
181: Inigo Goiri, info, IfStmt, LOG.info("{} data directory doesn't exist, creating it", dataDirPath);
183: Inigo Goiri, error, IfStmt, LOG.error("Cannot create data directory {}", dataDirPath);
222: Yiqun Lin, error, CatchClause, LOG.error(msg, e);
207: Yiqun Lin, debug, IfStmt, LOG.debug("There is a temporary file {} in {}", child, path);
209: Yiqun Lin, warn, IfStmt, LOG.warn("Removing {} as it's an old temporary record", child);
271: Yiqun Lin, error, CatchClause, LOG.error("Cannot parse line {} in file {}", line, path, ex);
339: Yiqun Lin, debug, IfStmt, LOG.debug("Not updating {}", record);
332: Inigo Goiri, error, IfStmt, LOG.error("Attempt to insert record {} that already exists", recordPath);
357: Yiqun Lin, error, CatchClause, LOG.error("Cannot write {}", recordPathTemp, e);
364: Yiqun Lin, error, CatchClause, LOG.error("Cannot close the writer for {}", recordPathTemp, e);
370: Yiqun Lin, error, IfStmt, LOG.error("Failed committing record into {}", recordPath);
423: Inigo Goiri, error, CatchClause, LOG.error("Cannot remove records {} query {}", clazz, query, e);
412: Yiqun Lin, error, IfStmt, LOG.error("Cannot remove record {}", recordToRemovePath);
417: Yiqun Lin, error, IfStmt, LOG.error("Cannot remove records {} query {}", clazz, query);
75: Yiqun Lin, error, CatchClause, LOG.error("Cannot rename {} to {}", src, dst, e);
93: Yiqun Lin, warn, IfStmt, LOG.warn("The root directory is not available, using {}", dir);
111: Yiqun Lin, error, CatchClause, LOG.error("Cannot open read stream for record {}", filename, ex);
104: Inigo Goiri, debug, TryStmt, LOG.debug("Loading file: {}", filename);
127: Yiqun Lin, error, CatchClause, LOG.error("Cannot open write stream for record {}", filename, e);
120: Yiqun Lin, debug, TryStmt, LOG.debug("Writing file: {}", filename);
96: Yiqun Lin, error, CatchClause, LOG.error("Cannot rename {} to {}", src, dst, e);
106: Yiqun Lin, error, CatchClause, LOG.error("Cannot remove {}", path, e);
144: Yiqun Lin, error, CatchClause, LOG.error("Cannot open read stream for {}", path);
159: Yiqun Lin, error, CatchClause, LOG.error("Cannot open write stream for {}", path);
176: Yiqun Lin, error, CatchClause, LOG.error("Cannot get children for {}", pathName, e);
77: Inigo Goiri, info, MethodDeclaration, LOG.info("Initializing ZooKeeper connection");
87: Inigo Goiri, error, CatchClause, LOG.error("Cannot initialize the ZK connection", e);
101: Inigo Goiri, error, CatchClause, LOG.error("Cannot initialize ZK node for {}: {}", className, e.getMessage());
168: Inigo Goiri, error, CatchClause, LOG.error(msg);
161: Inigo Goiri, error, CatchClause, LOG.error("Cannot get data for {}: {}", child, e.getMessage());
149: Inigo Goiri, error, CatchClause, LOG.error("Cannot create record type \"{}\" from \"{}\": {}", clazz.getSimpleName(), data, e.getMessage());
156: Inigo Goiri, error, IfStmt, LOG.error("Cannot get data for {} at {}, cleaning corrupted data", child, path);
223: Inigo Goiri, error, CatchClause, LOG.error("Cannot get existing records", ex);
235: Inigo Goiri, info, ForeachStmt, LOG.info("Removing \"{}\"", existingRecord);
245: Inigo Goiri, error, CatchClause, LOG.error("Cannot remove \"{}\"", existingRecord, e);
242: Inigo Goiri, error, IfStmt, LOG.error("Did not remove \"{}\"", existingRecord);
262: Inigo Goiri, info, MethodDeclaration, LOG.info("Deleting all children under {}", znode);
271: Inigo Goiri, error, CatchClause, LOG.error("Cannot remove {}: {}", znode, e.getMessage());
267: Inigo Goiri, info, ForeachStmt, LOG.info("Deleting {}", path);
296: Inigo Goiri, error, CatchClause, LOG.error("Cannot write record \"{}\": {}", znode, e.getMessage());
288: Inigo Goiri, info, IfStmt, LOG.info("Cannot write record \"{}\", it already exists", znode);
176: Inigo Goiri, info, IfStmt, LOG.info("Inserting new NN registration: {}", record);
173: Inigo Goiri, debug, IfStmt, LOG.debug("Updating NN registration: {} -> {}", existingEntry, record);
170: Inigo Goiri, info, IfStmt, LOG.info("NN registration state has changed: {} -> {}", existingEntry, record);
233: Inigo Goiri, debug, TryStmt, LOG.debug("Refreshed {} NN registrations from State Store", cachedRecords.size());
304: Inigo Goiri, debug, IfStmt, LOG.debug("Quorum failed, using most recent: {}", sortedList.first());
259: Inigo Goiri, debug, IfStmt, LOG.debug("Exception encountered", debugException);
120: weiy, error, CatchClause, LOG.error("Cannot create URI for the WebHDFS filesystem", e);
308: Yiqun Lin, info, MethodDeclaration, LOG.info("Simulating slow namenode {}", invocation.getMock());
312: Yiqun Lin, error, CatchClause, LOG.error("Simulating a slow namenode aborted");
225: Inigo Goiri, info, MethodDeclaration, LOG.info("Connecting to router at {}", fileSystemUri);
237: Inigo Goiri, info, IfStmt, LOG.info("Connecting to router admin at {}", routerSocket);
249: Inigo Goiri, info, IfStmt, LOG.info("Connecting to router at {}", fileSystemUri);
346: Inigo Goiri, info, MethodDeclaration, LOG.info("Connecting to namenode at {}", fileSystemUri);
357: Inigo Goiri, info, IfStmt, LOG.info("Connecting to namenode at {}", fileSystemUri);
736: Inigo Goiri, error, CatchClause, LOG.error("Cannot start Router DFS cluster: {}", e.getMessage(), e);
827: Inigo Goiri, info, MethodDeclaration, LOG.info("Waiting for NN {} {} to transition to {}", nsId, nnId, state);
931: Inigo Goiri, error, CatchClause, LOG.error("Cannot transition to active", e);
952: Inigo Goiri, error, CatchClause, LOG.error("Cannot transition to standby", e);
983: Inigo Goiri, error, IfStmt, LOG.error("Cannot shutdown router {}", router.rpcPort);
399: Inigo Goiri, info, IfStmt, LOG.info("Adding flat mount record {}: {}", i, record);
219: Yiqun Lin, error, CatchClause, LOG.error("Cannot close the client");
553: Inigo Goiri, error, CatchClause, LOG.error("Cannot get stats: {}", e.getMessage());
546: Inigo Goiri, error, IfStmt, LOG.error("Stats for {} don't match: {} != {}", i, combinedData[i], individualData[i]);
1093: Inigo Goiri, info, MethodDeclaration, LOG.info("List the available erasurce coding policies");
1096: Inigo Goiri, info, ForeachStmt, LOG.info("  {}", policy);
1099: Inigo Goiri, info, MethodDeclaration, LOG.info("List the erasure coding codecs");
1104: Inigo Goiri, info, ForeachStmt, LOG.info("  {}: {}", entry.getKey(), entry.getValue());
1107: Inigo Goiri, info, MethodDeclaration, LOG.info("Create a testing directory via the router at the root level");
1116: Inigo Goiri, info, MethodDeclaration, LOG.info("The policy for the new file should not be set");
1121: Inigo Goiri, info, MethodDeclaration, LOG.info("Set policy \"{}\" for \"{}\"", policyName, dirPath);
1125: Inigo Goiri, info, MethodDeclaration, LOG.info("Create {} in the path with the new EC policy", filePath2);
1130: Inigo Goiri, info, MethodDeclaration, LOG.info("Check that the policy is set for {}", filePath2);
1139: Inigo Goiri, info, MethodDeclaration, LOG.info("Create a new erasure coding policy");
1156: Inigo Goiri, info, MethodDeclaration, LOG.info("The new policy should be there and disabled");
1160: Inigo Goiri, info, ForeachStmt, LOG.info("  {}" + policy);
1169: Inigo Goiri, info, MethodDeclaration, LOG.info("Set the test folder to use the new policy");
1173: Inigo Goiri, info, MethodDeclaration, LOG.info("Create a file in the path with the new EC policy");
1186: Inigo Goiri, info, MethodDeclaration, LOG.info("Remove the policy and check the one for the test folder");
1195: Inigo Goiri, info, MethodDeclaration, LOG.info("Check the stats");
1269: Inigo Goiri, info, ForeachStmt, LOG.info("Checking {} for {}", nsId, path);
506: Inigo Goiri, error, CatchClause, LOG.error("Cannot set field " + fieldName + " on object " + record.getClass().getName() + " to data " + data + " of type " + data.getClass(), e);
546: Inigo Goiri, error, CatchClause, LOG.error("Cannot execute getter " + m.getName() + " on object " + record);
578: Inigo Goiri, error, CatchClause, LOG.error("Cannot get field " + fieldName + " on object " + record);
117: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Local filesystem " + curDir.toURI().toString() + " is unsupported?? (should never happen)");
164: Gera Shegalov, info, IfStmt, LOG.info("Context classloader of thread " + eventHandler.getName() + ": " + eventHandler.getContextClassLoader());
159: Gera Shegalov, info, IfStmt, LOG.info("Setting " + jobClassLoader + " as the context classloader of thread " + eventHandler.getName());
246: Jason Lowe, warn, CatchClause, LOG.warn("Returning, interrupted : " + e);
250: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Processing the event " + event.toString());
310: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Ignoring unexpected event " + event.toString());
308: Jason Lowe, debug, IfStmt, LOG.debug("Container completed " + event.toString());
297: Jason Darrell Lowe, info, IfStmt, LOG.info("canceling the task attempt " + taId);
386: Jason Darrell Lowe, info, IfStmt, LOG.info("removed attempt " + attemptID + " from the futures to keep track of");
481: Akira Ajisaka, Error, CatchClause, LOG.error("FSError from child", e);
489: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exception running local (uberized) 'child' : " + StringUtils.stringifyException(exception));
497: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Exception cleaning up: " + StringUtils.stringifyException(e));
506: Akira Ajisaka, Error, CatchClause, LOG.error("Error running local (uberized) 'child' : " + StringUtils.stringifyException(throwable));
415: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info(MRConfig.LOCAL_DIR + " for uber task: " + conf.get(MRConfig.LOCAL_DIR));
434: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("CONTAINER_REMOTE_LAUNCH contains a map task (" + attemptID + "), but should be finished with maps");
545: Akira Ajisaka, warn, IfStmt, LOG.warn("Unable to delete unexpected local file/dir " + curLocalFiles[j].getName() + ": insufficient permissions?");
578: Karthik Kambatla, debug, IfStmt, LOG.debug("Renaming map output file for task attempt " + mapId.toString() + " from original location " + mapOut.toString() + " to destination " + reduceIn.toString());
206: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Commit go/no-go request from " + taskAttemptID.toString());
241: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Commit-pending state update from " + taskAttemptID.toString());
258: Christopher Douglas, info, MethodDeclaration, LOG.info("Preempted state update from " + taskAttemptID.toString());
273: Naganarasimha, info, MethodDeclaration, LOG.info("Done acknowledgment from " + taskAttemptID.toString());
288: Akira Ajisaka, error, MethodDeclaration, LOG.error("Task: " + taskAttemptID + " - exited : " + msg);
305: Akira Ajisaka, error, MethodDeclaration, LOG.error("Task: " + taskAttemptID + " - failed due to FSError: " + message);
328: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("MapCompletionEvents request from " + taskAttemptID.toString() + ". startIndex " + startIndex + " maxEvents " + maxEvents);
348: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Diagnostics report from " + taskAttemptID.toString() + ": " + diagnosticInfo);
382: Eric Payne, error, IfStmt, LOG.error("Status update was called with illegal TaskAttemptId: " + yarnAttemptID);
393: Christopher Douglas, info, IfStmt, LOG.info("Setting preemption bit for task: " + yarnAttemptID + " of type " + yarnAttemptID.getTaskId().getTaskType());
400: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Ping from " + taskAttemptID.toString());
413: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Progress of TaskAttempt " + taskAttemptID + " is : " + taskStatus.getProgress());
491: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("JVM with ID : " + jvmId + " asked for a task");
519: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("JVM with ID: " + jvmId + " given task: " + task.getTaskID());
510: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("JVM with ID: " + jvmId + " asking for task before AM launch registered. Given null task");
505: Siddharth Seth, info, IfStmt, LOG.info("JVM with ID: " + jvmId + " is invalid and will be killed.");
620: Jason Lowe, info, IfStmt, LOG.info("TaskAttempt " + yarnAttemptID + ": lastStatusRef changed by another thread, retrying...");
75: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("Child starting");
103: Akira Ajisaka, info, MethodDeclaration, LOG.info("Executing with tokens: {}", credentials.getAllTokens());
122: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("PID: " + System.getenv().get("JVM_PID"));
179: Akira Ajisaka, Error, CatchClause, LOG.error("FSError from child", e);
184: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exception running child : " + StringUtils.stringifyException(exception));
203: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Exception cleaning up: " + StringUtils.stringifyException(e));
213: Akira Ajisaka, Error, CatchClause, LOG.error("Error running child : " + StringUtils.stringifyException(throwable));
133: Vinod Kumar Vavilapalli, info, ForStmt, LOG.info("Sleeping for " + sleepTimeMilliSecs + "ms before retrying again. Got null now.");
151: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(systemPropsToLog);
257: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(MRConfig.LOCAL_DIR + " for child: " + job.get(MRConfig.LOCAL_DIR));
297: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("APPLICATION_ATTEMPT_ID: " + appAttemptId);
311: Robert Joseph Evans, warn, IfStmt, LOG.warn("Shuffle secret missing from task credentials." + " Using job token secret as shuffle secret.");
90: Robert Joseph Evans, error, CatchClause, LOG.warn("error trying to open previous history file. No history data " + "will be copied over.", e);
98: Robert Joseph Evans, info, IfStmt, LOG.info("Got an error parsing job-history file" + ", ignoring incomplete events.", parseException);
120: Robert Joseph Evans, info, MethodDeclaration, LOG.info("History file is at " + historyFile);
178: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Failed while getting the configured log directories", e);
190: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Failed while checking for/creating  history staging path: [" + stagingDirPath + "]", e);
230: Arun Murthy, error, CatchClause, LOG.error("Failed checking for the existance of history intermediate " + "done directory: [" + doneDirPath + "]");
225: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(message);
205: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Creating intermediate history logDir: [" + doneDirPath + "] + based on conf. Should ideally be created by the JobHistoryServer: " + MRJobConfig.MR_AM_CREATE_JH_INTERMEDIATE_BASE_DIR);
242: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error creating user intermediate history done directory: [ " + doneDirPrefixPath + "]", e);
294: Li Lu, info, IfStmt, LOG.info("Emitting job history data to the timeline server is not " + "enabled");
274: Li Lu, info, IfStmt, LOG.info("Emitting job history data to the timeline service is enabled");
291: Jonathan Eagles, info, IfStmt, LOG.info("Timeline service is not enabled");
288: Li Lu, info, IfStmt, LOG.info("Timeline service is enabled; version: " + YarnConfiguration.getTimelineServiceVersion(conf));
306: Jason Lowe, warn, IfStmt, LOG.warn("Unrecognized value '" + jhistFormat + "' for property " + JHAdminConfig.MR_HS_JHIST_FORMAT + ".  Valid values are " + "'json' or 'binary'.  Falling back to default value '" + JHAdminConfig.DEFAULT_MR_HS_JHIST_FORMAT + "'.");
342: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Directory: [" + path + "] already exists.");
334: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Perms after creating " + fsStatus.getPermission().toShort() + ", Expected: " + fsp.toShort());
337: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Explicitly setting permissions to : " + fsp.toShort() + ", " + fsp);
363: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Size of the JobHistory event queue is " + eventQueue.size());
372: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("EventQueue take interrupted. Returning");
385: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Event handling interrupted");
402: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Stopping JobHistoryEventHandler. " + "Size of the outstanding queue size is " + eventQueue.size());
411: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Null event handling thread");
408: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Interrupting Event Handling thread");
421: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Interrupted Exception while stopping", ie);
417: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Waiting for Event Handling thread to complete");
433: Naganarasimha, info, CatchClause, LOG.info("Exception while canceling delayed flush timer. " + "Likely caused by a failed flush " + e.getMessage());
429: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Shutting down timer for " + mi);
442: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("In stop, writing event " + ev.getType());
453: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Found jobId " + toClose + " to have not been closed. Will close");
484: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Exception while closing file " + e.getMessage());
497: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Stopped JobHistoryEventHandler. super.stop()");
519: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Log Directory is null, returning");
547: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Could not create log file: [" + historyFile + "] + for job " + "[" + jobName + "]");
544: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Event Writer setup for JobId: " + jobId + ", File: " + historyFile);
563: Jason Lowe, info, CatchClause, LOG.info("Failed to write the job configuration file", e);
596: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error closing writer for JobID: " + id);
639: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error JobHistoryEventHandler in handleEvent: " + event, ioe);
662: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error writing History Event: " + event.getHistoryEvent(), e);
658: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("In HistoryEventHandler " + event.getHistoryEvent().getEventType());
750: Sunil G, debug, IfStmt, LOG.debug("In HistoryEventHandler, handle timelineEvent:" + event.getHistoryEvent().getEventType());
1145: Zhijie Shen, Error, CatchClause, LOG.error("Error putting entity " + tEntity.getEntityId() + " to Timeline" + "Server", ex);
1138: Jian He, Error, ForeachStmt, LOG.error("Error when publishing entity [" + error.getEntityType() + "," + error.getEntityId() + "], server side error code: " + error.getErrorCode());
1133: Jian He, debug, IfStmt, LOG.debug("Timeline entities are successfully put in event " + event.getEventType());
1270: Sangjin Lee, error, CatchClause, LOG.error("Exception while publishing configs on JOB_SUBMITTED Event " + " for the job : " + jobId, e);
1373: Sangjin Lee, warn, SwitchStmt, LOG.warn("EventType: " + event.getEventType() + " cannot be recognized" + " and handled by timeline service.");
1408: Sangjin Lee, error, CatchClause, LOG.error("Failed to process Event " + event.getEventType() + " for the job : " + jobId, e);
1450: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error closing writer for JobID: " + jobId);
1463: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("No file for job-history with " + jobId + " found in cache!");
1466: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("No file for jobconf with " + jobId + " found in cache!");
1486: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Unable to write out JobSummaryInfo to [" + qualifiedSummaryDoneFile + "]", e);
1534: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error closing writer for JobID: " + jobId);
1511: Jason Lowe, info, IfStmt, LOG.info("Set historyUrl to " + historyUrl);
1550: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("In flush timer task");
1631: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("Closing Writer");
1641: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("Writing event");
1693: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Flushing " + toString());
1706: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Shutting down timer " + toString());
1724: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Moved tmp to done: " + tmpPath + " to " + path);
1735: Robert Joseph Evans, info, IfStmt, LOG.info("Copying " + fromPath.toString() + " to " + toPath.toString());
1748: Jason Lowe, info, IfStmt, LOG.info("Copy failed from: " + fromPath.toString() + " to done location: " + toPath.toString());
1744: Jason Lowe, info, IfStmt, LOG.info("Copied from: " + fromPath.toString() + " to done location: " + toPath.toString());
1766: Thomas Graves, info, MethodDeclaration, LOG.info("JobHistoryEventHandler notified that forceJobCompletion is " + forceJobCompletion);
108: Robert Kanter, warn, CatchClause, Log.getLog().warn("Job end notification couldn't parse configured" + "proxy's port " + portConf + ". Not going to use a proxy");
104: Robert Kanter, info, TryStmt, Log.getLog().info("Job end notification using proxy type \"" + proxyType + "\" hostname \"" + hostname + "\" and port \"" + port + "\"");
142: Robert Kanter, warn, CatchClause, Log.getLog().warn("Job end notification to " + urlToNotify + " failed", ioe);
125: Robert Kanter, info, TryStmt, Log.getLog().info("Job end notification trying " + urlToNotify);
138: Robert Kanter, info, IfStmt, Log.getLog().info("Job end notification to " + urlToNotify + " succeeded");
132: Robert Kanter, warn, IfStmt, Log.getLog().warn("Job end notification to " + urlToNotify + " failed with code: " + conn.getResponseCode() + " and message \"" + conn.getResponseMessage() + "\"");
169: Robert Kanter, warn, CatchClause, Log.getLog().warn("Job end notification couldn't parse " + userUrl, mue);
176: Robert Kanter, info, WhileStmt, Log.getLog().info("Job end notification attempts left " + numTries);
186: Robert Kanter, info, IfStmt, Log.getLog().info("Job end notification succeeded for " + jobReport.getJobId());
183: Robert Kanter, warn, IfStmt, Log.getLog().warn("Job end notification failed to notify : " + urlToNotify);
270: Arun Murthy, info, ConstructorDeclaration, LOG.info("Created MRAppMaster for application " + applicationAttemptId);
307: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Using mapred newApiCommitter.");
338: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Attempt num: " + appAttemptID.getAttemptId() + " is last retry: " + isLastAMRetry + " because a commit was started.");
326: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Attempt num: " + appAttemptID.getAttemptId() + " is last retry: " + isLastAMRetry + " because the staging dir doesn't exist.");
332: Akira Ajisaka, error, IfStmt, LOG.error(shutDownMessage);
528: Jian He, info, MethodDeclaration, LOG.info("Delete startJobCommitFile in case commit is not finished as " + "successful or failed.");
538: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("OutputCommitter set in config " + conf.get("mapred.output.committer.class"));
561: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("OutputCommitter is " + committer.getClass().getName());
632: Arun Murthy, error, CatchClause, LOG.error("Failed to cleanup staging dir " + jobTempDir, io);
623: Arun Murthy, warn, IfStmt, LOG.warn("Job Staging directory is null");
627: Mahadev Konar, info, IfStmt, LOG.info("Deleting staging directory " + FileSystem.getDefaultUri(getConfig()) + " " + jobTempDir);
684: Devaraj K, warn, CatchClause, LOG.warn("Graceful stop failed. Exiting.. ", t);
660: Gera Shegalov, info, IfStmt, LOG.info("Job finished cleanly, recording last MRAppMaster retry");
707: Junping Du, warn, CatchClause, LOG.warn("Job end notification interrupted for jobID : " + job.getReport().getJobId(), ie);
696: Junping Du, info, TryStmt, LOG.info("Job end notification started for jobID : " + job.getReport().getJobId());
841: Jason Darrell Lowe, error, CatchClause, LOG.error("Can't make a speculator -- check " + MRJobConfig.MR_AM_JOB_SPECULATOR, ex);
845: Jason Darrell Lowe, error, CatchClause, LOG.error("Can't make a speculator -- check " + MRJobConfig.MR_AM_JOB_SPECULATOR, ex);
849: Jason Darrell Lowe, error, CatchClause, LOG.error("Can't make a speculator -- check " + MRJobConfig.MR_AM_JOB_SPECULATOR, ex);
853: Jason Darrell Lowe, error, CatchClause, LOG.error("Can't make a speculator -- check " + MRJobConfig.MR_AM_JOB_SPECULATOR, ex);
1069: Siddharth Seth, error, CatchClause, LOG.error("Failed to cleanup staging dir: ", io);
1065: Thomas Graves, info, IfStmt, LOG.info("Skipping cleaning up the staging dir. " + "assuming AM will be retried.");
1285: Robert Joseph Evans, info, IfStmt, LOG.info("MRAppMaster launching normal, non-uberized, multi-container " + "job " + job.getID() + ".");
1277: Robert Joseph Evans, info, IfStmt, LOG.info("MRAppMaster uberizing job " + job.getID() + " in local container (\"uber-AM\") on node " + nmHost + ":" + nmPort + ".");
1331: Karthik Kambatla, info, IfStmt, LOG.info("Attempting to recover.");
1335: Karthik Kambatla, warn, CatchClause, LOG.warn("Unable to parse prior job history, aborting recovery", e);
1362: Karthik Kambatla, info, IfStmt, LOG.info("Not attempting to recover. Recovery disabled. To enable " + "recovery, set " + MRJobConfig.MR_AM_JOB_RECOVERY_ENABLE);
1369: Karthik Kambatla, info, IfStmt, LOG.info("Not attempting to recover. Recovery is not supported by " + committer.getClass() + ". Use an OutputCommitter that supports" + " recovery.");
1383: Karthik Kambatla, info, IfStmt, LOG.info("Not attempting to recover. The shuffle key is invalid for " + "recovery.");
1393: Karthik Kambatla, info, IfStmt, LOG.info("Not attempting to recover. Intermediate spill encryption" + " is enabled.");
1410: Haibo Chen, info, CatchClause, LOG.info("Previous job temporary files do not exist, " + "no clean up was necessary.");
1406: Haibo Chen, info, TryStmt, LOG.info("Starting to clean up previous job's temporary files");
1408: Haibo Chen, info, TryStmt, LOG.info("Finished cleaning up previous job temporary files");
1426: Siddharth Seth, info, MethodDeclaration, LOG.info("Previous history file is at " + historyFile);
1437: Siddharth Seth, info, IfStmt, LOG.info("Got an error parsing job-history file" + ", ignoring incomplete events.", parseException);
1454: Siddharth Seth, info, IfStmt, LOG.info("Read from history task " + TypeConverter.toYarn(taskInfo.getTaskId()));
1458: Siddharth Seth, info, MethodDeclaration, LOG.info("Read completed tasks from history " + completedTasksFromPreviousRun.size());
1508: Jason Darrell Lowe, warn, CatchClause, LOG.warn("Could not parse the old history file. " + "Will not have old AMinfos ", e);
1635: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(msg);
1693: Akira Ajisaka, Error, CatchClause, LOG.error("Error starting MRAppMaster", t);
1685: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(systemPropsToLog);
1706: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("MRAppMaster received a signal. Signaling RMCommunicator and " + "JobHistoryEventHandler.");
1722: Jason Darrell Lowe, info, IfStmt, LOG.info("Notify RMCommunicator isAMLastRetry: " + isLastAMRetry);
1727: Jason Darrell Lowe, info, IfStmt, LOG.info("Notify JHEH isAMLastRetry: " + isLastAMRetry);
1742: Akira Ajisaka, info, MethodDeclaration, LOG.info("Executing with tokens: {}", credentials.getAllTokens());
108: Karthik Kambatla, info, IfStmt, LOG.info("Task timeout must be as least twice as long as the task " + "status report interval. Setting task timeout to " + taskTimeOut);
168: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("TaskHeartbeatHandler thread interrupted");
137: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Instantiated MRClientService at " + this.bindAddress);
149: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Webapps failed to start. Ignoring for now:", e);
299: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(message);
318: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(message);
336: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(message);
369: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(message);
394: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Getting task report for " + taskType + "   " + jobId + ". Report-size will be " + tasks.size());
148: Robert Joseph Evans, error, IfStmt, LOG.error("Returning, interrupted : " + e);
206: Chris Douglas, info, IfStmt, LOG.info("Cancelling commit");
232: Robert Joseph Evans, info, MethodDeclaration, LOG.info("Processing the event " + event.toString());
259: Robert Joseph Evans, warn, CatchClause, LOG.warn("Job setup failed", e);
279: Jian He, warn, CatchClause, LOG.warn("Exception in committer.isCommitJobRepeatable():", e);
291: Jian He, error, CatchClause, LOG.error("Could not commit job", e);
295: Robert Joseph Evans, error, CatchClause, LOG.error("could not create failure file.", e2);
312: Robert Joseph Evans, warn, CatchClause, LOG.warn("Could not abort job", e);
324: Robert Joseph Evans, warn, CatchClause, LOG.warn("Task cleanup failed for attempt " + event.getAttemptID(), e);
1003: Robert Joseph Evans, debug, IfStmt, LOG.debug("Processing " + event.getJobId() + " of type " + event.getType());
1012: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Can't handle this event at current state", e);
1020: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(jobId + "Job Transitioned from " + oldState + " to " + getInternalState());
1104: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Calling handler for JobFinishedEvent ");
1310: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(msg.toString());
1275: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Uberizing job " + jobId + ": " + numMapTasks + "m+" + numReduceTasks + "r tasks (" + dataInputLength + " input bytes) will run sequentially on single node.");
1359: Karthik Kambatla, info, IfStmt, LOG.info(mesg + ". AttemptId:" + id);
1518: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Job init failed", e);
1535: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("startJobs: parent=" + path + " child=" + oldJobIDString);
1554: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Adding job token for " + oldJobIDString + " to jobTokenSecretManager");
1560: Robert Joseph Evans, warn, IfStmt, LOG.warn("Shuffle secret key missing from job credentials." + " Using job token secret as shuffle secret.");
1582: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Input size for job " + job.jobId + " = " + inputLength + ". Number of splits = " + splits.length);
1599: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Number of reduces for job " + job.jobId + " = " + job.numReduceTasks);
1752: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Timeout expired in FAIL_WAIT waiting for tasks to get killed." + " Going to fail job anyway");
1962: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Too many fetch-failures for output of task attempt: " + mapId + " ... raising fetch failure to map");
1979: Haibo Chen, info, MethodDeclaration, LOG.info("Num completed Tasks: " + job.completedTaskCount);
2004: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Sending event " + toSend + " to " + job.getID());
2024: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(diagnosticMsg);
2103: Haibo Chen, info, IfStmt, LOG.info("Killing map task " + task.getID());
740: Daniel Templeton, warn, IfStmt, LOG.warn("Configuration " + resourceTypePrefix + MRJobConfig.RESOURCE_TYPE_NAME_VCORE + "=" + resourceRequest.getValue() + resourceRequest.getUnits() + " is overriding the " + cpuKey + "=" + conf.get(cpuKey) + " configuration");
727: Daniel Templeton, warn, IfStmt, LOG.warn("Configuration " + resourceTypePrefix + resourceName + "=" + resourceRequest.getValue() + resourceRequest.getUnits() + " is overriding the " + memoryKey + "=" + conf.get(memoryKey) + " configuration");
821: Daniel Templeton, info, SwitchStmt, LOG.info("TaskType " + taskType + " does not support custom resource types - this support can be " + "added in " + getClass().getSimpleName());
988: Akira Ajisaka, info, IfStmt, LOG.info("The job-jar file on the remote FS is " + remoteJobJar.toUri().toASCIIString());
1014: Akira Ajisaka, info, MethodDeclaration, LOG.info("The job-conf file on the remote FS is " + remoteJobConfPath.toUri().toASCIIString());
1022: Akira Ajisaka, info, MethodDeclaration, LOG.info("Adding #" + credentials.numberOfTokens() + " tokens and #" + credentials.numberOfSecretKeys() + " secret keys for NM use for launching container");
1032: Akira Ajisaka, info, MethodDeclaration, LOG.info("Size of containertokens_dob is " + taskCredentials.numberOfTokens());
1045: Akira Ajisaka, warn, IfStmt, LOG.warn("Cannot locate shuffle secret in credentials." + " Using job token as shuffle secret.");
1073: Akira Ajisaka, info, IfStmt, LOG.info("Adding ShuffleProvider Service: " + shuffleProvider + " to serviceData");
1358: Arun Murthy, debug, IfStmt, LOG.debug("Processing " + event.getTaskAttemptID() + " of type " + event.getType());
1367: Arun Murthy, error, CatchClause, LOG.error("Can't handle this event at current state for " + this.attemptId, e);
1383: Wangda Tan, info, IfStmt, LOG.info(attemptId + " TaskAttempt Transitioned from " + oldState + " to " + getInternalState());
1379: Wangda Tan, info, IfStmt, LOG.info(attemptId + " transitioned from state " + oldState + " to " + getInternalState() + ", event type is " + event.getType() + " and nodeId=" + nodeId);
1469: Siddharth Seth, error, CatchClause, LOG.error("Unable to recover task attempt " + attemptId, e);
1470: Siddharth Seth, info, CatchClause, LOG.info("Task attempt " + attemptId + " will be recovered as KILLED");
1467: Siddharth Seth, info, TryStmt, LOG.info("Recovered output from task attempt " + attemptId);
1497: Siddharth Seth, warn, IfStmt, LOG.warn("TaskAttempt " + attemptId + " found in unexpected state " + recoveredState + ", recovering as KILLED");
1494: Siddharth Seth, info, IfStmt, LOG.info("TaskAttempt" + attemptId + " had not completed, recovering as KILLED");
1519: Siddharth Seth, warn, CatchClause, LOG.warn("Task cleanup failed for attempt " + attemptId, e);
1722: Siddharth Seth, info, MethodDeclaration, LOG.info("TaskAttempt: [" + attemptId + "] using containerId: [" + container.getId() + " on NM: [" + StringInterner.weakIntern(container.getNodeId().toString()) + "]");
1847: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Failed to resolve address: " + src + ". Continuing to use the same.");
1947: Eli Collins, error, SwitchStmt, LOG.error("Task final state is not FAILED or KILLED: " + finalState);
2171: Robert Joseph Evans, debug, IfStmt, LOG.debug("Not generating HistoryFinish event since start event not " + "generated for taskAttempt: " + taskAttempt.getID());
2328: Jason Lowe, warn, MethodDeclaration, LOG.warn(msg);
2497: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Diagnostics report from " + taskAttempt.attemptId + ": " + diagEvent.getDiagnosticInfo());
575: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Result of canCommit for " + taskAttemptID + ":" + canCommit);
623: Arun Murthy, debug, IfStmt, LOG.debug("Created attempt " + attempt.getID());
651: Arun Murthy, debug, IfStmt, LOG.debug("Processing " + event.getTaskID() + " of type " + event.getType());
660: Arun Murthy, error, CatchClause, LOG.error("Can't handle this event at current state for " + this.taskId, e);
665: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(taskId + " Task Transitioned from " + oldState + " to " + getInternalState());
675: Vinod Kumar Vavilapalli, error, MethodDeclaration, LOG.error("Invalid event " + type + " on Task " + this.taskId);
759: Siddharth Seth, info, MethodDeclaration, LOG.info("Task succeeded with attempt " + successfulAttempt);
786: Siddharth Seth, info, MethodDeclaration, LOG.info("Recovering task " + taskId + " from prior app attempt, status was " + taskInfo.getTaskStatus());
852: Siddharth Seth, info, IfStmt, LOG.info("Missing successful attempt for task " + taskId + ", recovering as RUNNING");
916: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Scheduling a redundant attempt for task " + task.taskId);
931: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(attemptID + " given a go for committing the task output.");
963: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Issuing kill to other attempt " + attempt.getID());
1027: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Not generating HistoryFinish event since start event not" + " generated for task: " + task.getID());
1113: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Not generating HistoryFinish event since start event not" + " generated for task: " + task.getID());
1146: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Unexpected event for REDUCE task " + event.getType());
1191: Siddharth Seth, error, IfStmt, LOG.error("Unexpected event for REDUCE task " + event.getType());
1243: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Not generating HistoryFinish event since start event not" + " generated for task: " + task.getID());
135: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Launching " + taskAttemptID);
172: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Shuffle port returned by ContainerManager for " + taskAttemptID + " : " + port);
208: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("KILLING " + taskAttemptID);
241: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn(message);
267: Siddharth Seth, info, MethodDeclaration, LOG.info("Upper limit on the thread pool size is " + this.limitOnPoolSize);
272: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("The thread pool initial size is " + this.initialPoolSize);
299: Jason Darrell Lowe, error, IfStmt, LOG.error("Returning, interrupted : " + e);
322: Siddharth Seth, info, IfStmt, LOG.info("Setting ContainerLauncher pool size to " + newPoolSize + " as number-of-nodes to talk to is " + numNodes);
382: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Processing the event " + event.toString());
413: Arun Murthy, error, MethodDeclaration, LOG.error(message);
117: Zhijie Shen, info, CatchClause, LOG.info("Event from RM: shutting down Application Master");
126: Zhijie Shen, info, CatchClause, LOG.info("ApplicationMaster is out of sync with ResourceManager," + " hence resync and send outstanding requests.");
134: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Could not contact RM after " + retryInterval + " milliseconds.");
173: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Processing the event " + event.toString());
177: Arun Murthy, error, CatchClause, LOG.error("Exception while registering", are);
171: Zhijie Shen, info, TryStmt, LOG.info("maxContainerCapability: " + maxContainerCapability);
173: Sanford Ryza, info, TryStmt, LOG.info("queue: " + queue);
191: Arun Murthy, error, CatchClause, LOG.error("Exception while unregistering ", are);
217: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Setting job diagnostics to " + sb.toString());
220: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("History url is " + historyUrl);
237: Jian He, info, WhileStmt, LOG.info("Waiting for application to be successfully unregistered.");
263: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("InterruptedException while stopping", ie);
294: Karthik Kambatla, warn, IfStmt, LOG.warn("Allocated thread interrupted. Returning.");
282: Karthik Kambatla, Error, CatchClause, LOG.error("Error communicating with RM: " + e.getMessage(), e);
285: Karthik Kambatla, ERROR, CatchClause, LOG.error("ERROR IN CONTACTING RM. ", e);
339: Thomas Graves, info, MethodDeclaration, LOG.info("RMCommunicator notified that shouldUnregistered is: " + shouldUnregister);
345: Chris Douglas, info, MethodDeclaration, LOG.info("RMCommunicator notified that isSignalled is: " + isSignalled);
243: Arun Suresh, info, MethodDeclaration, LOG.info(this.scheduledRequests.getNumOpportunisticMapsPercent() + "% of the mappers will be scheduled using OPPORTUNISTIC containers");
261: Jason Darrell Lowe, error, IfStmt, LOG.error("Returning, interrupted : " + e);
269: Arun Murthy, Error, CatchClause, LOG.error("Error in handling event type " + event.getType() + " to the ContainreAllocator", t);
361: Arun Murthy, info, IfStmt, LOG.info("Size of event-queue in RMContainerAllocator is " + qSize);
365: Arun Murthy, warn, IfStmt, LOG.warn("Very low remaining capacity in the event-queue " + "of RMContainerAllocator: " + remCapacity);
390: Arun Murthy, info, IfStmt, LOG.info("Processing the event " + event.toString());
406: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Could not deallocate container for task attemptId " + aId);
435: Robert Kanter, info, IfStmt, LOG.info("reduceResourceRequest:" + reduceResourceRequest);
468: Robert Kanter, info, IfStmt, LOG.info(diagMsg);
488: Robert Kanter, info, IfStmt, LOG.info("mapResourceRequest:" + mapResourceRequest);
512: Robert Kanter, info, IfStmt, LOG.info(diagMsg);
621: Karthik Kambatla, info, MethodDeclaration, LOG.info("Going to preempt " + toPreempt + " due to lack of space for maps");
656: Thomas Graves, info, MethodDeclaration, LOG.info("Recalculating schedule, headroom=" + headRoom);
668: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Reduce slow start threshold reached. Scheduling reduces.");
663: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Reduce slow start threshold not met. " + "completedMapsForReduceSlowstart " + completedMapsForReduceSlowstart);
676: Robert Joseph Evans, info, IfStmt, LOG.info("All maps assigned. " + "Ramping up all remaining reduces:" + numPendingReduces);
726: Zhijie Shen, info, MethodDeclaration, LOG.info("completedMapPercent " + completedMapPercent + " totalResourceLimit:" + totalResourceLimit + " finalMapResourceLimit:" + finalMapResourceLimit + " finalReduceResourceLimit:" + finalReduceResourceLimit + " netScheduledMapResource:" + netScheduledMapResource + " netScheduledReduceResource:" + netScheduledReduceResource);
745: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Ramping down " + rampDown);
740: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Ramping up " + rampUp);
805: Zhijie Shen, info, CatchClause, LOG.info("ApplicationMaster is out of sync with ResourceManager," + " hence resync and send outstanding requests.");
817: Wangda Tan, info, CatchClause, LOG.info(diagMsg);
826: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Could not contact RM after " + retryInterval + " milliseconds.");
866: Thomas Graves, debug, IfStmt, LOG.debug("headroom=" + newHeadRoom);
872: Vinod Kumar Vavilapalli, debug, ForeachStmt, LOG.debug("Received new Container :" + cont);
897: Jason Lowe, info, MethodDeclaration, LOG.info("Received completed container " + container.getContainerId());
900: Jason Lowe, error, IfStmt, LOG.error("Container complete event for unknown container " + container.getContainerId());
1009: Siddharth Seth, info, IfStmt, LOG.info("Killing taskAttempt:" + tid + " because it is running on unusable node:" + taskAttemptNodeId);
1130: Jian He, debug, IfStmt, LOG.debug("Added attempt req to host " + host);
1141: Jian He, debug, IfStmt, LOG.debug("Added attempt req to rack " + rack);
1108: Siddharth Seth, info, IfStmt, LOG.info("Added " + event.getAttemptID() + " to list of failed maps");
1161: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Got allocated containers " + allocatedContainers.size());
1167: Arun Murthy, debug, IfStmt, LOG.debug("Assigning container " + allocated.getId() + " with priority " + allocated.getPriority() + " to NM " + allocated.getNodeId());
1205: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Container allocated at unwanted priority: " + priority + ". Returning to RM...");
1196: Jason Lowe, info, IfStmt, LOG.info("Cannot assign container " + allocated + " for a reduce as either " + " container memory less than required " + reduceResourceRequest + " or no pending reduce tasks.");
1184: Arun Murthy, info, IfStmt, LOG.info("Cannot assign container " + allocated + " for a map as either " + " container memory less than required " + mapResourceRequest + " or no pending map tasks - maps.isEmpty=" + maps.isEmpty());
1247: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Could not map allocated container to a valid request." + " Releasing allocated container " + allocated);
1232: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Placing a new container request for task attempt " + toBeReplacedReq.attemptID);
1264: Junping Du, info, WhileStmt, LOG.info("Releasing unassigned container " + allocated);
1282: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Assigned container (" + allocated + ") " + " to task " + assigned.attemptID + " on node " + allocated.getNodeId().toString());
1303: Arun Murthy, debug, IfStmt, LOG.debug("Assigning container " + allocated + " to reduce");
1299: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Assigning container " + allocated + " to fast fail map");
1326: Siddharth Seth, info, MethodDeclaration, LOG.info("Finding containerReq for allocated container: " + allocated);
1340: Siddharth Seth, info, IfStmt, LOG.info("Replacing MAP container " + allocated.getId());
1330: Siddharth Seth, info, IfStmt, LOG.info("Replacing FAST_FAIL_MAP container " + allocated.getId());
1335: Siddharth Seth, info, IfStmt, LOG.info("Found replacement: " + toBeReplaced);
1359: Siddharth Seth, info, MethodDeclaration, LOG.info("Found replacement: " + toBeReplaced);
1377: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Assigned from earlierFailedMaps");
1390: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Assigned to reduce");
1411: Jian He, debug, IfStmt, LOG.debug("Host matched to the request list " + host);
1425: Jian He, debug, IfStmt, LOG.debug("Assigned based on host match " + host);
1459: Jian He, debug, IfStmt, LOG.debug("Assigned based on rack match " + rack);
1483: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Assigned based on * match");
1505: Siddharth Seth, info, MethodDeclaration, LOG.info("Assigned container " + container.getId().toString() + " to " + tId);
1531: Vinod Kumar Vavilapalli, info, ForStmt, LOG.info("Preempting " + id);
1546: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Reduce preemption successful " + tId);
1620: Thomas Graves, info, MethodDeclaration, LOG.info(msgPrefix + "PendingReds:" + numPendingReduces + " ScheduledMaps:" + numScheduledMaps + " ScheduledReds:" + numScheduledReduces + " AssignedMaps:" + numAssignedMaps + " AssignedReds:" + numAssignedReduces + " CompletedMaps:" + numCompletedMaps + " CompletedReds:" + numCompletedReduces + " ContAlloc:" + numContainersAllocated + " ContRel:" + numContainersReleased + " HostLocal:" + hostLocalAssigned + " RackLocal:" + rackLocalAssigned);
181: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("nodeBlacklistingEnabled:" + nodeBlacklistingEnabled);
188: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("maxTaskFailuresPerNode is " + maxTaskFailuresPerNode);
194: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("blacklistDisablePercent is " + blacklistDisablePercent);
216: Arun Murthy, info, IfStmt, LOG.info("getResources() for " + applicationId + ":" + " ask=" + ask.size() + " release= " + release.size() + " newContainers=" + allocateResponse.getAllocatedContainers().size() + " finishedContainers=" + numCompletedContainers + " resourcelimit=" + availableResources + " knownNMs=" + clusterNmCount);
234: Bikas Saha, info, IfStmt, LOG.info("Update the blacklist for " + applicationId + ": blacklistAdditions=" + blacklistAdditions.size() + " blacklistRemovals=" + blacklistRemovals.size());
262: Junping Du, info, IfStmt, LOG.info("Applying ask limit of " + newReq.getNumContainers() + " for priority:" + reqLimit.getPriority() + " and capability:" + reqLimit.getCapability());
303: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("KnownNode Count at 0. Not computing ignoreBlacklisting");
317: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Ignore blacklisting set to false. Known: " + clusterNmCount + ", Blacklisted: " + blacklistedNodeCount + ", " + val + "%");
309: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Ignore blacklisting set to true. Known: " + clusterNmCount + ", Blacklisted: " + blacklistedNodeCount + ", " + val + "%");
333: Arun Murthy, debug, IfStmt, LOG.debug("Host " + hostName + " is already blacklisted.");
340: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(failures + " failures on node " + hostName);
451: Arun Murthy, debug, IfStmt, LOG.debug("Added priority=" + priority);
476: Arun Murthy, debug, IfStmt, LOG.debug("addResourceRequest:" + " applicationId=" + applicationId.getId() + " priority=" + priority.getPriority() + " resourceName=" + resourceName + " numContainers=" + remoteRequest.getNumContainers() + " #asks=" + ask.size());
493: Arun Murthy, debug, IfStmt, LOG.debug("Not decrementing resource as " + resourceName + " is not present in request table");
501: Arun Murthy, debug, IfStmt, LOG.debug("BEFORE decResourceRequest:" + " applicationId=" + applicationId.getId() + " priority=" + priority.getPriority() + " resourceName=" + resourceName + " numContainers=" + remoteRequest.getNumContainers() + " #asks=" + ask.size());
528: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("AFTER decResourceRequest:" + " applicationId=" + applicationId.getId() + " priority=" + priority.getPriority() + " resourceName=" + resourceName + " numContainers=" + remoteRequest.getNumContainers() + " #asks=" + ask.size());
114: Christopher Douglas, info, IfStmt, LOG.info("strict preemption :" + preemptionRequests.getStrictContract().getContainers().size() + " containers to kill");
130: Christopher Douglas, info, IfStmt, LOG.info("NOT preempting " + reqCont + " running task:" + reqTask);
128: Christopher Douglas, info, IfStmt, LOG.info("preempting " + reqCont + " running task:" + reqTask);
144: Christopher Douglas, info, IfStmt, LOG.info("negotiable preemption :" + preemptionRequests.getContract().getResourceRequest().size() + " resourceReq, " + preemptionRequests.getContract().getContainers().size() + " containers");
172: Christopher Douglas, info, ForeachStmt, LOG.info("ResourceRequest:" + reqRsrc);
216: Christopher Douglas, info, ForeachStmt, LOG.info("ResourceRequest:" + reqRsrc + " satisfied preempting " + reduceId);
233: Christopher Douglas, info, MethodDeclaration, LOG.info(" task completed:" + attemptID);
76: Christopher Douglas, info, MethodDeclaration, LOG.info("Evicting " + reqTask);
139: Chris Douglas, error, CatchClause, LOG.error("Can't make a speculation runtime estimator", ex);
142: Chris Douglas, error, CatchClause, LOG.error("Can't make a speculation runtime estimator", ex);
145: Chris Douglas, error, CatchClause, LOG.error("Can't make a speculation runtime estimator", ex);
148: Chris Douglas, error, CatchClause, LOG.error("Can't make a speculation runtime estimator", ex);
217: Jonathan Turner Eagles, error, IfStmt, LOG.error("Background thread returning, interrupted", e);
209: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("We launched " + speculations + " speculations.  Sleeping " + wait + " milliseconds.");
255: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("We got asked to run a debug speculation scan.");
301: Vinod Kumar Vavilapalli, info, SwitchEntryStmt, LOG.info("ATTEMPT_START " + event.getTaskID());
309: Vinod Kumar Vavilapalli, info, SwitchEntryStmt, LOG.info("JOB_CREATE " + event.getJobID());
469: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("DefaultSpeculator.addSpeculativeAttempt -- we are speculating " + taskID);
234: Robert Joseph Evans, error, CatchClause, LOG.error("Failed to render tasks page with task type : " + $(TASK_TYPE) + " for job id : " + $(JOB_ID), e);
299: Robert Joseph Evans, error, CatchClause, LOG.error("Failed to render attempts page with task type : " + $(TASK_TYPE) + " for job id : " + $(JOB_ID), e);
355: Robert Kanter, Error, CatchClause, LOG.error("Error reading/writing job" + " conf file for job: " + jobId, e);
115: Mahadev Konar, Error, CatchClause, LOG.error("Error while reading " + confPath, e);
109: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("handling event " + event.getClass() + " with type " + event.getType());
156: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("sleeping for 5 minutes...");
824: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Could not cleanup", e);
66: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("summary: " + out);
239: Vinod Kumar Vavilapalli, info, ConstructorDeclaration, LOG.info("PathUsed: " + testAbsPath);
245: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("COULD NOT CLEANUP: " + testAbsPath, e);
311: Arun Murthy, info, MethodDeclaration, LOG.info("Writing job conf to " + jobFile);
69: Akira Ajisaka, WARN, MethodDeclaration, GenericTestUtils.setRootLogLevel(Level.WARN);
181: Robert Joseph Evans, info, CatchClause, LOG.info("Caught expected Exception", e);
258: Robert Joseph Evans, info, CatchClause, LOG.info("Caught expected Exception", e);
296: Robert Joseph Evans, info, CatchClause, LOG.info("Caught expected Exception", e);
334: Robert Joseph Evans, info, CatchClause, LOG.info("Caught expected Exception", e);
411: Akira Ajisaka, DEBUG, MethodDeclaration, GenericTestUtils.setRootLogLevel(Level.DEBUG);
180: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for next attempt to start");
201: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for next attempt to start");
222: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for next attempt to start");
1360: Jason Darrell Lowe, info, WhileStmt, LOG.info("Waiting for next attempt to start");
1371: Jason Darrell Lowe, info, MethodDeclaration, LOG.info(t1a2contId.toString());
1372: Jason Darrell Lowe, info, MethodDeclaration, LOG.info(task1Attempt1.getID().toString());
1373: Jason Darrell Lowe, info, MethodDeclaration, LOG.info(task1Attempt2.getID().toString());
1591: Siddharth Seth, info, MethodDeclaration, LOG.info("--- START: testRecoverySuccessAttempt ---");
1648: Siddharth Seth, info, MethodDeclaration, LOG.info("--- START: testRecoveryAllFailAttempts ---");
1706: Siddharth Seth, info, MethodDeclaration, LOG.info("--- START:  testRecoveryTaskSuccessAllAttemptsFail ---");
1765: Siddharth Seth, info, MethodDeclaration, LOG.info("--- START:  testRecoveryTaskSuccessAllAttemptsFail ---");
1822: Siddharth Seth, info, MethodDeclaration, LOG.info("--- START:  testRecoveryAllAttemptsKilled ---");
1902: Siddharth Seth, info, WhileStmt, LOG.info(eventNum + " " + current.getClass().getName());
1917: Robert Kanter, info, IfStmt, LOG.info("JobCounterUpdateEvent " + jcue.getCounterUpdates().get(0).getCounterKey() + " " + jcue.getCounterUpdates().get(0).getIncrementValue());
1905: Siddharth Seth, info, IfStmt, LOG.info(expectedJobHistoryEvents.get(0).toString() + " " + jhe.getHistoryEvent().getEventType().toString() + " " + jhe.getJobID());
816: Vinod Kumar Vavilapalli, info, ConstructorDeclaration, LOG.info("Created MyAppMaster");
59: Karthik Kambatla, WARN, MethodDeclaration, Assert.assertEquals("[" + MRApps.crossPlatformify("JAVA_HOME") + "/bin/java" + " -Djava.net.preferIPv4Stack=true" + " -Dhadoop.metrics.log.level=WARN " + "  -Xmx820m -Djava.io.tmpdir=" + MRApps.crossPlatformify("PWD") + "/tmp" + " -Dlog4j.configuration=container-log4j.properties" + " -Dyarn.app.container.log.dir=<LOG_DIR>" + " -Dyarn.app.container.log.filesize=0" + " -Dhadoop.root.logger=INFO,CLA -Dhadoop.root.logfile=syslog" + " org.apache.hadoop.mapred.YarnChild 127.0.0.1" + " 54321" + " attempt_0_0000_m_000000_0" + " 0" + " 1><LOG_DIR>/stdout" + " 2><LOG_DIR>/stderr ]", app.launchCmdList.get(0));
122: Jason Lowe, WARN, MethodDeclaration, Assert.assertEquals("[" + MRApps.crossPlatformify("JAVA_HOME") + "/bin/java" + " -Djava.net.preferIPv4Stack=true" + " -Dhadoop.metrics.log.level=WARN " + "  -Xmx820m -Djava.io.tmpdir=" + MRApps.crossPlatformify("PWD") + "/tmp" + " -Dlog4j.configuration=container-log4j.properties" + " -Dyarn.app.container.log.dir=<LOG_DIR>" + " -Dyarn.app.container.log.filesize=0" + " -Dhadoop.root.logger=INFO,CLA -Dhadoop.root.logfile=syslog" + " -Dyarn.app.mapreduce.shuffle.logger=INFO," + appenderName + " -Dyarn.app.mapreduce.shuffle.logfile=syslog.shuffle" + " -Dyarn.app.mapreduce.shuffle.log.filesize=" + shuffleLogSize + " -Dyarn.app.mapreduce.shuffle.log.backups=" + shuffleBackups + " org.apache.hadoop.mapred.YarnChild 127.0.0.1" + " 54321" + " attempt_0_0000_r_000000_0" + " 0" + " 1><LOG_DIR>/stdout" + " 2><LOG_DIR>/stderr ]", app.launchCmdList.get(0));
164: Karthik Kambatla, WARN, MethodDeclaration, Assert.assertEquals("[" + MRApps.crossPlatformify("JAVA_HOME") + "/bin/java" + " -Djava.net.preferIPv4Stack=true" + " -Dhadoop.metrics.log.level=WARN " + "  -Xmx820m -Djava.io.tmpdir=" + MRApps.crossPlatformify("PWD") + "/tmp" + " -Dlog4j.configuration=" + testLogPropertieFile + " -Dyarn.app.container.log.dir=<LOG_DIR>" + " -Dyarn.app.container.log.filesize=0" + " -Dhadoop.root.logger=INFO,CLA -Dhadoop.root.logfile=syslog" + " org.apache.hadoop.mapred.YarnChild 127.0.0.1" + " 54321" + " attempt_0_0000_m_000000_0" + " 0" + " 1><LOG_DIR>/stdout" + " 2><LOG_DIR>/stderr ]", app.launchCmdList.get(0));
270: Arun Murthy, info, IfStmt, LOG.info("launchContext " + cmdString);
403: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testInit ---");
414: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testScheduleTask ---");
425: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testKillScheduledTask ---");
438: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testKillScheduledTaskAttempt ---");
453: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testLaunchTaskAttempt ---");
466: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testKillRunningTaskAttempt ---");
478: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("--- START: testKillSuccesfulTask ---");
497: Wangda Tan, info, MethodDeclaration, LOG.info("--- START: testKillAttemptForSuccessfulTask ---");
515: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testTaskProgress ---");
148: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for number of events processed to become " + 10 + ". It is now " + containerLauncher.numEventsProcessed.get() + ". Timeout is " + timeOut);
250: Siddharth Seth, info, WhileStmt, LOG.info("Waiting for number of events to become " + expectedNumEvents + ". It is now " + containerLauncher.numEventsProcessing.get());
307: Siddharth Seth, info, TryStmt, LOG.info("attempt.getDiagnostics: " + diagnostics);
450: Akira Ajisaka, error, CatchClause, LOG.error("Setup thread sleep interrupted: ", e);
137: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("POOL SIZE 1: " + this.eventQueue.size() + " POOL SIZE 2: " + this.launcherPool.getQueue().size() + " ACTIVE COUNT: " + this.launcherPool.getActiveCount());
144: Vinod Kumar Vavilapalli, debug, WhileStmt, LOG.debug("POOL SIZE 1: " + this.eventQueue.size() + " POOL SIZE 2: " + this.launcherPool.getQueue().size() + " ACTIVE COUNT: " + this.launcherPool.getActiveCount());
148: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("POOL SIZE 1: " + this.eventQueue.size() + " POOL SIZE 2: " + this.launcherPool.getQueue().size() + " ACTIVE COUNT: " + this.launcherPool.getActiveCount());
171: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("STARTING testHandle");
193: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("inserting launch event");
211: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("inserting cleanup event");
232: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("STARTING testOutOfOrder");
254: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("inserting cleanup event");
269: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("inserting launch event");
293: Robert Joseph Evans, info, MethodDeclaration, LOG.info("in test Shutdown");
316: Robert Joseph Evans, info, TryStmt, LOG.info("inserting launch event");
345: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("STARTING testContainerCleaned");
372: Jason Darrell Lowe, info, TryStmt, LOG.info("inserting launch event");
388: Jason Darrell Lowe, info, TryStmt, LOG.info("inserting cleanup event");
408: Jason Darrell Lowe, info, ForStmt, LOG.info(arg.getAllValues().get(i).toString());
184: Arun Murthy, info, MethodDeclaration, LOG.info("Running testSimple");
350: Arun Murthy, info, MethodDeclaration, LOG.info("Running testResource");
413: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Running tesReducerRampdownDiagnostics");
464: Karthik Kambatla, info, MethodDeclaration, LOG.info("Running testPreemptReducers");
510: Zhijie Shen, info, MethodDeclaration, LOG.info("Running testNonAggressivelyPreemptReducers");
569: Karthik Kambatla, info, MethodDeclaration, LOG.info("Running testForcePreemptReducers");
675: Wangda Tan, info, MethodDeclaration, LOG.info("Running testMapReduceAllocationWithNodeLabelExpression");
760: Jian He, info, MethodDeclaration, LOG.info("Running testUpdateCollectorInfo");
851: Arun Murthy, info, MethodDeclaration, LOG.info("Running testMapReduceScheduling");
978: Arun Murthy, info, MethodDeclaration, LOG.info("Running testReportedAppProgress");
1130: Arun Murthy, info, MethodDeclaration, LOG.info("Running testReportedAppProgressWithOnlyMaps");
1311: Arun Murthy, info, MethodDeclaration, LOG.info("Running testBlackListedNodes");
1414: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Running testIgnoreBlacklisting");
1455: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Failing container _1 on H1 (Node should be blacklisted and" + " ignore blacklisting enabled");
1602: Siddharth Seth, info, MethodDeclaration, LOG.info("Running testBlackListedNodesWithSchedulingToThatNode");
1639: Siddharth Seth, info, MethodDeclaration, LOG.info("Requesting 1 Containers _1 on H1");
1645: Siddharth Seth, info, MethodDeclaration, LOG.info("RM Heartbeat (to send the container requests)");
1652: Siddharth Seth, info, MethodDeclaration, LOG.info("h1 Heartbeat (To actually schedule the containers)");
1657: Siddharth Seth, info, MethodDeclaration, LOG.info("RM Heartbeat (To process the scheduled containers)");
1663: Siddharth Seth, info, MethodDeclaration, LOG.info("Failing container _1 on H1 (should blacklist the node)");
1693: Siddharth Seth, info, MethodDeclaration, LOG.info("RM Heartbeat (To process the scheduled containers)");
1709: Siddharth Seth, info, MethodDeclaration, LOG.info("h3 Heartbeat (To re-schedule the containers)");
1713: Siddharth Seth, info, MethodDeclaration, LOG.info("RM Heartbeat (To process the re-scheduled containers for H3)");
1720: Siddharth Seth, info, ForeachStmt, LOG.info(assig.getTaskAttemptID() + " assgined to " + assig.getContainer().getId() + " with priority " + assig.getContainer().getPriority());
1758: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("add application failed with ", ie);
1813: Jason Lowe, info, CatchClause, LOG.info("add application failed with ", ie);
2294: Robert Joseph Evans, info, MethodDeclaration, LOG.info("Running testCompletedTasksRecalculateSchedule");
2339: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Running testHeartbeatHandler");
2796: Jian He, info, MethodDeclaration, LOG.info("Running testAMRMTokenUpdate");
2946: Junping Du, info, MethodDeclaration, LOG.info("Running testConcurrentTaskLimits");
3105: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Running testUpdateAskOnRampDownAllReduces");
3269: Jason Lowe, info, MethodDeclaration, LOG.info("Running testAvoidAskMoreReducersWhenReducerPreemptionIsRequired");
3396: Naganarasimha, info, MethodDeclaration, LOG.info("Running testExcludeSchedReducesFromHeadroom");
163: Thomas White, info, ForeachStmt, LOG.info(String.format("Localized %s as %s", resourcePath, path));
199: Thomas White, info, IfStmt, LOG.info(String.format("Creating symlink: %s <- %s", target, link));
201: Thomas White, warn, IfStmt, LOG.warn(String.format("Failed to create symlink: %s <- %s", target, link));
232: Steve Loughran, info, ForStmt, LOG.info(urls[i].toString());
245: Thomas White, warn, IfStmt, LOG.warn("Failed to delete symlink created by the local job runner: " + symlink);
252: Todd Lipcon, info, TryStmt, LOG.info("Starting task: " + mapId);
277: Todd Lipcon, info, TryStmt, LOG.info("Finishing task: " + mapId);
330: Sanford Ryza, info, TryStmt, LOG.info("Starting task: " + reduceId);
353: Sanford Ryza, info, IfStmt, LOG.info("Finishing task: " + reduceId);
423: Sanford Ryza, debug, MethodDeclaration, LOG.debug("Starting mapper thread pool executor.");
424: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Max local threads: " + maxMapThreads);
425: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Map tasks to process: " + this.numMapTasks);
453: Sanford Ryza, debug, MethodDeclaration, LOG.debug("Starting reduce thread pool executor.");
454: Sanford Ryza, debug, MethodDeclaration, LOG.debug("Max local threads: " + maxReduceThreads);
455: Sanford Ryza, debug, MethodDeclaration, LOG.debug("Reduce tasks to process: " + this.numReduceTasks);
486: Sanford Ryza, info, MethodDeclaration, LOG.info(taskType + " task executor complete.");
501: Arun Murthy, info, MethodDeclaration, LOG.info("OutputCommitter set in config " + conf.get("mapred.output.committer.class"));
519: Arun Murthy, info, MethodDeclaration, LOG.info("OutputCommitter is " + committer.getClass().getName());
532: Arun Murthy, info, CatchClause, LOG.info("Failed to createOutputCommitter", e);
582: Todd Lipcon, Error, CatchClause, LOG.info("Error cleaning up job:" + id);
590: Steve Loughran, warn, CatchClause, LOG.warn(id.toString(), t);
601: Todd Lipcon, Error, CatchClause, LOG.warn("Error cleaning up " + id + ": " + e);
628: Todd Lipcon, info, MethodDeclaration, LOG.info(taskStatus.getStateString());
702: Todd Lipcon, info, MethodDeclaration, LOG.info("Task " + taskid + " reportedNextRecordRange " + range);
724: Steve Loughran, Error, MethodDeclaration, LOG.error("FSError: " + message + "from task: " + taskId);
729: Steve Loughran, Error, MethodDeclaration, LOG.error("shuffleError: " + message + "from task: " + taskId);
734: Jason Lowe, Fatal, MethodDeclaration, LOG.error("Fatal: " + msg + " from task: " + taskId + " fast fail: " + fastFail);
1031: Arun Murthy, debug, MethodDeclaration, LOG.debug(MRConfig.LOCAL_DIR + " for child : " + childMapredLocalDir);
202: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Parsing job history file with partial data encoded into name: " + jhFileName);
150: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to parse submit time from job history file " + jhFileName + " : " + e);
164: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to parse finish time from job history file " + jhFileName + " : " + e);
172: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to parse num maps from job history file " + jhFileName + " : " + e);
180: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to parse num reduces from job history file " + jhFileName + " : " + e);
198: Jason Darrell Lowe, warn, CatchClause, LOG.warn("Unable to parse start time from job history file " + jhFileName + " : " + e);
228: Billie Rinaldi, warn, IfStmt, LOG.warn("Unsupported permission configured in " + JHAdminConfig.MR_HISTORY_INTERMEDIATE_USER_DONE_DIR_PERMISSIONS + ", the user and the group permission must be 7 (rwx). " + "The permission was set to " + permission.toString());
283: Zhijie Shen, info, IfStmt, LOG.info("Default file system is set solely " + "by core-default.xml therefore -  ignoring");
276: Zhijie Shen, error, CatchClause, LOG.error("Unable to create default file context [" + defaultConf.get(CommonConfigurationKeysPublic.FS_DEFAULT_NAME_KEY) + "]", e);
273: Zhijie Shen, info, TryStmt, LOG.info("Default file system [" + fc.getDefaultFileSystem().getUri() + "]");
109: Thomas Graves, debug, IfStmt, LOG.debug("Connecting to MRHistoryServer at: " + hsAddress);
43: Mahadev Konar, debug, MethodDeclaration, LOG.debug("Looking for a token with service " + service.toString());
46: Mahadev Konar, debug, IfStmt, LOG.debug("Token kind is " + token.getKind().toString() + " and the token's service name is " + token.getService());
332: Sangjin Lee, warn, IfStmt, LOG.warn("The same path is included more than once " + "with different links or wildcards: " + p + " [" + name + ", " + old + "]");
388: Jason Darrell Lowe, info, IfStmt, LOG.info("Creating job classloader");
390: Thomas White, debug, IfStmt, LOG.debug("APP_CLASSPATH=" + appClasspath);
386: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Not creating job classloader since APP_CLASSPATH is not set.");
409: Gera Shegalov, info, IfStmt, LOG.info("Setting classloader " + classLoader + " on the configuration and as the thread context classloader");
110: Arun Murthy, info, ForeachStmt, LOG.info("Path" + ": " + outputFile);
119: Todd Lipcon, info, MethodDeclaration, LOG.info("Java Classpath: " + System.getProperty("java.class.path"));
116: Todd Lipcon, info, ConstructorDeclaration, LOG.info("Created a new BackupStore with a memory of " + maxSize);
170: Todd Lipcon, debug, WhileStmt, LOG.debug("Dropping a segment");
179: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Setting the FirsSegmentOffset to " + currentKVOffset);
219: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Reset - First segment offset is " + firstSegmentOffset + " Segment List Size is " + segmentList.size());
411: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Created a new mem block of " + allocatedSize);
480: Todd Lipcon, debug, MethodDeclaration, LOG.debug("ID: " + segmentList.size() + " WRITE TO MEM");
513: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Added Memory Segment to List. List Size is " + segmentList.size());
544: Todd Lipcon, debug, MethodDeclaration, LOG.debug("ID: " + segmentList.size() + " WRITE TO DISK");
564: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Disk Segment added to List. Size is " + segmentList.size());
574: Todd Lipcon, info, MethodDeclaration, LOG.info("Created file: " + tmp);
595: Todd Lipcon, warn, MethodDeclaration, LOG.warn("Reserve(int, InputStream) not supported by BackupRamManager");
605: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Reserving: " + reservedSize + " Requested: " + requestedSize);
611: Chris Douglas, debug, IfStmt, LOG.debug("No space available. Available: " + availableSize + " MinSize: " + minSize);
621: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Unreserving: " + requestedSize + ". Available: " + availableSize);
90: Todd Lipcon, debug, IfStmt, LOG.debug("Trying to delete " + context.fullPath);
125: Todd Lipcon, debug, IfStmt, LOG.debug(getName() + " started.");
143: Daniel Templeton, warn, IfStmt, LOG.warn("Interrupted deletion of " + context.fullPath);
140: Daniel Templeton, warn, IfStmt, LOG.warn("Interrupted deletion of an invalid path: Path deletion " + "context is null.");
147: Todd Lipcon, Error, CatchClause, LOG.warn("Error deleting path " + context.fullPath + ": " + e);
136: Todd Lipcon, debug, IfStmt, LOG.debug("DELETED " + context.fullPath);
133: Todd Lipcon, warn, IfStmt, LOG.warn("CleanupThread:Unable to delete path " + context.fullPath);
470: Todd Lipcon, warn, IfStmt, LOG.warn("Counter name MAP_INPUT_BYTES is deprecated. " + "Use FileInputFormatCounters as group name and " + " BYTES_READ as counter name instead");
600: Todd Lipcon, info, MethodDeclaration, log.info("Counters: " + size());
602: Todd Lipcon, info, ForeachStmt, log.info("  " + group.getDisplayName());
604: Arun Murthy, info, ForeachStmt, log.info("    " + counter.getDisplayName() + "=" + counter.getCounter());
70: Todd Lipcon, warn, CatchClause, LOG.warn("Not able to initialize queue " + name);
97: Todd Lipcon, warn, IfStmt, LOG.warn("Configuring \"" + MAPRED_QUEUE_NAMES_KEY + "\" in mapred-site.xml or " + "hadoop-site.xml is deprecated and will overshadow " + QUEUE_CONF_FILE_NAME + ". Remove this property and configure " + "queue hierarchy in " + QUEUE_CONF_FILE_NAME);
115: Todd Lipcon, warn, IfStmt, LOG.warn("Configuring queue ACLs in mapred-site.xml or " + "hadoop-site.xml is deprecated. Configure queue ACLs in " + QUEUE_CONF_FILE_NAME);
256: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Time taken to get FileStatuses: " + sw.now(TimeUnit.MILLISECONDS));
259: Devaraj K, info, MethodDeclaration, LOG.info("Total input files to process : " + result.length);
386: Ray Chiang, debug, IfStmt, LOG.debug("File is not splittable so no parallelization " + "is possible: " + file.getPath());
400: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Total # of splits generated by getSplits: " + splits.size() + ", TimeTaken: " + sw.now(TimeUnit.MILLISECONDS));
121: Todd Lipcon, warn, IfStmt, LOG.warn("Could not obtain compressor from CodecPool");
344: Todd Lipcon, warn, IfStmt, LOG.warn("Could not obtain decompressor from CodecPool");
99: Alejandro Abdelnur, info, CatchClause, LOG.info("Unable to determine FileDescriptor", e);
47: Todd Lipcon, info, ConstructorDeclaration, LOG.info("IndexCache created with max memory = " + totalMemoryAllowed);
79: Todd Lipcon, debug, IfStmt, LOG.debug("IndexCache HIT: MapId " + mapId + " found");
113: Todd Lipcon, debug, IfStmt, LOG.debug("IndexCache HIT: MapId " + mapId + " found");
116: Todd Lipcon, debug, MethodDeclaration, LOG.debug("IndexCache MISS: MapId " + mapId + " not found");
158: Todd Lipcon, info, IfStmt, LOG.info("Map ID " + mapId + " not found in cache");
155: Todd Lipcon, warn, IfStmt, LOG.warn("Map ID" + mapId + " not found in queue!!");
109: Siddharth Seth, debug, IfStmt, LOG.debug("checkAccess job acls, jobOwner: " + jobOwner + " jobacl: " + jobOperation.toString() + " user: " + callerUGI.getShortUserName());
2037: Todd Lipcon, warn, MethodDeclaration, LOG.warn("getMaxVirtualMemoryForTask() is deprecated. " + "Instead use getMemoryForMapTask() and getMemoryForReduceTask()");
2066: Todd Lipcon, warn, MethodDeclaration, LOG.warn("setMaxVirtualMemoryForTask() is deprecated." + "Instead use setMemoryForMapTask() and setMemoryForReduceTask()");
2085: Todd Lipcon, warn, MethodDeclaration, LOG.warn("The API getMaxPhysicalMemoryForTask() is deprecated." + " Refer to the APIs getMemoryForMapTask() and" + " getMemoryForReduceTask() for details.");
2096: Todd Lipcon, warn, MethodDeclaration, LOG.warn("The API setMaxPhysicalMemoryForTask() is deprecated." + " The value set is ignored. Refer to " + " setMemoryForMapTask() and setMemoryForReduceTask() for details.");
2107: Todd Lipcon, warn, IfStmt, LOG.warn(JobConf.deprecatedString(JobConf.MAPRED_TASK_MAXVMEM_PROPERTY) + " Instead use " + JobConf.MAPREDUCE_JOB_MAP_MEMORY_MB_PROPERTY + " and " + JobConf.MAPREDUCE_JOB_REDUCE_MEMORY_MB_PROPERTY);
2112: Robert Joseph Evans, warn, IfStmt, LOG.warn(JobConf.deprecatedString(JobConf.MAPRED_TASK_ULIMIT));
2115: Robert Joseph Evans, warn, IfStmt, LOG.warn(JobConf.deprecatedString(JobConf.MAPRED_MAP_TASK_ULIMIT));
2118: Robert Joseph Evans, warn, IfStmt, LOG.warn(JobConf.deprecatedString(JobConf.MAPRED_REDUCE_TASK_ULIMIT));
2149: Gera Shegalov, warn, IfStmt, LOG.warn("Invalid value for " + MRJobConfig.HEAP_MEMORY_MB_RATIO + ", using the default.");
2158: Gera Shegalov, info, IfStmt, LOG.info("Task java-opts do not specify heap size. Setting task attempt" + " jvm max heap size to " + xmxArg);
2213: Gera Shegalov, info, IfStmt, LOG.info("Figured value for " + configName + " from javaOpts");
96: Todd Lipcon, error, CatchClause, LOG.error("Notification error [" + notification.getUri() + "]", ioex);
99: Todd Lipcon, error, CatchClause, LOG.error("Notification error [" + notification.getUri() + "]", ex);
105: Todd Lipcon, error, CatchClause, LOG.error("Notification retry error [" + notification + "]", iex);
228: Karthik Kambatla, info, IfStmt, LOG.info("Found UTF-8 BOM and skipped it");
267: Todd Lipcon, info, WhileStmt, LOG.info("Skipped line of size " + newSize + " at pos " + (pos - newSize));
263: Todd Lipcon, warn, IfStmt, LOG.warn("Further records got skipped.");
417: Karthik Kambatla, warn, CatchClause, LOG.warn(msg, e);
405: Karthik Kambatla, debug, TryStmt, LOG.debug("Trying map output collector class: " + subclazz.getName());
409: Karthik Kambatla, info, TryStmt, LOG.info("Map output collector class = " + collector.getClass().getName());
451: Todd Lipcon, info, MethodDeclaration, LOG.info("numReduceTasks: " + numReduceTasks);
497: Harsh J, info, MethodDeclaration, LOG.info("Processing split: " + inputSplit);
768: Harsh J, info, MethodDeclaration, LOG.info("Processing split: " + split);
1012: Suresh Srinivas, info, MethodDeclaration, LOG.info(JobContext.IO_SORT_MB + ": " + sortmb);
1013: Suresh Srinivas, info, MethodDeclaration, LOG.info("soft limit at " + softLimit);
1014: Suresh Srinivas, info, MethodDeclaration, LOG.info("bufstart = " + bufstart + "; bufvoid = " + bufvoid);
1015: Suresh Srinivas, info, MethodDeclaration, LOG.info("kvstart = " + kvstart + "; length = " + maxRec);
1196: Todd Lipcon, info, CatchClause, LOG.info("Record too large for in-memory buffer: " + e.getMessage());
1219: Suresh Srinivas, info, MethodDeclaration, LOG.info("(EQUATOR) " + pos + " kvi " + kvindex + "(" + (kvindex * 4) + ")");
1236: Suresh Srinivas, info, MethodDeclaration, LOG.info("(RESET) equator " + e + " kv " + kvstart + "(" + (kvstart * 4) + ")" + " kvi " + kvindex + "(" + (kvindex * 4) + ")");
1476: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting flush of map output");
1478: Jason Lowe, info, IfStmt, LOG.info("kvbuffer is null. Skipping flush.");
1498: Suresh Srinivas, info, IfStmt, LOG.info("Spilling map output");
1499: Suresh Srinivas, info, IfStmt, LOG.info("bufstart = " + bufstart + "; bufend = " + bufmark + "; bufvoid = " + bufvoid);
1501: Suresh Srinivas, info, IfStmt, LOG.info("kvstart = " + kvstart + "(" + (kvstart * 4) + "); kvend = " + kvend + "(" + (kvend * 4) + "); length = " + (distanceTo(kvend, kvstart, kvmeta.capacity()) + 1) + "/" + maxRec);
1595: Suresh Srinivas, info, MethodDeclaration, LOG.info("Spilling map output");
1596: Suresh Srinivas, info, MethodDeclaration, LOG.info("bufstart = " + bufstart + "; bufend = " + bufmark + "; bufvoid = " + bufvoid);
1598: Suresh Srinivas, info, MethodDeclaration, LOG.info("kvstart = " + kvstart + "(" + (kvstart * 4) + "); kvend = " + kvend + "(" + (kvend * 4) + "); length = " + (distanceTo(kvend, kvstart, kvmeta.capacity()) + 1) + "/" + maxRec);
1696: Todd Lipcon, info, TryStmt, LOG.info("Finished spill " + numSpills);
1938: Todd Lipcon, debug, IfStmt, LOG.debug("MapId=" + mapId + " Reducer=" + parts + "Spill =" + i + "(" + indexRecord.startOffset + "," + indexRecord.rawLength + ", " + indexRecord.partLength + ")");
2039: Arun Murthy, info, CatchClause, LOG.info("Ignoring exception during close for " + c, ie);
2051: Arun Murthy, info, CatchClause, LOG.info("Ignoring exception during close for " + c, ie);
2064: Arun Murthy, info, CatchClause, LOG.info("Ignoring exception during close for " + c, ie);
2079: Arun Murthy, info, CatchClause, LOG.info("Ignoring exception during close for " + c, ie);
460: Todd Lipcon, debug, ForeachStmt, LOG.debug("MergeQ: adding: " + file);
606: Todd Lipcon, info, MethodDeclaration, LOG.info("Merging " + segments.size() + " sorted segments");
710: Todd Lipcon, info, IfStmt, LOG.info("Merging " + segmentsToMerge.size() + " intermediate segments out of a total of " + (segments.size() + segmentsToMerge.size()));
705: Todd Lipcon, info, IfStmt, LOG.info("Down to the last merge-pass, with " + numSegments + " segments left of total size: " + (totalBytes - totalBytesProcessed) + " bytes");
300: Todd Lipcon, debug, MethodDeclaration, LOG.debug("created jobQInfo " + queueInfo.getQueueName());
338: Todd Lipcon, info, IfStmt, LOG.info(" current name " + name + " not equal to " + newState.getName());
351: Akira Ajisaka, error, IfStmt, LOG.error("In the current state, queue " + getName() + " has " + children.size() + " but the new state has none!");
358: Akira Ajisaka, error, IfStmt, LOG.error("Number of children for queue " + newState.getName() + " in newState is " + newChildrenSize + " which is not equal to " + childrenSize + " in the current state.");
372: Todd Lipcon, info, IfStmt, LOG.info(" Queue " + q.getName() + " not equal to " + newq.getName());
344: Todd Lipcon, info, IfStmt, LOG.info(newState + " has added children in refresh ");
171: Todd Lipcon, info, CatchClause, LOG.info("Failed to set setXIncludeAware(true) for parser " + docBuilderFactory + NAME_SEPARATOR + e);
235: Todd Lipcon, Error, CatchClause, LOG.info("Error parsing conf file: " + e);
189: Todd Lipcon, info, IfStmt, LOG.info("Bad conf file: top-level element not <queues>");
196: Todd Lipcon, warn, IfStmt, LOG.warn("Configuring " + ACLS_ENABLED_TAG + " flag in " + QueueManager.QUEUE_CONF_FILE_NAME + " is not valid. " + "This tag is ignored. Configure " + MRConfig.MR_ACLS_ENABLED + " in mapred-site.xml. See the " + " documentation of " + MRConfig.MR_ACLS_ENABLED + ", which is used for enabling job level authorization and " + " queue level authorization.");
207: Todd Lipcon, info, IfStmt, LOG.info(" Bad configuration no queues defined ");
219: Todd Lipcon, info, IfStmt, LOG.info("At root level only \" queue \" tags are allowed ");
205: Todd Lipcon, info, MethodDeclaration, LOG.info("AllQueues : " + allQueues + "; LeafQueues : " + leafQueues);
241: Todd Lipcon, info, IfStmt, LOG.info("Queue " + queueName + " is not present");
246: Todd Lipcon, info, IfStmt, LOG.info("Cannot submit job to parent queue " + q.getName());
255: Todd Lipcon, debug, IfStmt, LOG.debug("Checking access for the acl " + toFullPropertyName(queueName, qACL.getAclName()) + " for user " + ugi.getShortUserName());
352: Todd Lipcon, warn, IfStmt, LOG.warn(MSG_REFRESH_FAILURE_WITH_CHANGE_OF_HIERARCHY);
370: Todd Lipcon, error, CatchClause, LOG.error(msg.toString());
389: Todd Lipcon, info, MethodDeclaration, LOG.info("Queue configuration is refreshed successfully.");
275: Todd Lipcon, warn, IfStmt, LOG.warn("Further groups got skipped.");
363: Sanford Ryza, info, MethodDeclaration, LOG.info("Using ShuffleConsumerPlugin: " + shuffleConsumerPlugin);
640: Arun Murthy, info, CatchClause, LOG.info("Exception in closing " + c, e);
91: Todd Lipcon, debug, IfStmt, LOG.debug("previousRange " + previousRange);
108: Todd Lipcon, debug, WhileStmt, LOG.debug("nextRange " + nextRange + "   startIndex:" + startIndex + "  endIndex:" + endIndex);
144: Todd Lipcon, debug, IfStmt, LOG.debug("previousRange " + previousRange);
150: Todd Lipcon, debug, IfStmt, LOG.debug("removed previousRange " + previousRange);
162: Todd Lipcon, debug, WhileStmt, LOG.debug("nextRange " + nextRange + "   startIndex:" + startIndex + "  endIndex:" + endIndex);
184: Todd Lipcon, debug, IfStmt, LOG.debug("added " + recRange);
348: Todd Lipcon, debug, MethodDeclaration, LOG.debug("currentIndex " + next + "   " + range);
360: Todd Lipcon, warn, IfStmt, LOG.warn("Skipping index " + next + "-" + range.getEndIndex());
360: Akira Ajisaka, error, MethodDeclaration, LOG.error(logMsg);
373: Akira Ajisaka, error, CatchClause, LOG.error("Failed to contact the tasktracker", ioe);
602: Todd Lipcon, debug, IfStmt, LOG.debug("using new api for output committer");
625: Luke Lu, info, MethodDeclaration, LOG.info(" Using ResourceCalculatorProcessTree : " + pTree);
639: Thomas White, warn, IfStmt, LOG.warn("Task status: \"" + status + "\" truncated to max limit (" + progressStatusLength + " characters)");
808: Jason Lowe, error, CatchClause, LOG.error(e.getMessage(), e);
802: Jason Lowe, warn, IfStmt, LOG.warn(localStatus);
799: Jason Lowe, error, IfStmt, LOG.error(localStatus);
830: Jason Lowe, warn, CatchClause, LOG.warn("Could not get LocalFileSystem BYTES_WRITTEN counter");
923: Akira Ajisaka, error, CatchClause, LOG.error(errMsg);
927: Akira Ajisaka, error, CatchClause, LOG.error("Failed to update failure diagnosis", ioe);
929: Akira Ajisaka, error, CatchClause, LOG.error("Killing " + taskId);
933: Todd Lipcon, info, CatchClause, LOG.info("Communication exception: " + StringUtils.stringifyException(t));
937: Todd Lipcon, warn, IfStmt, LOG.warn("Last retry, killing " + taskId);
901: Jason Lowe, warn, IfStmt, LOG.warn("Parent died.  Exiting " + taskId);
914: Christopher Douglas, info, IfStmt, LOG.info("PREEMPTION TASK: setting mustPreempt to " + mustPreempt.get() + " given " + amFeedback.getPreemption() + " for " + taskId + " task status: " + taskStatus.getPhase());
970: Jason Lowe, error, CatchClause, LOG.error("Issues starting disk monitor thread: " + e.getMessage(), e);
1011: Todd Lipcon, debug, IfStmt, LOG.debug("sending reportNextRecordRange " + range);
1232: Christopher Douglas, info, MethodDeclaration, LOG.info("Task:" + taskId + " is done." + " And is in the process of committing");
1246: Todd Lipcon, warn, CatchClause, LOG.warn("Failure sending commit pending: " + StringUtils.stringifyException(ie));
1264: Naganarasimha, info, MethodDeclaration, LOG.info("Final Counters for " + taskId + ": " + getCounters().toString());
1319: Todd Lipcon, warn, CatchClause, LOG.warn("Failure sending status update: " + StringUtils.stringifyException(ie));
1310: Jason Lowe, warn, IfStmt, LOG.warn("Parent died.  Exiting " + taskId);
1307: Jason Lowe, warn, IfStmt, LOG.warn("Task no longer available: " + taskId);
1357: Todd Lipcon, warn, CatchClause, LOG.warn("Could not find output size ", e);
1371: Todd Lipcon, warn, CatchClause, LOG.warn("Failure signalling completion: " + StringUtils.stringifyException(ie));
1368: Todd Lipcon, info, TryStmt, LOG.info("Task '" + taskId + "' done.");
1397: Todd Lipcon, warn, CatchClause, LOG.warn("Failure asking whether task can commit: " + StringUtils.stringifyException(ie));
1413: Todd Lipcon, warn, CatchClause, LOG.warn("Failure committing: " + StringUtils.stringifyException(iee));
1409: Todd Lipcon, info, TryStmt, LOG.info("Task " + taskId + " is allowed to commit now");
1426: Todd Lipcon, warn, CatchClause, LOG.warn("Failure cleaning up: " + StringUtils.stringifyException(ioe));
1444: Naganarasimha, info, MethodDeclaration, LOG.info("Running cleanup for the task");
1457: Todd Lipcon, info, MethodDeclaration, LOG.info("Cleaning up job");
1469: Todd Lipcon, info, IfStmt, LOG.info("Committing job");
1460: Todd Lipcon, info, IfStmt, LOG.info("Aborting job with runstate : " + jobRunStateForCleanup.name());
98: Todd Lipcon, error, CatchClause, LOG.error("getTaskLogFileDetail threw an exception " + ie);
647: Robert Joseph Evans, debug, IfStmt, LOG.debug("mkdirs failed. Ignoring.");
126: Todd Lipcon, info, IfStmt, LOG.info("task-diagnostic-info for task " + taskid + " : " + info);
134: Todd Lipcon, info, IfStmt, LOG.info("task-diagnostic-info for task " + taskid + " : " + diagnosticInfo);
149: Todd Lipcon, info, IfStmt, LOG.info("state-string for task " + taskid + " : " + stateString);
196: Todd Lipcon, error, IfStmt, LOG.error("Trying to set finish time for task " + taskid + " when no start time is set, stackTrace is : " + StringUtils.stringifyException(new Exception()));
274: Todd Lipcon, error, IfStmt, LOG.error("Trying to set illegal startTime for task : " + taskid + ".Stack trace is : " + StringUtils.stringifyException(new Exception()));
98: Todd Lipcon, info, CatchClause, LOG.info("Exception" + ioe);
172: Todd Lipcon, info, MethodDeclaration, LOG.info(specToString());
167: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("seed: " + seed);
75: Todd Lipcon, debug, IfStmt, LOG.debug("Configuring jobConf " + jobConf.getJobName() + " to use " + numberOfThreads + " threads");
159: Todd Lipcon, debug, IfStmt, LOG.debug("Finished dispatching all Mappper.map calls, job " + job.getJobName());
172: Todd Lipcon, debug, IfStmt, LOG.debug("Awaiting all running Mappper.map calls to finish, job " + job.getJobName());
131: Todd Lipcon, Error, ConstructorDeclaration, cmd = TaskLog.captureOutAndError(null, cmd, stdout, stderr, logLength, false);
152: Todd Lipcon, debug, ConstructorDeclaration, LOG.debug("Authentication succeeded");
195: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Waiting for authentication response");
215: Todd Lipcon, info, MethodDeclaration, LOG.info("Aborting because of " + StringUtils.stringifyException(t));
167: Todd Lipcon, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
127: Todd Lipcon, debug, TryStmt, LOG.debug("Handling uplink command " + cmd);
158: Todd Lipcon, debug, IfStmt, LOG.debug("Pipe child done");
132: Todd Lipcon, warn, IfStmt, LOG.warn("Message " + cmd + " received before authentication is " + "complete. Ignoring");
263: Todd Lipcon, debug, MethodDeclaration, LOG.debug("closing connection");
272: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Sending AUTHENTICATION_REQ, digest=" + digest + ", challenge=" + challenge);
280: Todd Lipcon, debug, MethodDeclaration, LOG.debug("starting downlink");
338: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Sent close command");
343: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Sent abort command");
82: Todd Lipcon, info, TryStmt, LOG.info("starting application");
118: Todd Lipcon, info, TryStmt, LOG.info("waiting for finish");
120: Todd Lipcon, info, TryStmt, LOG.info("got done");
506: Todd Lipcon, Error, CatchClause, LOG.info("Error : " + pe);
476: Todd Lipcon, warn, IfStmt, LOG.warn("-jobconf option is deprecated, please use -D instead.");
86: Jason Lowe, info, CatchClause, LOG.info("Failed to instantiate ClientProtocolProvider, please " + "check the /META-INF/services/org.apache." + "hadoop.mapreduce.protocol.ClientProtocolProvider " + "files on the classpath", e);
121: Varun Saxena, info, IfStmt, LOG.info("Initializing cluster for Job Tracker=" + jobTrackAddr.toString());
125: Jason Lowe, debug, ForeachStmt, LOG.debug("Trying ClientProtocolProvider : " + provider.getClass().getName());
149: Gera Shegalov, info, CatchClause, LOG.info(errMsg, e);
142: Jason Lowe, debug, IfStmt, LOG.debug("Cannot pick " + provider.getClass().getName() + " as the ClientProtocolProvider - returned null protocol");
138: Jason Lowe, debug, IfStmt, LOG.debug("Picked " + provider.getClass().getName() + " as the ClientProtocolProvider");
137: Alejandro Abdelnur, debug, IfStmt, LOG.debug("IV written to Stream [" + Base64.encodeBase64URLSafeString(iv) + "]");
182: Alejandro Abdelnur, debug, IfStmt, LOG.debug("IV read from [" + Base64.encodeBase64URLSafeString(iv) + "]");
217: Alejandro Abdelnur, debug, IfStmt, LOG.debug("IV read from Stream [" + Base64.encodeBase64URLSafeString(iv) + "]");
1494: Chris Trezzo, error, IfStmt, LOG.error(confParam + " is mis-formatted, returning empty shared cache upload policies." + " Error on [" + s + "]");
1574: Mahadev Konar, info, MethodDeclaration, LOG.info("The url to track the job: " + getTrackingURL());
1619: Todd Lipcon, info, MethodDeclaration, LOG.info("Running job: " + jobId);
1640: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Job " + jobId + " running in uber mode : " + isUber());
1647: Todd Lipcon, info, IfStmt, LOG.info(report);
1660: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Job " + jobId + " failed with state " + status.getState() + " due to: " + status.getFailureInfo());
1658: Arun Murthy, info, IfStmt, LOG.info("Job " + jobId + " completed successfully");
1665: Todd Lipcon, info, IfStmt, LOG.info(counters.toString());
1680: Todd Lipcon, info, IfStmt, LOG.info(event.toString());
1686: Todd Lipcon, info, IfStmt, LOG.info(event.toString());
1699: Todd Lipcon, info, IfStmt, LOG.info(event.toString());
1703: Todd Lipcon, info, SwitchStmt, LOG.info(event.toString());
1715: Todd Lipcon, warn, IfStmt, LOG.warn(PROGRESS_MONITOR_POLL_INTERVAL_KEY + " has been set to an invalid value; " + " replacing with " + DEFAULT_MONITOR_POLL_INTERVAL);
1728: Todd Lipcon, warn, IfStmt, LOG.warn(COMPLETION_POLL_INTERVAL_KEY + " has been set to an invalid value; " + "replacing with " + DEFAULT_COMPLETION_POLL_INTERVAL);
147: Karthik Kambatla, warn, IfStmt, LOG.warn("Hadoop command-line option parsing not performed. " + "Implement the Tool interface and execute your application " + "with ToolRunner to remedy this.");
480: Karthik Kambatla, warn, IfStmt, LOG.warn("No job jar file set.  User classes may not be found. " + "See Job or Job#setJar(String).");
697: Chris Trezzo, warn, IfStmt, LOG.warn("Shared cache does not support directories" + " (see YARN-6097)." + " Will not upload " + filePath + " to the shared cache.");
718: Chris Trezzo, Error, CatchClause, LOG.warn("Error trying to contact the shared cache manager," + " disabling the SCMClient for the rest of this job submission", e);
751: Chris Trezzo, Error, CatchClause, LOG.warn("Error trying to convert URL received from shared cache to" + " a URI: " + url.toString());
804: Karthik Kambatla, debug, MethodDeclaration, LOG.debug("default FileSystem: " + jtFs.getUri());
893: Weiwei Yang, debug, IfStmt, LOG.debug("Ignore disabling erasure coding for path {} because method " + "disableErasureCodingForPath doesn't exist, probably " + "talking to a lower version HDFS.", path.toString(), e);
883: Weiwei Yang, info, IfStmt, LOG.info("Disabling Erasure Coding for path: " + path);
156: Alejandro Abdelnur, info, IfStmt, LOG.info("Permissions on staging directory " + stagingArea + " are " + "incorrect: " + fsStatus.getPermission() + ". Fixing permissions " + "to correct value " + JOB_DIR_PERMISSION);
263: Todd Lipcon, info, IfStmt, LOG.info("Cleaning up the staging area " + submitJobDir);
170: Todd Lipcon, debug, TryStmt, LOG.debug("Configuring job " + jobId + " with " + submitJobDir + " as the submit dir");
193: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Max job attempts set to 1 since encrypted intermediate" + "data spill is enabled");
202: Todd Lipcon, debug, TryStmt, LOG.debug("Creating splits at " + jtFs.makeQualified(submitJobDir));
205: Todd Lipcon, info, TryStmt, LOG.info("number of splits:" + maps);
301: Robert Joseph Evans, info, MethodDeclaration, LOG.info("Submitting tokens for job: " + jobId);
302: Akira Ajisaka, info, MethodDeclaration, LOG.info("Executing with tokens: {}", credentials.getAllTokens());
404: Todd Lipcon, info, IfStmt, LOG.info("loading user's secret keys from " + tokensFileName);
416: Todd Lipcon, warn, CatchClause, LOG.warn("couldn't parse Token Cache JSON file with user secret keys");
427: Todd Lipcon, debug, MethodDeclaration, LOG.debug("adding the following namenodes' delegation tokens:" + Arrays.toString(nameNodes));
235: Robert Joseph Evans, warn, IfStmt, LOG.warn("Group " + groupName + " is deprecated. Use " + newGroupName + " instead");
204: Zhijie Shen, warn, CatchClause, LOG.warn(counterName + " is not a recognized counter.");
162: Zhijie Shen, warn, IfStmt, LOG.warn(counter.getName() + "is not a known counter.");
172: Zhijie Shen, warn, IfStmt, LOG.warn(name + "is not a known counter.");
199: Zhijie Shen, warn, CatchClause, LOG.warn(counterName + " is not a recognized counter.");
117: Robert Joseph Evans, info, CatchClause, LOG.info("Caught exception parsing history file after " + eventCtr + " events", ioe);
293: Jason Darrell Lowe, Info, IfStmt, LOG.warn("TaskInfo is null for TaskAttemptUnsuccessfulCompletionEvent" + " taskId:  " + event.getTaskId().toString());
300: Jason Darrell Lowe, Info, IfStmt, LOG.warn("AttemptInfo is null for TaskAttemptUnsuccessfulCompletionEvent" + " taskAttemptId:  " + event.getTaskAttemptId().toString());
66: Todd Lipcon, error, IfStmt, LOG.error("Cannot find a range for NUMERIC or DECIMAL fields with one end NULL.");
133: Todd Lipcon, warn, IfStmt, LOG.warn("Set BigDecimal splitSize to MIN_INCREMENT");
207: Todd Lipcon, debug, CatchClause, LOG.debug("SQLException closing resultset: " + se.toString());
215: Todd Lipcon, debug, CatchClause, LOG.debug("SQLException closing statement: " + se.toString());
222: Todd Lipcon, debug, CatchClause, LOG.debug("SQLException committing split transaction: " + se.toString());
269: Todd Lipcon, warn, IfStmt, LOG.warn("Could not find " + SUBSTITUTE_TOKEN + " token in query: " + query + "; splits may not partition data.");
285: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Creating db record reader for db product: " + dbProductName);
125: Todd Lipcon, error, IfStmt, LOG.error("Could not find the clause substitution token " + DataDrivenDBInputFormat.SUBSTITUTE_TOKEN + " in the query: [" + inputQuery + "]. Parallel splits may not work correctly.");
134: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Using query: " + query.toString());
149: Todd Lipcon, warn, CatchClause, LOG.warn("Encountered a NULL date in the split column. Splits may be poorly balanced.");
371: Eli Collins, debug, CatchClause, LOG.debug("Exception on close", sqlE);
105: Todd Lipcon, warn, CatchClause, LOG.warn(StringUtils.stringifyException(ex));
50: Todd Lipcon, warn, MethodDeclaration, LOG.warn("Generating splits for a floating-point index column. Due to the");
51: Todd Lipcon, warn, MethodDeclaration, LOG.warn("imprecise representation of floating-point values in Java, this");
52: Todd Lipcon, warn, MethodDeclaration, LOG.warn("may result in an incomplete import.");
53: Todd Lipcon, warn, MethodDeclaration, LOG.warn("You are strongly encouraged to choose an integral split column.");
117: Todd Lipcon, error, CatchClause, LOG.error("Could not find method setSessionTimeZone in " + conn.getClass().getName(), ex);
132: Todd Lipcon, warn, CatchClause, LOG.warn("Time zone " + clientTimeZone + " could not be set on Oracle database.");
134: Todd Lipcon, warn, CatchClause, LOG.warn("Setting default time zone: GMT");
139: Todd Lipcon, error, CatchClause, LOG.error("Could not set time zone for oracle connection", ex2);
130: Todd Lipcon, info, TryStmt, LOG.info("Time zone has been set to " + clientTimeZone);
66: Todd Lipcon, warn, MethodDeclaration, LOG.warn("Generating splits for a textual index column.");
67: Todd Lipcon, warn, MethodDeclaration, LOG.warn("If your database sorts in a case-insensitive order, " + "this may result in a partial import or duplicate records.");
69: Todd Lipcon, warn, MethodDeclaration, LOG.warn("You are strongly encouraged to choose an integral split column.");
94: Todd Lipcon, info, MethodDeclaration, LOG.info(FieldSelectionHelper.specToString(fieldSeparator, mapOutputKeyValueSpec, allMapValueFieldsFrom, mapOutputKeyFieldList, mapOutputValueFieldList) + "\nignoreInputKey:" + ignoreInputKey);
90: Todd Lipcon, info, MethodDeclaration, LOG.info(FieldSelectionHelper.specToString(fieldSeparator, reduceOutputKeyValueSpec, allReduceValueFieldsFrom, reduceOutputKeyFieldList, reduceOutputValueFieldList));
605: Ray Chiang, debug, IfStmt, LOG.debug("File is not splittable so no parallelization " + "is possible: " + stat.getPath());
289: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Time taken to get FileStatuses: " + sw.now(TimeUnit.MILLISECONDS));
292: Devaraj K, info, MethodDeclaration, LOG.info("Total input files to process : " + result.size());
437: Ray Chiang, debug, IfStmt, LOG.debug("File is not splittable so no parallelization " + "is possible: " + file.getPath());
453: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Total # of splits generated by getSplits: " + splits.size() + ", TimeTaken: " + sw.now(TimeUnit.MILLISECONDS));
116: Sanford Ryza, info, IfStmt, LOG.info("Expecting " + numRecordsRemainingInSplit + " records each with a length of " + recordLength + " bytes in the split with an effective size of " + splitSize + " bytes");
105: Sanford Ryza, info, IfStmt, LOG.info("Compressed input; cannot compute number of records in the split");
165: Karthik Kambatla, info, IfStmt, LOG.info("Found UTF-8 BOM and skipped it");
203: Todd Lipcon, info, WhileStmt, LOG.info("Skipped line of size " + newSize + " at pos " + (pos - newSize));
264: Akira Ajisaka, warn, CatchClause, LOG.warn(e.toString());
339: Arun Murthy, info, CatchClause, LOG.info(getJobName() + " got an error while submitting ", ioe);
271: Arun Murthy, Error, CatchClause, LOG.error("Error while trying to run jobs.", t);
233: Arun Murthy, debug, WhileStmt, LOG.debug("Checking state of job " + j);
287: Arun Murthy, Error, CatchClause, LOG.error("Error while tyring to clean up " + j.getJobName(), e);
289: Arun Murthy, Error, CatchClause, LOG.error("Error while tyring to clean up " + j.getJobName(), e);
333: Robert Joseph Evans, error, IfStmt, LOG.error("Job control has circular dependency for the  job " + controlledJob.getJobName());
135: Todd Lipcon, debug, IfStmt, LOG.debug("Configuring multithread runner to use " + numberOfThreads + " threads");
140: Gera Shegalov, info, ConstructorDeclaration, LOG.info("File Output Committer Algorithm version is " + algorithmVersion);
155: Wangda Tan, info, ConstructorDeclaration, LOG.info("FileOutputCommitter skip cleanup _temporary folders under " + "output directory:" + skipCleanup + ", ignore cleanup failures: " + ignoreCleanupFailures);
358: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Output Path is null in setupJob()");
355: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Mkdirs failed to create " + jobAttemptPath);
381: Jian He, warn, IfStmt, LOG.warn("Exception get thrown in job commit, retry (" + attempt + ") time.", e);
441: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Output Path is null in commitJob()");
408: Wangda Tan, info, IfStmt, LOG.info("Skip cleanup the _temporary folders under job's output " + "directory in commitJob.");
456: Jason Lowe, debug, IfStmt, LOG.debug("Merging data from " + from + " to " + to);
528: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Output Path is null in cleanupJob()");
616: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Output Path is null in commitTask()");
613: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("No Output found for " + attemptId);
598: Gera Shegalov, info, IfStmt, LOG.info("Saved output of task '" + attemptId + "' to " + outputPath);
604: Jason Lowe, debug, IfStmt, LOG.debug(String.format("Deleting the temporary directory of '%s': '%s'", attemptId, taskAttemptPath));
608: Jason Lowe, warn, IfStmt, LOG.warn("Could not delete " + taskAttemptPath);
593: Gera Shegalov, info, IfStmt, LOG.info("Saved output of task '" + attemptId + "' to " + committedTaskPath);
641: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Output Path is null in abortTask()");
638: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Could not delete " + taskAttemptPath);
727: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Output Path is null in recoverTask()");
694: Jason Lowe, debug, IfStmt, LOG.debug("Trying to recover task from " + previousCommittedTaskPath);
719: Gera Shegalov, info, TryStmt, LOG.info("Recovering task for upgrading scenario, moving files from " + previousCommittedTaskPath + " to " + outputPath);
724: Gera Shegalov, info, IfStmt, LOG.info("Done recovering task " + attemptId);
711: Gera Shegalov, warn, IfStmt, LOG.warn(attemptId + " had no output to recover.");
243: Steve Loughran, debug, MethodDeclaration, LOG.debug("Work path is {}", workPath);
312: Steve Loughran, debug, MethodDeclaration, LOG.debug("Work file for {} extension '{}' is {}", context, extension, workFile);
48: Steve Loughran, debug, MethodDeclaration, LOG.debug("Using PathOutputCommitter implementation {}", clazz);
89: Christopher Douglas, info, MethodDeclaration, LOG.info("cleanUpPartialOutputForTask: removing everything belonging to " + context.getTaskAttemptID().getTaskID() + " in: " + getCommittedTaskPath(context).getParent());
60: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("Creating committer with output path {} and task context" + " {}", outputPath, context);
74: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("Creating committer with output path {} and job context" + " {}", outputPath, context);
132: Steve Loughran, debug, MethodDeclaration, LOG.debug("Creating FileOutputCommitter for path {} and context {}", outputPath, context);
164: Steve Loughran, debug, IfStmt, LOG.debug("No scheme-specific factory defined in {}", schemeKey);
161: Steve Loughran, debug, IfStmt, LOG.debug("Using schema-specific factory for {}", outputPath);
182: Steve Loughran, debug, IfStmt, LOG.debug("Using OutputCommitter factory class {} from key {}", factory, key);
174: Steve Loughran, debug, IfStmt, LOG.debug("No output committer factory defined," + " defaulting to FileOutputCommitterFactory");
204: Todd Lipcon, debug, MethodDeclaration, LOG.debug("seed: " + seed);
319: Todd Lipcon, info, MethodDeclaration, LOG.info("Using " + samples.length + " samples");
71: Todd Lipcon, warn, IfStmt, LOG.warn("Using deprecated num.key.fields.for.partition. " + "Use mapreduce.partition.keypartitioner.options instead");
147: Daryn Sharp, info, ForeachStmt, LOG.info("Got dt for " + fs.getUri() + "; " + token);
201: Todd Lipcon, debug, IfStmt, LOG.debug("Task: Loaded jobTokenFile from: " + localJobTokenFile.toUri().getPath() + "; num of sec keys  = " + ts.numberOfSecretKeys() + " Number of tokens " + ts.numberOfTokens());
138: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Max block location exceeded for split: " + split + " splitsize: " + locations.length + " maxsize: " + maxBlockLocations);
169: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Max block location exceeded for split: " + split + " splitsize: " + locations.length + " maxsize: " + maxBlockLocations);
61: Todd Lipcon, info, MethodDeclaration, LOG.info(reduce + " Thread started: " + getName());
76: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("EventFetcher is interrupted.. Returning");
79: Todd Lipcon, info, CatchClause, LOG.info("Exception in getting events", ie);
69: Todd Lipcon, info, IfStmt, LOG.info(reduce + ": " + "Got " + numNewMaps + " new map-outputs");
71: Todd Lipcon, debug, TryStmt, LOG.debug("GetMapEventsThread about to sleep for " + SLEEP_TIME);
104: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Got interrupted while joining " + getName(), ie);
127: Vinod Kumar Vavilapalli, debug, DoStmt, LOG.debug("Got " + events.length + " map completion events from " + fromEventIdx);
228: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Got interrupt while joining " + getName(), ie);
278: Robert Kanter, warn, CatchClause, LOG.warn("Connection rejected by the host " + te.host + ". Will retry later.");
284: Junping Du, warn, CatchClause, LOG.warn("Failed to connect to " + host + " with " + remaining.size() + " map outputs", ie);
318: Thomas Graves, debug, IfStmt, LOG.debug("Fetcher " + id + " going to fetch from " + host + " for: " + maps);
358: Thomas Graves, warn, IfStmt, LOG.warn("copyMapOutput failed for tasks " + Arrays.toString(failedTasks));
417: Jason Lowe, warn, IfStmt, LOG.warn("Failed to connect to host: " + url + "after " + fetchRetryTimeout + " milliseconds.");
444: Robert Kanter, warn, IfStmt, LOG.warn("Get a negative backoff value from ShuffleHandler. Setting" + " it to the default value " + FETCH_RETRY_DELAY_DEFAULT);
466: Jason Lowe, debug, MethodDeclaration, LOG.debug("url=" + msgToEncode + ";encHash=" + encHash + ";replyHash=" + replyHash);
469: Devaraj K, debug, MethodDeclaration, LOG.debug("for url=" + msgToEncode + " sent hash and received reply");
584: Jason Lowe, warn, IfStmt, LOG.warn("fetcher#" + id + " failed to read map header" + mapId + " decomp: " + decompressedLength + ", " + compressedLength, ioe);
594: Thomas Graves, warn, CatchClause, LOG.warn("Failed to shuffle output of " + mapId + " from " + host.getHostName(), ioe);
509: Todd Lipcon, warn, CatchClause, LOG.warn("Invalid map id ", e);
526: Thomas Graves, debug, IfStmt, LOG.debug("header: " + mapId + ", len: " + compressedLength + ", decomp len: " + decompressedLength);
542: Alejandro Abdelnur, info, IfStmt, LOG.info("fetcher#" + id + " - MergeManager returned status WAIT ...");
558: Jonathan Turner Eagles, warn, CatchClause, LOG.warn("Failed to shuffle for fetcher#" + id, e);
552: Jonathan Turner Eagles, info, TryStmt, LOG.info("fetcher#" + id + " about to shuffle output of map " + mapOutput.getMapId() + " decomp: " + decompressedLength + " len: " + compressedLength + " to " + mapOutput.getDescription());
621: Jason Lowe, warn, IfStmt, LOG.warn("Timeout for copying MapOutput with retry on host " + host + "after " + fetchRetryTimeout + " milliseconds.");
616: Jason Lowe, warn, IfStmt, LOG.warn("Shuffle output from " + host.getHostName() + " failed, retry it.", ioe);
640: Todd Lipcon, warn, IfStmt, LOG.warn(getName() + " invalid lengths in map output header: id: " + mapId + " len: " + compressedLength + ", decomp len: " + decompressedLength);
648: Todd Lipcon, warn, IfStmt, LOG.warn(getName() + " data for the wrong reduce map: " + mapId + " len: " + compressedLength + " decomp len: " + decompressedLength + " for reduce " + forReduce);
657: Todd Lipcon, warn, IfStmt, LOG.warn("Invalid map-output! Received output for " + mapId);
686: Todd Lipcon, debug, MethodDeclaration, LOG.debug("MapOutput URL for " + host + " -> " + url.toString());
723: Jason Lowe, error, IfStmt, LOG.error("Connection retry failed with " + attempts + " attempts in " + retryTimeInSeconds + " seconds");
739: Jason Lowe, warn, CatchClause, LOG.warn("Sleep in connection retry get interrupted.");
94: Alejandro Abdelnur, info, TryStmt, LOG.info("Read " + memory.length + " bytes from map-output for " + getMapId());
102: Sanford Ryza, debug, WhileStmt, LOG.debug("LocalFetcher " + id + " going to fetch: " + map);
140: Sanford Ryza, info, IfStmt, LOG.info("fetcher#" + id + " - MergeManager returned Status.WAIT ...");
145: Sanford Ryza, info, MethodDeclaration, LOG.info("localfetcher#" + id + " about to shuffle output of map " + mapOutput.getMapId() + " decomp: " + decompressedLength + " len: " + compressedLength + " to " + mapOutput.getDescription());
198: Gera Shegalov, info, IfStmt, LOG.info("The max number of bytes for a single in-memory shuffle cannot" + " be larger than Integer.MAX_VALUE. Setting it to Integer.MAX_VALUE");
208: Alejandro Abdelnur, info, ConstructorDeclaration, LOG.info("MergerManager: memoryLimit=" + memoryLimit + ", " + "maxSingleShuffleLimit=" + maxSingleShuffleLimit + ", " + "mergeThreshold=" + mergeThreshold + ", " + "ioSortFactor=" + ioSortFactor + ", " + "memToMemMergeOutputsThreshold=" + memToMemMergeOutputsThreshold);
269: Alejandro Abdelnur, info, IfStmt, LOG.info(mapId + ": Shuffling to disk since " + requestedSize + " is greater than maxSingleShuffleLimit (" + maxSingleShuffleLimit + ")");
293: Alejandro Abdelnur, debug, IfStmt, LOG.debug(mapId + ": Stalling shuffle since usedMemory (" + usedMemory + ") is greater than memoryLimit (" + memoryLimit + ")." + " CommitMemory is (" + commitMemory + ")");
300: Alejandro Abdelnur, debug, MethodDeclaration, LOG.debug(mapId + ": Proceeding with shuffle since usedMemory (" + usedMemory + ") is lesser than memoryLimit (" + memoryLimit + ")." + "CommitMemory is (" + commitMemory + ")");
323: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("closeInMemoryFile -> map-output of size: " + mapOutput.getSize() + ", inMemoryMapOutputs.size() -> " + inMemoryMapOutputs.size() + ", commitMemory -> " + commitMemory + ", usedMemory ->" + usedMemory);
331: Alejandro Abdelnur, info, IfStmt, LOG.info("Starting inMemoryMerger's merge since commitMemory=" + commitMemory + " > mergeThreshold=" + mergeThreshold + ". Current usedMemory=" + usedMemory);
350: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("closeInMemoryMergedFile -> size: " + mapOutput.getSize() + ", inMemoryMergedMapOutputs.size() -> " + inMemoryMergedMapOutputs.size());
411: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("Initiating Memory-to-Memory merge with " + noInMemorySegments + " segments of total-size: " + mergeOutputSize);
425: Alejandro Abdelnur, info, MethodDeclaration, LOG.info(reduceId + " Memory-to-Memory merge of the " + noInMemorySegments + " files in-memory complete.");
479: Alejandro Abdelnur, info, TryStmt, LOG.info("Initiating in-memory merge with " + noInMemorySegments + " segments...");
500: Alejandro Abdelnur, info, TryStmt, LOG.info(reduceId + " Merge of the " + noInMemorySegments + " files in-memory complete." + " Local file is " + outputPath + " of size " + localFS.getFileStatus(outputPath).getLen());
530: Alejandro Abdelnur, info, IfStmt, LOG.info("No ondisk files to merge...");
538: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("OnDiskMerger: We have  " + inputs.size() + " map outputs on disk. Triggering merge...");
584: Alejandro Abdelnur, info, MethodDeclaration, LOG.info(reduceId + " Finished merging " + inputs.size() + " map output files on disk of total-size " + approxOutputSize + "." + " Local output file is " + outputPath + " of size " + localFS.getFileStatus(outputPath).getLen());
695: Jason Lowe, info, MethodDeclaration, LOG.info("finalMerge called with " + inMemoryMapOutputs.size() + " in-memory map-outputs and " + onDiskMapOutputs.size() + " on-disk map-outputs");
768: Alejandro Abdelnur, info, IfStmt, LOG.info("Keeping " + numMemDiskSegments + " segments, " + inMemToDiskBytes + " bytes in memory for " + "intermediate, on-disk merge");
762: Alejandro Abdelnur, info, IfStmt, LOG.info("Merged " + numMemDiskSegments + " segments, " + inMemToDiskBytes + " bytes to disk to satisfy " + "reduce memory limit");
785: Alejandro Abdelnur, debug, ForeachStmt, LOG.debug("Disk file: " + file + " Length is " + fileLength);
792: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("Merging " + onDisk.length + " files, " + onDiskBytes + " bytes from disk");
807: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("Merging " + finalSegments.size() + " segments, " + inMemBytes + " bytes from memory into reduce");
65: Jason Darrell Lowe, info, IfStmt, LOG.info(getName() + ": Starting merge with " + toMergeInputs.size() + " segments, while ignoring " + inputs.size() + " segments");
118: Alejandro Abdelnur, info, TryStmt, LOG.info("Read " + (compressedLength - bytesLeft) + " bytes from map-output for " + getMapId());
154: Alejandro Abdelnur, info, CatchClause, LOG.info("failure to clean up " + tmpOutputPath, ie);
162: Arun Murthy, info, SwitchStmt, LOG.info("Ignoring obsolete output of " + event.getTaskStatus() + " map-task: '" + event.getTaskAttemptId() + "'");
167: Arun Murthy, info, SwitchStmt, LOG.info("Ignoring output of failed map TIP: '" + event.getTaskAttemptId() + "'");
222: Jason Lowe, warn, IfStmt, LOG.warn("Aborting already-finished MapOutput for " + mapId);
220: Arun Murthy, debug, IfStmt, LOG.debug("map " + mapId + " done " + status.getStateString());
336: Jason Darrell Lowe, error, CatchClause, LOG.error("Shuffle failed : local error on this node");
333: Jason Darrell Lowe, error, TryStmt, LOG.error("Shuffle failed : local error on this node: " + InetAddress.getLocalHost());
349: Tsuyoshi Ozawa, info, IfStmt, LOG.info("Reporting fetch failure for " + mapId + " to MRAppMaster.");
393: Akira Ajisaka, error, IfStmt, LOG.error("Shuffle failed with too many fetch failures " + "and insufficient progress!");
456: Daniel Templeton, debug, IfStmt, LOG.debug("Assigning " + host + " with " + host.getNumKnownMapOutputs() + " to " + Thread.currentThread().getName());
489: Daniel Templeton, debug, IfStmt, LOG.debug("assigned " + includedMaps + " of " + totalSize + " to " + host + " to " + Thread.currentThread().getName());
502: Arun Murthy, info, MethodDeclaration, LOG.info(host + " freed by " + Thread.currentThread().getName() + " in " + (Time.monotonicNow() - SHUFFLE_START.get()) + "ms");
170: Akira Ajisaka, Error, CatchClause, LOG.info("Error number format: ", ne);
666: Xuan, info, ForStmt, LOG.info("Could not obtain job info after " + String.valueOf(i + 1) + " attempt(s). Sleeping for " + String.valueOf(retryInterval / 1000) + " seconds and retrying.");
60: Todd Lipcon, warn, CatchClause, LOG.warn("setsid is not available on this machine. So not using it.");
63: Todd Lipcon, info, TryStmt, LOG.info("setsid exited with exit code " + shexec.getExitCode());
131: Todd Lipcon, Error, CatchClause, LOG.warn("Error executing shell command " + ioe);
137: Todd Lipcon, info, IfStmt, LOG.info("Signaling process " + pid + " with " + signalName + ". Exit code " + shexec.getExitCode());
134: Todd Lipcon, info, IfStmt, LOG.info("Sending signal to all members of process group " + pid + ": " + signalName + ". Exit code " + shexec.getExitCode());
206: Todd Lipcon, warn, CatchClause, LOG.warn("Thread sleep is interrupted.");
295: Todd Lipcon, Error, CatchClause, LOG.warn("Error executing shell command " + shexec.toString() + ioe);
320: Todd Lipcon, Error, CatchClause, LOG.warn("Error executing shell command " + shexec.toString() + ioe);
63: Vinod Kumar Vavilapalli, info, ConstructorDeclaration, LOG.info("Running with numThreads: " + numThreads);
74: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Using Test Dir: " + TEST_ROOT_DIR);
88: Robert Joseph Evans, DEBUG, MethodDeclaration, f = TaskLog.getRealTaskLogFileLocation(taid, true, LogName.DEBUGOUT);
97: Robert Joseph Evans, DEBUG, MethodDeclaration, assertTrue(readTaskLog(TaskLog.LogName.DEBUGOUT, taid, true).length() > 0);
107: Chris Trezzo, info, CatchClause, LOG.info("IO exception in closing file system");
85: Jason Lowe, warn, IfStmt, LOG.warn("Failed to delete test root dir and its content under " + TEST_ROOT_DIR);
261: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("created: " + p);
908: Robert Kanter, info, MethodDeclaration, LOG.info("out = " + outStr);
72: Vinod Kumar Vavilapalli, info, ConstructorDeclaration, LOG.info("Running with numThreads: " + numThreads);
83: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Using Test Dir: " + TEST_ROOT_DIR);
772: Jason Lowe, info, WhileStmt, LOG.info("Awaiting thread termination!");
95: Christopher Douglas, info, MethodDeclaration, LOG.info(">>>> " + name.getMethodName());
120: Christopher Douglas, info, MethodDeclaration, LOG.info("<<<< " + name.getMethodName());
128: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("testReduceOutOfDiskSpace");
580: Gera Shegalov, info, CatchClause, LOG.info("The expected checksum exception was thrown.", e);
72: Thomas Graves, info, MethodDeclaration, LOG.info("CachedHistoryStorage Init");
94: Robert Kanter, error, CatchClause, LOG.error("The property " + JHAdminConfig.MR_HISTORY_LOADED_TASKS_CACHE_SIZE + " is not an integer value.  Please set it to a positive" + " integer value.");
150: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Failed to execute refreshLoadedJobCache: CachedHistoryStorage is not started");
171: Robert Kanter, debug, IfStmt, LOG.debug("Looking for Job " + jobId);
202: Robert Kanter, error, IfStmt, LOG.error(e.getCause().getMessage());
213: Thomas Graves, debug, MethodDeclaration, LOG.debug("Called getAllPartialJobs()");
224: Siddharth Seth, Error, CatchClause, LOG.warn("Error trying to scan for all FileInfos", e);
99: Vinod Kumar Vavilapalli, info, ConstructorDeclaration, LOG.info("Loading job: " + jobId + " from file: " + historyFile);
189: Robert Kanter, error, CatchClause, LOG.error("Problem determining local host: " + e.getMessage());
313: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Cannot constuct TACEStatus from TaskAtemptState: [" + taStateString + "] for taskAttemptId: [" + taskAttempt.getID() + "]. Defaulting to KILLED");
372: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Loading history file: [" + historyFileAbsolute + "]");
397: Vinod Kumar Vavilapalli, Info, IfStmt, LOG.info("TaskInfo loaded");
147: Xuan Gong, info, MethodDeclaration, LOG.info("Instantiated HistoryClientService at " + this.bindAddress);
118: Siddharth Seth, error, IfStmt, LOG.error("Dropping " + key + " from the SerialNumberIndex. We will no " + "longer be able to see jobs that are in that serial index for " + cache.get(key));
216: Siddharth Seth, debug, IfStmt, LOG.debug("Adding " + jobId + " to job list cache with " + fileInfo.getJobIndexInfo());
248: Jason Lowe, Error, CatchClause, LOG.error("Error while trying to delete history files" + " that could not be moved to done.", e);
272: Zhihai Xu, warn, IfStmt, LOG.warn("Waiting to remove IN_INTERMEDIATE state histories " + "(e.g. " + firstInIntermediateKey + ") from JobListCache " + "because it is not in done yet. Total count is " + inIntermediateCount + ".");
278: Zhihai Xu, warn, IfStmt, LOG.warn("Waiting to remove MOVE_FAILED state histories " + "(e.g. " + firstMoveFailedKey + ") from JobListCache " + "because it is not in done yet. Total count is " + moveFailedCount + ".");
289: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Removing from cache " + fileInfo);
343: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Scan not needed of " + fs.getPath());
339: Jason Darrell Lowe, Error, CatchClause, LOG.error("Error while trying to scan the directory " + p, e);
396: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("moveToDone: " + historyFile);
401: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Move no longer pending");
453: Siddharth Seth, Error, CatchClause, LOG.error("Error while trying to move a job to done", t);
413: Siddharth Seth, info, IfStmt, LOG.info("No file for job-history with " + jobId + " found in cache!");
417: Siddharth Seth, info, IfStmt, LOG.info("No file for jobConf with " + jobId + " found in cache!");
426: Siddharth Seth, info, IfStmt, SUMMARY_LOG.info(jobSummaryString);
427: Siddharth Seth, info, IfStmt, LOG.info("Deleting JobSummary file: [" + summaryFile + "]");
422: Siddharth Seth, info, IfStmt, LOG.info("No summary file for job: " + jobId);
492: Jason Lowe, debug, IfStmt, LOG.debug("deleting " + historyFile + " and " + confFile);
532: Jason Lowe, warn, CatchClause, LOG.warn("Waiting has been interrupted");
681: Alejandro Abdelnur, info, IfStmt, LOG.info("Waiting for FileSystem at " + doneDirPrefixPath.toUri().getAuthority() + "to be available");
689: Alejandro Abdelnur, info, IfStmt, LOG.info("Waiting for FileSystem at " + doneDirPrefixPath.toUri().getAuthority() + "to be out of safe mode");
711: Alejandro Abdelnur, info, IfStmt, LOG.info("Waiting for FileSystem at " + intermediateDoneDirPath.toUri().getAuthority() + "to be available");
719: Alejandro Abdelnur, info, IfStmt, LOG.info("Waiting for FileSystem at " + intermediateDoneDirPath.toUri().getAuthority() + "to be out of safe mode");
760: Thomas Graves, info, CatchClause, LOG.info("Directory: [" + path + "] already exists.");
752: Thomas Graves, info, TryStmt, LOG.info("Perms after creating " + fsStatus.getPermission().toShort() + ", Expected: " + fsp.toShort());
755: Thomas Graves, info, IfStmt, LOG.info("Explicitly setting permissions to : " + fsp.toShort() + ", " + fsp);
778: Thomas Graves, info, MethodDeclaration, LOG.info("Initializing Existing Jobs...");
782: Robert Kanter, info, MethodDeclaration, LOG.info("Found " + timestampedDirList.size() + " directories to load");
796: Robert Kanter, info, IfStmt, LOG.info(currCacheSize * 100.0 / maxCacheSize + "% of cache is loaded.");
803: Robert Kanter, info, MethodDeclaration, LOG.info("Existing job initialization finished. " + loadedPercent + "% of cache is occupied.");
812: Thomas Graves, warn, IfStmt, LOG.warn("Could not find timestamp portion from path: " + serialDirPath.toString() + ". Continuing with next");
817: Thomas Graves, warn, IfStmt, LOG.warn("Could not find serial portion from path: " + serialDirPath.toString() + ". Continuing with next");
826: Thomas Graves, debug, IfStmt, LOG.debug("Adding " + serialDirPath + " to serial index");
832: Thomas Graves, warn, IfStmt, LOG.warn("Could not find timestamp portion from path: " + serialDirPath + ". Continuing with next");
837: Thomas Graves, warn, IfStmt, LOG.warn("Could not find serial portion from path: " + serialDirPath.toString() + ". Continuing with next");
846: Thomas Graves, debug, IfStmt, LOG.debug("Adding " + path + " to job list cache.");
852: Thomas Graves, debug, IfStmt, LOG.debug("Adding in history for " + fs.getPath());
882: Devaraj K, Error, CatchClause, LOG.error("Error while scanning directory " + path, fe);
918: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("Scanning intermediate dirs");
941: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Scanning intermediate dir " + absPath);
946: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Found " + fileStatusList.size() + " files");
950: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("scanning file: " + fs.getPath());
992: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Duplicate: deleting");
974: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Scheduling move to done of " + found);
983: Siddharth Seth, info, CatchClause, LOG.info("Failed to process fileInfo for job: " + found.getJobId(), e);
970: Siddharth Seth, Error, CatchClause, LOG.warn("Error cleaning up a HistoryFile that is out of date.", e);
1085: Thomas Graves, info, MethodDeclaration, LOG.info("Moving " + src.toString() + " to " + target.toString());
1114: Thomas Graves, info, TryStmt, LOG.info("Perms after creating " + fsStatus.getPermission().toShort() + ", Expected: " + fsp.toShort());
1117: Thomas Graves, info, IfStmt, LOG.info("Explicitly setting permissions to : " + fsp.toShort() + ", " + fsp);
90: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Using " + storeUri + " for history server state storage");
119: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Loading history server state from " + rootStatePath);
129: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Storing token " + tokenId.getSequenceNumber());
144: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Updating token " + tokenId.getSequenceNumber());
171: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Removing token " + tokenId.getSequenceNumber());
179: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Storing master key " + key.getKeyId());
205: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Removing master key " + key.getKeyId());
389: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Skipping unexpected file in history server token bucket: " + stat.getPath());
405: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Skipping unexpected file in history server token state: " + stat.getPath());
423: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Skipping unexpected file in history server token state: " + stat.getPath());
433: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Loaded " + numKeys + " master keys and " + numTokens + " tokens from " + tokenStatePath);
77: Jason Lowe, info, MethodDeclaration, LOG.info("Using state database at " + storeRoot + " for recovery");
83: Jason Lowe, info, IfStmt, LOG.info("Creating state database at " + dbfile);
111: Jason Lowe, info, MethodDeclaration, LOG.info("Recovered " + numKeys + " token master keys");
113: Jason Lowe, info, MethodDeclaration, LOG.info("Recovered " + numTokens + " tokens");
131: Jason Lowe, debug, IfStmt, LOG.debug("Loading master key from " + key);
177: Jason Lowe, debug, IfStmt, LOG.debug("Loading token from " + key);
214: Jason Lowe, debug, IfStmt, LOG.debug("Storing token " + tokenId.getSequenceNumber());
261: Jason Lowe, debug, IfStmt, LOG.debug("Storing master key " + masterKey.getKeyId());
286: Jason Lowe, debug, IfStmt, LOG.debug("Removing master key " + masterKey.getKeyId());
355: Jason Lowe, info, MethodDeclaration, LOG.info("Loaded state version info " + loadedVersion);
360: Jason Lowe, info, IfStmt, LOG.info("Storing state version info " + getCurrentVersion());
65: Jason Darrell Lowe, info, IfStmt, LOG.info(createSuccessLog(user, operation, target));
133: Jason Darrell Lowe, warn, IfStmt, LOG.warn(createFailureLog(user, operation, perm, target, description));
63: Jason Darrell Lowe, error, IfStmt, LOG.error(message);
78: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Storing master key " + key.getKeyId());
83: Jason Darrell Lowe, error, CatchClause, LOG.error("Unable to store master key " + key.getKeyId(), e);
90: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Removing master key " + key.getKeyId());
95: Jason Darrell Lowe, error, CatchClause, LOG.error("Unable to remove master key " + key.getKeyId(), e);
103: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Storing token " + tokenId.getSequenceNumber());
108: Jason Darrell Lowe, error, CatchClause, LOG.error("Unable to store token " + tokenId.getSequenceNumber(), e);
116: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Storing token " + tokenId.getSequenceNumber());
121: Jason Darrell Lowe, error, CatchClause, LOG.error("Unable to remove token " + tokenId.getSequenceNumber(), e);
129: Jason Darrell Lowe, debug, IfStmt, LOG.debug("Updating token " + tokenId.getSequenceNumber());
134: Jason Darrell Lowe, error, CatchClause, LOG.error("Unable to update token " + tokenId.getSequenceNumber(), e);
139: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Recovering " + getClass().getSimpleName());
86: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("JobHistory Init");
149: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Stopping JobHistory");
151: Siddharth Seth, info, IfStmt, LOG.info("Stopping History Cleaner/Move To Done");
164: Siddharth Seth, warn, IfStmt, LOG.warn("HistoryCleanerService/move to done shutdown may not have " + "succeeded, Forcing a shutdown");
194: Siddharth Seth, Error, CatchClause, LOG.error("Error while scanning intermediate done dir ", e);
191: Siddharth Seth, info, TryStmt, LOG.info("Starting scan to move intermediate done files");
201: Siddharth Seth, info, MethodDeclaration, LOG.info("History Cleaner started");
205: Siddharth Seth, Error, CatchClause, LOG.warn("Error trying to clean up ", e);
207: Siddharth Seth, info, MethodDeclaration, LOG.info("History Cleaner complete");
226: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Called getAllJobs(AppId): " + appID);
251: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Failed to execute refreshLoadedJobCache: JobHistory service is not started");
303: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Failed to execute refreshJobRetentionSettings : Job History service is not started");
99: Jason Darrell Lowe, Error, CatchClause, LOG.error("Error while starting the Secret Manager threads", io);
229: Akira Ajisaka, Error, CatchClause, LOG.error("Error starting JobHistoryServer", t);
167: Jason Darrell Lowe, warn, CatchClause, LOG.warn("Couldn't get current user", ioe);
176: Jason Darrell Lowe, warn, IfStmt, LOG.warn("User " + user.getShortUserName() + " doesn't have permission" + " to call '" + method + "'");
186: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("HS Admin: " + method + " invoked by user " + user.getShortUserName());
74: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Getting list of all Jobs.");
59: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("JOBID is " + TypeConverter.fromYarn(jobId).toString());
120: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("JOBID is " + TypeConverter.fromYarn(jobId).toString());
168: Sanford Ryza, info, MethodDeclaration, LOG.info("JOBID is " + TypeConverter.fromYarn(jobId).toString());
133: Siddharth Seth, info, MethodDeclaration, LOG.info("STARTING testHistoryParsing()");
137: Siddharth Seth, info, TryStmt, LOG.info("FINISHED testHistoryParsing()");
143: Siddharth Seth, info, MethodDeclaration, LOG.info("STARTING testHistoryParsingWithParseErrors()");
147: Siddharth Seth, info, TryStmt, LOG.info("FINISHED testHistoryParsingWithParseErrors()");
174: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("JOBID is " + TypeConverter.fromYarn(jobId).toString());
187: Siddharth Seth, info, CatchClause, LOG.info("Can not get FileContext", ioe);
246: Siddharth Seth, info, SynchronizedStmt, LOG.info("JobHistoryFile is: " + historyFilePath);
250: Siddharth Seth, info, CatchClause, LOG.info("Can not open history file: " + historyFilePath, ioe);
403: Siddharth Seth, info, MethodDeclaration, LOG.info("STARTING testHistoryParsingForFailedAttempts");
462: Siddharth Seth, info, TryStmt, LOG.info("FINISHED testHistoryParsingForFailedAttempts");
434: Jason Darrell Lowe, info, CatchClause, LOG.info("Can not open history file: " + historyFilePath, ioe);
470: Haibo Chen, info, MethodDeclaration, LOG.info("STARTING testHistoryParsingForKilledAndFailedAttempts");
526: Haibo Chen, info, TryStmt, LOG.info("FINISHED testHistoryParsingForKilledAndFailedAttempts");
510: Haibo Chen, info, CatchClause, LOG.info("Can not open history file: " + historyFilePath, ioe);
538: Robert Joseph Evans, info, MethodDeclaration, LOG.info("STARTING testCountersForFailedTask");
595: Robert Joseph Evans, info, TryStmt, LOG.info("FINISHED testCountersForFailedTask");
570: Jason Darrell Lowe, info, CatchClause, LOG.info("Can not open history file: " + historyFilePath, ioe);
601: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("STARTING testDiagnosticsForKilledJob");
654: Jason Darrell Lowe, info, TryStmt, LOG.info("FINISHED testDiagnosticsForKilledJob");
633: Jason Darrell Lowe, info, CatchClause, LOG.info("Can not open history file: " + historyFilePath, ioe);
660: Siddharth Seth, info, MethodDeclaration, LOG.info("STARTING testScanningOldDirs");
700: Siddharth Seth, info, TryStmt, LOG.info("FINISHED testScanningOldDirs");
672: Thomas Graves, info, TryStmt, LOG.info("JOBID is " + TypeConverter.fromYarn(jobId).toString());
817: Thomas Graves, info, MethodDeclaration, LOG.info("STARTING testDeleteFileInfo");
863: Thomas Graves, info, TryStmt, LOG.info("FINISHED testDeleteFileInfo");
872: Thomas Graves, info, MethodDeclaration, LOG.info("STARTING testJobHistoryMethods");
917: Thomas Graves, info, TryStmt, LOG.info("FINISHED testJobHistoryMethods");
886: Thomas Graves, info, TryStmt, LOG.info("JOBID is " + TypeConverter.fromYarn(jobId).toString());
1019: Jason Darrell Lowe, info, MethodDeclaration, LOG.info(" job info: " + jobInfo.getJobname() + " " + jobInfo.getSucceededMaps() + " " + jobInfo.getTotalMaps() + " " + jobInfo.getJobId());
1037: Jason Darrell Lowe, info, MethodDeclaration, LOG.info(" job info: " + jobInfo.getJobname() + " " + jobInfo.getSucceededMaps() + " " + jobInfo.getTotalMaps() + " " + jobInfo.getJobId());
1055: Jason Darrell Lowe, info, MethodDeclaration, LOG.info(" job info: " + jobInfo.getJobname() + " " + jobInfo.getSucceededMaps() + " " + jobInfo.getTotalMaps() + " " + jobInfo.getJobId());
70: Mahadev Konar, info, MethodDeclaration, LOG.info("HsJobPage");
78: Mahadev Konar, info, MethodDeclaration, LOG.info("HsTasksPage");
87: Rohith Sharma K S, info, MethodDeclaration, LOG.info("HsTasksPage");
99: Mahadev Konar, info, MethodDeclaration, LOG.info("HsTaskPage");
108: Rohith Sharma K S, info, MethodDeclaration, LOG.info("HsTaskPage");
119: Mahadev Konar, info, MethodDeclaration, LOG.info("HsAttemptsPage with data");
131: Mahadev Konar, info, MethodDeclaration, LOG.info("HsAttemptsPage");
139: Mahadev Konar, info, MethodDeclaration, LOG.info("HsConfPage");
145: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("HsAboutPage");
151: Arun Murthy, info, MethodDeclaration, LOG.info("JobCounterView");
159: Thomas Graves, info, MethodDeclaration, LOG.info("JobCounterViewForKilledJob");
167: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("HsSingleCounterPage");
174: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("HsLogsPage");
186: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("HsLogsPage with data");
208: Robert Joseph Evans, info, MethodDeclaration, LOG.info("HsLogsPage with params for single log and data limits");
243: Robert Joseph Evans, info, MethodDeclaration, LOG.info("HsLogsPage with bad start/end params");
62: Mahadev Konar, warn, CatchClause, LOG.warn("Could not connect to History server.", e);
88: Arun Murthy, debug, MethodDeclaration, LOG.debug("Connecting to HistoryServer at: " + serviceAddr);
90: Arun Murthy, debug, MethodDeclaration, LOG.debug("Connected to HistoryServer at: " + serviceAddr);
170: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Could not get Job info from RM for job " + jobId + ". Redirecting to job history server.");
228: Arun Murthy, warn, CatchClause, LOG.warn("getProxy() call interruped", e1);
237: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Could not get Job info from RM for job " + jobId + ". Redirecting to job history server.");
242: Arun Murthy, warn, CatchClause, LOG.warn("getProxy() call interruped", e);
184: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Job " + jobId + " is running, but the host is unknown." + " Verify user has VIEW_JOB access.");
176: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("AM not assigned to Job. Waiting to get the AM ...");
179: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Application state is " + application.getYarnApplicationState());
212: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Network ACL closed to AM for job " + jobId + ". Not going to try to reach the AM.");
202: Mahadev Konar, debug, IfStmt, LOG.debug("Connecting to " + serviceAddr);
279: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Application state is completed. FinalApplicationStatus=" + application.getFinalApplicationStatus().toString() + ". Redirecting to job history server");
290: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Job History Server is not configured.");
298: Vinod Kumar Vavilapalli, trace, MethodDeclaration, LOG.trace("Connecting to ApplicationMaster at: " + serviceAddr);
304: Vinod Kumar Vavilapalli, trace, MethodDeclaration, LOG.trace("Connected to ApplicationMaster at: " + serviceAddr);
329: Arun Murthy, debug, CatchClause, LOG.debug("Failed to contact AM/History for job " + jobId + " retrying..", e.getTargetException());
349: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("ClientServiceDelegate invoke call interrupted", ie);
353: Arun Murthy, debug, CatchClause, LOG.debug("Failed to contact AM/History for job " + jobId + "  Will retry..", e);
363: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("ClientServiceDelegate invoke call interrupted", ie);
153: Vinod Kumar Vavilapalli, warn, MethodDeclaration, LOG.warn("getBlacklistedTrackers - Not implemented yet");
258: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("getStagingAreaDir: dir=" + path);
396: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("Creating setup context, jobSubmitDir url is " + yarnUrlForJobSubmitDir);
518: Arun Murthy, debug, MethodDeclaration, LOG.debug("Command to launch container for ApplicationMaster is : " + mergedCommand);
613: subru, warn, CatchClause, LOG.warn(errMsg);
618: subru, info, IfStmt, LOG.info("SUBMITTING ApplicationSubmissionContext app:" + applicationId + " to queue:" + appContext.getQueue() + " with reservationId:" + appContext.getReservationID());
704: Daniel Templeton, warn, IfStmt, LOG.warn("Configuration " + MR_AM_RESOURCE_PREFIX + resourceName + "=" + resourceReq.getValue() + resourceReq.getUnits() + " is overriding the " + MRJobConfig.MR_AM_CPU_VCORES + "=" + conf.get(MRJobConfig.MR_AM_CPU_VCORES) + " configuration");
692: Daniel Templeton, warn, IfStmt, LOG.warn("Configuration " + MR_AM_RESOURCE_PREFIX + resourceName + "=" + resourceReq.getValue() + resourceReq.getUnits() + " is overriding the " + MRJobConfig.MR_AM_VMEM_MB + "=" + conf.get(MRJobConfig.MR_AM_VMEM_MB) + " configuration");
740: Robert Kanter, debug, IfStmt, LOG.debug("AppMaster capability = " + capability);
778: Robert Kanter, warn, IfStmt, LOG.warn(errMsg);
784: Robert Kanter, debug, ForeachStmt, LOG.debug("ResourceRequest: resource = " + amResourceRequest.getResourceName() + ", locality = " + amResourceRequest.getRelaxLocality());
820: Jason Lowe, info, MethodDeclaration, LOG.info("Send configurations that match regex expression: " + regex + " , total number of configs: " + count + ", total size : " + dob.getLength() + " bytes.");
827: Jason Lowe, info, ForStmt, LOG.info(entry.getKey() + " ===> " + entry.getValue());
965: Mahadev Konar, Error, CatchClause, LOG.debug("Error when checking for application status", io);
1005: Jonathan Turner Eagles, warn, IfStmt, LOG.warn("Usage of -Djava.library.path in " + javaConf + " can cause " + "programs to no longer function if hadoop native libraries " + "are used. These values should be set as part of the " + "LD_LIBRARY_PATH in the " + component + " JVM env using " + envConf + " config settings.");
62: Konstantin Boudnik, info, InitializerDeclaration, LOG.info(ALL_PROBABILITIES + "=" + conf.get(ALL_PROBABILITIES));
99: Todd Lipcon, debug, MethodDeclaration, LOG.debug("Request for " + newProbName + " returns=" + ret);
62: Todd Lipcon, info, ConstructorDeclaration, LOG.info("Starting AccumulatingReducer on " + hostName);
127: Todd Lipcon, info, MethodDeclaration, LOG.info("creating control file: " + fileSize + " mega bytes, " + nrFiles + " files");
148: Todd Lipcon, info, MethodDeclaration, LOG.info("created control files for: " + nrFiles + " files");
177: Todd Lipcon, info, MethodDeclaration, LOG.info("Number of bytes processed = " + totalSize);
178: Todd Lipcon, info, MethodDeclaration, LOG.info("Exec time = " + execTime);
179: Todd Lipcon, info, MethodDeclaration, LOG.info("IO rate = " + ioRateMbSec);
437: Todd Lipcon, info, MethodDeclaration, LOG.info("nrFiles = " + nrFiles);
438: Todd Lipcon, info, MethodDeclaration, LOG.info("fileSize (MB) = " + fileSize);
439: Todd Lipcon, info, MethodDeclaration, LOG.info("bufferSize = " + bufferSize);
465: Todd Lipcon, info, IfStmt, LOG.info(resultLine);
542: Todd Lipcon, info, ForStmt, LOG.info(resultLines[i]);
548: Todd Lipcon, info, MethodDeclaration, LOG.info("Cleaning up test files");
115: Todd Lipcon, info, MethodDeclaration, LOG.info("Created map input files.");
182: Todd Lipcon, info, CatchClause, LOG.info("Corrupted block detected in \"" + name + "\" at " + offset);
205: Todd Lipcon, info, MethodDeclaration, LOG.info("Number of bytes processed = " + totalSize);
206: Todd Lipcon, info, MethodDeclaration, LOG.info("Exec time = " + execTime);
207: Todd Lipcon, info, MethodDeclaration, LOG.info("IO rate = " + ioRateMbSec);
261: Todd Lipcon, info, MethodDeclaration, LOG.info("root = " + rootName);
262: Todd Lipcon, info, MethodDeclaration, LOG.info("bufferSize = " + bufferSize);
352: Todd Lipcon, info, ForStmt, LOG.info(cur);
358: Todd Lipcon, info, MethodDeclaration, LOG.info("Cleaning up test files");
218: Todd Lipcon, error, CatchClause, LOG.error("FileCreateDaemon failed.", ex);
248: Todd Lipcon, info, IfStmt, LOG.info("Finished " + numFinishedThreads + " threads out of " + numRunningThreads);
259: Todd Lipcon, info, MethodDeclaration, LOG.info("creating control file: JH log dir = " + jhLogDir);
261: Todd Lipcon, info, MethodDeclaration, LOG.info("created control file: JH log dir = " + jhLogDir);
321: Todd Lipcon, error, IfStmt, LOG.error("Incorrect JOBID: " + keyVal[1].substring(0, Math.min(keyVal[1].length(), 100)) + " expect " + JOBID);
352: Todd Lipcon, error, IfStmt, LOG.error("TASKID = NULL for job " + JOBID);
412: Todd Lipcon, error, IfStmt, LOG.error("Incorrect TASKID: " + keyVal[1].substring(0, Math.min(keyVal[1].length(), 100)) + " expect " + TASKID);
443: Todd Lipcon, error, IfStmt, LOG.error("Incorrect TASK_TYPE: " + from.TASK_TYPE + " expect " + TASK_TYPE + " for task " + TASKID);
461: Todd Lipcon, error, IfStmt, LOG.error("Unexpected TASK_ATTEMPT_ID = null for task " + TASKID);
518: Todd Lipcon, error, IfStmt, LOG.error("Incorrect TASKID: " + keyVal[1] + " expect " + taskID);
510: Todd Lipcon, error, IfStmt, LOG.error("Incorrect TASKID: " + keyVal[1] + " expect " + taskID);
764: Todd Lipcon, error, CatchClause, LOG.error("JHLAMapper.parseLogFile", ie);
706: Todd Lipcon, info, TryStmt, LOG.info("Opened " + filePath);
713: Todd Lipcon, info, IfStmt, LOG.info("Codec created " + filePath);
717: Todd Lipcon, info, TryStmt, LOG.info("Reader created " + filePath);
743: Todd Lipcon, info, IfStmt, LOG.info(txt);
747: Todd Lipcon, info, IfStmt, LOG.info("Finished parsing job: " + jh.JOBID + " line count = " + jobLineCount);
750: Todd Lipcon, info, IfStmt, LOG.info("Collected stats for job: " + jh.JOBID);
758: Todd Lipcon, error, IfStmt, LOG.error("JOBID = NULL in " + filePath + " at " + processed);
863: Todd Lipcon, error, IfStmt, LOG.error("Start time 0 for task attempt " + tah.TASK_ATTEMPT_ID);
867: Todd Lipcon, error, IfStmt, LOG.error("Finish time " + tah.FINISH_TIME + " is less than " + "Start time " + tah.START_TIME + " for task attempt " + tah.TASK_ATTEMPT_ID);
875: Todd Lipcon, error, IfStmt, LOG.error("Unexpected TASK_TYPE = " + th.TASK_TYPE + " for attempt " + tah.TASK_ATTEMPT_ID);
902: Todd Lipcon, info, MethodDeclaration, LOG.info("Total    Maps = " + jh.TOTAL_MAPS + "  Reduces = " + jh.TOTAL_REDUCES);
904: Todd Lipcon, info, MethodDeclaration, LOG.info("Finished Maps = " + jh.FINISHED_MAPS + "  Reduces = " + jh.FINISHED_REDUCES);
906: Todd Lipcon, info, MethodDeclaration, LOG.info("numAttempts = " + numAttempts);
907: Todd Lipcon, info, MethodDeclaration, LOG.info("totalTime   = " + totalTime);
908: Todd Lipcon, info, MethodDeclaration, LOG.info("averageAttemptTime = " + (numAttempts == 0 ? 0 : totalTime / numAttempts));
910: Todd Lipcon, info, MethodDeclaration, LOG.info("jobTotalTime = " + (jh.FINISH_TIME <= jh.SUBMIT_TIME ? 0 : jh.FINISH_TIME - jh.SUBMIT_TIME));
973: Todd Lipcon, info, MethodDeclaration, LOG.info(key + " == " + value);
1026: Todd Lipcon, info, IfStmt, LOG.info("Start JHLA test ============ ");
1080: Chris Douglas, info, MethodDeclaration, LOG.info("Analyzing results ...");
1122: Chris Douglas, info, MethodDeclaration, LOG.info("Analyzing results ... done.");
1126: Todd Lipcon, info, MethodDeclaration, LOG.info("Cleaning up test files");
297: Konstantin Shvachko, info, MethodDeclaration, LOG.info("creating control file: " + nrBytes + " bytes, " + nrFiles + " files");
329: Kai Zheng, info, MethodDeclaration, LOG.info("created control files for: " + nrFiles + " files");
386: Todd Lipcon, info, MethodDeclaration, LOG.info("Number of bytes processed = " + totalSize);
387: Todd Lipcon, info, MethodDeclaration, LOG.info("Exec time = " + execTime);
388: Todd Lipcon, info, MethodDeclaration, LOG.info("IO rate = " + ioRateMbSec);
424: Konstantin Shvachko, info, MethodDeclaration, LOG.info("out = " + out.getClass().getName());
495: Konstantin Shvachko, info, MethodDeclaration, LOG.info("out = " + out.getClass().getName());
541: Konstantin Shvachko, info, MethodDeclaration, LOG.info("in = " + in.getClass().getName());
606: Konstantin Shvachko, info, MethodDeclaration, LOG.info("in = " + in.getClass().getName());
607: Konstantin Shvachko, info, MethodDeclaration, LOG.info("skipSize = " + skipSize);
767: Todd Lipcon, info, MethodDeclaration, LOG.info(version);
826: Todd Lipcon, info, MethodDeclaration, LOG.info("nrFiles = " + nrFiles);
827: Konstantin Shvachko, info, MethodDeclaration, LOG.info("nrBytes (MB) = " + toMB(nrBytes));
828: Todd Lipcon, info, MethodDeclaration, LOG.info("bufferSize = " + bufferSize);
830: Konstantin Shvachko, info, IfStmt, LOG.info("skipSize = " + skipSize);
832: Todd Lipcon, info, MethodDeclaration, LOG.info("baseDir = " + getBaseDir(config));
836: Konstantin Shvachko, info, IfStmt, LOG.info("compressionClass = " + compressionClass);
860: Todd Lipcon, info, IfStmt, LOG.info(resultLine);
957: Kai Zheng, info, MethodDeclaration, LOG.info("erasureCodePolicy = " + erasureCodePolicyName);
987: Kai Zheng, info, MethodDeclaration, LOG.info("storagePolicy = " + storagePolicy);
1009: Kai Zheng, info, IfStmt, LOG.info("enable erasureCodePolicy = " + erasureCodePolicyName + " on " + path.toString());
1070: Todd Lipcon, info, ForStmt, LOG.info(resultLines[i]);
1105: Todd Lipcon, info, MethodDeclaration, LOG.info("Cleaning up test files");
89: Todd Lipcon, info, MethodDeclaration, LOG.info("seed = " + seed);
127: Todd Lipcon, info, MethodDeclaration, LOG.info("creating control file: " + megaBytes + " bytes, " + numFiles + " files");
157: Todd Lipcon, info, MethodDeclaration, LOG.info("created control file for: " + totalSize + " bytes");
482: Todd Lipcon, info, MethodDeclaration, LOG.info("seed = " + seed);
483: Todd Lipcon, info, MethodDeclaration, LOG.info("files = " + files);
484: Todd Lipcon, info, MethodDeclaration, LOG.info("megaBytes = " + megaBytes);
525: Haohui Mai, warn, CatchClause, LOG.warn("Cannot test HdfsClientConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT (=" + HdfsClientConfigKeys.DFS_NAMENODE_RPC_PORT_DEFAULT + ")", be);
540: Todd Lipcon, info, TryStmt, LOG.info("uri=" + uri);
555: Todd Lipcon, info, IfStmt, LOG.info("uri2=" + uri2);
48: Todd Lipcon, error, IfStmt, LOG.error("Cannot create dirs for history log file: " + historyLog);
50: Todd Lipcon, error, BlockStmt, LOG.error("Cannot create history log file: " + historyLog);
128: Todd Lipcon, error, BlockStmt, LOG.error("Cannot delete history log file: " + historyLog);
130: Todd Lipcon, error, BlockStmt, LOG.error("Cannot delete history log dir: " + historyLog);
103: Todd Lipcon, Error, CatchClause, LOG.warn("Error with appending", e);
107: Todd Lipcon, Error, CatchClause, LOG.warn("Error with appending", e);
113: Todd Lipcon, Error, CatchClause, LOG.warn("Error with closing append stream", e);
75: Todd Lipcon, info, TryStmt, LOG.info("Attempting to append to file at " + fn + " of size " + Helper.toByteInfo(appendSize));
98: Todd Lipcon, info, TryStmt, LOG.info("Appended " + Helper.toByteInfo(bytesAppended) + " to file " + fn + " in " + timeTaken + " milliseconds");
718: Todd Lipcon, info, MethodDeclaration, LOG.info("Base directory = " + cfg.getBaseDirectory());
719: Todd Lipcon, info, MethodDeclaration, LOG.info("Data directory = " + cfg.getDataPath());
720: Todd Lipcon, info, MethodDeclaration, LOG.info("Output directory = " + cfg.getOutputPath());
721: Todd Lipcon, info, MethodDeclaration, LOG.info("Result file = " + cfg.getResultFile());
722: Todd Lipcon, info, MethodDeclaration, LOG.info("Grid queue = " + cfg.getQueueName());
723: Todd Lipcon, info, MethodDeclaration, LOG.info("Should exit on first error = " + cfg.shouldExitOnFirstError());
731: Todd Lipcon, info, BlockStmt, LOG.info(duration);
733: Todd Lipcon, info, MethodDeclaration, LOG.info("Map amount = " + cfg.getMapAmount());
734: Todd Lipcon, info, MethodDeclaration, LOG.info("Reducer amount = " + cfg.getReducerAmount());
735: Todd Lipcon, info, MethodDeclaration, LOG.info("Operation amount = " + cfg.getOpCount());
736: Todd Lipcon, info, MethodDeclaration, LOG.info("Total file limit = " + cfg.getTotalFiles());
737: Todd Lipcon, info, MethodDeclaration, LOG.info("Total dir file limit = " + cfg.getDirSize());
745: Todd Lipcon, info, BlockStmt, LOG.info(read);
754: Todd Lipcon, info, BlockStmt, LOG.info(write);
763: Todd Lipcon, info, BlockStmt, LOG.info(append);
768: Todd Lipcon, info, BlockStmt, LOG.info(bsize);
771: Todd Lipcon, info, IfStmt, LOG.info("Random seed = " + cfg.getRandomSeed());
774: Todd Lipcon, info, IfStmt, LOG.info("Sleep range = " + cfg.getSleepRange() + " milliseconds");
776: Todd Lipcon, info, MethodDeclaration, LOG.info("Replication amount = " + cfg.getReplication());
777: Todd Lipcon, info, MethodDeclaration, LOG.info("Operations are:");
782: Todd Lipcon, info, ForeachStmt, LOG.info(name);
784: Todd Lipcon, info, ForeachStmt, LOG.info(" " + opInfo.getDistribution().name());
788: Todd Lipcon, info, IfStmt, LOG.info(" ???");
786: Todd Lipcon, info, IfStmt, LOG.info(" " + percFormatter.format(opInfo.getPercent()));
170: Todd Lipcon, Error, CatchClause, LOG.warn("Error with creating", e);
176: Todd Lipcon, Error, CatchClause, LOG.warn("Error closing create stream", e);
137: Todd Lipcon, info, TryStmt, LOG.info("Attempting to create file at " + fn + " of size " + Helper.toByteInfo(writeSize) + " using blocksize " + Helper.toByteInfo(blockSize) + " and replication amount " + replicationAmount);
156: Todd Lipcon, info, TryStmt, LOG.info("Created file at " + fn + " of size " + Helper.toByteInfo(bytesWritten) + " bytes using blocksize " + Helper.toByteInfo(blockSize) + " and replication amount " + replicationAmount + " in " + timeTaken + " milliseconds");
83: Todd Lipcon, Error, CatchClause, LOG.warn("Error with deleting", e);
87: Todd Lipcon, Error, CatchClause, LOG.warn("Error with deleting", e);
78: Todd Lipcon, info, IfStmt, LOG.info("Could delete " + fn);
72: Todd Lipcon, info, IfStmt, LOG.info("Could not delete " + fn);
84: Todd Lipcon, Error, CatchClause, LOG.warn("Error with listing", e);
88: Todd Lipcon, Error, CatchClause, LOG.warn("Error with listing", e);
80: Todd Lipcon, info, TryStmt, LOG.info("Directory " + dir + " has " + dirEntries + " entries");
86: Todd Lipcon, Error, CatchClause, LOG.warn("Error with mkdir", e);
90: Todd Lipcon, Error, CatchClause, LOG.warn("Error with mkdir", e);
81: Todd Lipcon, warn, IfStmt, LOG.warn("Could not make " + dir);
77: Todd Lipcon, info, IfStmt, LOG.info("Made directory " + dir);
121: Todd Lipcon, Error, CatchClause, LOG.warn("Error with reading", e);
125: Todd Lipcon, Error, CatchClause, LOG.warn("Error reading bad file", e);
129: Todd Lipcon, Error, CatchClause, LOG.warn("Error reading", e);
135: Todd Lipcon, Error, CatchClause, LOG.warn("Error closing read stream", e);
84: Todd Lipcon, info, TryStmt, LOG.info("Attempting to read file at " + fn + " of size (" + readStrAm + ")");
113: Todd Lipcon, info, TryStmt, LOG.info("Read " + Helper.toByteInfo(bytesRead) + " of " + fn + " with " + chunkSame + " chunks being same as expected and " + chunkDiff + " chunks being different than expected in " + timeTaken + " milliseconds");
111: Todd Lipcon, Error, CatchClause, LOG.warn("Error with renaming", e);
115: Todd Lipcon, Error, CatchClause, LOG.warn("Error with renaming", e);
106: Todd Lipcon, warn, IfStmt, LOG.warn("Could not rename " + src + " to " + target);
102: Todd Lipcon, info, IfStmt, LOG.info("Renamed " + src + " to " + target);
72: Todd Lipcon, info, MethodDeclaration, LOG.info(msg);
70: Todd Lipcon, Error, CatchClause, LOG.warn("Error with sleeping", e);
70: Todd Lipcon, error, CatchClause, LOG.error("Unable to setup slive " + StringUtils.stringifyException(e));
102: Todd Lipcon, info, MethodDeclaration, LOG.info(msg);
55: Todd Lipcon, info, MethodDeclaration, LOG.info(msg);
90: Todd Lipcon, info, TryStmt, LOG.info("Combined " + val + " into/with " + collector);
88: Todd Lipcon, error, CatchClause, LOG.error("Unable to parse arguments due to error: ", e);
91: Todd Lipcon, info, MethodDeclaration, LOG.info("Running with option list " + Helper.stringifyArray(args, " "));
101: Todd Lipcon, error, CatchClause, LOG.error("Unable to merge config due to error: ", e);
105: Todd Lipcon, error, IfStmt, LOG.error("Unable to merge config & options!");
112: Todd Lipcon, error, CatchClause, LOG.error("Unable to dump options due to error: ", e);
109: Todd Lipcon, info, TryStmt, LOG.info("Options are:");
121: Todd Lipcon, error, CatchClause, LOG.error("Unable to run job due to error: ", e);
117: Todd Lipcon, info, TryStmt, LOG.info("Running job:");
128: Todd Lipcon, error, CatchClause, LOG.error("Unable to report on job due to error: ", e);
125: Todd Lipcon, info, TryStmt, LOG.info("Reporting on job:");
139: Todd Lipcon, error, CatchClause, LOG.error("Unable to cleanup job due to error: ", e);
136: Todd Lipcon, info, TryStmt, LOG.info("Cleaning up job:");
223: Todd Lipcon, info, MethodDeclaration, LOG.info("Writing report using contents of " + dn);
267: Todd Lipcon, info, IfStmt, LOG.info("Report results being placed to logging output");
263: Todd Lipcon, info, IfStmt, LOG.info("Report results being placed to logging output and to file " + resFile.getCanonicalPath());
297: Todd Lipcon, info, IfStmt, LOG.info("Attempting to recursively delete " + base);
209: Todd Lipcon, info, IfStmt, LOG.info("Deleting file " + place);
224: Todd Lipcon, info, MethodDeclaration, LOG.info("Deleting directory " + dir);
261: Akira Ajisaka, info, MethodDeclaration, LOG.info(ostat.toString());
267: Akira Ajisaka, info, MethodDeclaration, LOG.info(vfout.toString());
96: Plamen Jeliazkov, Error, CatchClause, LOG.warn("Error with truncating", e);
100: Plamen Jeliazkov, Error, CatchClause, LOG.warn("Error with truncating", e);
75: Plamen Jeliazkov, info, TryStmt, LOG.info("Attempting to truncate file at " + fn + " to size " + Helper.toByteInfo(truncateSize));
91: Plamen Jeliazkov, info, TryStmt, LOG.info("Truncate file " + fn + " to " + Helper.toByteInfo(truncateSize) + " in " + timeTaken + " milliseconds");
107: Plamen Jeliazkov, info, MethodDeclaration, LOG.info("Waiting on truncate file recovery for " + fn);
130: Todd Lipcon, info, ForeachStmt, LOG.info(type.name() + " has " + amLeft + " initial operations out of " + totalAm + " for its ratio " + formatter.format(opData.getPercent()));
155: Todd Lipcon, info, IfStmt, LOG.info(opsLeft + " left over operations found (due to inability to support partial operations)");
124: Todd Lipcon, info, IfStmt, LOG.info("Deleting data directory");
138: Todd Lipcon, info, MethodDeclaration, LOG.info("Creating " + numberOfMaps + " control files");
271: Todd Lipcon, info, MethodDeclaration, LOG.info("Test Inputs: ");
272: Todd Lipcon, info, MethodDeclaration, LOG.info("           Test Operation: " + operation);
273: Todd Lipcon, info, MethodDeclaration, LOG.info("               Start time: " + sdf.format(new Date(startTime)));
274: Todd Lipcon, info, MethodDeclaration, LOG.info("           Number of maps: " + numberOfMaps);
275: Todd Lipcon, info, MethodDeclaration, LOG.info("        Number of reduces: " + numberOfReduces);
276: Todd Lipcon, info, MethodDeclaration, LOG.info("               Block Size: " + blockSize);
277: Todd Lipcon, info, MethodDeclaration, LOG.info("           Bytes to write: " + bytesToWrite);
278: Todd Lipcon, info, MethodDeclaration, LOG.info("       Bytes per checksum: " + bytesPerChecksum);
279: Todd Lipcon, info, MethodDeclaration, LOG.info("          Number of files: " + numberOfFiles);
280: Todd Lipcon, info, MethodDeclaration, LOG.info("       Replication factor: " + replicationFactorPerFile);
281: Todd Lipcon, info, MethodDeclaration, LOG.info("                 Base dir: " + baseDir);
282: Todd Lipcon, info, MethodDeclaration, LOG.info("     Read file after open: " + readFileAfterOpen);
450: Akira Ajisaka, info, ForeachStmt, LOG.info(resultLine);
675: Todd Lipcon, info, IfStmt, LOG.info("Waiting in barrier for: " + sleepTime + " ms");
799: Akira Ajisaka, error, CatchClause, LOG.error("Exception recorded in op: Create/Write/Close, " + "file: \"" + filePath + "\"", e);
843: Akira Ajisaka, error, CatchClause, LOG.error("Exception recorded in op: OpenRead, " + "file: \"" + filePath + "\"", e);
881: Akira Ajisaka, error, CatchClause, LOG.error("Exception recorded in op: Rename, " + "file: \"" + filePath + "\"", e);
917: Akira Ajisaka, error, CatchClause, LOG.error("Exception recorded in op: Delete, " + "file: \"" + filePath + "\"", e);
935: Todd Lipcon, info, ConstructorDeclaration, LOG.info("Starting NNBenchReducer !!!");
941: Todd Lipcon, info, ConstructorDeclaration, LOG.info("Starting NNBenchReducer on " + hostName);
86: Todd Lipcon, warn, MethodDeclaration, LOG.warn("Exception while " + operation + ": " + StringUtils.stringifyException(e));
86: Todd Lipcon, info, MethodDeclaration, LOG.info("With compression = " + compressionType + ": " + "compressed length = " + fileLength);
82: Todd Lipcon, info, MethodDeclaration, LOG.info("Writing " + numBytesToWrite + " bytes to " + file + " with " + "minKeySize: " + minKeySize + " keySizeRange: " + keySizeRange + " minValueSize: " + minValueSize + " valueSizeRange: " + valueSizeRange);
101: Todd Lipcon, info, MethodDeclaration, LOG.info("Created " + file + " of size: " + fileSizeInMB + "MB in " + (end - start) / 1000 + "secs");
102: Akira Ajisaka, error, CatchClause, LOG.error(e.getMessage());
112: Akira Ajisaka, error, CatchClause, LOG.error(e.getMessage());
228: Akira Ajisaka, error, CatchClause, LOG.error(e.getMessage());
270: Akira Ajisaka, error, CatchClause, LOG.error(e.getMessage());
62: Alejandro Abdelnur, warn, IfStmt, LOG.warn("Cannot restart the mini cluster, start it first");
99: Todd Lipcon, info, MethodDeclaration, LOG.info("creating control file: " + numLines + " numLines, " + sortOrder + " sortOrder");
125: Todd Lipcon, info, MethodDeclaration, LOG.info("created control file: " + inputFile);
189: Todd Lipcon, info, ForStmt, LOG.info("Running job " + i + ":" + " input=" + FileInputFormat.getInputPaths(jobConf)[0] + " output=" + FileOutputFormat.getOutputPath(jobConf));
80: Todd Lipcon, info, MethodDeclaration, LOG.info("This must be run in only the distributed mode " + "(LocalJobRunner not supported).\n\tUsage: MRReliabilityTest " + "-libjars <path to hadoop-examples.jar> [-scratchdir <dir>]" + "\n[-scratchdir] points to a scratch space on this host where temp" + " files for this test will be created. Defaults to current working" + " dir. \nPasswordless SSH must be set up between this host and the" + " nodes which the test is going to use.\n" + "The test should be run on a free cluster with no parallel job submission" + " going on, as the test requires to restart TaskTrackers and kill tasks" + " any job submission while the tests are running can cause jobs/tests to fail");
137: Todd Lipcon, info, MethodDeclaration, LOG.info("SleepJob done");
158: Todd Lipcon, info, MethodDeclaration, LOG.info("RandomWriter job done");
168: Todd Lipcon, info, MethodDeclaration, LOG.info("Sort job done");
178: Allen Wittenauer, info, MethodDeclaration, LOG.info("SortValidator job done");
194: Todd Lipcon, info, IfStmt, LOG.info(jobName + " done.");
191: Todd Lipcon, info, IfStmt, LOG.info(jobName + " job failed with status: " + status);
211: Akira Ajisaka, error, CatchClause, LOG.error("JOB " + jobClass + " failed to run");
221: Todd Lipcon, info, WhileStmt, LOG.info("Waiting for the job " + jobClass + " to start");
227: Allen Wittenauer, error, IfStmt, LOG.error("The last job returned by the querying " + "JobTracker is complete :" + rJob.getJobID() + " .Exiting the test");
233: Todd Lipcon, info, WhileStmt, LOG.info("JobID : " + jobId + " not started RUNNING yet");
241: Todd Lipcon, info, IfStmt, LOG.info("DONE WITH THE TASK KILL/FAIL TESTS");
247: Todd Lipcon, info, IfStmt, LOG.info("DONE WITH THE TESTS TO DO WITH LOST TASKTRACKERS");
295: Todd Lipcon, info, IfStmt, LOG.info("Will STOP/RESUME tasktrackers based on " + "Reduces' progress");
292: Todd Lipcon, info, IfStmt, LOG.info("Will STOP/RESUME tasktrackers based on Maps'" + " progress");
298: Allen Wittenauer, info, MethodDeclaration, LOG.info("Initial progress threshold: " + threshold + ". Threshold Multiplier: " + thresholdMultiplier + ". Number of iterations: " + numIterations);
329: Akira Ajisaka, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
342: Todd Lipcon, info, MethodDeclaration, LOG.info(new Date() + " Stopping a few trackers");
346: Todd Lipcon, info, ForeachStmt, LOG.info(new Date() + " Marking tracker on host: " + host);
358: Todd Lipcon, info, MethodDeclaration, LOG.info(new Date() + " Resuming the stopped trackers");
380: Todd Lipcon, info, IfStmt, LOG.info(output);
430: Todd Lipcon, info, IfStmt, LOG.info("Will kill tasks based on Reduces' progress");
428: Todd Lipcon, info, IfStmt, LOG.info("Will kill tasks based on Maps' progress");
432: Allen Wittenauer, info, MethodDeclaration, LOG.info("Initial progress threshold: " + threshold + ". Threshold Multiplier: " + thresholdMultiplier + ". Number of iterations: " + numIterations);
499: Akira Ajisaka, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
456: Todd Lipcon, info, IfStmt, LOG.info(new Date() + " Killing a few tasks");
469: Todd Lipcon, info, ForeachStmt, LOG.info(new Date() + " Killed task : " + t);
486: Todd Lipcon, info, ForeachStmt, LOG.info(new Date() + " Killed task : " + t);
118: Todd Lipcon, info, MethodDeclaration, LOG.info(runningJob.getCounters().toString());
151: Todd Lipcon, info, ForeachStmt, LOG.info("skipPath: " + skipPath);
161: Todd Lipcon, debug, WhileStmt, LOG.debug("key:" + key + " value:" + value.toString());
179: Todd Lipcon, debug, MethodDeclaration, LOG.debug("mapperOutput " + mapperOutput.size());
181: Todd Lipcon, debug, MethodDeclaration, LOG.debug("reducerOutput " + reducerOutput.size());
193: Todd Lipcon, debug, WhileStmt, LOG.debug("Output: key:" + key + "  value:" + value);
231: Todd Lipcon, debug, MethodDeclaration, LOG.debug("MAP key:" + key + "  value:" + str);
242: Todd Lipcon, warn, TryStmt, LOG.warn("MAP Encountered BAD record");
237: Todd Lipcon, warn, IfStmt, LOG.warn("MAP Encountered BAD record");
233: Todd Lipcon, warn, IfStmt, LOG.warn("MAP Encountered BAD record");
260: Todd Lipcon, debug, WhileStmt, LOG.debug("REDUCE key:" + key + "  value:" + value);
267: Todd Lipcon, warn, TryStmt, LOG.warn("REDUCE Encountered BAD record");
262: Todd Lipcon, warn, IfStmt, LOG.warn("REDUCE Encountered BAD record");
189: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("services started");
199: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Sleeping for 5 seconds before stop for" + " the client socket to not get EOF immediately..");
206: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Sleeping for 5 seconds after stop for" + " the server to exit cleanly..");
258: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Group " + group.getDisplayName());
261: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Counter is " + itc.next().getDisplayName());
79: Todd Lipcon, info, MethodDeclaration, LOG.info("Trying to getSplits with splits = " + SIZE_SPLITS);
81: Todd Lipcon, info, MethodDeclaration, LOG.info("Got getSplits = " + splits.length);
68: Robert Joseph Evans, info, MethodDeclaration, LOG.info("seed = " + seed);
89: Robert Joseph Evans, info, ForStmt, LOG.info("splitting: requesting = " + numSplits);
91: Robert Joseph Evans, info, ForStmt, LOG.info("splitting: got =        " + splits.length);
76: Robert Joseph Evans, info, MethodDeclaration, LOG.info("seed = " + seed);
93: Robert Joseph Evans, info, ForStmt, LOG.info("splitting: requesting = " + numSplits);
95: Robert Joseph Evans, info, ForStmt, LOG.info("splitting: got =        " + splits.length);
106: Robert Joseph Evans, debug, ForStmt, LOG.debug("split= " + split);
113: Robert Joseph Evans, debug, WhileStmt, LOG.debug("read " + v);
115: Robert Joseph Evans, warn, IfStmt, LOG.warn("conflict with " + v + " at position " + reader.getPos());
122: Robert Joseph Evans, info, TryStmt, LOG.info("splits=" + split + " count=" + count);
157: Todd Lipcon, warn, IfStmt, LOG.warn("testGzip() skipped:  native (C/C++) libs not loaded");
115: Sanford Ryza, info, CatchClause, LOG.info("Exception message:" + ioe.getMessage());
143: Sanford Ryza, info, CatchClause, LOG.info("Exception message:" + ioe.getMessage());
171: Sanford Ryza, info, CatchClause, LOG.info("Exception message:" + ioe.getMessage());
263: Sanford Ryza, info, MethodDeclaration, LOG.info("Seed = " + seed);
270: Sanford Ryza, info, ForStmt, LOG.info("----------------------------------------------------------");
285: Sanford Ryza, info, ForStmt, LOG.info("totalRecords=" + totalRecords + " recordLength=" + recordLength);
315: Sanford Ryza, info, IfStmt, LOG.info("Number of splits set to: " + numSplits);
324: Sanford Ryza, info, ForStmt, LOG.info("Actual number of splits = " + splits.length);
414: Sanford Ryza, info, CatchClause, LOG.info("Exception message:" + ioe.getMessage());
170: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Job finished : " + job.isComplete());
237: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for a map task to be launched");
104: Todd Lipcon, info, MethodDeclaration, LOG.info("runWordCount");
63: Todd Lipcon, info, MethodDeclaration, LOG.info("seed = " + seed);
73: Todd Lipcon, debug, ForStmt, LOG.debug("creating; entries = " + length);
93: Todd Lipcon, debug, ForStmt, LOG.debug("splitting: requesting = " + numSplits);
95: Todd Lipcon, debug, ForStmt, LOG.debug("splitting: got =        " + splits.length);
100: Todd Lipcon, debug, ForStmt, LOG.debug("split[" + j + "]= " + splits[j]);
116: Todd Lipcon, debug, WhileStmt, LOG.debug("read " + v);
118: Todd Lipcon, warn, IfStmt, LOG.warn("conflict with " + v + " in split " + j + " at position " + reader.getPos());
126: Todd Lipcon, debug, TryStmt, LOG.debug("splits[" + j + "]=" + splits[j] + " count=" + count);
83: Eli Collins, info, MethodDeclaration, LOG.info("Task " + taskid + " reporting done.");
87: Eli Collins, info, MethodDeclaration, LOG.info("Task " + taskId + " reporting file system error: " + message);
91: Eli Collins, info, MethodDeclaration, LOG.info("Task " + taskId + " reporting shuffle error: " + message);
95: Jason Lowe, info, MethodDeclaration, LOG.info("Task " + taskId + " reporting fatal error: " + msg + " fast fail: " + fastFail);
133: Eli Collins, info, MethodDeclaration, LOG.info(buf.toString());
142: Eli Collins, info, MethodDeclaration, LOG.info("Task " + taskid + " has problem " + trace);
153: Eli Collins, info, MethodDeclaration, LOG.info("Task " + taskid + " reportedNextRecordRange " + range);
187: Todd Lipcon, info, MethodDeclaration, LOG.info("Map task progress is " + mapTaskProgress);
253: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
286: Todd Lipcon, info, CatchClause, LOG.info("IO exception in closing file system)");
177: Zhijie Shen, info, MethodDeclaration, LOG.info("testMRNewTimelineServiceEventHandling start.");
209: Zhijie Shen, info, TryStmt, LOG.info("A MiniMRYarnCluster get start.");
213: Zhijie Shen, info, TryStmt, LOG.info("Run 1st job which should be successful.");
242: Zhijie Shen, info, TryStmt, LOG.info("Run 2nd job which should be failed.");
399: Sangjin Lee, info, IfStmt, LOG.info("strLine.trim()= " + strLine.trim());
65: Todd Lipcon, info, MethodDeclaration, LOG.info("Creating " + numFiles + " file(s) in " + multiFileDir);
77: Todd Lipcon, debug, IfStmt, LOG.debug("Created file " + path + " with length " + numBytes);
87: Suresh Srinivas, info, MethodDeclaration, LOG.info("Test started");
88: Suresh Srinivas, info, MethodDeclaration, LOG.info("Max split count           = " + MAX_SPLIT_COUNT);
89: Suresh Srinivas, info, MethodDeclaration, LOG.info("Split count increment     = " + SPLIT_COUNT_INCR);
90: Suresh Srinivas, info, MethodDeclaration, LOG.info("Max bytes per file        = " + MAX_BYTES);
91: Suresh Srinivas, info, MethodDeclaration, LOG.info("Max number of files       = " + MAX_NUM_FILES);
92: Suresh Srinivas, info, MethodDeclaration, LOG.info("Number of files increment = " + NUM_FILES_INCR);
103: Todd Lipcon, info, ForStmt, LOG.info("Running for Num Files=" + numFiles + ", split count=" + i);
126: Todd Lipcon, info, MethodDeclaration, LOG.info("Test Finished");
91: Todd Lipcon, info, MethodDeclaration, LOG.info("Creating data by SequenceFileAsBinaryOutputFormat");
115: Todd Lipcon, info, MethodDeclaration, LOG.info("Reading data by SequenceFileInputFormat");
89: Todd Lipcon, info, MethodDeclaration, LOG.info("Generated " + splits.length + " splits.");
95: Todd Lipcon, info, WhileStmt, LOG.info("Accept record " + key.toString());
108: Todd Lipcon, info, MethodDeclaration, LOG.info("Testing Regex Filter with patter: \\A10*");
119: Todd Lipcon, info, ForStmt, LOG.info("******Number of records: " + length);
131: Todd Lipcon, info, MethodDeclaration, LOG.info("Testing Percent Filter with frequency: 1000");
143: Todd Lipcon, info, ForStmt, LOG.info("******Number of records: " + length);
146: Todd Lipcon, info, ForStmt, LOG.info("Accepted " + count + " records");
160: Todd Lipcon, info, MethodDeclaration, LOG.info("Testing MD5 Filter with frequency: 1000");
171: Todd Lipcon, info, ForStmt, LOG.info("******Number of records: " + length);
173: Todd Lipcon, info, ForStmt, LOG.info("Accepted " + countRecords(0) + " records");
59: Akira Ajisaka, debug, MethodDeclaration, LOG.debug(sr.toString());
99: Akira Ajisaka, debug, MethodDeclaration, LOG.debug(sr.toString());
59: Todd Lipcon, warn, IfStmt, LOG.warn("Can't create " + inDir);
95: Todd Lipcon, info, MethodDeclaration, LOG.info("job is complete: " + runningJob.isSuccessful());
77: Todd Lipcon, info, MethodDeclaration, LOG.info("seed = " + seed);
87: Todd Lipcon, debug, ForStmt, LOG.debug("creating; entries = " + length);
107: Todd Lipcon, debug, ForStmt, LOG.debug("splitting: requesting = " + numSplits);
109: Todd Lipcon, debug, ForStmt, LOG.debug("splitting: got =        " + splits.length);
120: Todd Lipcon, debug, ForStmt, LOG.debug("split[" + j + "]= " + splits[j]);
127: Todd Lipcon, debug, WhileStmt, LOG.debug("read " + v);
129: Todd Lipcon, warn, IfStmt, LOG.warn("conflict with " + v + " in split " + j + " at position " + reader.getPos());
137: Todd Lipcon, debug, TryStmt, LOG.debug("splits[" + j + "]=" + splits[j] + " count=" + count);
164: Todd Lipcon, info, MethodDeclaration, LOG.info("seed = " + seed);
215: Jason Lowe, info, MethodDeclaration, LOG.info("creating; entries = " + length);
233: Jason Lowe, info, ForStmt, LOG.info("setting block size of the input file to " + splitpos);
238: Jason Lowe, info, ForStmt, LOG.info("splitting: got =        " + splits.length);
243: Jason Lowe, debug, ForStmt, LOG.debug("split[" + j + "]= " + splits[j]);
250: Jason Lowe, debug, WhileStmt, LOG.debug("read " + v);
252: Jason Lowe, warn, IfStmt, LOG.warn("conflict with " + v + " in split " + j + " at position " + reader.getPos());
262: Jason Lowe, debug, IfStmt, LOG.debug("splits[" + j + "]=" + splits[j] + " count=" + counter);
260: Jason Lowe, info, IfStmt, LOG.info("splits[" + j + "]=" + splits[j] + " count=" + counter);
275: Akira Ajisaka, info, MethodDeclaration, LOG.info("creating; entries = " + length);
295: Akira Ajisaka, info, MethodDeclaration, LOG.info("splitting: requesting = " + numSplits);
297: Akira Ajisaka, info, MethodDeclaration, LOG.info("splitting: got =        " + splits.length);
303: Akira Ajisaka, debug, ForStmt, LOG.debug("split[" + j + "]= " + splits[j]);
310: Akira Ajisaka, debug, WhileStmt, LOG.debug("read " + v);
312: Akira Ajisaka, warn, IfStmt, LOG.warn("conflict with " + v + " in split " + j + " at position " + reader.getPos());
323: Akira Ajisaka, debug, IfStmt, LOG.debug("splits[" + j + "]=" + splits[j] + " count=" + counter);
321: Akira Ajisaka, info, IfStmt, LOG.info("splits[" + j + "]=" + splits[j] + " count=" + counter);
453: Todd Lipcon, info, MethodDeclaration, LOG.info("Reading a line from /dev/null");
325: Arun Murthy, info, CatchClause, LOG.info("Logging exception:", io);
598: Jonathan Turner Eagles, WARN, MethodDeclaration, assertTrue(logMsg.contains("WARN - Usage of -Djava.library.path in " + "yarn.app.mapreduce.am.admin-command-opts can cause programs to no " + "longer function if hadoop native libraries are used. These values " + "should be set as part of the LD_LIBRARY_PATH in the app master JVM " + "env using yarn.app.mapreduce.am.admin.user.env config settings."));
603: Jonathan Turner Eagles, WARN, MethodDeclaration, assertTrue(logMsg.contains("WARN - Usage of -Djava.library.path in " + "yarn.app.mapreduce.am.command-opts can cause programs to no longer " + "function if hadoop native libraries are used. These values should " + "be set as part of the LD_LIBRARY_PATH in the app master JVM env " + "using yarn.app.mapreduce.am.env config settings."));
167: Todd Lipcon, info, MethodDeclaration, LOG.info("Generating random input for the benchmark");
168: Todd Lipcon, info, MethodDeclaration, LOG.info("Total data : " + totalDataSize + " mb");
169: Todd Lipcon, info, MethodDeclaration, LOG.info("Data per map: " + dataSizePerMap + " mb");
170: Todd Lipcon, info, MethodDeclaration, LOG.info("Number of spills : " + numSpillsPerMap);
171: Todd Lipcon, info, MethodDeclaration, LOG.info("Number of maps per host : " + numMapsPerHost);
172: Todd Lipcon, info, MethodDeclaration, LOG.info("Number of hosts : " + cluster.getTaskTrackers());
186: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting the benchmark for threaded spills");
255: Todd Lipcon, info, TryStmt, LOG.info("Running sort with 1 spill per map");
260: Todd Lipcon, info, TryStmt, LOG.info("Total time taken : " + String.valueOf(endTime - startTime) + " millisec");
273: Todd Lipcon, info, TryStmt, LOG.info("Running sort with " + numSpillsPerMap + " spills per map");
278: Todd Lipcon, info, TryStmt, LOG.info("Total time taken : " + String.valueOf(endTime - startTime) + " millisec");
755: Thomas White, warn, CatchClause, LOG.warn("Caught exception while deleting path " + context.fullPath);
757: Thomas White, info, CatchClause, LOG.info(StringUtils.stringifyException(e));
751: Thomas White, warn, IfStmt, LOG.warn("Stale path " + context.fullPath);
121: Todd Lipcon, debug, WhileStmt, LOG.debug("Jobs in waiting state: " + theControl.getWaitingJobs().size());
122: Todd Lipcon, debug, WhileStmt, LOG.debug("Jobs in ready state: " + theControl.getReadyJobs().size());
123: Todd Lipcon, debug, WhileStmt, LOG.debug("Jobs in running state: " + theControl.getRunningJobs().size());
124: Todd Lipcon, debug, WhileStmt, LOG.debug("Jobs in success state: " + theControl.getSuccessfulJobs().size());
126: Todd Lipcon, debug, WhileStmt, LOG.debug("Jobs in failed state: " + theControl.getFailedJobs().size());
127: Todd Lipcon, debug, WhileStmt, LOG.debug("\n");
75: Todd Lipcon, info, IfStmt, LOG.info("compile.c++ is not defined, so skipping TestPipes");
45: Haibo Chen, info, IfStmt, LOG.info("Free memory = " + free + " bytes. Creating 1 MB on the heap.");
41: Sangjin Lee, info, ConstructorDeclaration, LOG.info("JobHistoryFileParser created with " + fs);
46: Sangjin Lee, info, MethodDeclaration, LOG.info("parsing job history file " + path);
52: Sangjin Lee, info, MethodDeclaration, LOG.info("parsing job configuration file " + path);
148: Sangjin Lee, info, WhileStmt, LOG.info("this mapper will process file " + fileName);
169: Sangjin Lee, warn, IfStmt, LOG.warn("we already have the job history file " + jobFiles.getJobHistoryFilePath() + ": skipping " + path);
177: Sangjin Lee, warn, IfStmt, LOG.warn("we already have the job conf file " + jobFiles.getJobConfFilePath() + ": skipping " + path);
182: Sangjin Lee, warn, SwitchStmt, LOG.warn("unknown type: " + path);
67: Sangjin Lee, info, IfStmt, LOG.info(context.getTaskAttemptID().getTaskID() + " will process " + jobs.size() + " jobs");
64: Sangjin Lee, info, IfStmt, LOG.info(context.getTaskAttemptID().getTaskID() + " will process no jobs");
73: Sangjin Lee, info, ForeachStmt, LOG.info("processing " + jobIdStr + "...");
88: Sangjin Lee, info, TryStmt, LOG.info("parsed the job history file and the configuration file for job " + jobIdStr);
95: Sangjin Lee, info, TryStmt, LOG.info("converted them into timeline entities for job " + jobIdStr);
113: Sangjin Lee, error, CatchClause, LOG.error("writing to the timeline service failed", e);
118: Sangjin Lee, info, TryStmt, LOG.info("wrote " + numEntities + " entities in " + totalTime + " ms");
141: Sangjin Lee, info, ForeachStmt, LOG.info("wrote entity " + entity.getEntityId());
65: Zhijie Shen, info, IfStmt, LOG.info(context.getTaskAttemptID().getTaskID() + " will process " + jobs.size() + " jobs");
62: Zhijie Shen, info, IfStmt, LOG.info(context.getTaskAttemptID().getTaskID() + " will process no jobs");
74: naganarasimha, info, IfStmt, LOG.info(jobIdStr + " missing either the job history file or the " + "configuration file. Skipping.");
78: Zhijie Shen, info, ForeachStmt, LOG.info("processing " + jobIdStr + "...");
92: Sangjin Lee, info, TryStmt, LOG.info("parsed the job history file and the configuration file " + "for job " + jobIdStr);
107: Zhijie Shen, info, TryStmt, LOG.info("converted them into timeline entities for job " + jobIdStr);
125: Zhijie Shen, error, CatchClause, LOG.error("writing to the timeline service failed", e);
130: Zhijie Shen, info, TryStmt, LOG.info("wrote " + numEntities + " entities in " + totalTime + " ms");
158: Zhijie Shen, info, ForeachStmt, LOG.info("wrote entity " + entity.getId());
408: Todd Lipcon, info, ForeachStmt, LOG.info("Path" + ": " + outputFile);
161: Alejandro Abdelnur, info, IfStmt, LOG.info("Started MiniDFSCluster -- namenode on port " + dfs.getNameNodePort());
181: Alejandro Abdelnur, info, IfStmt, LOG.info("Started MiniMRCluster");
234: Alejandro Abdelnur, warn, CatchClause, LOG.warn("options parsing failed:  " + e.getMessage());
294: Alejandro Abdelnur, warn, IfStmt, LOG.warn("Ignoring -D option " + prop);
298: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("Updated " + num_confs_updated + " configuration settings from command line.");
86: Sangjin Lee, error, CatchClause, LOG.error("writing to the timeline service failed", e);
91: Sangjin Lee, info, MethodDeclaration, LOG.info("wrote " + testtimes + " entities (" + kbs * testtimes + " kB) in " + totalTime + " ms");
114: Zhijie Shen, error, CatchClause, LOG.error("writing to the timeline service failed", e);
119: Zhijie Shen, info, TryStmt, LOG.info("wrote " + testtimes + " entities (" + kbs * testtimes + " kB) in " + totalTime + " ms");
103: Sanford Ryza, info, MethodDeclaration, LOG.info("counters max=" + Limits.getCountersMax());
117: Sanford Ryza, info, MethodDeclaration, LOG.info("counter groups max=" + Limits.getGroupsMax());
148: Arun Murthy, info, CatchClause, LOG.info("got expected: " + e);
85: Todd Lipcon, info, MethodDeclaration, LOG.info("Thread " + threadId + " : " + context.getInputSplit());
326: Todd Lipcon, info, MethodDeclaration, LOG.info("Submitting job...");
328: Todd Lipcon, info, MethodDeclaration, LOG.info("Starting thread to interrupt main thread in 2 minutes");
330: Todd Lipcon, info, MethodDeclaration, LOG.info("Waiting for job to complete...");
334: Akira Ajisaka, error, CatchClause, LOG.error("Interrupted while waiting for job completion", ie);
336: Akira Ajisaka, error, ForStmt, LOG.error("Dumping stacks");
342: Todd Lipcon, info, MethodDeclaration, LOG.info("Job completed, stopping interrupter");
349: Todd Lipcon, info, MethodDeclaration, LOG.info("Verifying output");
512: Sanford Ryza, info, MethodDeclaration, LOG.info("expected sum: " + expectedSum + ", got " + valueSum);
54: Todd Lipcon, info, ConstructorDeclaration, LOG.info("seed: " + seed);
320: Todd Lipcon, info, MethodDeclaration, LOG.info("Running " + name);
501: Todd Lipcon, info, MethodDeclaration, LOG.info("SEED: " + seed);
523: Todd Lipcon, info, MethodDeclaration, LOG.info("SEED: " + seed);
87: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("waiting for jobId...");
95: Robert Kanter, info, MethodDeclaration, LOG.info("args = " + Arrays.toString(args));
317: Thomas Graves, info, WhileStmt, LOG.info("line = " + line);
339: Thomas Graves, info, WhileStmt, LOG.info("line = " + line);
360: Thomas Graves, info, WhileStmt, LOG.info("line = " + line);
584: Thomas Graves, info, WhileStmt, LOG.info("line = " + line);
608: Thomas Graves, info, WhileStmt, LOG.info("line = " + line);
654: Thomas Graves, info, WhileStmt, LOG.info("line = " + line);
677: Thomas Graves, info, WhileStmt, LOG.info("line = " + line);
695: Todd Lipcon, info, WhileStmt, LOG.info("line = " + line);
752: Akira Ajisaka, info, WhileStmt, LOG.info("line = " + line);
140: Todd Lipcon, info, MethodDeclaration, LOG.info("Executing TEST:0 for Key:" + key.toString());
143: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:0. Marking");
148: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
152: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:0. Reset");
158: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
160: Todd Lipcon, info, IfStmt, LOG.info("TEST:0. Check:1 Expected: " + expectedValues.get(count) + ", Got: " + i);
168: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:0 Done");
191: Todd Lipcon, info, MethodDeclaration, LOG.info("Executing TEST:1 for Key:" + key);
194: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:1. Marking");
198: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
207: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:1. Reset");
212: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
217: Todd Lipcon, info, IfStmt, LOG.info("TEST:1. Check:1 Expected: " + expectedValues.get(count) + ", Got: " + i);
226: Todd Lipcon, info, IfStmt, LOG.info("TEST:1. Marking -- " + key + ": " + i);
240: Todd Lipcon, info, IfStmt, LOG.info(("TEST:1 Check:2. Iterator returned lesser values"));
247: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:1. Reset");
252: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
257: Todd Lipcon, info, IfStmt, LOG.info("TEST:1. Check:3 Expected: " + expectedValues1.get(count) + ", Got: " + i);
267: Todd Lipcon, info, IfStmt, LOG.info("TEST:1. Marking -- " + key + ":" + i);
277: Todd Lipcon, info, IfStmt, LOG.info(("TEST:1 Check:4. Iterator returned fewer values"));
283: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:1. Reset");
288: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
292: Todd Lipcon, info, IfStmt, LOG.info("TEST:1. Check:5 Expected: " + expectedValues.get(count) + ", Got: " + i);
298: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:1 Done");
321: Todd Lipcon, info, MethodDeclaration, LOG.info("Executing TEST:2 for Key:" + key);
324: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:2 Marking");
328: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
338: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:2 reset");
342: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
347: Todd Lipcon, info, IfStmt, LOG.info("TEST:2. Check:1 Expected: " + expectedValues.get(count) + ", Got: " + i);
357: Todd Lipcon, info, IfStmt, LOG.info("TEST:2. Marking -- " + key + ":" + i);
367: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:2. Reset");
373: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
378: Todd Lipcon, info, IfStmt, LOG.info("TEST:2. Check:2 Expected: " + expectedValues1.get(count) + ", Got: " + i);
388: Todd Lipcon, info, IfStmt, LOG.info("TEST:2. Marking -- " + key + ":" + i);
399: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:2. Reset");
403: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
407: Todd Lipcon, info, IfStmt, LOG.info("TEST:2. Check:1 Expected: " + expectedValues.get(count) + ", Got: " + i);
413: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:2 Done");
433: Todd Lipcon, info, MethodDeclaration, LOG.info("Executing TEST:3 for Key:" + key);
436: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:3. Marking");
441: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
444: Todd Lipcon, info, IfStmt, LOG.info("TEST:3. Clearing Mark");
449: Todd Lipcon, info, IfStmt, LOG.info("TEST:3. Marking -- " + key + ":" + i);
460: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:3. After reset");
464: Todd Lipcon, info, IfStmt, LOG.info("TEST:3, Check:1. HasNext returned false");
472: Todd Lipcon, info, WhileStmt, LOG.info(key + ":" + i);
477: Todd Lipcon, info, IfStmt, LOG.info("TEST:2. Check:1 Expected: " + expectedValues.get(count) + ", Got: " + i);
485: Todd Lipcon, info, IfStmt, LOG.info("TEST:3. After clear mark");
492: Todd Lipcon, info, TryStmt, LOG.info("TEST:3. Before Reset");
499: Todd Lipcon, info, IfStmt, LOG.info("TEST:3 Check:4 reset was successfule even after clearMark");
504: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST:3 Done.");
565: Todd Lipcon, info, WhileStmt, LOG.info("Output: key: " + key + " value: " + value);
89: Sangjin Lee, info, MethodDeclaration, LOG.info("converted job " + jobInfo.getJobId() + " to a timeline entity");
97: Sangjin Lee, info, MethodDeclaration, LOG.info("job " + jobInfo.getJobId() + " has " + taskInfoMap.size() + " tasks");
121: Sangjin Lee, info, MethodDeclaration, LOG.info("converted task " + taskInfo.getTaskId() + " to a timeline entity");
130: Sangjin Lee, info, MethodDeclaration, LOG.info("task " + taskInfo.getTaskId() + " has " + taskAttemptInfoMap.size() + " task attempts");
160: Sangjin Lee, info, MethodDeclaration, LOG.info("converted task attempt " + taskAttemptInfo.getAttemptId() + " to a timeline entity");
102: Zhijie Shen, info, MethodDeclaration, LOG.info("converted job " + jobInfo.getJobId() + " to a timeline entity");
129: Zhijie Shen, info, MethodDeclaration, LOG.info("job " + jobInfo.getJobId() + " has " + taskInfoMap.size() + " tasks");
158: Zhijie Shen, info, MethodDeclaration, LOG.info("converted task " + taskInfo.getTaskId() + " to a timeline entity");
167: Zhijie Shen, info, MethodDeclaration, LOG.info("task " + taskInfo.getTaskId() + " has " + taskAttemptInfoMap.size() + " task attempts");
202: Zhijie Shen, info, MethodDeclaration, LOG.info("converted task attempt " + taskAttemptInfo.getAttemptId() + " to a timeline entity");
106: Todd Lipcon, warn, CatchClause, LOG.warn("Exception occurred while closing connection :" + StringUtils.stringifyException(ex));
114: Todd Lipcon, warn, CatchClause, LOG.warn("Exception occurred while shutting down HSQLDB :" + StringUtils.stringifyException(ex));
92: Robert Joseph Evans, info, ForStmt, LOG.info("splitting: requesting = " + numSplits);
94: Robert Joseph Evans, info, ForStmt, LOG.info("splitting: got =        " + splits.size());
121: Robert Joseph Evans, debug, WhileStmt, LOG.debug("read " + k);
81: Robert Joseph Evans, info, MethodDeclaration, LOG.info("seed = " + seed);
97: Robert Joseph Evans, info, ForStmt, LOG.info("splitting: requesting = " + numSplits);
99: Robert Joseph Evans, info, ForStmt, LOG.info("splitting: got =        " + splits.size());
110: Robert Joseph Evans, debug, ForStmt, LOG.debug("split= " + split);
130: Robert Joseph Evans, debug, WhileStmt, LOG.debug("read " + v);
135: Robert Joseph Evans, debug, TryStmt, LOG.debug("split=" + split + " count=" + count);
127: Sanford Ryza, info, CatchClause, LOG.info("Exception message:" + ioe.getMessage());
163: Sanford Ryza, info, CatchClause, LOG.info("Exception message:" + ioe.getMessage());
198: Sanford Ryza, info, CatchClause, LOG.info("Exception message:" + ioe.getMessage());
289: Sanford Ryza, info, MethodDeclaration, LOG.info("Seed = " + seed);
296: Sanford Ryza, info, ForStmt, LOG.info("----------------------------------------------------------");
311: Sanford Ryza, info, ForStmt, LOG.info("totalRecords=" + totalRecords + " recordLength=" + recordLength);
342: Sanford Ryza, info, IfStmt, LOG.info("Number of splits set to: " + numSplits);
353: Sanford Ryza, info, ForStmt, LOG.info("Actual number of splits = " + splits.size());
460: Sanford Ryza, info, CatchClause, LOG.info("Exception message:" + ioe.getMessage());
74: Todd Lipcon, info, MethodDeclaration, LOG.info("seed = " + seed);
85: Todd Lipcon, debug, ForStmt, LOG.debug("creating; entries = " + length);
104: Todd Lipcon, debug, ForStmt, LOG.debug("splitting: requesting = " + numSplits);
106: Todd Lipcon, debug, ForStmt, LOG.debug("splitting: got =        " + splits.size());
111: Todd Lipcon, debug, ForStmt, LOG.debug("split[" + j + "]= " + splits.get(j));
140: Todd Lipcon, debug, WhileStmt, LOG.debug("read " + v);
145: Todd Lipcon, debug, TryStmt, LOG.debug("splits[" + j + "]=" + splits.get(j) + " count=" + count);
172: Todd Lipcon, info, MethodDeclaration, LOG.info("seed = " + seed);
184: Todd Lipcon, info, ForStmt, LOG.info("creating; entries = " + length);
205: Todd Lipcon, info, ForStmt, LOG.info("splitting: requesting = " + numSplits);
207: Todd Lipcon, info, ForStmt, LOG.info("splitting: got =        " + splits.size());
212: Todd Lipcon, debug, ForStmt, LOG.debug("split[" + j + "]= " + splits.get(j));
235: Todd Lipcon, debug, WhileStmt, LOG.debug("read " + k + "," + v);
243: Todd Lipcon, debug, IfStmt, LOG.debug("splits[" + j + "]=" + splits.get(j) + " count=" + count);
241: Todd Lipcon, info, IfStmt, LOG.info("splits[" + j + "]=" + splits.get(j) + " count=" + count);
112: Todd Lipcon, info, WhileStmt, LOG.info("Accept record " + reader.getCurrentKey().toString());
125: Todd Lipcon, info, MethodDeclaration, LOG.info("Testing Regex Filter with patter: \\A10*");
137: Todd Lipcon, info, ForStmt, LOG.info("******Number of records: " + length);
149: Todd Lipcon, info, MethodDeclaration, LOG.info("Testing Percent Filter with frequency: 1000");
162: Todd Lipcon, info, ForStmt, LOG.info("******Number of records: " + length);
165: Todd Lipcon, info, ForStmt, LOG.info("Accepted " + count + " records");
179: Todd Lipcon, info, MethodDeclaration, LOG.info("Testing MD5 Filter with frequency: 1000");
191: Todd Lipcon, info, ForStmt, LOG.info("******Number of records: " + length);
193: Todd Lipcon, info, ForStmt, LOG.info("Accepted " + countRecords(0) + " records");
129: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Starting testJobControlWithFailJob");
153: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Starting testJobControlWithKillJob");
192: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Starting testJobControl");
212: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Starting testControlledJob");
98: Todd Lipcon, info, MethodDeclaration, LOG.info("Creating data by SequenceFileAsBinaryOutputFormat");
122: Todd Lipcon, info, MethodDeclaration, LOG.info("Reading data by SequenceFileInputFormat");
383: Todd Lipcon, info, MethodDeclaration, LOG.info("input : " + input);
385: Todd Lipcon, info, MethodDeclaration, LOG.info("keyspecs : " + keySpecs);
390: Todd Lipcon, info, MethodDeclaration, LOG.info("length : " + e1);
396: Todd Lipcon, info, MethodDeclaration, LOG.info("start : " + start);
404: Todd Lipcon, info, MethodDeclaration, LOG.info("end : " + end);
408: Todd Lipcon, info, MethodDeclaration, LOG.info("length : " + length);
412: Todd Lipcon, info, MethodDeclaration, LOG.info("output : " + output);
413: Todd Lipcon, info, MethodDeclaration, LOG.info("expected-output : " + expectedOutput);
127: Thomas Graves, info, TryStmt, LOG.info("Got delegation token at: " + tokenFetchTime);
148: Thomas Graves, info, TryStmt, LOG.info("Renewed token at: " + renewalTime + ", NextExpiryTime: " + nextExpTime);
170: Thomas Graves, info, TryStmt, LOG.info("At time: " + System.currentTimeMillis() + ", token should be invalid");
188: Thomas Graves, info, TryStmt, LOG.info("Got delegation token at: " + tokenFetchTime);
214: Thomas Graves, info, TryStmt, LOG.info("Cancelled delegation token at: " + System.currentTimeMillis());
106: Robert Joseph Evans, info, MethodDeclaration, LOG.info("Service address for token is " + token.getService());
82: Todd Lipcon, debug, ForStmt, LOG.debug("Normalized volume: " + nonCanonicalVols[v] + " -> " + this.volumes[v]);
94: Todd Lipcon, warn, IfStmt, LOG.warn("Cannot create " + TOBEDELETED + " in " + volumes[v] + ". Ignored.");
222: Todd Lipcon, debug, IfStmt, LOG.debug("Successfully did " + this.toString());
219: Todd Lipcon, warn, IfStmt, LOG.warn("Failure in " + this);
216: Todd Lipcon, warn, IfStmt, LOG.warn("Failure in " + this + " with exception " + StringUtils.stringifyException(e));
80: Todd Lipcon, info, IfStmt, LOG.info("relative to working: " + pathname + " -> .");
116: Todd Lipcon, info, MethodDeclaration, LOG.info("relative to working: " + pathname + " -> " + s);
147: Todd Lipcon, info, MethodDeclaration, LOG.info("TEST_ROOT_DIR is " + TEST_ROOT_DIR);
157: Alejandro Abdelnur, info, IfStmt, LOG.info(stagingPath + " exists! deleting...");
160: Alejandro Abdelnur, info, TryStmt, LOG.info("mkdir: " + stagingPath);
219: Akira Ajisaka, info, MethodDeclaration, LOG.info("MiniMRYARN ResourceManager address: " + getConfig().get(YarnConfiguration.RM_ADDRESS));
221: Akira Ajisaka, info, MethodDeclaration, LOG.info("MiniMRYARN ResourceManager web address: " + WebAppUtils.getRMWebAppURLWithoutScheme(getConfig()));
223: Akira Ajisaka, info, MethodDeclaration, LOG.info("MiniMRYARN HistoryServer address: " + getConfig().get(JHAdminConfig.MR_HISTORY_ADDRESS));
225: Akira Ajisaka, info, MethodDeclaration, LOG.info("MiniMRYARN HistoryServer web address: " + getResolvedMRHistoryWebAppURLWithoutScheme(getConfig(), MRWebAppUtil.getJHSHttpPolicy() == HttpConfig.Policy.HTTPS_ONLY));
65: Alejandro Abdelnur, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
89: Alejandro Abdelnur, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
113: Alejandro Abdelnur, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
72: Arun Murthy, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
152: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
318: Jason Lowe, info, MethodDeclaration, LOG.info("\n\n\nStarting testSleepJob: useRemoteJar=" + useRemoteJar);
326: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
413: Jason Lowe, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
482: Junping Du, info, MethodDeclaration, LOG.info("\n\n\nStarting testJobClassloader()" + " useCustomClasses=" + useCustomClasses);
486: Arun Murthy, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
605: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("\n\n\nStarting testRandomWriter().");
607: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
664: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("\n\n\nStarting testFailingMapper().");
667: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
746: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("\n\n\nStarting testSleepJobWithSecurityOn().");
767: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("User name is " + user.getUserName());
769: Vinod Kumar Vavilapalli, info, ForeachStmt, LOG.info("Token is " + str.encodeToUrlString());
799: Jason Darrell Lowe, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
832: Jason Darrell Lowe, warn, IfStmt, LOG.warn("application did not reach terminal state within 60 seconds");
858: Jason Darrell Lowe, info, ForeachStmt, LOG.info("Checking for glob: " + absSyslogGlob);
944: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Java Classpath: " + System.getProperty("java.class.path"));
1029: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
1122: Ming Ma, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
1152: Ming Ma, warn, IfStmt, LOG.warn("application did not reach terminal state within 60 seconds");
1176: Ming Ma, info, ForeachStmt, LOG.info("Checking for glob: " + absSyslogGlob);
1306: Chris Trezzo, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
84: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
104: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
118: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
147: Suresh Srinivas, warn, IfStmt, LOG.warn("application did not reach terminal state within 60 seconds");
157: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("CounterMR " + counterMR);
78: Sanford Ryza, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
98: Sanford Ryza, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
110: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Starting testDefaultProfiler");
116: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Starting testDefaultProfiler");
122: Sanford Ryza, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
165: Sanford Ryza, warn, IfStmt, LOG.warn("application did not reach terminal state within 60 seconds");
70: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
103: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("\n\n\nStarting testJobSucceed().");
106: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
132: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("\n\n\nStarting testJobFail().");
135: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
71: Mahadev Konar, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
100: Mahadev Konar, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
110: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
198: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
102: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("\n\n\nStarting uberized testFailingMapper().");
105: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MRAppJar " + MiniMRYarnCluster.APPJAR + " not found. Not running test.");
59: Todd Lipcon, info, MethodDeclaration, LOG.info("The key " + key);
63: Todd Lipcon, info, IfStmt, LOG.info("The value  " + val);
63: Todd Lipcon, info, MethodDeclaration, LOG.info("Hadoop platform inited");
71: Todd Lipcon, info, MethodDeclaration, LOG.info("NativeHandler: direct buffer size: " + bufferSize);
83: Todd Lipcon, error, IfStmt, LOG.error(message);
92: Todd Lipcon, error, IfStmt, LOG.error(message);
101: Todd Lipcon, error, IfStmt, LOG.error(message);
107: Todd Lipcon, error, IfStmt, LOG.error(message);
127: Todd Lipcon, error, CatchClause, LOG.error(message);
122: Todd Lipcon, error, IfStmt, LOG.error(message);
117: Todd Lipcon, error, IfStmt, LOG.error(message);
151: Todd Lipcon, error, IfStmt, LOG.error(message);
137: Sean Zhong, error, IfStmt, LOG.error(message);
165: Todd Lipcon, error, CatchClause, LOG.error(message);
169: Todd Lipcon, info, MethodDeclaration, LOG.info("Native output collector can be successfully enabled!");
58: Todd Lipcon, error, CatchClause, LOG.error("Failed to load nativetask JNI library with error: " + t);
59: Todd Lipcon, info, CatchClause, LOG.info("java.library.path=" + System.getProperty("java.library.path"));
60: Todd Lipcon, info, CatchClause, LOG.info("LD_LIBRARY_PATH=" + System.getenv("LD_LIBRARY_PATH"));
54: Todd Lipcon, info, TryStmt, LOG.info("Nativetask JNI library loaded.");
88: Todd Lipcon, warn, IfStmt, LOG.warn("Can't create NativeObject for class " + clazz + ", probably not exist.");
101: Todd Lipcon, warn, IfStmt, LOG.warn("Can't create NativeObject for class " + clazz + ", probably not exist.");
58: Todd Lipcon, debug, IfStmt, LOG.debug("platform " + platform.name() + " support key class" + keyClassName);
71: Todd Lipcon, debug, IfStmt, LOG.debug("platform " + platform.name() + " define comparator " + keyComparator.getName());
58: Todd Lipcon, debug, IfStmt, LOG.debug("StatusUpdater thread exiting " + "since it got interrupted");
65: Todd Lipcon, warn, CatchClause, LOG.warn("Update native status got exception", e);
66: Todd Lipcon, info, IfStmt, LOG.info("NativeTask Combiner is enabled, class = " + combinerClazz);
83: Todd Lipcon, info, IfStmt, LOG.info("[NativeCollectorOnlyHandler] combiner is not null");
37: Todd Lipcon, info, MethodDeclaration, LOG.info(OutputUtil.NATIVE_TASK_OUTPUT_MANAGER + " = " + clazz.getName());
77: Binglin Chang, info, ForStmt, LOG.info("===KV Size Test: min size: " + min + ", max size: " + max);
99: Tsuyoshi Ozawa, info, IfStmt, LOG.info("Created test file " + inputpath + " in " + sw.now(TimeUnit.MILLISECONDS) + "ms");
82: Todd Lipcon, info, MethodDeclaration, LOG.info("Parameterizing with value classes: " + valueClassesStr);
87: Todd Lipcon, info, MethodDeclaration, LOG.info("Parameterizing with key classes: " + keyClassesStr);
95: Binglin Chang, info, ForStmt, LOG.info("===KV Size Test: min size: " + min + ", max size: " + max + ", keyClass: " + keyClass.getName() + ", valueClass: " + valueClass.getName());
129: Todd Lipcon, info, MethodDeclaration, LOG.info("creating file " + filepath + "(" + filesize + " bytes)");
130: Todd Lipcon, info, MethodDeclaration, LOG.info(keyClsName + " " + valueClsName);
40: Todd Lipcon, error, CatchClause, LOG.error("load nativetask lib failed, Native-Task Delegation is disabled", e);
81: Siddharth Seth, warn, CatchClause, LOG.warn("Failed to manage OS cache for " + identifier, t);
167: Siddharth Seth, warn, CatchClause, LOG.warn("Failed to manage OS cache for " + identifier, t);
467: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error during initApp", e);
479: Karthik Kambatla, Error, CatchClause, LOG.error("Error during stopApp", e);
549: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(getName() + " listening on port " + port);
590: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error during getMeta", e);
631: Karthik Kambatla, info, MethodDeclaration, LOG.info("Using state database at " + dbPath + " for recovery");
637: Karthik Kambatla, info, IfStmt, LOG.info("Creating state database at " + dbfile);
701: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Loaded state DB schema version info " + loadedVersion);
706: Naganarasimha, info, IfStmt, LOG.info("Storing state DB schema version info " + getCurrentVersion());
719: Karthik Kambatla, info, MethodDeclaration, LOG.info("Added token for " + jobId.toString());
801: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Encrypted shuffle is enabled.");
883: Jian He, debug, IfStmt, LOG.debug("Loaded : " + key + " via loader");
855: Jian He, debug, IfStmt, LOG.debug("PathCache Eviction: " + notification.getKey() + ", Reason=" + notification.getCause());
914: Jonathan Turner Eagles, info, IfStmt, LOG.info(String.format("Current number of shuffle connections (%d) is " + "greater than or equal to the max allowed shuffle connections (%d)", accepted.size(), maxShuffleConnections));
957: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("KeepAliveParam : " + keepAliveList + " : " + keepAliveParam);
965: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("RECV: " + request.getUri() + "\n  mapId: " + mapIds + "\n  reduceId: " + reduceQ + "\n  jobId: " + jobQ + "\n  keepAlive: " + keepAliveParam);
1004: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Shuffle failure ", e);
1023: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Shuffle error in populating headers :", e);
1080: Eric Payne, error, IfStmt, LOG.error("Shuffle error :", e);
1078: Eric Payne, error, IfStmt, LOG.error("Shuffle error :" + e);
1120: Jian He, debug, IfStmt, LOG.debug("Retrieved pathInfo for " + identifier + " check for corresponding loaded messages to determine whether" + " it was loaded or cached");
1136: Jian He, Info, IfStmt, LOG.debug("getMapOutputInfo: jobId=" + jobId + ", mapId=" + mapId + ",dataFile=" + pathInfo.dataPath + ", indexFile=" + pathInfo.indexPath);
1178: Jason Lowe, debug, IfStmt, AUDITLOG.debug(sb.toString());
1197: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Content Length in shuffle : " + contentLength);
1186: Jason Lowe, debug, IfStmt, LOG.debug("Setting connection close header...");
1216: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Request for unknown token " + appid);
1225: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Missing header hash for " + appid);
1230: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("verifying request. enc_str=" + enc_str + "; hash=..." + urlHashStr.substring(len - len / 2, len - 1));
1248: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Fetcher request verfied. enc_str=" + enc_str + ";reply=" + reply.substring(len - len / 2, len - 1));
1268: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info(spillfile + " not found");
1341: Robert Joseph Evans, debug, IfStmt, LOG.debug("Ignoring closed channel error", cause);
1346: Robert Joseph Evans, debug, IfStmt, LOG.debug("Ignoring client socket close", cause);
1351: Vinod Kumar Vavilapalli, error, MethodDeclaration, LOG.error("Shuffle error: ", cause);
1353: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Shuffle error " + e);
142: Chris Nauroth, info, CatchClause, LOG.info("Expected - illegal argument is passed.");
152: Chris Nauroth, info, CatchClause, LOG.info("Expected - illegal argument is passed.");
683: Jonathan Turner Eagles, info, CatchClause, LOG.info("Expected - connection should not be open");
711: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(appId.toString());
125: Robert Kanter, Error, CatchClause, LOG.error("Error in execution " + e.getMessage());
118: Robert Kanter, info, TryStmt, LOG.info("Uploaded " + target);
121: Robert Kanter, info, TryStmt, LOG.info("Suggested mapreduce.application.classpath $PWD/" + alias + "/*");
136: Robert Kanter, info, ForeachStmt, LOG.info("Original source " + item);
138: Robert Kanter, info, ForeachStmt, LOG.info("Expanded source " + expanded);
161: Robert Kanter, warn, IfStmt, LOG.warn("Ignored " + expanded + " only jars are supported");
155: Robert Kanter, warn, IfStmt, LOG.warn("Ignored " + expanded + ". It is not a directory");
152: Robert Kanter, warn, IfStmt, LOG.warn("Could not list directory " + path);
148: Robert Kanter, info, IfStmt, LOG.info("Ignored " + jar + " because it is a directory");
178: Robert Kanter, info, IfStmt, LOG.info("Target " + targetPath);
197: Robert Kanter, warn, IfStmt, LOG.warn("Cannot set replication to " + initialReplication + " for path: " + targetPath + " on a non-distributed fileystem " + fileSystem.getClass().getName());
183: Robert Kanter, info, IfStmt, LOG.info("Set replication to " + initialReplication + " for path: " + targetPath);
185: Robert Kanter, info, IfStmt, LOG.info("Disabling Erasure Coding for path: " + targetPath);
208: Robert Kanter, info, IfStmt, LOG.info("Creating GZip");
238: Robert Kanter, info, ForStmt, LOG.info(String.format("Replication counts offset:%d blocks:%d", offset, blockCount.get(offset)));
269: Robert Kanter, info, IfStmt, LOG.info("Cannot set replication to " + finalReplication + " for path: " + targetPath + " on a non-distributed fileystem " + fileSystem.getClass().getName());
251: Robert Kanter, info, IfStmt, LOG.info("Set replication to " + finalReplication + " for path: " + targetPath);
263: Robert Kanter, error, IfStmt, LOG.error(String.format("Timed out after %d seconds while waiting for acceptable" + " replication of %d (current replication is %d)", timeout, acceptableReplication, currentReplication));
280: Robert Kanter, info, MethodDeclaration, LOG.info("Compressing tarball");
284: Robert Kanter, info, ForeachStmt, LOG.info("Adding " + fullPath);
304: Robert Kanter, info, ForeachStmt, LOG.info("Environment " + item.getKey() + " " + item.getValue());
312: Robert Kanter, info, ForeachStmt, LOG.info("Whitelisted " + compiledPattern.toString());
321: Robert Kanter, info, ForeachStmt, LOG.info("Blacklisted " + compiledPattern.toString());
356: Robert Kanter, info, IfStmt, LOG.info("Ignored non-jar " + jar.getAbsolutePath());
361: Robert Kanter, info, IfStmt, LOG.info("Whitelisted " + jar.getAbsolutePath());
370: Robert Kanter, info, IfStmt, LOG.info("Blacklisted " + jar.getAbsolutePath());
379: Robert Kanter, info, IfStmt, LOG.info("Whitelisted " + jar.getAbsolutePath());
388: Robert Kanter, info, IfStmt, LOG.info("Ignored " + jar.getAbsolutePath() + " because it is on " + "the the blacklist");
385: Robert Kanter, info, IfStmt, LOG.info("Ignored " + jar.getAbsolutePath() + " because it is missing " + "from the whitelist");
419: Robert Kanter, debug, CatchClause, LOG.debug("Not a link", jar);
421: Robert Kanter, warn, CatchClause, LOG.warn("Cannot read symbolic link on", jar);
414: Robert Kanter, info, IfStmt, LOG.info(String.format("Ignoring same directory link %s to %s", jarPath.toString(), link.toString()));
527: Robert Kanter, info, IfStmt, LOG.info(String.format("Target file system not specified. Using default %s", fs));
523: Robert Kanter, error, IfStmt, LOG.error("No filesystem specified in either fs or target.");
532: Robert Kanter, error, IfStmt, LOG.error("Target directory not specified");
545: Robert Kanter, warn, IfStmt, LOG.warn("Unexpected parameters");
97: Todd Lipcon, info, MethodDeclaration, LOG.info("offset=" + offset + ", length=" + length);
130: Todd Lipcon, info, MethodDeclaration, LOG.info("hex.size() = " + hex.size());
157: Todd Lipcon, info, IfStmt, LOG.info("Writing text output to " + outfile);
222: Todd Lipcon, info, ConstructorDeclaration, LOG.info("Map #" + i + ": workload=" + workload(offset, size) + ", offset=" + offset + ", size=" + size);
119: Todd Lipcon, warn, CatchClause, LOG.warn("Exception occurred while closing connection :" + StringUtils.stringifyException(ex));
127: Todd Lipcon, warn, CatchClause, LOG.warn("Exception occurred while shutting down HSQLDB :" + StringUtils.stringifyException(ex));
271: Todd Lipcon, info, TryStmt, LOG.info("totalPageview=" + totalPageview);
272: Todd Lipcon, info, TryStmt, LOG.info("sumPageview=" + sumPageview);
221: Todd Lipcon, debug, MethodDeclaration, LOG.debug("cover " + col.head.name);
243: Todd Lipcon, debug, MethodDeclaration, LOG.debug("uncover " + col.head.name);
163: Todd Lipcon, info, MethodDeclaration, LOG.info(s = "sigma=" + sigma);
171: Todd Lipcon, info, MethodDeclaration, LOG.info(s = "result=" + result);
351: Todd Lipcon, info, ForStmt, LOG.info("parts[" + i + "] = " + parts[i]);
371: Todd Lipcon, info, MethodDeclaration, LOG.info("index=" + index);
176: Todd Lipcon, info, MethodDeclaration, LOG.info("Generating " + totalRows + " using " + numSplits);
95: Kai Zheng, info, CatchClause, LOG.info("Operation hsync is not supported so far on path with " + "erasure code policy set");
147: Todd Lipcon, debug, IfStmt, LOG.debug("picking " + result);
158: Todd Lipcon, debug, ForeachStmt, LOG.debug("  examine: " + cur.filename + " " + cur.locations.size());
174: Todd Lipcon, debug, IfStmt, LOG.debug(" best: " + best[i].filename);
236: Todd Lipcon, info, MethodDeclaration, LOG.info("starting solve");
250: Todd Lipcon, info, MethodDeclaration, LOG.info("done");
300: Todd Lipcon, info, MethodDeclaration, LOG.info("starting");
324: Mahadev Konar, error, CatchClause, LOG.error(e.getMessage());
335: Todd Lipcon, info, MethodDeclaration, LOG.info("done");
96: Gera Shegalov, info, CatchClause, LOG.info("Expected exception: ", fae);
107: Gera Shegalov, info, CatchClause, LOG.info("Expected exception: ", fae);
100: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info("cmake compilation finished successfully in " + TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS) + " millisecond(s).");
138: Colin Patrick Mccabe, info, IfStmt, getLog().info("mkdirs '" + output + "'");
156: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info("Running " + bld.toString());
157: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info("with extra environment variables " + Exec.envToString(env));
189: Colin Patrick Mccabe, error, CatchClause, getLog().error("Interrupted while joining output thread", e);
193: Colin Patrick Mccabe, warn, ForeachStmt, getLog().warn(line);
215: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info("Running " + bld.toString());
241: Colin Patrick Mccabe, error, CatchClause, getLog().error("Interrupted while joining stdoutThread", e);
245: Colin Patrick Mccabe, warn, ForeachStmt, getLog().warn(line);
253: Colin Patrick Mccabe, error, CatchClause, getLog().error("Interrupted while joining stderrThread", e);
258: Colin Patrick Mccabe, warn, ForeachStmt, getLog().warn(line);
217: Colin Patrick Mccabe, info, IfStmt, getLog().info("skipTests is in effect for test " + testName);
223: Colin Patrick Mccabe, info, IfStmt, getLog().info("Skipping missing test " + testName);
248: Colin Patrick Mccabe, debug, IfStmt, getLog().debug("did not find test '" + testName + "' in " + "list " + testProp);
271: Colin Patrick Mccabe, info, IfStmt, getLog().info("Skipping test " + testName + " because negative precondition number " + idx + " was met.");
265: Colin Patrick Mccabe, info, IfStmt, getLog().info("Skipping test " + testName + " because precondition number " + idx + " was not met.");
305: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info("-------------------------------------------------------");
306: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info(" C M A K E B U I L D E R    T E S T");
307: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info("-------------------------------------------------------");
315: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info(bld.toString());
323: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info("with extra environment variables " + Exec.envToString(env));
357: Colin Patrick Mccabe, error, CatchClause, getLog().error("Interrupted while waiting for testThread", e);
368: Colin Patrick Mccabe, error, CatchClause, getLog().error("failed to write status file!", e);
375: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info("STATUS: " + status + " after " + TimeUnit.MILLISECONDS.convert(end - start, TimeUnit.NANOSECONDS) + " millisecond(s).");
378: Colin Patrick Mccabe, info, MethodDeclaration, getLog().info("-------------------------------------------------------");
92: Chris Douglas, info, IfStmt, getLog().info("Creating " + newDir.toString());
129: Andrew Wang, debug, IfStmt, mojo.getLog().debug("Skipping entry that is not a file or directory: " + f);
178: Andrew Wang, info, TryStmt, mojo.getLog().info("Wrote protoc checksums to file " + checksumFile);
195: Andrew Wang, error, IfStmt, mojo.getLog().error("stdout: " + out);
191: Andrew Wang, error, IfStmt, mojo.getLog().error("protoc, not found at: " + protocCommand);
255: Andrew Wang, debug, IfStmt, mojo.getLog().debug(b.toString());
262: Andrew Wang, error, IfStmt, mojo.getLog().error("protoc compiler error");
264: Andrew Wang, error, ForeachStmt, mojo.getLog().error(s);
267: Andrew Wang, error, ForeachStmt, mojo.getLog().error(s);
242: Andrew Wang, info, IfStmt, mojo.getLog().info("No changes detected in protoc files, skipping " + "generation.");
115: Robert Kanter, info, TryStmt, getLog().info("Compressing " + path + " to " + outFile);
88: Tsuyoshi Ozawa, warn, CatchClause, mojo.getLog().warn(command + " failed: " + ioe.toString());
90: Tsuyoshi Ozawa, warn, CatchClause, mojo.getLog().warn(command + " failed: " + ie.toString());
76: Suresh Srinivas, warn, IfStmt, mojo.getLog().warn(command + " failed with error code " + retCode);
78: Suresh Srinivas, debug, ForeachStmt, mojo.getLog().debug(s);
133: Suresh Srinivas, debug, IfStmt, getLog().debug(scmOut.toString());
135: Suresh Srinivas, info, MethodDeclaration, getLog().info("SCM: " + scm);
230: Suresh Srinivas, debug, ForeachStmt, getLog().debug("Computing MD5 for: " + file);
279: Suresh Srinivas, info, MethodDeclaration, getLog().info("Computed MD5: " + md5str);
76: Xiaoyu Yao, info, MethodDeclaration, LOG.info("Creating OzoneClient with default configuration.");
295: Anu Engineer, error, CatchClause, LOG.error(message + " exception:" + e);
288: Anu Engineer, debug, TryStmt, LOG.debug("Using {} as client protocol.", protocolClass.getCanonicalName());
51: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("Invoking method {} on proxy {}", method, proxy);
55: Xiaoyu Yao, debug, TryStmt, LOG.debug("Call: {} took {} ms", method, Time.monotonicNow() - startTime);
279: Chen Liang, debug, TryStmt, LOG.debug("get key accessing {} {}", xceiverClient.getPipeline().getContainerName(), containerKey);
134: Nandakumar, debug, ConstructorDeclaration, LOG.debug("Expecting open key with one block, but got" + info.getKeyLocationVersions().size());
183: Nandakumar, error, IfStmt, LOG.error("Container creation failed for {}.", containerName, ex);
181: Nandakumar, debug, IfStmt, LOG.debug("Container {} already exists.", containerName);
211: Nandakumar, error, CatchClause, LOG.error("Allocate block fail when writing.");
260: Nandakumar, error, CatchClause, LOG.error("Try to allocate more blocks for write failed, already " + "allocated " + succeededAllocates + " blocks for this write.");
326: Nandakumar, warn, IfStmt, LOG.warn("Closing ChunkGroupOutputStream, but key args is null");
39: Xiaoyu Yao, debug, MethodDeclaration, LOG.debug("Returning exception. ex: {}", exception.toJsonString());
246: Xiaoyu Yao, info, TryStmt, LOG.info("Creating Volume: {}, with {} as owner and quota set to {}.", volumeName, owner, quota == null ? "default" : quota);
392: Xiaoyu Yao, info, TryStmt, LOG.info("Creating Bucket: {}/{}, with Versioning {} and Storage Type" + " set to {}", volumeName, bucketName, versioning, storageType);
146: Anu Engineer, warn, IfStmt, LOG.warn("The chunk size ({}) is not allowed to be more than" + " the maximum size ({})," + " resetting to the maximum size.", configuredChunkSize, ScmConfigKeys.OZONE_SCM_CHUNK_MAX_SIZE);
209: Anu Engineer, info, MethodDeclaration, LOG.info("Creating Volume: {}, with {} as owner and quota set to {} bytes.", volumeName, owner, quota);
339: Anu Engineer, info, MethodDeclaration, LOG.info("Creating Bucket: {}/{}, with Versioning {} and " + "Storage Type set to {}", volumeName, bucketName, isVersionEnabled, storageType);
259: Anu Engineer, trace, CatchClause, LOG.trace("", orce);
504: Anu Engineer, trace, TryStmt, LOG.trace("listKeys URI={}", uri);
110: Mukul Kumar Singh, info, LambdaExpr, LOG.info("{}. Got {} of {} DN Heartbeats.", isReady ? "Cluster is ready" : "Waiting for cluster to be ready", healthy, hddsDatanodes.size());
131: Mukul Kumar Singh, info, LambdaExpr, LOG.info("Waiting for cluster to be ready. No datanodes found");
187: Mukul Kumar Singh, info, MethodDeclaration, LOG.info("Creating StorageContainerLocationProtocol RPC client with address {}", address);
252: Mukul Kumar Singh, error, CatchClause, LOG.error("Exception while shutting down the cluster.", e);
225: Mukul Kumar Singh, info, TryStmt, LOG.info("Shutting down the Mini Ozone Cluster");
233: Mukul Kumar Singh, info, IfStmt, LOG.info("Shutting down the keySpaceManager");
239: Mukul Kumar Singh, info, IfStmt, LOG.info("Shutting down the StorageContainerManager");
245: Mukul Kumar Singh, info, IfStmt, LOG.info("Shutting down the HddsDatanodes");
420: Mukul Kumar Singh, TRACE, IfStmt, GenericTestUtils.setRootLogLevel(Level.TRACE);
422: Mukul Kumar Singh, INFO, MethodDeclaration, GenericTestUtils.setRootLogLevel(Level.INFO);
95: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info(OzoneConfigKeys.DFS_CONTAINER_RATIS_RPC_TYPE_KEY + " = " + rpc.name());
198: Anu Engineer, trace, MethodDeclaration, LOG.trace("writeChunk {} (key={}) to pipeline=", datalen, keyName, pipeline);
301: Anu Engineer, trace, MethodDeclaration, LOG.trace("readChunk key={} from pipeline={}", request.getKeyName(), request.getPipeline());
333: Anu Engineer, trace, MethodDeclaration, LOG.trace("deleteChunk key={} from pipeline={}", writeRequest.getKeyName(), writeRequest.getPipeline());
361: Anu Engineer, trace, MethodDeclaration, LOG.trace("addContainer: {}", containerName);
449: Anu Engineer, trace, MethodDeclaration, LOG.trace("putKey: {} to pipeline={}", writeRequest.getKeyName(), writeRequest.getPipeline());
481: Anu Engineer, trace, MethodDeclaration, LOG.trace("getKey: name={} from pipeline={}", putKeyRequest.getKeyData().getName(), putKeyRequest.getPipeline());
525: Anu Engineer, trace, MethodDeclaration, LOG.trace("deleteKey: name={} from pipeline={}", putKeyRequest.getKeyData().getName(), putKeyRequest.getPipeline());
147: Weiwei Yang, info, ForStmt, LOG.info("Creating file {}", chunk.getAbsolutePath());
170: Nanda kumar, info, MethodDeclaration, log.info("Deleting {}", path);
72: Tsz-Wo Nicholas Sze, info, MethodDeclaration, LOG.info(testName + "(rpc=" + rpc + ", numNodes=" + numNodes);
90: Anu Engineer, info, TryStmt, LOG.info("pipeline=" + pipeline);
71: Anu Engineer, info, MethodDeclaration, LOG.info("runTestRatisManager, rpc=" + rpc);
98: Anu Engineer, info, ForStmt, LOG.info("Created RatisCluster " + ratisId);
107: Anu Engineer, info, TryStmt, LOG.info("chosen = " + chosen);
122: Nanda kumar, info, MethodDeclaration, LOG.info("DN Container Data:  keyCount: {} used: {} ", cd.getKeyCount(), cd.getBytesUsed());
127: Nanda kumar, info, MethodDeclaration, LOG.info("SCM Container Info keyCount: {} usedBytes: {}", cinfo.getNumberOfKeys(), cinfo.getUsedBytes());
198: Xiaoyu Yao, Error, CatchClause, log.error("Error received in client setup", ex);
175: Xiaoyu Yao, INFO, MethodDeclaration, p.addLast("log", new LoggingHandler(LogLevel.INFO));
211: Xiaoyu Yao, info, IfStmt, log.info("STATUS: " + response.getStatus());
212: Xiaoyu Yao, info, IfStmt, log.info("VERSION: " + response.getProtocolVersion());
218: Xiaoyu Yao, info, IfStmt, log.info(content.content().toString(UTF_8));
220: Xiaoyu Yao, info, IfStmt, log.info("END OF CONTENT");
227: Xiaoyu Yao, error, MethodDeclaration, log.error("Exception upon channel read", cause);
92: Anu Engineer, info, ConstructorDeclaration, LOG.info("ObjectStoreHandler initializing with {}: {}", OZONE_HANDLER_TYPE_KEY, shType);
185: Anu Engineer, info, MethodDeclaration, LOG.info("Closing ObjectStoreHandler.");
62: Xiaoyu Yao, error, IfStmt, LOG.error("Not starting {}, as the plugin is not invoked through {}", OzoneHddsDatanodeService.class.getSimpleName(), HddsDatanodeService.class.getSimpleName());
102: Xiaoyu Yao, error, CatchClause, LOG.error("Invalid bucket.", argEx);
97: Xiaoyu Yao, debug, TryStmt, LOG.debug("Success");
152: Xiaoyu Yao, error, MethodDeclaration, LOG.error("IOException:", fsExp);
252: Chris Nauroth, debug, CatchClause, LOG.debug("Malformed Version. version: {}", version);
285: Chris Nauroth, debug, IfStmt, LOG.debug("Malformed storage type. Type: {}", storageClassString.get(0).toUpperCase());
99: Xiaoyu Yao, error, CatchClause, LOG.error("Invalid bucket in key call.", argExp);
102: Xiaoyu Yao, error, CatchClause, LOG.error("IOException:", fsExp);
113: Yiqun Lin, error, CatchClause, LOG.error("NoSuchAlgorithmException. Probably indicates an unusual java " + "installation.", algoEx);
94: Xiaoyu Yao, debug, TryStmt, LOG.debug("Success");
163: Chris Nauroth, debug, IfStmt, LOG.debug(msg);
191: Chris Nauroth, debug, IfStmt, LOG.debug(msg);
242: Anu Engineer, debug, SwitchStmt, LOG.debug("Unrecognized query param : {} ", info);
101: Xiaoyu Yao, error, CatchClause, LOG.error("Illegal argument.", ex);
96: Chris Nauroth, info, TryStmt, LOG.info("Success");
134: Xiaoyu Yao, error, MethodDeclaration, LOG.error("IOException:", fsExp);
182: Xiaoyu Yao, debug, CatchClause, LOG.debug("Malformed Quota.", ex);
239: Xiaoyu Yao, debug, CatchClause, LOG.debug("unable to get the volume list for the user.", ex);
269: Xiaoyu Yao, debug, CatchClause, LOG.debug("unable to get the bucket list for the specified volume.", ex);
154: Chris Nauroth, error, IfStmt, LOG.error("Creation of Ozone root failed. " + file.toString());
169: Chris Nauroth, error, CatchClause, LOG.error("Cannot open db :" + ex.getMessage());
204: Anu Engineer, debug, IfStmt, LOG.debug("Volume {} already exists.", volumeName);
873: Chris Nauroth, debug, IfStmt, LOG.debug("we are overwriting a file. This is by design.");
875: Chris Nauroth, error, IfStmt, LOG.error("Unable to delete the file: {}", fullPath);
55: Anu Engineer, error, MethodDeclaration, LOG.error("Unexpected exception in Netty pipeline.", cause);
140: Anu Engineer, info, CatchClause, LOG.info("Interrupted while attempting to cancel dispatch thread.");
226: Anu Engineer, trace, MethodDeclaration, LOG.trace("begin RequestRunner, nettyReq = {}", this.nettyReq);
234: Xiaoyu Yao, Error, CatchClause, LOG.error("Error running Jersey Request Runner", e);
241: Anu Engineer, trace, MethodDeclaration, LOG.trace("end RequestRunner, nettyReq = {}", this.nettyReq);
260: Anu Engineer, trace, MethodDeclaration, LOG.trace("begin writeStatusAndHeaders, contentLength = {}, jerseyResp = {}.", contentLength, jerseyResp);
268: Anu Engineer, trace, MethodDeclaration, LOG.trace("end writeStatusAndHeaders, contentLength = {}, jerseyResp = {}.", contentLength, jerseyResp);
344: Anu Engineer, trace, MethodDeclaration, LOG.trace("baseUri = {}, reqUri = {}", baseUri, reqUri);
148: Anu Engineer, info, IfStmt, LOG.info("Listening HDDS REST traffic on " + httpAddress);
78: Anu Engineer, trace, MethodDeclaration, LOG.trace("begin RequestContentObjectStoreChannelHandler channelRead0, " + "ctx = {}, content = {}", ctx, content);
107: Anu Engineer, trace, MethodDeclaration, LOG.trace("end RequestContentObjectStoreChannelHandler channelRead0, " + "ctx = {}, content = {}", ctx, content);
68: Anu Engineer, trace, MethodDeclaration, LOG.trace("begin RequestDispatchObjectStoreChannelHandler channelRead0, " + "ctx = {}, nettyReq = {}", ctx, nettyReq);
81: Anu Engineer, trace, IfStmt, LOG.trace("Sending continue response.");
93: Anu Engineer, trace, MethodDeclaration, LOG.trace("end RequestDispatchObjectStoreChannelHandler channelRead0, " + "ctx = {}, nettyReq = {}", ctx, nettyReq);
124: Anu Engineer, warn, IfStmt, LOG.warn("The chunk size ({}) is not allowed to be more than" + " the maximum size ({})," + " resetting to the maximum size.", chunkSize, ScmConfigKeys.OZONE_SCM_CHUNK_MAX_SIZE);
114: Nandakumar, error, IfStmt, LOG.error("Bucket creation failed for bucket:{} in volume:{}", bucketName, volumeName, ex);
90: Nandakumar, debug, IfStmt, LOG.debug("volume: {} not found ", volumeName);
96: Nandakumar, debug, IfStmt, LOG.debug("bucket: {} already exists ", bucketName);
111: Xiaoyu Yao, debug, TryStmt, LOG.debug("created bucket: {} in volume: {}", bucketName, volumeName);
147: Nandakumar, error, IfStmt, LOG.error("Exception while getting bucket info for bucket: {}", bucketName, ex);
139: Nandakumar, debug, IfStmt, LOG.debug("bucket: {} not found in volume: {}.", bucketName, volumeName);
225: Nandakumar, error, IfStmt, LOG.error("Setting bucket property failed for bucket:{} in volume:{}", bucketName, volumeName, ex);
172: Nandakumar, debug, IfStmt, LOG.debug("volume: {} not found ", volumeName);
179: Nandakumar, debug, IfStmt, LOG.debug("bucket: {} not found ", bucketName);
193: Xiaoyu Yao, debug, IfStmt, LOG.debug("Updating ACLs for bucket: {} in volume: {}", bucketName, volumeName);
203: Xiaoyu Yao, debug, IfStmt, LOG.debug("Updating bucket storage type for bucket: {} in volume: {}", bucketName, volumeName);
213: Xiaoyu Yao, debug, IfStmt, LOG.debug("Updating bucket versioning for bucket: {} in volume: {}", bucketName, volumeName);
290: Nandakumar, error, IfStmt, LOG.error("Delete bucket failed for bucket:{} in volume:{}", bucketName, volumeName, ex);
271: Nandakumar, debug, IfStmt, LOG.debug("volume: {} not found ", volumeName);
277: Nandakumar, debug, IfStmt, LOG.debug("bucket: {} not found ", bucketName);
283: Nandakumar, debug, IfStmt, LOG.debug("bucket: {} is not empty ", bucketName);
135: Weiwei Yang, error, CatchClause, LOG.error("Unable to get pending deletion keys, retry in" + " next interval", e);
132: Anu Engineer, debug, IfStmt, LOG.debug("No pending deletion key found in KSM");
99: Weiwei Yang, info, IfStmt, LOG.info("Found {} to-delete keys in KSM", keyBlocksList.size());
117: Weiwei Yang, warn, IfStmt, LOG.warn("Key {} deletion failed because some of the blocks" + " were failed to delete, failed blocks: {}", result.getObjectKey(), String.join(",", result.getFailedBlocks()));
107: Weiwei Yang, debug, TryStmt, LOG.debug("Key {} deleted from KSM DB", result.getObjectKey());
125: Weiwei Yang, info, IfStmt, LOG.info("Number of key deleted from KSM DB: {}," + " task elapsed time: {}ms", results.size(), Time.monotonicNow() - startTime);
156: Nandakumar, error, IfStmt, LOG.error("volume not found: {}", volumeName);
162: Nandakumar, error, IfStmt, LOG.error("bucket not found: {}/{} ", volumeName, bucketName);
196: Nandakumar, error, IfStmt, LOG.error("Allocate block for a key not in open status in meta store " + objectKey + " with ID " + clientID);
323: Nandakumar, error, IfStmt, LOG.error("Key open failed for volume:{} bucket:{} key:{}", volumeName, bucketName, keyName, ex);
316: Nandakumar, debug, TryStmt, LOG.debug("Key {} allocated in volume {} bucket {}", keyName, volumeName, bucketName);
363: Anu Engineer, error, CatchClause, LOG.error("Key commit failed for volume:{} bucket:{} key:{}", volumeName, bucketName, keyName, ex);
391: Xiaoyu Yao, error, CatchClause, LOG.error("Get key failed for volume:{} bucket:{} key:{}", volumeName, bucketName, keyName, ex);
384: Xiaoyu Yao, debug, IfStmt, LOG.debug("volume:{} bucket:{} Key:{} not found", volumeName, bucketName, keyName);
421: Weiwei Yang, error, CatchClause, LOG.error(String.format("Delete key failed for volume:%s " + "bucket:%s key:%s", volumeName, bucketName, keyName), ex);
322: Anu Engineer, error, CatchClause, LOG.error("Failed to start the KeyspaceManager.", t);
396: Nanda kumar, error, CatchClause, LOG.error("Could not initialize KSM version file", ioe);
440: Anu Engineer, info, MethodDeclaration, LOG.info(buildRpcServerStartMessage("KeyspaceManager RPC server", ksmRpcAddress));
463: Anu Engineer, error, CatchClause, LOG.error("Key Space Manager stop failed.", e);
475: Anu Engineer, info, CatchClause, LOG.info("Interrupted during KeyspaceManager join.", e);
110: Xiaoyu Yao, error, CatchClause, LOG.error("Unable to get hanging open keys, retry in" + " next interval", e);
107: Xiaoyu Yao, debug, IfStmt, LOG.debug("No hanging open key fond in KSM");
82: Xiaoyu Yao, debug, IfStmt, LOG.debug("Found {} to-delete open keys in KSM", toDeleteSize);
97: Xiaoyu Yao, warn, IfStmt, LOG.warn("Deleting open Key {} failed because some of the blocks" + " were failed to delete, failed blocks: {}", result.getObjectKey(), String.join(",", result.getFailedBlocks()));
93: Xiaoyu Yao, warn, CatchClause, LOG.warn("Failed to delete hanging-open key {}", result.getObjectKey(), e);
90: Xiaoyu Yao, debug, TryStmt, LOG.debug("Key {} deleted from KSM DB", result.getObjectKey());
103: Xiaoyu Yao, info, IfStmt, LOG.info("Found {} expired open key entries, successfully " + "cleaned up {} entries", toDeleteSize, deletedSize);
97: Anu Engineer, error, CatchClause, LOG.error("Caught an exception while processing ServiceList request", e);
83: Nandakumar, debug, IfStmt, LOG.debug("Too many volumes for user:{}", owner);
105: Nandakumar, debug, IfStmt, LOG.debug("volume:{} not found for user:{}");
165: Nandakumar, error, IfStmt, LOG.error("Volume creation failed for user:{} volume:{}", args.getOwnerName(), args.getVolume(), ex);
134: Nandakumar, debug, IfStmt, LOG.debug("volume:{} already exists", args.getVolume());
161: Nandakumar, debug, TryStmt, LOG.debug("created volume:{} user:{}", args.getVolume(), args.getOwnerName());
217: Nandakumar, error, IfStmt, LOG.error("Changing volume ownership failed for user:{} volume:{}", owner, volume, ex);
190: Nandakumar, debug, IfStmt, LOG.debug("Changing volume ownership failed for user:{} volume:{}", owner, volume);
260: Nandakumar, error, IfStmt, LOG.error("Changing volume quota failed for volume:{} quota:{}", volume, quota, ex);
240: Nandakumar, debug, IfStmt, LOG.debug("volume:{} does not exist", volume);
292: Nandakumar, Info, IfStmt, LOG.warn("Info volume failed for volume:{}", volume, ex);
282: Nandakumar, debug, IfStmt, LOG.debug("volume:{} does not exist", volume);
333: Nandakumar, error, IfStmt, LOG.error("Delete volume failed for volume:{}", volume, ex);
315: Nandakumar, debug, IfStmt, LOG.debug("volume:{} does not exist", volume);
320: Nandakumar, debug, IfStmt, LOG.debug("volume:{} is not empty", volume);
368: Nandakumar, error, IfStmt, LOG.error("Check volume access failed for volume:{} user:{} rights:{}", volume, userAcl.getName(), userAcl.getRights(), ex);
358: Nandakumar, debug, IfStmt, LOG.debug("volume:{} does not exist", volume);
160: Anu Engineer, debug, IfStmt, LOG.debug("Unknown error occurs", ex);
408: Yiqun Lin, debug, CatchClause, LOG.debug("Command Failed.", ex);
222: Anu Engineer, info, MethodDeclaration, LOG.info("Number of Threads: " + numOfThreads);
231: Anu Engineer, info, IfStmt, LOG.info("Mode: offline");
232: Anu Engineer, info, IfStmt, LOG.info("Number of Volumes: {}.", numOfVolumes);
233: Anu Engineer, info, IfStmt, LOG.info("Number of Buckets per Volume: {}.", numOfBuckets);
234: Anu Engineer, info, IfStmt, LOG.info("Number of Keys per Bucket: {}.", numOfKeys);
235: Anu Engineer, info, IfStmt, LOG.info("Key size: {} bytes", keySize);
228: Anu Engineer, info, IfStmt, LOG.info("Mode: online");
252: Anu Engineer, info, IfStmt, LOG.info("Data validation is enabled.");
255: Anu Engineer, info, MethodDeclaration, LOG.info("Starting progress bar Thread.");
580: Nandakumar, warn, CatchClause, LOG.warn("Could not close the output stream for json", e);
703: Nanda kumar, trace, MethodDeclaration, LOG.trace("Creating volume: {}", volumeName);
716: Nanda kumar, error, CatchClause, LOG.error("Could not create volume", e);
776: Anu Engineer, error, CatchClause, LOG.error("Exception while creating bucket: {}" + " in volume: {}.", bucketName, volume, e);
725: Anu Engineer, trace, TryStmt, LOG.trace("Creating bucket: {} in volume: {}", bucketName, volume.getName());
770: Anu Engineer, error, CatchClause, LOG.error("Exception while adding key: {} in bucket: {}" + " of volume: {}.", key, bucket, volume, e);
741: Anu Engineer, trace, TryStmt, LOG.trace("Adding key: {} in bucket: {} of volume: {}", key, bucket, volume);
765: Anu Engineer, trace, IfStmt, LOG.trace("Key {}, is queued for validation.", key);
1144: Anu Engineer, error, CatchClause, LOG.error("Exception while validating write: " + ex.getMessage());
1136: Anu Engineer, warn, IfStmt, LOG.warn("Data validation error for key {}/{}/{}", kv.bucket.getVolumeName(), kv.bucket, kv.key);
1138: Anu Engineer, warn, IfStmt, LOG.warn("Expected: {}, Actual: {}", DFSUtil.bytes2String(kv.value), DFSUtil.bytes2String(value));
259: Weiwei Yang, info, MethodDeclaration, LOG.info("DB path {}", value);
263: Anu Engineer, error, IfStmt, LOG.error("DB path not exist:{}", dbPath);
268: Anu Engineer, Error, IfStmt, LOG.error("Error processing db path {}", dbPath);
275: Anu Engineer, Error, IfStmt, LOG.error("Error processing output path {}", outPath);
280: Weiwei Yang, error, IfStmt, LOG.error("The db output path should be a file instead of a directory");
290: Anu Engineer, info, MethodDeclaration, LOG.info("Parent path [{}] db name [{}]", parentPath, dbName);
307: Anu Engineer, error, IfStmt, LOG.error("Unrecognized db name {}", dbName);
304: Weiwei Yang, info, IfStmt, LOG.info("Converting ksm DB");
301: Chen Liang, info, IfStmt, LOG.info("Converting open container DB");
298: Chen Liang, info, IfStmt, LOG.info("Converting node pool DB");
295: Chen Liang, info, IfStmt, LOG.info("Converting block DB");
292: Anu Engineer, info, IfStmt, LOG.info("Converting container DB");
367: Weiwei Yang, info, MethodDeclaration, LOG.info("Create tables for sql ksm db.");
384: Weiwei Yang, error, CatchClause, LOG.error("Exception inserting key {} type {}", keyString, type, ex);
490: Anu Engineer, info, MethodDeclaration, LOG.info("Create tables for sql container db.");
528: Anu Engineer, info, MethodDeclaration, LOG.info("Insert to sql container db, for container {}", containerName);
552: Anu Engineer, info, MethodDeclaration, LOG.info("Insertion completed.");
569: Chen Liang, info, MethodDeclaration, LOG.info("Create tables for sql block db.");
616: Chen Liang, info, MethodDeclaration, LOG.info("Create table for sql node pool db.");
667: Chen Liang, info, MethodDeclaration, LOG.info("Create table for open container db.");
701: Anu Engineer, error, CatchClause, LOG.error(ex.toString());
703: Weiwei Yang, debug, IfStmt, LOG.debug("Command execution failed", ex);
125: Sammi Chen, warn, IfStmt, LOG.warn("Failed to delete temporary file {}", tFile);
154: Sammi Chen, warn, IfStmt, LOG.warn("Failed to delete temporary file {}", tFile);
185: Sammi Chen, debug, MethodDeclaration, LOG.debug("Waiting for {} uploads to complete", partETagsFutures.size());
189: Sammi Chen, warn, CatchClause, LOG.warn("Interrupted partUpload", ie);
196: Sammi Chen, debug, CatchClause, LOG.debug("Cancelling futures");
52: Sammi Chen, warn, CatchClause, LOG.warn("Exception thrown when copy from " + srcKey + " to " + dstKey + ", exception: " + e);
80: Sammi Chen, warn, CatchClause, LOG.warn("Exception thrown when retrieve key: " + this.key + ", exception: " + e);
93: Sammi Chen, warn, CatchClause, LOG.warn("Exception thrown when call shouldRetry, exception " + ex);
126: Mingfei, debug, TryStmt, LOG.debug("Overwriting file {}", path);
171: Mingfei, debug, CatchClause, LOG.debug("Couldn't delete {} - does not exist", path);
235: Kai Zheng, info, MethodDeclaration, LOG.info("oss delete the {} root directory of {}", bucket, recursive);
250: Kai Zheng, debug, IfStmt, LOG.debug("Creating new fake directory at {}", f);
395: Kai Zheng, debug, IfStmt, LOG.debug("List status for path: " + path);
456: Kai Zheng, debug, IfStmt, LOG.debug("Adding: rd (not a dir): " + path);
403: Kai Zheng, debug, IfStmt, LOG.debug("listStatus: doing listObjects for directory " + key);
420: Kai Zheng, debug, IfStmt, LOG.debug("Adding: fi: " + keyPath);
413: Kai Zheng, debug, IfStmt, LOG.debug("Ignoring: " + objKey);
437: Kai Zheng, debug, IfStmt, LOG.debug("Adding: rd: " + keyPath);
431: Kai Zheng, debug, IfStmt, LOG.debug("Ignoring: " + prefix);
445: Kai Zheng, debug, IfStmt, LOG.debug("listStatus: list truncated - getting next batch");
505: Kai Zheng, debug, IfStmt, LOG.debug("{} is a File", qualifiedPath);
596: Kai Zheng, debug, IfStmt, LOG.debug("Cannot rename the root of a filesystem");
686: Kai Zheng, debug, IfStmt, LOG.debug("Cannot rename a directory to a subdirectory of self");
730: Sammi Chen, warn, CatchClause, LOG.warn("interrupted when wait copies to finish");
142: Mingfei, error, IfStmt, LOG.error(msg);
123: Mingfei, warn, IfStmt, LOG.warn("Proxy host set without port. Using HTTP default 80");
120: Mingfei, warn, IfStmt, LOG.warn("Proxy host set without port. Using HTTPS default 443");
132: Mingfei, error, IfStmt, LOG.error(msg);
162: Mingfei, warn, IfStmt, LOG.warn(MIN_MULTIPART_UPLOAD_THRESHOLD_KEY + " must be at least 5 MB");
167: Mingfei, warn, IfStmt, LOG.warn(MIN_MULTIPART_UPLOAD_THRESHOLD_KEY + " must be less than 1 GB");
200: Kai Zheng, warn, IfStmt, LOG.warn("Keys to delete is empty.");
325: Mingfei, debug, MethodDeclaration, LOG.debug(copyResult.getETag());
381: Mingfei, debug, TryStmt, LOG.debug(completeMultipartUploadResult.getETag());
408: Mingfei, debug, TryStmt, LOG.debug(result.getETag());
486: Mingfei, error, CatchClause, LOG.error("Failed to purge " + prefix);
606: Sammi Chen, debug, CatchClause, LOG.debug("Failed to upload " + file.getPath() + ", " + "try again.", e);
103: Kai Zheng, debug, IfStmt, LOG.debug("Aborting old stream to open at pos " + pos);
170: Sammi Chen, warn, CatchClause, LOG.warn("interrupted when wait a read buffer");
50: Sammi Chen, warn, IfStmt, LOG.warn(key + " is configured to " + v + ", will use default value: " + defVal);
115: Mingfei, debug, TryStmt, LOG.debug("Credential provider class is:" + className);
203: Sammi Chen, debug, MethodDeclaration, LOG.debug("Value of {} is {}", key, v);
222: Sammi Chen, debug, MethodDeclaration, LOG.debug("Value of {} is {}", key, v);
244: Sammi Chen, warn, IfStmt, LOG.warn("oss: {} capped to ~2.14GB(maximum allowed size with " + "current output mechanism)", MULTIPART_UPLOAD_PART_SIZE_KEY);
240: Sammi Chen, warn, IfStmt, LOG.warn("{} must be at least 100 KB; configured value is {}", property, partSize);
85: Kai Zheng, info, MethodDeclaration, LOG.info("5MB file created: smallSeekFile.txt");
89: Kai Zheng, info, MethodDeclaration, LOG.info("multiple fold position seeking test...:");
92: Kai Zheng, info, ForStmt, LOG.info("begin seeking for pos: " + pos);
96: Kai Zheng, info, ForStmt, LOG.info("completed seeking at pos: " + instream.getPos());
98: Kai Zheng, info, MethodDeclaration, LOG.info("random position seeking test...:");
102: Kai Zheng, info, ForStmt, LOG.info("begin seeking for pos: " + pos);
106: Kai Zheng, info, ForStmt, LOG.info("completed seeking at pos: " + instream.getPos());
117: Sammi Chen, info, MethodDeclaration, LOG.info("5MB file created: smallSeekFile.txt");
144: Sammi Chen, info, MethodDeclaration, LOG.info("5MB file created: smallSeekFileOSSFileReader.txt");
168: Kai Zheng, info, MethodDeclaration, LOG.info(sizeFlag + "MB file created: /test/" + filename);
188: Kai Zheng, info, IfStmt, LOG.info("Bytes read: " + Math.round((double) bytesRead / (1024 * 1024)) + " MB");
61: Mingfei, error, IfStmt, LOG.error("Empty root directory test failed {} attempts.  Failing test.", maxAttempts);
51: Mingfei, info, IfStmt, LOG.info("Attempt {} of {} for empty root directory test failed.  " + "Attempting retry.", attempt, maxAttempts);
125: Karthik Kambatla, debug, CatchClause, LOG.debug("Exception", e);
151: Wangda Tan, info, IfStmt, LOG.info("Can not find any valid fileControllers.");
153: Wangda Tan, info, IfStmt, LOG.info("The configurated fileControllers:" + YarnConfiguration.LOG_AGGREGATION_FILE_FORMATS);
167: Wangda Tan, info, IfStmt, LOG.info("LogAggregationFileController:" + fileController.getClass().getName());
169: Wangda Tan, info, IfStmt, LOG.info("Remote Log Dir Root: " + remoteRootLogDir);
170: Wangda Tan, info, IfStmt, LOG.info("Log Suffix: " + suffix);
171: Wangda Tan, info, IfStmt, LOG.info("Working Dir: " + workingDir);
184: Wangda Tan, info, IfStmt, LOG.info("No eligible applications to process");
189: Wangda Tan, error, IfStmt, LOG.error("Failed to create the workingDir:" + workingDir.toString());
199: Wangda Tan, info, TryStmt, LOG.info(sb.toString());
268: Karthik Kambatla, info, IfStmt, LOG.info("Setting " + MAX_ELIGIBLE_APPS_OPTION + " to 0 accomplishes " + "nothing. Please either set it to a negative value " + "(default, all) or a more reasonable value.");
310: Robert Kanter, info, IfStmt, LOG.info("Existing Working Dir detected: -" + FORCE_OPTION + " not specified -> exiting");
306: Robert Kanter, info, IfStmt, LOG.info("Existing Working Dir detected: -" + FORCE_OPTION + " specified -> recreating Working Dir");
353: Robert Kanter, info, IfStmt, LOG.info(app.getAppId() + " not in the ResourceManager");
346: Robert Kanter, info, IfStmt, LOG.info(app.getAppId() + " has aggregation status " + aggStatus);
340: Robert Kanter, info, IfStmt, LOG.info("Skipping " + app.getAppId() + " due to aggregation status being " + aggStatus);
432: Robert Kanter, info, IfStmt, LOG.info("Skipping all logs under " + userLogPath + " due to " + ioe.getMessage());
424: Robert Kanter, info, IfStmt, LOG.info("Skipping logs under " + appLogPath + " due to " + ioe.getMessage());
416: Robert Kanter, info, IfStmt, LOG.info("Skipping " + appLogPath.getName() + " due to not " + "having enough log files (" + files.length + " < " + minNumLogFiles + ")");
385: Robert Kanter, info, IfStmt, LOG.info("Skipping " + appLogPath.getName() + " due to existing .har file");
394: Robert Kanter, info, IfStmt, LOG.info("Skipping " + appLogPath.getName() + " due to " + "total file size being too large (" + totalFileSize + " > " + maxTotalLogsSize + ")");
403: Robert Kanter, info, IfStmt, LOG.info("Adding " + appLogPath.getName() + " for user " + userLogPath.getName());
445: Wangda Tan, info, IfStmt, LOG.info("Too many applications (" + eligibleApplications.size() + " > " + maxEligible + ")");
464: Robert Kanter, info, IfStmt, LOG.info("Removing " + sortedApplications.get(i));
499: Robert Kanter, info, IfStmt, LOG.info("Generating script at: " + localScript.getAbsolutePath());
567: Robert Kanter, info, IfStmt, LOG.info("Running Distributed Shell with arguments: " + Arrays.toString(dsArgs));
91: Karthik Kambatla, debug, CatchClause, LOG.debug("Exception", e);
114: Robert Kanter, info, IfStmt, LOG.info("Running as " + user);
153: Karthik Kambatla, info, MethodDeclaration, LOG.info(sb.toString());
156: Xuan Gong, warn, IfStmt, LOG.warn("Failed to create archives for " + appId);
167: Xuan Gong, warn, IfStmt, LOG.warn("The created archive \"" + harName + "\" is missing or empty.");
172: Karthik Kambatla, info, TryStmt, LOG.info("Moving har to original location");
174: Karthik Kambatla, info, TryStmt, LOG.info("Deleting original logs");
108: Robert Kanter, Info, MethodDeclaration, HadoopArchiveLogs.AppInfo app1 = new HadoopArchiveLogs.AppInfo(ApplicationId.newInstance(CLUSTER_TIMESTAMP, 1).toString(), USER);
111: Robert Kanter, Info, MethodDeclaration, HadoopArchiveLogs.AppInfo app2 = new HadoopArchiveLogs.AppInfo(ApplicationId.newInstance(CLUSTER_TIMESTAMP, 2).toString(), USER);
114: Robert Kanter, Info, MethodDeclaration, HadoopArchiveLogs.AppInfo app3 = new HadoopArchiveLogs.AppInfo(ApplicationId.newInstance(CLUSTER_TIMESTAMP, 3).toString(), USER);
117: Robert Kanter, Info, MethodDeclaration, HadoopArchiveLogs.AppInfo app4 = new HadoopArchiveLogs.AppInfo(ApplicationId.newInstance(CLUSTER_TIMESTAMP, 4).toString(), USER);
120: Robert Kanter, Info, MethodDeclaration, HadoopArchiveLogs.AppInfo app5 = new HadoopArchiveLogs.AppInfo(ApplicationId.newInstance(CLUSTER_TIMESTAMP, 5).toString(), USER);
123: Robert Kanter, Info, MethodDeclaration, HadoopArchiveLogs.AppInfo app6 = new HadoopArchiveLogs.AppInfo(ApplicationId.newInstance(CLUSTER_TIMESTAMP, 6).toString(), USER);
126: Robert Kanter, Info, MethodDeclaration, HadoopArchiveLogs.AppInfo app7 = new HadoopArchiveLogs.AppInfo(ApplicationId.newInstance(CLUSTER_TIMESTAMP, 7).toString(), USER);
208: Robert Kanter, Info, TryStmt, hal.eligibleApplications.add(new HadoopArchiveLogs.AppInfo(appImpl1.getApplicationId().toString(), USER));
211: Robert Kanter, Info, TryStmt, hal.eligibleApplications.add(new HadoopArchiveLogs.AppInfo(appImpl2.getApplicationId().toString(), USER));
214: Robert Kanter, Info, TryStmt, hal.eligibleApplications.add(new HadoopArchiveLogs.AppInfo(appImpl3.getApplicationId().toString(), USER));
217: Robert Kanter, Info, TryStmt, HadoopArchiveLogs.AppInfo app4 = new HadoopArchiveLogs.AppInfo(appImpl4.getApplicationId().toString(), USER);
221: Robert Kanter, Info, TryStmt, hal.eligibleApplications.add(new HadoopArchiveLogs.AppInfo(appImpl5.getApplicationId().toString(), USER));
224: Robert Kanter, Info, TryStmt, hal.eligibleApplications.add(new HadoopArchiveLogs.AppInfo(appImpl6.getApplicationId().toString(), USER));
227: Robert Kanter, Info, TryStmt, HadoopArchiveLogs.AppInfo app7 = new HadoopArchiveLogs.AppInfo(appImpl7.getApplicationId().toString(), USER);
231: Robert Kanter, Info, TryStmt, HadoopArchiveLogs.AppInfo app8 = new HadoopArchiveLogs.AppInfo(appImpl8.getApplicationId().toString(), USER);
257: Wangda Tan, Info, MethodDeclaration, HadoopArchiveLogs.AppInfo appInfo1 = new HadoopArchiveLogs.AppInfo(app1.toString(), USER);
267: Wangda Tan, Info, MethodDeclaration, HadoopArchiveLogs.AppInfo appInfo2 = new HadoopArchiveLogs.AppInfo(app2.toString(), USER);
572: Todd Lipcon, info, CatchClause, LOG.info("Unable to clean tmp directory " + jobDirectory);
929: Todd Lipcon, debug, CatchClause, LOG.debug("Exception in archives  ", e);
127: Chris Nauroth, debug, CatchClause, LOG.debug("No credentials provided by {}: {}", provider, e.toString(), e);
122: Chris Nauroth, debug, IfStmt, LOG.debug("Using credentials from {}", provider);
109: Steve Loughran, debug, IfStmt, LOG.debug("Signer override = {}", signerOverride);
161: Steve Loughran, error, IfStmt, LOG.error(msg);
134: Steve Loughran, warn, IfStmt, LOG.warn("Proxy host set without port. Using HTTP default 80");
131: Steve Loughran, warn, IfStmt, LOG.warn("Proxy host set without port. Using HTTPS default 443");
143: Steve Loughran, error, IfStmt, LOG.error(msg);
151: Steve Loughran, debug, IfStmt, LOG.debug("Using proxy server {}:{} as user {} with password {} on " + "domain {} as workstation {}", awsConf.getProxyHost(), awsConf.getProxyPort(), String.valueOf(awsConf.getProxyUsername()), awsConf.getProxyPassword(), awsConf.getProxyDomain(), awsConf.getProxyWorkstation());
183: Steve Loughran, debug, MethodDeclaration, LOG.debug("Using User-Agent: {}", userAgent);
205: Steve Loughran, error, CatchClause, LOG.error(msg);
227: Steve Loughran, debug, IfStmt, LOG.debug("Enabling path style access!");
138: Steve Loughran, debug, MethodDeclaration, LOG.debug("{}, p={} -> {}", key, p, delay);
164: Steve Loughran, info, MethodDeclaration, LOG.info("clearing all delayed puts / deletes");
203: Steve Loughran, debug, MethodDeclaration, LOG.debug("key {}", key);
213: Steve Loughran, debug, MethodDeclaration, LOG.debug("key {}", putObjectRequest.getKey());
237: Steve Loughran, debug, MethodDeclaration, LOG.debug("prefix {}", listObjectsRequest.getPrefix());
258: Steve Loughran, debug, MethodDeclaration, LOG.debug("prefix {}", request.getPrefix());
442: Steve Loughran, debug, IfStmt, LOG.debug("no delay for key {}", key);
452: Steve Loughran, info, IfStmt, LOG.info("delaying {}", key);
449: Steve Loughran, debug, IfStmt, LOG.debug("no longer delaying {}", key);
485: Steve Loughran, debug, MethodDeclaration, LOG.debug("delaying put of {}", key);
579: Steve Loughran, debug, MethodDeclaration, LOG.debug("Wrapping in InconsistentS3Object for key {}", var1.getKey());
587: Steve Loughran, debug, MethodDeclaration, LOG.debug("Wrapping in InconsistentS3Object for key {}", key);
37: Steve Loughran, warn, MethodDeclaration, LOG.warn("** FAILURE INJECTION ENABLED.  Do not run in production! **");
219: Steve Loughran, debug, MethodDeclaration, LOG.debug("read() for key {}", getKey());
226: Steve Loughran, debug, MethodDeclaration, LOG.debug("read(b, {}, {}) for key {}", off, len, getKey());
148: Steve Loughran, info, CatchClause, log.info("{}: {}", toDescription(action, path), e.toString(), e);
314: Steve Loughran, debug, IfStmt, LOG.debug("retry #{}", retryCount);
387: Steve Loughran, debug, CatchClause, LOG.debug("Action {} failed", action, e);
407: Steve Loughran, debug, CatchClause, LOG.debug("Action {} failed", action, e);
482: Steve Loughran, debug, MethodDeclaration, LOG.debug("{}: " + exception, text);
485: Steve Loughran, debug, IfStmt, LOG.debug("{}: " + exception, text, exception);
378: Steve Loughran, debug, IfStmt, LOG.debug("Start iterating the provided status.");
399: Steve Loughran, debug, IfStmt, LOG.debug("Returning provided file status {}", status);
394: Steve Loughran, debug, IfStmt, LOG.debug("Removed the status from provided file status {}", status);
426: Chris Nauroth, debug, IfStmt, LOG.debug("All entries in batch were filtered...continuing");
452: Chris Nauroth, debug, IfStmt, LOG.debug("{}: {}", keyPath, stringify(summary));
462: Chris Nauroth, debug, IfStmt, LOG.debug("Ignoring: {}", keyPath);
458: Chris Nauroth, debug, IfStmt, LOG.debug("Adding: {}", status);
477: Chris Nauroth, debug, IfStmt, LOG.debug("Ignoring directory: {}", keyPath);
473: Chris Nauroth, debug, IfStmt, LOG.debug("Adding directory: {}", status);
486: Chris Nauroth, debug, MethodDeclaration, LOG.debug("Added {} entries; ignored {}; hasNext={}; hasMoreObjects={}", added, ignored, hasNext, objects.isTruncated());
598: Chris Nauroth, debug, TryStmt, LOG.debug("[{}], Requesting next {} objects under {}", listingCount, maxKeys, listPath);
602: Chris Nauroth, debug, TryStmt, LOG.debug("New listing status: {}", this);
158: Steve Loughran, debug, MethodDeclaration, LOG.debug("[{}], Requesting next {} uploads prefix {}, " + "next key {}, next upload id {}", listCount, maxKeys, prefix, req.getKeyMarker(), req.getUploadIdMarker());
165: Steve Loughran, debug, MethodDeclaration, LOG.debug("New listing state: {}", this);
88: Chris Nauroth, debug, IfStmt, LOG.debug("S3A write delta changed after finished: {} bytes", delta);
169: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("Initialized S3ABlockOutputStream for {}" + " output to {}", key, activeBlock);
172: Steve Loughran, debug, IfStmt, LOG.debug("Put tracker requests multipart upload");
187: Steve Loughran, error, IfStmt, LOG.error("Number of partitions in stream exceeds limit for S3: " + Constants.MAX_MULTIPART_COUNT + " write may fail.");
216: Steve Loughran, debug, IfStmt, LOG.debug("Clearing active block");
244: Aaron Fabbri, warn, CatchClause, LOG.warn("Stream closed: " + e.getMessage());
311: Steve Loughran, debug, MethodDeclaration, LOG.debug("Writing block # {}", blockCount);
331: Steve Loughran, debug, IfStmt, LOG.debug("Initiating Multipart upload");
349: Steve Loughran, debug, IfStmt, LOG.debug("Ignoring close() as stream is already closed");
354: Steve Loughran, debug, MethodDeclaration, LOG.debug("{}: Closing block #{}: current block= {}", this, blockCount, hasBlock ? block : "(none)");
400: Steve Loughran, debug, TryStmt, LOG.debug("Statistics: {}", statistics);
387: Steve Loughran, info, IfStmt, LOG.info("File {} will be visible when the job is committed", key);
394: Steve Loughran, debug, TryStmt, LOG.debug("Upload complete to {} by {}", key, writeOperationHelper);
418: Steve Loughran, debug, MethodDeclaration, LOG.debug("Executing regular upload for {}", writeOperationHelper);
449: Steve Loughran, warn, CatchClause, LOG.warn("Interrupted object upload", ie);
531: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("Initiated multi-part upload for {} with " + "id '{}'", writeOperationHelper, uploadId);
576: Steve Loughran, debug, MethodDeclaration, LOG.debug("Queueing upload of {} for upload {}", block, uploadId);
604: Steve Loughran, debug, TryStmt, LOG.debug("Uploading part {} for id '{}'", currentPartNumber, uploadId);
608: Steve Loughran, debug, TryStmt, LOG.debug("Completed upload of {} to part {}", block, partETag.getETag());
610: Steve Loughran, debug, TryStmt, LOG.debug("Stream statistics of {}", statistics);
627: Steve Loughran, debug, MethodDeclaration, LOG.debug("Waiting for {} uploads to complete", partETagsFutures.size());
631: Steve Loughran, warn, CatchClause, LOG.warn("Interrupted partUpload", ie);
638: Steve Loughran, debug, CatchClause, LOG.debug("Cancelling futures");
744: Steve Loughran, warn, SwitchStmt, LOG.warn("Transfer failure of block {}", block);
231: Steve Loughran, debug, MethodDeclaration, LOG.debug("{}: entering state {}", this, next);
324: Steve Loughran, debug, MethodDeclaration, LOG.debug("Start datablock[{}] upload", index);
346: Steve Loughran, debug, IfStmt, LOG.debug("Closed {}", this);
519: Steve Loughran, debug, MethodDeclaration, LOG.debug("Requesting buffer of size {}", limit);
525: Steve Loughran, debug, MethodDeclaration, LOG.debug("Releasing buffer");
647: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("Creating ByteBufferInputStream of size {}", size);
659: Steve Loughran, debug, MethodDeclaration, LOG.debug("ByteBufferInputStream.close() for {}", ByteBufferBlock.super.toString());
721: Steve Loughran, debug, MethodDeclaration, LOG.debug("mark at {}", position());
727: Steve Loughran, debug, MethodDeclaration, LOG.debug("reset");
886: Steve Loughran, debug, MethodDeclaration, LOG.debug("Closing {}", this);
891: Steve Loughran, debug, IfStmt, LOG.debug("Block[{}]: Deleting buffer file as upload did not start", index);
898: Steve Loughran, debug, SwitchStmt, LOG.debug("Block[{}]: Buffer file {} exists close upload stream", index, bufferFile);
940: Steve Loughran, debug, MethodDeclaration, LOG.debug("block[{}]: closeBlock()", index);
948: Steve Loughran, debug, IfStmt, LOG.debug("block[{}]: skipping re-entrant closeBlock()", index);
944: Steve Loughran, warn, IfStmt, LOG.warn("delete({}) returned false", bufferFile.getAbsoluteFile());
237: Steve Loughran, debug, MethodDeclaration, LOG.debug("Initializing S3AFileSystem for {}", bucket);
278: Steve Loughran, warn, IfStmt, LOG.warn(MAX_THREADS + " must be at least 2: forcing to 2.");
299: Steve Loughran, warn, IfStmt, LOG.warn("Configured fs.s3a.list.version {} is invalid, forcing " + "version 2", listVersion);
313: Steve Loughran, debug, TryStmt, LOG.debug("Input fadvise policy = {}", inputPolicy);
317: Steve Loughran, debug, TryStmt, LOG.debug("Filesystem support for magic committers {} enabled", magicCommitterEnabled ? "is" : "is not");
325: Aaron Fabbri, warn, IfStmt, LOG.warn("The \"slow\" output stream is no longer supported");
333: Aaron Fabbri, debug, TryStmt, LOG.debug("Using S3ABlockOutputStream with buffer = {}; block={};" + " queue limit={}", blockOutputBuffer, partSize, blockOutputActiveBlocks);
341: Aaron Fabbri, debug, IfStmt, LOG.debug("Using metadata store {}, authoritative={}", getMetadataStore(), allowAuthoritative);
419: Steve Loughran, debug, CatchClause, LOG.debug("Failed to purge multipart uploads against {}," + " FS may be read only", bucket);
436: Steve Loughran, debug, MethodDeclaration, LOG.debug("Purging outstanding multipart uploads older than {}", purgeBefore);
493: Steve Loughran, warn, MethodDeclaration, LOG.warn("Access to S3A client requested, reason {}", reason);
503: Steve Loughran, debug, MethodDeclaration, LOG.debug("Setting S3 client to {}", client);
607: Steve Loughran, debug, MethodDeclaration, LOG.debug("Setting input strategy: {}", inputPolicy);
698: Steve Loughran, debug, MethodDeclaration, LOG.debug("Opening '{}' for reading; input policy = {}", f, inputPolicy);
760: Steve Loughran, debug, TryStmt, LOG.debug("Overwriting file {}", path);
864: Mingliang Liu, debug, CatchClause, LOG.debug(e.getMessage());
867: Mingliang Liu, debug, CatchClause, LOG.debug(e.toString());
897: Steve Loughran, debug, MethodDeclaration, LOG.debug("Rename path {} to {}", src, dst);
915: Mingliang Liu, debug, IfStmt, LOG.debug("rename: src and dest refer to the same file or directory: {}", dst);
951: Steve Loughran, debug, CatchClause, LOG.debug("rename: destination path {} not found", dst);
999: Steve Loughran, debug, IfStmt, LOG.debug("rename: renaming directory {} to {}", src, dst);
1063: Steve Loughran, debug, IfStmt, LOG.debug("To move the non-empty top-level dir src={} and dst={}", src, dst);
981: Steve Loughran, debug, IfStmt, LOG.debug("rename: renaming file {} to {}", src, dst);
1073: Steve Loughran, debug, IfStmt, LOG.debug("source & dest parents are different; fix up dir markers");
1411: Steve Loughran, debug, CatchClause, LOG.debug("Partial failure of delete, {} errors", errors.size(), e);
1413: Steve Loughran, debug, ForeachStmt, LOG.debug("{}: \"{}\" - {}", error.getKey(), error.getCode(), error.getMessage());
1506: Steve Loughran, debug, MethodDeclaration, LOG.debug("PUT {} bytes to {} via transfer manager ", len, putObjectRequest.getKey());
1528: Steve Loughran, debug, MethodDeclaration, LOG.debug("PUT {} bytes to {}", len, putObjectRequest.getKey());
1592: Chris Nauroth, debug, MethodDeclaration, LOG.debug("PUT start {} bytes", bytes);
1609: Steve Loughran, debug, MethodDeclaration, LOG.debug("PUT completed success={}; {} bytes", success, bytes);
1709: Steve Loughran, debug, CatchClause, LOG.debug("Couldn't delete {} - does not exist", f);
1702: Steve Loughran, warn, CatchClause, LOG.warn("Cannot create directory marker at {}: {}", f.getParent(), e.toString());
1704: Steve Loughran, debug, CatchClause, LOG.debug("Failed to create fake dir above {}", f, e);
1733: Steve Loughran, debug, MethodDeclaration, LOG.debug("Delete path {} - recursive {}", f, recursive);
1790: Steve Loughran, debug, IfStmt, LOG.debug("delete: Path is a file");
1738: Steve Loughran, debug, IfStmt, LOG.debug("delete: Path is a directory: {}", f);
1760: Steve Loughran, debug, IfStmt, LOG.debug("Getting objects for directory prefix {} to delete", key);
1770: Steve Loughran, debug, ForeachStmt, LOG.debug("Got object to delete {}", summary.getKey());
1756: Steve Loughran, debug, IfStmt, LOG.debug("Deleting fake empty directory {}", key);
1810: Steve Loughran, info, MethodDeclaration, LOG.info("s3a delete the {} root directory of {}", bucket, recursive);
1836: Steve Loughran, debug, IfStmt, LOG.debug("Creating new fake directory at {}", f);
1885: Chris Nauroth, debug, MethodDeclaration, LOG.debug("List status for path: {}", path);
1916: Chris Nauroth, debug, IfStmt, LOG.debug("Adding: rd (not a dir): {}", path);
1902: Steve Loughran, debug, IfStmt, LOG.debug("listStatus: doing listObjects for directory {}", key);
2028: Steve Loughran, debug, MethodDeclaration, LOG.debug("Making directory: {}", f);
2107: Steve Loughran, debug, MethodDeclaration, LOG.debug("Getting path status for {}  ({})", path, key);
2128: Steve Loughran, debug, IfStmt, LOG.debug("MetadataStore doesn't know if dir is empty, using S3.");
2175: Steve Loughran, debug, IfStmt, LOG.debug("Found exact file: normal file");
2172: Steve Loughran, debug, IfStmt, LOG.debug("Found exact file: fake directory");
2200: Chris Nauroth, warn, IfStmt, LOG.warn("Found file (with /): real file? should not happen: {}", key);
2197: Steve Loughran, debug, IfStmt, LOG.debug("Found file (with /): fake directory");
2243: cnauroth, debug, IfStmt, LOG.debug("Found root directory");
2230: Steve Loughran, debug, IfStmt, LOG.debug("Found path as directory (with /): {}/{}", prefixes.size(), summaries.size());
2234: Steve Loughran, debug, ForeachStmt, LOG.debug("Summary: {} {}", summary.getKey(), summary.getSize());
2237: Steve Loughran, debug, ForeachStmt, LOG.debug("Prefix: {}", prefix);
2254: Chris Nauroth, debug, MethodDeclaration, LOG.debug("Not Found: {}", path);
2366: Steve Loughran, debug, MethodDeclaration, LOG.debug("Copying local file from {} to {}", src, dst);
2444: Steve Loughran, info, CatchClause, LOG.info("Interrupted: aborting upload");
2465: Steve Loughran, debug, MethodDeclaration, LOG.debug("Filesystem {} is closed", uri);
2516: Steve Loughran, debug, MethodDeclaration, LOG.debug("copyFile {} -> {} ", srcKey, dstKey);
2595: Steve Loughran, debug, MethodDeclaration, LOG.debug("Initiate multipart upload to {}", request.getKey());
2688: Steve Loughran, debug, MethodDeclaration, LOG.debug("Finished write to {}, len {}", key, length);
2703: Steve Loughran, error, CatchClause, LOG.error("S3Guard: Error updating MetadataStore for write to {}:", key, e);
2720: Mingliang Liu, trace, WhileStmt, LOG.trace("To delete unnecessary fake directory {} for {}", key, path);
2733: Steve Loughran, debug, IfStmt, LOG.debug("While deleting keys {} ", sb.toString(), e);
3024: Steve Loughran, debug, IfStmt, LOG.debug("getFileChecksum({})", path);
3084: Chris Nauroth, debug, MethodDeclaration, LOG.debug("listFiles({}, {})", path, recursive);
3097: Chris Nauroth, debug, IfStmt, LOG.debug("Requesting all entries under {} with delimiter '{}'", key, delimiter);
3090: Chris Nauroth, debug, IfStmt, LOG.debug("Path is a file");
3169: Chris Nauroth, debug, MethodDeclaration, LOG.debug("listLocatedStatus({}, {}", path, filter);
3176: Steve Loughran, debug, IfStmt, LOG.debug("Path is a file");
3266: Steve Loughran, info, MethodDeclaration, LOG.info("Aborting multipart upload {} to {}", uploadId, destKey);
3286: Steve Loughran, info, IfStmt, LOG.info("Aborting multipart upload {} to {} initiated by {} on {}", uploadId, destKey, upload.getInitiator(), df.format(upload.getInitiated()));
71: Steve Loughran, warn, SwitchStmt, LOG.warn("Unrecognized " + INPUT_FADVISE + " value: \"{}\"", trimmed);
167: Steve Loughran, debug, MethodDeclaration, LOG.debug("reopen({}) for {} range[{}-{}], length={}," + " streamPosition={}, nextReadPosition={}, policy={}", uri, reason, targetPos, contentRangeFinish, length, pos, nextReadPos, inputPolicy);
225: Steve Loughran, debug, CatchClause, LOG.debug("Ignoring IOE on seek of {} to {}", uri, positiveTargetPos, ioe);
285: Steve Loughran, info, IfStmt, LOG.info("Switching to Random IO seek policy");
261: Steve Loughran, debug, IfStmt, LOG.debug("Forward seek on {}, of {} bytes", uri, diff);
275: Steve Loughran, warn, IfStmt, LOG.warn("Failed to seek on {} to {}. Current position {}", uri, targetPos, pos);
398: Steve Loughran, info, MethodDeclaration, LOG.info("Got exception while trying to read from stream {}" + " trying to recover: " + ioe, uri);
491: Steve Loughran, debug, TryStmt, LOG.debug("Statistics of stream {}\n{}", key, streamStatistics);
519: Mingliang Liu, debug, IfStmt, LOG.debug("Closing stream {}: {}", reason, forceAbort ? "abort" : "soft");
542: Steve Loughran, debug, CatchClause, LOG.debug("When closing {} stream for {}", uri, reason, e);
532: Mingliang Liu, debug, TryStmt, LOG.debug("Drained stream of {} bytes", drained);
553: Mingliang Liu, debug, IfStmt, LOG.debug("Stream {} {}: {}; remaining={} streamPos={}," + " nextReadPos={}," + " request range {}-{} length={}", uri, (shouldAbort ? "aborted" : "closed"), reason, remaining, pos, nextReadPos, contentRangeStart, contentRangeFinish, length);
579: Mingliang Liu, info, IfStmt, LOG.info("Forced reset of connection to {}", uri);
396: Steve Loughran, debug, IfStmt, LOG.debug("No gauge {}", name);
410: Steve Loughran, debug, IfStmt, LOG.debug("No quantiles {}", name);
530: Steve Loughran, debug, IfStmt, LOG.debug("No Gauge: " + op);
546: Steve Loughran, debug, IfStmt, LOG.debug("No Gauge: {}", op);
953: Steve Loughran, warn, IfStmt, LOG.warn("Closing output stream statistics while data is still marked" + " as pending upload in {}", this);
63: Chris Nauroth, debug, MethodDeclaration, LOG.debug("{} += {}  ->  {}", op, count, updated);
572: Mingliang Liu, debug, MethodDeclaration, LOG.debug("For URI {}, using credentials {}", S3xLoginHelper.toString(binding), credentials);
628: Chris Nauroth, debug, MethodDeclaration, LOG.debug("Credential provider class is {}", className);
701: Ravi Prakash, Warn, MethodDeclaration, S3xLoginHelper.Login login = S3xLoginHelper.extractLoginDetailsWithWarnings(name);
844: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Value of {} is {}", key, v);
865: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Value of {} is {}", key, v);
887: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Value of {} is {}", key, v);
905: Steve Loughran, warn, IfStmt, LOG.warn("{} must be at least 5 MB; configured value is {}", property, partSize);
921: Steve Loughran, warn, IfStmt, LOG.warn("s3a: {} capped to ~2.14GB" + " (maximum allowed size with current output mechanism)", name);
1001: Steve Loughran, debug, MethodDeclaration, LOG.debug("Propagating entries under {}", bucketPrefix);
1022: Aaron Fabbri, debug, IfStmt, LOG.debug("Updating {} from {}", generic, origin);
1014: Steve Loughran, debug, IfStmt, LOG.debug("Ignoring bucket option {}", key);
1042: Steve Loughran, debug, CatchClause, LOG.debug("Failed to delete {}", path, e);
1058: Steve Loughran, warn, CatchClause, LOG.warn("Failed to delete {}", path, e);
1182: Steve Loughran, debug, IfStmt, LOG.debug("Setting {} to {}", CREDENTIAL_PROVIDER_PATH, joined);
1208: Steve Loughran, error, CatchClause, LOG.error("Cannot retrieve " + SERVER_SIDE_ENCRYPTION_KEY, e);
1247: Mingliang Liu, debug, SwitchStmt, LOG.debug("Using SSE-KMS with {}", diagnostics);
1253: Mingliang Liu, debug, SwitchStmt, LOG.debug("Data is unencrypted");
1256: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Using SSE-C with {}", diagnostics);
1302: Steve Loughran, debug, IfStmt, log.debug("Exception in closing {}", c, e);
1297: Steve Loughran, debug, IfStmt, log.debug("Closing {}", c);
1342: Aaron Fabbri, debug, MethodDeclaration, LOG.debug("Unset {}", k);
167: Steve Loughran, debug, MethodDeclaration, LOG.debug("Write to {} failed", this, ex);
190: Steve Loughran, debug, MethodDeclaration, LOG.debug("Initiating Multipart upload to {}", destKey);
265: Steve Loughran, debug, MethodDeclaration, LOG.debug("Completing multipart upload {} with {} parts", uploadId, partETags.size());
316: Steve Loughran, debug, MethodDeclaration, LOG.debug("Aborting multipart uploads under {}", prefix);
319: Steve Loughran, debug, MethodDeclaration, LOG.debug("Number of outstanding uploads: {}", multipartUploads.size());
325: Steve Loughran, debug, CatchClause, LOG.debug("Already aborted: {}", upload.getKey(), e);
377: Steve Loughran, debug, MethodDeclaration, LOG.debug("Creating part upload request for {} #{} size {}", uploadId, partNumber, size);
117: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("{}", this);
122: Aaron Fabbri, debug, IfStmt, LOG.debug("Scope down policy {}", policy);
127: Aaron Fabbri, debug, IfStmt, LOG.debug("STS Endpoint: {}", epr);
130: Aaron Fabbri, debug, ConstructorDeclaration, LOG.debug("Credentials to obtain role credentials: {}", credentials);
148: Aaron Fabbri, error, CatchClause, LOG.error("Failed to get credentials for role {}", arn, e);
130: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("{} instantiated for job \"{}\" ID {} with destination {}", role, jobName(context), jobIdString(context), outputPath);
193: Steve Loughran, debug, MethodDeclaration, LOG.debug("Setting work path to {}", workPath);
334: Steve Loughran, warn, MethodDeclaration, LOG.warn("Cannot recover task {}", taskContext.getTaskAttemptID());
440: Steve Loughran, warn, IfStmt, LOG.warn("{}: No pending uploads to commit", getRole());
442: Steve Loughran, debug, MethodDeclaration, LOG.debug("{}: committing the output of {} task(s)", getRole(), pending.size());
500: Steve Loughran, info, MethodDeclaration, LOG.info("{}: aborting job {} in state {}", getRole(), jobIdString(context), state);
582: Steve Loughran, warn, CatchClause, LOG.warn("Commit failure for job {}", id, e);
634: Steve Loughran, warn, MethodDeclaration, LOG.warn("{}: using deprecated cleanupJob call for {}", r, id);
670: Steve Loughran, info, IfStmt, LOG.info(action, ex);
708: Steve Loughran, debug, IfStmt, LOG.debug("{}: creating thread pool of size {}", getRole(), numThreads);
745: Steve Loughran, info, IfStmt, LOG.info("{}: no pending commits to abort", getRole());
54: Steve Loughran, info, MethodDeclaration, LOG.info("Using Commmitter {} for {}", outputCommitter, outputPath);
145: Steve Loughran, debug, MethodDeclaration, LOG.debug("Committing single commit {}", commit);
158: Steve Loughran, warn, CatchClause, LOG.warn(msg, e);
164: Steve Loughran, warn, CatchClause, LOG.warn(msg, e);
152: Steve Loughran, debug, TryStmt, LOG.debug("Successful commit of file length {}", l);
225: Steve Loughran, warn, CatchClause, LOG.warn("Failed to load commit file {}", status.getPath(), e);
259: Steve Loughran, info, MethodDeclaration, LOG.info("Aborting commit to object {}{}", destKey, origin);
291: Steve Loughran, debug, MethodDeclaration, LOG.debug("Aborting all pending commit filess under {}" + " (recursive={}", pendingDir, recursive);
297: Steve Loughran, info, CatchClause, LOG.info("No directory to abort {}", pendingDir);
302: Steve Loughran, debug, IfStmt, LOG.debug("No files to abort under {}", pendingDir);
310: Steve Loughran, debug, CatchClause, LOG.debug("listed file already deleted: {}", pendingFile);
393: Steve Loughran, debug, MethodDeclaration, LOG.debug("Touching success marker for job {}: {}", markerPath, successData);
404: Steve Loughran, warn, MethodDeclaration, LOG.warn("Revert {}", commit);
428: Steve Loughran, debug, MethodDeclaration, LOG.debug("Initiating multipart upload from {} to {}", localFile, destPath);
492: Steve Loughran, error, CatchClause, LOG.error("Failed to abort upload {} to {}", uploadId, destKey, e);
463: Steve Loughran, debug, TryStmt, LOG.debug("File size is {}, number of parts to upload = {}", length, numParts);
72: Steve Loughran, error, IfStmt, LOG.error("{}: {}:\n{}", E_NORMAL_FS, fsUri, fs);
46: Steve Loughran, info, ConstructorDeclaration, log.info("Starting: {}", text);
57: Steve Loughran, info, MethodDeclaration, log.info(this.toString());
107: Steve Loughran, warn, IfStmt, LOG.warn("File being created has a \"magic\" path, but the filesystem" + " has magic file support disabled: {}", path);
105: Steve Loughran, debug, IfStmt, LOG.debug("Created {}", tracker);
199: Steve Loughran, error, CatchClause, LOG.error("Failed to revert task", e);
216: Steve Loughran, error, CatchClause, LOG.error("Failed to abort task", e);
175: Steve Loughran, error, CatchClause, LOG.error("Failed to clean up on failure", e);
291: Steve Loughran, error, CatchClause, LOG.error("Failed to abort task", e);
287: Steve Loughran, info, TryStmt, LOG.info("Aborting task");
263: Steve Loughran, info, CatchClause, LOG.info("Task failed", e);
269: Steve Loughran, error, CatchClause, LOG.error("Failed to clean up on failure", e);
253: Steve Loughran, debug, TryStmt, LOG.debug("Executing task");
256: Steve Loughran, debug, TryStmt, LOG.debug("Task succeeded");
310: Steve Loughran, info, IfStmt, LOG.info("Reverting all {} succeeded tasks from {} futures", succeeded.size(), futureCount);
323: Steve Loughran, error, CatchClause, LOG.error("Failed to revert task", e);
352: Steve Loughran, debug, MethodDeclaration, LOG.debug("Waiting for {} tasks to complete", size);
358: Steve Loughran, debug, IfStmt, LOG.debug("Finished count -> {}/{}", numFinished, size);
107: Steve Loughran, debug, MethodDeclaration, LOG.debug("Reading pending commits in file {}", path);
211: Steve Loughran, debug, MethodDeclaration, LOG.debug("Reading success data from {}", path);
76: Steve Loughran, info, ConstructorDeclaration, LOG.info("File {} is written as magic file to path {}", path, destKey);
130: Steve Loughran, info, MethodDeclaration, LOG.info("Uncommitted data pending to file {};" + " commit metadata for {} parts in {}. sixe: {} byte(s)", path.toUri(), parts.size(), pendingPartKey, bytesWritten);
133: Steve Loughran, debug, MethodDeclaration, LOG.debug("Closed MPU to {}, saved commit information to {}; data=:\n{}", path, pendingPartKey, commitData);
76: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("Task attempt {} has work path {}", context.getTaskAttemptID(), getWorkPath());
166: Steve Loughran, info, TryStmt, LOG.info("Task {} committed {} files", context.getTaskAttemptID(), commits.size());
218: Steve Loughran, info, MethodDeclaration, LOG.info("Saving work of {} to {}", taskAttemptID, taskOutcomePath);
222: Steve Loughran, warn, CatchClause, LOG.warn("Failed to save task commit data to {} ", taskOutcomePath, e);
73: Steve Loughran, debug, IfStmt, LOG.debug("Failing commit by task attempt {} to write" + " to existing output path {}", context.getJobID(), getOutputPath());
107: Steve Loughran, info, IfStmt, LOG.info("{}: removed output path to be replaced: {}", getRole(), outputPath);
103: Steve Loughran, debug, IfStmt, LOG.debug("Failing commit by task attempt {} to write" + " to existing path {} under {}", context.getTaskAttemptID(), partitionPath, getOutputPath());
147: Steve Loughran, debug, ForeachStmt, LOG.debug("{}: removing partition path to be replaced: " + getRole(), partitionPath);
131: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("{}: final output path is {}", getRole(), finalOutputPath);
135: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("Conflict resolution mode: {}", mode);
381: Steve Loughran, debug, MethodDeclaration, LOG.debug("Scanning {} for files to commit", attemptPath);
453: Steve Loughran, debug, MethodDeclaration, LOG.debug("{}, Setting up job {}", getRole(), jobIdString(context));
515: Steve Loughran, debug, IfStmt, LOG.debug("Cleaning up work path {}", workPath);
541: Steve Loughran, info, IfStmt, LOG.info("Not cleanup up pending uploads to {} as {} is false ", getOutputPath(), FS_S3A_COMMITTER_STAGING_ABORT_PENDING_UPLOADS);
558: Steve Loughran, debug, CatchClause, LOG.debug("No job directory to read uploads from");
621: Steve Loughran, debug, TryStmt, LOG.debug("{} files to commit under {}", stats.length, attemptPath);
638: Steve Loughran, error, CatchClause, LOG.error("{}: commit of task {} failed", getRole(), context.getTaskAttemptID(), e);
636: Steve Loughran, info, TryStmt, LOG.info("{}: upload file count: {}", getRole(), count);
657: Steve Loughran, debug, MethodDeclaration, LOG.debug("{}: commitTaskInternal", getRole());
662: Steve Loughran, debug, MethodDeclaration, LOG.debug("{}: attempt path is {}", getRole(), attemptPath);
673: Steve Loughran, info, MethodDeclaration, LOG.info("{}: uploading from staging directory to S3", getRole());
674: Steve Loughran, info, MethodDeclaration, LOG.info("{}: Saving pending data information to {}", getRole(), commitsAttemptPath);
723: Steve Loughran, error, IfStmt, LOG.error("{}: Exception during commit process, aborting {} commit(s)", getRole(), commits.size());
703: Steve Loughran, debug, LambdaExpr, LOG.debug("{}: adding pending commit {}", getRole(), commit);
736: Steve Loughran, debug, MethodDeclaration, LOG.debug("Committing wrapped task");
739: Steve Loughran, debug, MethodDeclaration, LOG.debug("Cleaning up attempt dir {}", attemptPath);
766: Steve Loughran, error, CatchClause, LOG.error("{}: exception when aborting task {}", getRole(), context.getTaskAttemptID(), e);
84: Steve Loughran, debug, MethodDeclaration, LOG.debug("Creating DynamoDB client in region {}", region);
255: Steve Loughran, debug, MethodDeclaration, LOG.debug("Creating DynamoDB client {} with S3 region {}", cls, s3Region);
277: Steve Loughran, debug, IfStmt, LOG.debug("Inferring DynamoDB region from S3 bucket: {}", region);
273: Steve Loughran, debug, IfStmt, LOG.debug("Overriding S3 region with configured DynamoDB region: {}", region);
376: Steve Loughran, debug, MethodDeclaration, LOG.debug("Deleting from table {} in region {}: {}", tableName, region, path);
381: Steve Loughran, debug, IfStmt, LOG.debug("Skip deleting root directory as it does not exist in table");
403: Steve Loughran, debug, MethodDeclaration, LOG.debug("Deleting subtree from table {} in region {}: {}", tableName, region, path);
408: Steve Loughran, debug, IfStmt, LOG.debug("Subtree path {} does not exist; this will be a no-op", path);
437: Steve Loughran, debug, MethodDeclaration, LOG.debug("Get from table {} in region {}: {}", tableName, region, path);
461: Steve Loughran, debug, IfStmt, LOG.debug("Get from table {} in region {} returning for {}: {}", tableName, region, path, meta);
505: Steve Loughran, debug, MethodDeclaration, LOG.debug("Listing table {} in region {}: {}", tableName, region, path);
520: Steve Loughran, trace, LambdaExpr, LOG.trace("Listing table {} in region {} for {} returning {}", tableName, region, path, metas);
548: Steve Loughran, debug, WhileStmt, LOG.debug("auto-create ancestor path {} for child path {}", parent, path);
566: Steve Loughran, debug, MethodDeclaration, LOG.debug("Moving paths of table {} in region {}: {} paths to delete and {}" + " paths to create", tableName, region, pathsToDelete == null ? 0 : pathsToDelete.size(), pathsToCreate == null ? 0 : pathsToCreate.size());
570: Steve Loughran, trace, MethodDeclaration, LOG.trace("move: pathsToDelete = {}, pathsToCreate = {}", pathsToDelete, pathsToCreate);
660: Steve Loughran, debug, IfStmt, LOG.debug("Sleeping {} msec before next retry", action.delayMillis);
693: Steve Loughran, debug, MethodDeclaration, LOG.debug("Saving batch of {} items to table {}, region {}", items.length, tableName, region);
755: Steve Loughran, debug, MethodDeclaration, LOG.debug("Saving to table {} in region {}: {}", tableName, region, meta);
780: Steve Loughran, debug, IfStmt, LOG.debug("Shutting down {}", this);
790: Steve Loughran, info, IfStmt, LOG.info("In destroy(): no table to delete");
793: Steve Loughran, info, MethodDeclaration, LOG.info("Deleting DynamoDB table {} in region {}", tableName, region);
799: Steve Loughran, info, CatchClause, LOG.info("ResourceNotFoundException while deleting DynamoDB table {} in " + "region {}.  This may indicate that the table does not exist, " + "or has been deleted by another concurrent thread or process.", tableName, region);
805: Steve Loughran, warn, CatchClause, LOG.warn("Interrupted while waiting for DynamoDB table {} being deleted", tableName, ie);
861: Steve Loughran, info, MethodDeclaration, LOG.info("Finished pruning {} items in batches of {}", itemCount, S3GUARD_DDB_BATCH_WRITE_REQUEST_LIMIT);
893: Steve Loughran, debug, TryStmt, LOG.debug("Binding to table {}", tableName);
895: Aaron Fabbri, debug, TryStmt, LOG.debug("Table state: {}", description);
900: Steve Loughran, debug, SwitchStmt, LOG.debug("Table {} in region {} is being created/updated. This may" + " indicate that the table is being operated by another " + "concurrent thread or process. Waiting for active...", tableName, region);
920: Steve Loughran, debug, TryStmt, LOG.debug("Using existing DynamoDB table {} in region {} created {}", tableName, region, (created != null) ? new Date(created) : null);
965: Steve Loughran, debug, IfStmt, LOG.debug("Sleeping {} ms before next retry", action.delayMillis);
987: Steve Loughran, warn, IfStmt, LOG.warn("Table {} contains no version marker", tableName);
1015: Steve Loughran, warn, CatchClause, LOG.warn("Interrupted while waiting for table {} in region {} active", tableName, region, e);
1044: Steve Loughran, warn, CatchClause, LOG.warn("ResourceInUseException while creating DynamoDB table {} " + "in region {}.  This may indicate that the table was " + "created by another concurrent thread or process.", tableName, region);
1035: Steve Loughran, info, TryStmt, LOG.info("Creating non-existent DynamoDB table {} in region {}", tableName, region);
1042: Steve Loughran, debug, TryStmt, LOG.debug("Awaiting table becoming active");
1062: Steve Loughran, debug, MethodDeclaration, LOG.debug("Putting item {}", item);
1084: Steve Loughran, info, LambdaExpr, LOG.info("Provision table {} in region {}: readCapacityUnits={}, " + "writeCapacityUnits={}", tableName, region, p.getReadCapacityUnits(), p.getWriteCapacityUnits());
1206: Aaron Fabbri, info, IfStmt, LOG.info("Table capacity unchanged at read: {}, write: {}", newRead, newWrite);
1200: Aaron Fabbri, info, IfStmt, LOG.info("Current table capacity is read: {}, write: {}", currentRead, currentWrite);
1202: Aaron Fabbri, info, IfStmt, LOG.info("Changing capacity of table to read: {}, write: {}", newRead, newWrite);
1251: Steve Loughran, info, IfStmt, LOG.info("Retrying {}: {}", text, ex.toString());
1252: Steve Loughran, debug, IfStmt, LOG.debug("Retrying {}", text, ex);
1246: Steve Loughran, debug, IfStmt, LOG.debug("DynamoDB IO limits reached in {};" + " consider increasing capacity: {}", text, ex.toString());
1241: Steve Loughran, warn, IfStmt, LOG.warn("DynamoDB IO limits reached in {};" + " consider increasing capacity: {}", text, ex.toString());
1243: Steve Loughran, debug, IfStmt, LOG.debug("Throttled", ex);
160: Aaron Fabbri, debug, IfStmt, LOG.debug("get({}) -> {}", path, m == null ? "null" : m.prettyPrint());
183: Steve Loughran, debug, IfStmt, LOG.debug("listChildren({}) -> {}", path, listing == null ? "null" : listing.prettyPrint());
204: Steve Loughran, debug, ForeachStmt, LOG.debug("move: deleting metadata {}", meta);
210: Steve Loughran, debug, ForeachStmt, LOG.debug("move: adding metadata {}", meta);
238: Steve Loughran, debug, IfStmt, LOG.debug("put {} -> {}", path, meta.prettyPrint());
281: Steve Loughran, debug, IfStmt, LOG.debug("put dirMeta {}", meta.prettyPrint());
400: Steve Loughran, debug, MethodDeclaration, LOG.debug("delete file entry for {}", path);
419: Steve Loughran, debug, IfStmt, LOG.debug("removing parent's entry for {} ", path);
110: Steve Loughran, error, CatchClause, LOG.error(message, e);
97: Steve Loughran, debug, TryStmt, LOG.debug("Using {} metadata store for {} filesystem", msClass.getSimpleName(), fs.getScheme());
125: Aaron Fabbri, debug, IfStmt, LOG.debug("Metastore option source {}", conf.getPropertySources(S3_METADATA_STORE_IMPL));
335: Steve Loughran, error, CatchClause, LOG.error("MetadataStore#put() failure:", ioe);
417: Steve Loughran, debug, IfStmt, LOG.debug("Skip moving ancestors of source root directory {}", srcRoot);
427: Steve Loughran, debug, WhileStmt, LOG.debug("Renaming non-listed parent {} to {}", parentSrc, parentDst);
239: Aaron Fabbri, info, IfStmt, LOG.info("Create metadata store: {}", uri + " scheme: " + uri.getScheme());
270: Steve Loughran, info, MethodDeclaration, LOG.info("Metadata store {} is initialized.", getStore());
301: Aaron Fabbri, debug, MethodDeclaration, LOG.debug("updated bucket store option {}", updatedBucketOption);
553: Steve Loughran, debug, CatchClause, LOG.debug("Failed to bind to store to be destroyed", e);
1458: Aaron Fabbri, debug, MethodDeclaration, LOG.debug("Executing command {}", subCommand);
97: Ravi Prakash, WARN, IfStmt, LOG.warn(LOGIN_WARNING);
128: Steve Loughran, WARN, IfStmt, LOG.warn(PLUS_WARNING);
44: Chris Nauroth, info, MethodDeclaration, getLog().info("FS details {}", getFileSystem());
78: Steve Loughran, error, IfStmt, LOG.error("Empty root directory test failed {} attempts.  Failing test.", maxAttempts);
67: Steve Loughran, info, IfStmt, LOG.info("Attempt {} of {} for empty root directory test failed.  " + "This is likely caused by eventual consistency of S3 " + "listings.  Attempting retry.", attempt, maxAttempts);
119: Chris Nauroth, info, MethodDeclaration, LOG.info("\n\n{}: {}\n", getMethodName(), String.format(text, args));
153: Lei Xu, info, CatchClause, LOG.info("Thread {} interrupted.", name);
172: Lei Xu, debug, IfStmt, LOG.debug("Creating thread pool");
196: Lei Xu, info, WhileStmt, LOG.info("Waiting for thread pool shutdown.");
198: Lei Xu, error, IfStmt, LOG.error("Failed to terminate thread pool gracefully.");
65: Steve Loughran, error, IfStmt, LOG.error("Unexpected nested cause: {} in {}", e.getCause(), e, e);
101: Steve Loughran, info, MethodDeclaration, LOG.info("closing output stream");
107: Steve Loughran, info, MethodDeclaration, LOG.info("end of test case");
64: Steve Loughran, info, ForeachStmt, LOG.info("entry: {}", stat);
107: Chris Nauroth, warn, IfStmt, LOG.warn("Custom endpoint test skipped as " + S3ATestConstants.CONFIGURATION_TEST_ENDPOINT + "config " + "setting was not detected");
392: Steve Loughran, error, CatchClause, LOG.error("Caught exception: ", e);
44: Steve Loughran, info, MethodDeclaration, getLog().info("FS details {}", getFileSystem());
118: Ravi Prakash, debug, CatchClause, LOG.debug("{} failure: {}", text, e, e);
56: Lei Xu, info, LambdaExpr, LOG.info("Test filesystem = {} implemented by {}", fsURI, fileSystem);
83: Lei Xu, info, LambdaExpr, LOG.info("Test filesystem = {} implemented by {}", fsURI, fileSystem);
107: Lei Xu, info, LambdaExpr, LOG.info("Test filesystem = {} implemented by {}", fsURI, fileSystem);
134: Lei Xu, info, LambdaExpr, LOG.info("Test filesystem = {} implemented by {}", fsURI, fileSystem);
176: Chris Nauroth, info, TryStmt, LOG.info("Filesystem {}", s3a);
93: Steve Loughran, info, CatchClause, LOG.info("File not found, as expected.");
187: Steve Loughran, info, IfStmt, LOG.info("File not found on read(), as expected.");
184: Steve Loughran, Error, IfStmt, LOG.error("Error:", e);
62: Steve Loughran, debug, WhileStmt, LOG.debug("Read batch of data from input stream...");
144: Steve Loughran, info, MethodDeclaration, LOG.info("Checksum for {}: {}", file1, checksum1);
107: Steve Loughran, debug, IfStmt, LOG.debug("Not our upload {},{}", listing.getKey(), listing.getUploadId());
104: Steve Loughran, debug, IfStmt, LOG.debug("Matched: {},{}", listing.getKey(), listing.getUploadId());
87: Steve Loughran, debug, IfStmt, LOG.debug("STS Endpoint ={}", stsEndpoint);
117: Steve Loughran, info, CatchClause, LOG.info("Expected Exception: {}", ex.toString());
118: Steve Loughran, debug, CatchClause, LOG.debug("Expected Exception: {}", ex, ex);
304: Steve Loughran, info, ForeachStmt, LOG.info("Testing with normalPathNum={}, delayedPathNum={}", normalPathNum, delayedPathNum);
443: Steve Loughran, info, MethodDeclaration, LOG.info("S3AFileSystem::listFiles('{}', {}) -> {}", baseTestDir, recursive, listedFiles);
113: Steve Loughran, info, SwitchStmt, LOG.info(s, ex);
154: Steve Loughran, debug, MethodDeclaration, LOG.debug("Setting S3 client to {}", client);
61: Steve Loughran, error, CatchClause, LOG.error(String.format("Failure aborting upload %s, continuing.", ik.getKey()), e);
58: Steve Loughran, debug, TryStmt, LOG.debug("aborting upload id {}", ik.getUploadId());
79: Steve Loughran, debug, MethodDeclaration, LOG.debug("uploaded part etag {}, upid {}", partEtag.getETag(), uploadId);
96: Steve Loughran, info, CatchClause, LOG.info("Ignoring exception: ", ioe);
92: Steve Loughran, debug, WhileStmt, LOG.debug("Cleaning up upload: {} {}", upload.getKey(), truncatedUploadId(upload.getUploadId()));
408: Steve Loughran, debug, IfStmt, LOG.debug("Enabling S3Guard, authoritative={}, implementation={}", authoritative, implClass);
450: Chris Nauroth, info, ForeachStmt, log.info(metric.toString());
764: Steve Loughran, warn, IfStmt, LOG.warn(message);
815: Steve Loughran, info, MethodCallExpr, LOG.info("{}", status);
828: Steve Loughran, info, MethodDeclaration, LOG.info("Enabling inconsistent S3 client");
140: Steve Loughran, info, TryStmt, LOG.info("Provider is {}", provider);
295: Steve Loughran, info, MethodDeclaration, LOG.info("Creating test FS and user {} with assumed role {}", conf.get(ACCESS_KEY), roleARN);
380: Steve Loughran, info, MethodDeclaration, LOG.info("Found {} outstanding MPUs", counter);
574: Steve Loughran, info, MethodDeclaration, LOG.info("Renaming readonly files {} to {}", readOnlyDir, destDir);
577: Steve Loughran, info, MethodDeclaration, LOG.info("Result of renaming read-only files is AccessDeniedException", ex);
694: Steve Loughran, info, TryStmt, LOG.info("Cleanup");
676: Steve Loughran, info, TryStmt, LOG.info("abortAllSinglePendingCommits({})", readOnlyDir);
90: Steve Loughran, info, MethodDeclaration, LOG.info("Setting role policy to policy of size {}:\n{}", p.length(), p);
261: Steve Loughran, info, IfStmt, log().info("Multipart uploads deleted: {}", count);
336: Steve Loughran, info, MethodDeclaration, log().info("Success data {}", successData.toString());
337: Steve Loughran, info, MethodDeclaration, log().info("Metrics\n{}", successData.dumpMetrics("  ", " = ", "\n"));
339: Steve Loughran, info, MethodDeclaration, log().info("Diagnostics\n{}", successData.dumpDiagnostics("  ", " = ", "\n"));
394: Steve Loughran, error, CatchClause, LOG.error("When closing {} on context {}", writer, context, e);
195: Steve Loughran, debug, IfStmt, LOG.debug("Using log4j path {}", log4jPath);
220: Steve Loughran, info, MethodDeclaration, LOG.info("Found {} files", fileCount);
222: Steve Loughran, debug, ForeachStmt, LOG.debug("result: {}", result);
235: Steve Loughran, info, MethodDeclaration, LOG.info("Committer name " + committerName() + "\n{}", commitDetails);
237: Steve Loughran, info, MethodDeclaration, LOG.info("Committer statistics: \n{}", successData.dumpMetrics("  ", " = ", "\n"));
239: Steve Loughran, info, MethodDeclaration, LOG.info("Diagnostics\n{}", successData.dumpDiagnostics("  ", " = ", "\n"));
190: Steve Loughran, info, CatchClause, log().info("Exception during cleanup", e);
195: Steve Loughran, info, IfStmt, log().info("Statistics for {}:\n{}", fileSystem.getUri(), fileSystem.getInstrumentation().dump("  ", " =  ", "\n", true));
527: Steve Loughran, warn, CatchClause, log().warn("Exception aborting task:", e);
533: Steve Loughran, warn, CatchClause, log().warn("Exception aborting job", e);
672: Steve Loughran, debug, MethodDeclaration, log().debug("Validating content in {}", expectedFile);
787: Steve Loughran, info, CatchClause, log().info("Outdir {} is not created by task commit phase ", outDir);
1186: Steve Loughran, info, WhileStmt, log().info("Awaiting thread termination!");
177: Steve Loughran, info, MethodDeclaration, LOG.info("Abort call");
368: Steve Loughran, debug, MethodDeclaration, LOG.debug("Destination entry: {}", status);
391: Steve Loughran, info, MethodDeclaration, LOG.info("Contents of {}: \n{}", pendingDataPath, data);
516: Steve Loughran, info, MethodDeclaration, LOG.info("Aborting");
518: Steve Loughran, info, MethodDeclaration, LOG.info("Abort completed");
70: Steve Loughran, debug, MethodDeclaration, LOG.debug("Creating LineRecordWriter with destination {}", file);
110: Steve Loughran, debug, MethodDeclaration, LOG.debug("Closing output file {} with {} lines :{}", dest, lines, out);
471: Steve Loughran, info, IfStmt, LOG.info("{}: Failed {}", this, i);
477: Steve Loughran, info, MethodDeclaration, LOG.info("{}: {} -> {}", this, before, i);
186: Steve Loughran, info, CatchClause, LOG.info("Exception while purging old uploads", e);
532: Steve Loughran, debug, LambdaExpr, LOG.debug("initiateMultipartUpload for {}", mockClient);
554: Steve Loughran, debug, LambdaExpr, LOG.debug("uploadPart for {}", mockClient);
560: Steve Loughran, info, IfStmt, LOG.info("Triggering upload failure");
582: Steve Loughran, debug, LambdaExpr, LOG.debug("completeMultipartUpload for {}", mockClient);
602: Steve Loughran, debug, LambdaExpr, LOG.debug("abortMultipartUpload for {}", mockClient);
631: Steve Loughran, debug, LambdaExpr, LOG.debug("deleteObject for {}", mockClient);
643: Steve Loughran, debug, LambdaExpr, LOG.debug("deleteObject for {}", mockClient);
115: Steve Loughran, info, MethodDeclaration, LOG.info("\n\n: {}\n", String.format(text, args));
296: Aaron Fabbri, error, CatchClause, LOG.error("Command {} failed: \n{}", cmd, buf);
310: Aaron Fabbri, info, MethodDeclaration, LOG.info("exec {}", (Object) args);
94: Steve Loughran, info, MethodDeclaration, LOG.info("Creating DynamoDBLocal client using endpoint {} in region {}", ddbEndpoint, region);
123: Steve Loughran, info, IfStmt, LOG.info("Setting {} -> {}", SYSPROP_SQLITE_LIB, System.getProperty(SYSPROP_SQLITE_LIB));
138: Steve Loughran, error, CatchClause, LOG.error(msg, t);
134: Steve Loughran, info, TryStmt, LOG.info("DynamoDBLocal singleton server was started at {}", ddbEndpoint);
149: Steve Loughran, info, IfStmt, LOG.info("Shutting down the in-memory DynamoDBLocal server");
154: Steve Loughran, error, CatchClause, LOG.error(msg, t);
77: Steve Loughran, warn, CatchClause, LOG.warn("Failed to delete {}, as it was not found", tableName, e);
131: Steve Loughran, error, CatchClause, LOG.error(e.getClass() + ": " + e.getMessage());
136: Steve Loughran, info, MethodDeclaration, LOG.info("Parallel DynamoDB client creation {} ran from {} to {}", index, timer.getStartTime(), timer.getEndTime());
276: Steve Loughran, warn, TryStmt, LOG.warn("Table may have not been cleaned up: " + testTableName);
216: Aaron Fabbri, info, TryStmt, LOG.info("Set Capacity output=\n{}", capacityOut);
222: Aaron Fabbri, info, TryStmt, LOG.info("Set Capacity output=\n{}", capacityOut);
238: Aaron Fabbri, info, TryStmt, LOG.info("Set Capacity output=\n{}", capacityOut);
251: Aaron Fabbri, info, MethodDeclaration, LOG.info("{}; capacities {}", tableInfo, updated);
260: Aaron Fabbri, info, MethodDeclaration, LOG.info("Exec output=\n{}", output);
271: Aaron Fabbri, info, MethodDeclaration, LOG.info("Exec output=\n{}", output);
441: Steve Loughran, debug, IfStmt, LOG.debug("Matched CLI output: {} {} {} {}", fields);
446: Steve Loughran, debug, WhileStmt, LOG.debug("Not matched: {}", line);
116: Steve Loughran, debug, MethodDeclaration, LOG.debug("== Setup. ==");
126: Steve Loughran, debug, MethodDeclaration, LOG.debug("== Tear down. ==");
131: Steve Loughran, warn, CatchClause, LOG.warn("Failed to destroy tables in teardown", e);
170: Steve Loughran, info, MethodDeclaration, LOG.info("We got {} by iterating DescendantsIterator", actual);
107: Steve Loughran, error, CatchClause, LOG.error(msg, e);
272: Steve Loughran, info, MethodDeclaration, LOG.info("doTestBatchWrite: oldDir={}, newDir={}", oldDir, newDir);
531: Steve Loughran, info, MethodDeclaration, LOG.info("Old provision = {}, new provision = {}", oldProvision, newProvision);
116: Steve Loughran, info, TryStmt, LOG.info("Running {} moves of {} paths each", operations, origMetas.size());
201: Steve Loughran, info, MethodDeclaration, log.info(String.format("Elapsed %.2f msec. %.3f msec / %s (%d ops)", msec, msecPerOp, op, count));
183: Steve Loughran, info, CatchClause, LOG.info("Wrapped output stream is not block stream: {}", out.getWrappedStream());
196: Steve Loughran, info, IfStmt, LOG.info(String.format("[%02d%%] Buffered %.2f MB out of %d MB;" + " PUT %d bytes (%d pending) in %d operations (%d active);" + " elapsedTime=%.2fs; write to buffer bandwidth=%.2f MB/s", percentage, writtenMB, filesizeMB, storageStatistics.getLong(putBytes), gaugeValue(putBytesPending), storageStatistics.getLong(putRequests), gaugeValue(putRequestsActive), elapsedTime, writtenMB / elapsedTime));
211: Steve Loughran, info, TryStmt, LOG.info("Closing stream {}", out);
212: Steve Loughran, info, TryStmt, LOG.info("Statistics : {}", streamStatistics);
223: Steve Loughran, info, MethodDeclaration, LOG.info("Statistics after stream closed: {}", streamStatistics);
226: Steve Loughran, info, MethodDeclaration, LOG.info("PUT {} bytes in {} operations; {} MB/operation", putByteCount, putRequestCount, putByteCount / (putRequestCount * _1MB));
229: Steve Loughran, info, MethodDeclaration, LOG.info("Time per PUT {} nS", toHuman(timer.nanosPerOperation(putRequestCount)));
301: Steve Loughran, warn, SwitchStmt, LOG.warn("Transfer failure");
309: Steve Loughran, info, SwitchStmt, LOG.info(String.format("Event %s; total uploaded=%d MB in %.1fs;" + " effective upload bandwidth = %.2f MB/s", progressEvent, writtenMB, elapsedTimeS, writtenMB / elapsedTimeS));
319: Steve Loughran, info, IfStmt, LOG.info("Event {}", progressEvent);
317: Steve Loughran, debug, IfStmt, LOG.debug("Event {}", progressEvent);
362: Chris Nauroth, info, MethodDeclaration, LOG.info("File System state after operation:\n{}", getFileSystem());
390: Steve Loughran, info, IfStmt, LOG.info("File is encrypted with algorithm {}", encryption);
419: Steve Loughran, info, TryStmt, LOG.info("Final stream state: {}", in);
426: Steve Loughran, info, MethodDeclaration, LOG.info("Time per positioned read = {} nS", toHuman(timer.nanosPerOperation(ops)));
449: Steve Loughran, info, TryStmt, LOG.info("Final stream state: {}", in);
454: Steve Loughran, info, MethodDeclaration, LOG.info("Time per MB to read = {} nS", toHuman(timer.nanosPerOperation(mb)));
472: Steve Loughran, info, MethodDeclaration, LOG.info("Time per MB to rename = {} nS", toHuman(timer.nanosPerOperation(mb)));
483: Steve Loughran, info, MethodDeclaration, LOG.info("Time per MB to rename = {} nS", toHuman(timer2.nanosPerOperation(mb)));
511: Steve Loughran, info, MethodDeclaration, LOG.info("Statistics\n{}", sb);
80: Steve Loughran, info, MethodDeclaration, LOG.info("Generating data...");
86: Steve Loughran, debug, ForStmt, LOG.debug("{}: Block {}...", aSource, mb);
91: Steve Loughran, info, MethodDeclaration, LOG.info("Data generated...");
152: Steve Loughran, info, MethodDeclaration, LOG.info("Rename {} ran from {} to {}", index, timer.getStartTime(), timer.getEndTime());
158: Steve Loughran, info, MethodDeclaration, LOG.info("Waiting for tasks to complete...");
159: Steve Loughran, info, MethodDeclaration, LOG.info("Deadlock may have occurred if nothing else is logged" + " or the test times out");
166: Steve Loughran, info, MethodDeclaration, LOG.info("All tasks have completed successfully");
67: Steve Loughran, info, MethodDeclaration, LOG.info("Time per create: {} msec", timer.nanosPerOperation(numOperations) / 1000);
92: Aaron T. Myers, Error, CatchClause, LOG.warn("Error while uploading file", e.getCause());
89: Aaron T. Myers, warn, IfStmt, LOG.warn("cannot create file");
70: Chris Nauroth, info, MethodDeclaration, LOG.info("Time per operation: {}", toHuman(createTimer.nanosPerOperation(created.totalCount())));
185: Chris Nauroth, info, MethodDeclaration, LOG.info("Time per call: {}", toHuman(timer.nanosPerOperation(attempts)));
186: Chris Nauroth, info, MethodDeclaration, LOG.info("metadata: {}", metadataRequests);
187: Chris Nauroth, info, MethodDeclaration, LOG.info("metadata per operation {}", metadataRequests.diff() / attempts);
188: Chris Nauroth, info, MethodDeclaration, LOG.info("listObjects: {}", listRequests);
189: Chris Nauroth, info, MethodDeclaration, LOG.info("listObjects: per operation {}", listRequests.diff() / attempts);
85: Steve Loughran, info, IfStmt, LOG.info("Using {} as input stream source", testData);
91: Steve Loughran, warn, CatchClause, LOG.warn("Failed to read file {} specified in {}", testFile, KEY_CSVTEST_FILE, e);
81: Steve Loughran, warn, IfStmt, LOG.warn(assumptionMessage);
203: Steve Loughran, info, MethodDeclaration, LOG.info("Time per {}: {} nS", operation, toHuman(timer.duration() / count));
250: Mingliang Liu, warn, IfStmt, LOG.warn("0 bytes returned by read() operation #{}", reads);
242: Mingliang Liu, debug, IfStmt, LOG.debug("Bytes in read #{}: {} , block bytes: {}," + " remaining in block: {}" + " duration={} nS; ns/byte: {}, bandwidth={} MB/s", reads, bytesRead, blockSize - remaining, remaining, readTimer.duration(), readTimer.nanosPerOperation(bytesRead), readTimer.bandwidthDescription(bytesRead));
255: Mingliang Liu, info, ForStmt, LOG.info("Bandwidth of block {}: {} MB/s: ", blockId, bw);
257: Mingliang Liu, warn, IfStmt, LOG.warn("Bandwidth {} too low on block {}: resetting connection", bw, blockId);
267: Mingliang Liu, info, MethodDeclaration, LOG.info("Overall Bandwidth {} MB/s; reset connections {}", timer2.bandwidth(totalToRead), resetCount);
365: Steve Loughran, info, MethodDeclaration, LOG.info(String.format("Stream Statistics%n{}"), streamStatistics);
381: Steve Loughran, info, MethodDeclaration, LOG.info("Reading {} blocks, readahead = {}", blockCount, readahead);
393: Steve Loughran, info, MethodDeclaration, LOG.info("Effective bandwidth {} MB/S", timer.bandwidthDescription(streamStatistics.bytesRead - streamStatistics.bytesSkippedOnSeek));
468: Steve Loughran, info, MethodDeclaration, LOG.info("Effective bandwidth {} MB/S", timer.bandwidthDescription(streamStatistics.bytesRead - streamStatistics.bytesSkippedOnSeek));
494: Steve Loughran, info, MethodDeclaration, LOG.info("Starting initial reads");
540: Steve Loughran, info, MethodDeclaration, LOG.info("Time per byte(): {} nS", toHuman(readTimer.nanosPerOperation(bytesRead)));
542: Steve Loughran, info, MethodDeclaration, LOG.info("Time per read(): {} nS", toHuman(readTimer.nanosPerOperation(readOps)));
560: Steve Loughran, info, MethodDeclaration, LOG.info("seeking");
562: Steve Loughran, info, MethodDeclaration, LOG.info("reading");
575: Steve Loughran, info, MethodDeclaration, LOG.info("Time per read(): {} nS", toHuman(timer.nanosPerOperation(readCount)));
92: Steve Loughran, debug, MethodDeclaration, LOG.debug("Scale test operation count = {}", getOperationCount());
150: Chris Nauroth, warn, IfStmt, LOG.warn("Disabling threads for {} operation as thread count {} is <= 1", operation, threadCount);
145: Chris Nauroth, warn, CatchClause, LOG.warn("Failed to create thread pool with threads {} for operation {} on blob {}." + " Use config {} to set less number of threads. Setting config value to <= 1 will disable threads.", threadCount, operation, key, config);
154: Chris Nauroth, debug, IfStmt, LOG.debug("Using thread pool for {} operation with threads {}", operation, threadCount);
185: Chris Nauroth, error, CatchClause, LOG.error("Threads got interrupted {} blob operation for {} ", operation, key);
191: Chris Nauroth, warn, IfStmt, LOG.warn("{} threads not used for {} operation on blob {}", threadsNotUsed, operation, key);
205: Chris Nauroth, error, IfStmt, LOG.error("{} failed as operation on subfolders and files failed.", operation);
197: Chris Nauroth, info, IfStmt, LOG.info("Not able to schedule threads to {} blob {}. Fall back to {} blob serially.", operation, key, operation);
221: Chris Nauroth, debug, IfStmt, LOG.debug("Serializing the {} operation", operation);
224: Chris Nauroth, warn, IfStmt, LOG.warn("Failed to {} file {}", operation, contents[i]);
235: Chris Nauroth, info, MethodDeclaration, LOG.info("Time taken for {} operation is: {} ms with threads: {}", operation, (end - start), threadCount);
323: Chris Nauroth, error, CatchClause, LOG.error("Encountered Exception for {} operation for file {}", this.operation, file.getKey());
316: Chris Nauroth, error, IfStmt, LOG.error("{} operation failed for file {}", this.operation, file.getKey());
332: Chris Nauroth, warn, IfStmt, LOG.warn("Terminating execution of {} operation now as some other thread" + " already got exception or operation failed", this.operation, file.getKey());
339: Chris Nauroth, debug, MethodDeclaration, LOG.debug("Time taken to process {} files count for {} operation: {} ms", processedFilesCount, this.operation, (end - start));
542: cnauroth, debug, MethodDeclaration, LOG.debug("Page blob directories:  {}", setToString(pageBlobDirs));
550: Steve Loughran, debug, MethodDeclaration, LOG.debug("Block blobs with compaction directories:  {}", setToString(blockBlobWithCompationDirs));
565: cnauroth, warn, CatchClause, LOG.warn("Unable to initialize HBase root as an atomic rename directory.");
567: cnauroth, debug, MethodDeclaration, LOG.debug("Atomic rename directories: {} ", setToString(atomicRenameDirs));
813: cnauroth, debug, MethodDeclaration, LOG.debug("AzureNativeFileSystemStore init. Settings={},{},{},{{},{},{},{}},{{},{},{}}", concurrentWrites, tolerateOobAppends, ((storageConnectionTimeout > 0) ? storageConnectionTimeout : STORAGE_CONNECTION_TIMEOUT_DEFAULT), minBackoff, deltaBackoff, maxBackoff, maxRetries, selfThrottlingEnabled, selfThrottlingReadFactor, selfThrottlingWriteFactor);
858: Steve Loughran, error, CatchClause, LOG.error("Service returned StorageException when checking existence " + "of container {} in account {}", containerName, accountName, ex);
1079: Steve Loughran, debug, IfStmt, LOG.debug("The account access key is not configured for {}. " + "Now try anonymous access.", sessionUri);
1231: cnauroth, info, CatchClause, LOG.info("URI syntax error creating URI for {}", dir);
1510: Steve Loughran, debug, IfStmt, LOG.debug("Using stream seek algorithm {}", inputStreamVersion);
2054: cnauroth, debug, MethodDeclaration, LOG.debug("Retrieving metadata for {}", key);
2078: cnauroth, debug, IfStmt, LOG.debug("Found {} as an explicit blob. Checking if it's a file or folder.", key);
2092: Steve Loughran, debug, IfStmt, LOG.debug("{} is a normal blob.", key);
2087: Steve Loughran, debug, IfStmt, LOG.debug("{} is a folder blob.", key);
2123: cnauroth, debug, IfStmt, LOG.debug("Found blob as a directory-using this file under it to infer its properties {}", blobItem.getUri());
2519: Steve Loughran, error, IfStmt, LOG.error("Encountered Storage Exception for delete on Blob: {}" + ", Exception Details: {} Error Code: {}", blob.getUri(), e.getMessage(), e.getErrorCode());
2531: cnauroth, debug, IfStmt, LOG.debug("Swallowing delete exception on retry: {}", e.getMessage());
2585: cnauroth, warn, CatchClause, LOG.warn("Got unexpected exception trying to acquire lease on " + key + "." + e3.getMessage());
2594: cnauroth, error, CatchClause, LOG.error("Unable to free lease on " + key, e4);
2621: cnauroth, debug, MethodDeclaration, LOG.debug("Moving {} to {}", srcKey, dstKey);
2715: cnauroth, warn, IfStmt, LOG.warn("Rename: CopyBlob: StorageException: ServerBusy: Retry complete, will attempt client side copy for page blob");
2735: cnauroth, warn, CatchClause, LOG.warn("Rename: CopyBlob: StorageException: Failed");
2857: cnauroth, debug, MethodDeclaration, LOG.debug("acquiring lease on {}", key);
2914: Chris Nauroth, debug, MethodDeclaration, LOG.debug("finalize() called");
379: Steve Loughran, debug, IfStmt, LOG.debug("Encountered storage exception." + " StorageException : {} ErrorCode : {}", ex, ex.getErrorCode());
574: Steve Loughran, debug, MethodDeclaration, LOG.debug("close {} ", key);
590: Steve Loughran, error, IfStmt, LOG.error("Time out occurred while close() is waiting for IO request to" + " finish in append" + " for blob : {}", key);
606: Steve Loughran, debug, CatchClause, LOG.debug("Lease free update blob {} encountered Storage Exception:" + " {} Error Code : {}", key, ex, ex.getErrorCode());
736: Steve Loughran, debug, CatchClause, LOG.debug("Encountered exception during uploading block for Blob {}" + " Exception : {}", key, ioe);
730: Steve Loughran, debug, TryStmt, LOG.debug("upload block finished for {} ms. block {} ", TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime), blockId);
802: Steve Loughran, debug, CatchClause, LOG.debug("Encountered exception during uploading block for Blob {}" + " Exception : {}", key, ioe);
796: Steve Loughran, debug, TryStmt, LOG.debug("Upload block list took {} ms for blob {} ", TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime), key);
874: Steve Loughran, debug, MethodDeclaration, LOG.debug("upload block {} size: {} for blob {}", entry.getId(), entry.getSize(), key);
902: Steve Loughran, debug, MethodDeclaration, LOG.debug("commit block list with {} blocks for blob {}", uncommittedBlockEntries.size(), key);
912: Steve Loughran, debug, IfStmt, LOG.debug("commit already applied for {}", key);
917: Steve Loughran, debug, IfStmt, LOG.debug("nothing to commit for {}", key);
921: Steve Loughran, debug, MethodDeclaration, LOG.debug("active commands: {} for {}", activeBlockCommands.size(), key);
942: Steve Loughran, debug, IfStmt, LOG.debug("Block compaction: activated with {} blocks for {}", blockEntries.size(), key);
948: Steve Loughran, debug, IfStmt, LOG.debug("Block compaction finished for {} ms with {} blocks for {}", TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startCompaction), blockEntries.size(), key);
1027: Steve Loughran, debug, IfStmt, LOG.debug("Block compaction: {} blocks for {}", maxSegmentEnd - maxSegmentBegin, key);
1039: Steve Loughran, error, CatchClause, LOG.error("Storage exception encountered during block compaction phase" + " : {} Storage Exception : {} Error Code: {}", key, ex, ex.getErrorCode());
1139: Steve Loughran, debug, CatchClause, LOG.debug("Encountered exception during execution of command for Blob :" + " {} Exception : {}", key, ex);
1133: Steve Loughran, debug, TryStmt, LOG.debug("command finished for {} ms", TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));
68: Jitendra Pandey, debug, IfStmt, LOG.debug("{} : Initializing CachingAuthorizer instance", label);
95: Jitendra Pandey, debug, IfStmt, LOG.debug("{}: CACHE HIT: {}, {}", label, key.toString(), result.toString());
92: Jitendra Pandey, debug, IfStmt, LOG.debug("{}: CACHE MISS: {}", label, key.toString());
102: Jitendra Pandey, debug, IfStmt, LOG.debug("{}: CACHE PUT: {}, {}", label, key.toString(), value.toString());
211: Steve Loughran, debug, IfStmt, LOG.debug(String.format("%5.5s, %10d, %10d, %10d, %10d, %6.2f, %5d, %5d, %5d", name, (int) bytesFailed, (int) bytesSuccessful, (int) operationsFailed, (int) operationsSuccessful, errorPercentage, periodMs, (int) sleepDuration, (int) newSleepDuration));
57: Steve Loughran, debug, ConstructorDeclaration, LOG.debug("Client-side throttling is enabled for the WASB file system.");
147: Chris Nauroth, debug, ConstructorDeclaration, LOG.debug("Time taken to list {} blobs for rename operation is: {} ms", fileMetadata.length, (end - start));
200: cnauroth, error, IfStmt, LOG.error("Deleting corruped rename pending file {} \n {}", redoFile, contents);
258: cnauroth, warn, IfStmt, LOG.warn("rename pending file " + redoFile + " is already deleted");
295: cnauroth, debug, MethodDeclaration, LOG.debug("Preparing to write atomic rename state to {}", path.toString());
340: cnauroth, error, IfStmt, LOG.error("Internal error: Exceeded maximum rename pending file size of {} bytes.", MAX_RENAME_PENDING_FILE_SIZE);
592: cnauroth, info, CatchClause, LOG.info("Unable to delete source folder during folder rename redo. " + "If the source folder is already gone, this is not an error " + "condition. Continuing with redo.", e);
625: Mingliang Liu, warn, IfStmt, LOG.warn("Attempting to complete rename of file " + srcKey + "/" + fileName + " during folder rename redo, and file was not found in source " + "or destination " + dstKey + "/" + fileName + ". " + "This must mean the rename of this file has already completed");
841: cnauroth, error, IfStmt, LOG.error("Encountered Storage Exception for read on Blob : {}" + " Exception details: {} Error Code : {}", key, e, ((StorageException) innerException).getErrorCode());
895: cnauroth, error, IfStmt, LOG.error("Encountered Storage Exception for read on Blob : {}" + " Exception details: {} Error Code : {}", key, e, ((StorageException) innerException).getErrorCode());
936: cnauroth, debug, TryStmt, LOG.debug("Seek to position {}. Bytes skipped {}", pos, this.pos);
1083: cnauroth, error, IfStmt, LOG.error("Encountered Storage Exception for write on Blob : {}" + " Exception details: {} Error Code : {}", key, e.getMessage(), storageExcp.getErrorCode());
1106: cnauroth, error, IfStmt, LOG.error("Encountered Storage Exception for write on Blob : {}" + " Exception details: {} Error Code : {}", key, e.getMessage(), storageExcp.getErrorCode());
1136: cnauroth, error, IfStmt, LOG.error("Encountered Storage Exception for write on Blob : {}" + " Exception details: {} Error Code : {}", key, e.getMessage(), storageExcp.getErrorCode());
1368: cnauroth, debug, MethodDeclaration, LOG.debug("NativeAzureFileSystem. Initializing.");
1369: cnauroth, debug, MethodDeclaration, LOG.debug("  blockSize  = {}", conf.getLong(AZURE_BLOCK_SIZE_PROPERTY_NAME, MAX_AZURE_BLOCK_SIZE));
1575: cnauroth, debug, MethodDeclaration, LOG.debug("Opening file: {} for append", f);
1678: cnauroth, warn, CatchClause, LOG.warn("Got unexpected exception trying to get lease on {} . {}", pathToKey(parent), e.getMessage());
1701: cnauroth, warn, CatchClause, LOG.warn("Unable to free lease because: {}", e.getMessage());
1721: cnauroth, error, CatchClause, LOG.error(msg);
1778: cnauroth, debug, MethodDeclaration, LOG.debug("Creating file: {}", f.toString());
1925: Steve Loughran, debug, MethodDeclaration, LOG.debug("Deleting file: {}", f);
2056: Steve Loughran, debug, IfStmt, LOG.debug("Found an implicit parent directory while trying to" + " delete the directory {}. Creating the directory blob for" + " it in {}. ", f, parentKey);
2098: Steve Loughran, debug, IfStmt, LOG.debug("Time taken to list {} blobs for delete operation: {} ms", fileMetadataList.size(), (end - start));
2118: Steve Loughran, warn, IfStmt, LOG.warn("Attempt to delete non-existent {} {}", file.isDir() ? "directory" : "file", file.getKey());
2130: Steve Loughran, error, IfStmt, LOG.error("Failed to delete files / subfolders in blob {}", key);
2135: Steve Loughran, error, IfStmt, LOG.error("Cannot delete root directory {}", f);
2142: Steve Loughran, error, IfStmt, LOG.error("Failed delete directory : {}", f);
2012: Steve Loughran, debug, IfStmt, LOG.debug("Found an implicit parent directory while trying to" + " delete the file {}. Creating the directory blob for" + " it in {}.", f, parentKey);
2156: Steve Loughran, debug, MethodDeclaration, LOG.debug("Delete Successful for : {}", f);
2163: Steve Loughran, debug, MethodDeclaration, LOG.debug("Deleting file: {}", f);
2313: cnauroth, debug, IfStmt, LOG.debug("Found an implicit parent directory while trying to" + " delete the directory {}. Creating the directory blob for" + " it in {}. ", f, parentKey);
2351: Chris Nauroth, debug, IfStmt, LOG.debug("Time taken to list {} blobs for delete operation: {} ms", fileMetadataList.size(), (end - start));
2369: Steve Loughran, warn, IfStmt, LOG.warn("Attempt to delete non-existent {} {}", file.isDir() ? "directory" : "file", file.getKey());
2381: Chris Nauroth, error, IfStmt, LOG.error("Failed to delete files / subfolders in blob {}", key);
2388: Steve Loughran, error, IfStmt, LOG.error("Failed delete directory : {}", f);
2244: cnauroth, debug, IfStmt, LOG.debug("Found an implicit parent directory while trying to" + " delete the file {}. Creating the directory blob for" + " it in {}.", f, parentKey);
2402: Steve Loughran, debug, MethodDeclaration, LOG.debug("Delete Successful for : {}", f);
2473: Steve Loughran, debug, CatchClause, LOG.debug("Authorization check failed for {}", currentPath);
2494: Steve Loughran, error, IfStmt, LOG.error("User does not have permissions to delete {}. " + "Parent directory has sticky bit set.", filePath);
2522: Steve Loughran, debug, IfStmt, LOG.debug("Cannot delete {} since some of its contents " + "cannot be deleted", pathToRemove);
2568: Steve Loughran, debug, IfStmt, LOG.debug("Encountered FileNotFoundException while performing " + "stickybit check operation for {}", metaData.getKey());
2649: cnauroth, debug, MethodDeclaration, LOG.debug("Getting the file status for {}", f.toString());
2730: cnauroth, debug, IfStmt, LOG.debug("Found the path: {} as a file.", f.toString());
2783: cnauroth, debug, MethodDeclaration, LOG.debug("Listing status for {}", f.toString());
2887: cnauroth, debug, IfStmt, LOG.debug("Did not find any metadata for path: {}", key);
2810: cnauroth, debug, IfStmt, LOG.debug("Found path as a file");
2882: cnauroth, debug, IfStmt, LOG.debug("Found path as a directory with {}" + " files in it.", status.size());
3005: Mingliang Liu, debug, IfStmt, LOG.debug("Found ancestor {}, for path: {}", ancestor.toString(), f.toString());
3020: cnauroth, debug, MethodDeclaration, LOG.debug("Creating directory: {}", f.toString());
3076: cnauroth, debug, MethodDeclaration, LOG.debug("Opening file: {}", f.toString());
3131: cnauroth, debug, MethodDeclaration, LOG.debug("Moving {} to {}", src, dst);
3165: Steve Loughran, debug, IfStmt, LOG.debug("Encountered FileNotFound Exception when performing sticky bit check " + "on {}. Failing rename", srcKey);
3191: cnauroth, debug, IfStmt, LOG.debug("BlobNotFound exception encountered for Destination key : {}. " + "Swallowing the exception to handle race condition gracefully", dstKey);
3224: cnauroth, debug, IfStmt, LOG.debug("Parent of destination {} doesn't exists. Failing rename", dst);
3236: cnauroth, debug, IfStmt, LOG.debug("Parent of the destination {}" + " is a file, failing the rename.", dst);
3232: cnauroth, debug, IfStmt, LOG.debug("Parent of the destination {}" + " doesn't exist, failing the rename.", dst);
3209: cnauroth, debug, IfStmt, LOG.debug("Destination {}" + " is an already existing file, failing the rename.", dst);
3205: cnauroth, debug, IfStmt, LOG.debug("Destination {} " + " is a directory, adjusted the destination to be {}", dst, dstKey);
3253: cnauroth, debug, IfStmt, LOG.debug("Source {} doesn't exists. Failing rename", src);
3306: cnauroth, debug, IfStmt, LOG.debug("Renamed {} to {} successfully.", src, dst);
3265: cnauroth, debug, IfStmt, LOG.debug("Source {} found as a file, renaming.", src);
3280: Steve Loughran, debug, IfStmt, LOG.debug("BlobNotFoundException encountered. Failing rename", src);
3285: Steve Loughran, debug, IfStmt, LOG.debug("Destination BlobAlreadyExists. Failing rename", src);
3262: cnauroth, debug, IfStmt, LOG.debug("Source {} doesn't exist, failing the rename.", src);
3316: cnauroth, debug, MethodDeclaration, LOG.debug("Renamed {} to {} successfully.", src, dst);
3360: cnauroth, warn, CatchClause, LOG.warn("Got unexpected exception trying to get lease on {}. {}", parentKey, e.getMessage());
3369: cnauroth, error, CatchClause, LOG.error("Unable to free lease on {}", parentKey, e);
3447: Steve Loughran, debug, IfStmt, LOG.debug("Source {} doesn't exist. Failing rename.", srcPath);
3455: Steve Loughran, debug, IfStmt, LOG.debug("Path {} doesn't exist, failing rename.", srcParentPath);
3648: cnauroth, debug, MethodDeclaration, LOG.debug("Submitting metrics when file system closed took {} ms.", (System.currentTimeMillis() - startTime));
3722: cnauroth, debug, MethodDeclaration, LOG.debug("Deleting dangling file {}", file.getKey());
3745: cnauroth, debug, MethodDeclaration, LOG.debug("Recovering {}", file.getKey());
3823: cnauroth, debug, MethodDeclaration, LOG.debug("Recovering files with dangling temp data in {}", root);
3840: cnauroth, debug, MethodDeclaration, LOG.debug("Deleting files with dangling temp data in {}", root);
3846: Chris Nauroth, debug, MethodDeclaration, LOG.debug("finalize() called.");
3906: Mingliang Liu, error, IfStmt, LOG.error(errorMsg);
3895: Mingliang Liu, debug, IfStmt, LOG.debug("Cannot find file/folder - '{}'. Returning owner as empty string", absolutePath);
3892: Mingliang Liu, debug, IfStmt, LOG.debug("Retrieved '{}' as owner for path - {}", owner, absolutePath);
57: cnauroth, debug, IfStmt, log.debug("Exception in closing {}", closeable, e);
122: cnauroth, debug, ForeachStmt, LOG.debug("Thread " + entry.getKey().getName());
125: cnauroth, debug, ForStmt, LOG.debug("\tat " + trace[j]);
132: cnauroth, warn, IfStmt, LOG.warn(String.format("Blob %s has %d page ranges beyond the first range. " + "Only reading the first range.", blob.getUri(), allRanges.size() - 1));
166: cnauroth, debug, ConstructorDeclaration, LOG.debug("Read value of fs.azure.page.blob.size as " + pageBlobConfigSize + " from configuration (0 if not present).");
209: cnauroth, debug, MethodDeclaration, LOG.debug("Closing page blob output stream.");
222: cnauroth, debug, CatchClause, LOG.debug("Caught InterruptedException");
214: cnauroth, debug, TryStmt, LOG.debug(ioThreadPool.toString());
216: cnauroth, debug, IfStmt, LOG.debug("Timed out after 10 minutes waiting for IO requests to finish");
218: cnauroth, debug, IfStmt, LOG.debug(ioThreadPool.toString());
251: cnauroth, debug, TryStmt, LOG.debug("before runInternal()");
253: cnauroth, debug, TryStmt, LOG.debug("after runInternal()");
350: cnauroth, debug, MethodDeclaration, LOG.debug("writing payload of " + rawPayload.length + " bytes to Azure page blob");
358: cnauroth, debug, CatchClause, LOG.debug(ExceptionUtils.getStackTrace(ex));
361: cnauroth, debug, CatchClause, LOG.debug(ExceptionUtils.getStackTrace(ex));
356: cnauroth, trace, TryStmt, LOG.trace("Azure uploadPages time for " + rawPayload.length + " bytes = " + (end - start));
365: cnauroth, debug, IfStmt, LOG.debug("Caught error in PageBlobOutputStream#writePayloadToServer()");
412: cnauroth, warn, CatchClause, LOG.warn("Failed to extend size of " + cloudPageBlob.getUri());
539: cnauroth, debug, MethodDeclaration, LOG.debug("Entering PageBlobOutputStream#hsync().");
542: cnauroth, debug, MethodDeclaration, LOG.debug(ioThreadPool.toString());
552: cnauroth, debug, MethodDeclaration, LOG.debug("Leaving PageBlobOutputStream#hsync(). Total hsync duration = " + (System.currentTimeMillis() - start) + " msec.");
132: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Initializing RemoteSASKeyGeneratorImpl instance");
166: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Initialization of RemoteSASKeyGenerator instance successful");
180: Jitendra Pandey, debug, TryStmt, LOG.debug("Generating Container SAS Key: Storage Account {}, Container {}", storageAccount, container);
218: Jitendra Pandey, debug, TryStmt, LOG.debug("Generating RelativePath SAS Key for relativePath {} inside Container {} inside Storage Account {}", relativePath, container, storageAccount);
120: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Initializing RemoteWasbAuthorizerImpl instance");
115: Mingliang Liu, error, MethodDeclaration, LOG.error(errorMsg);
123: Mingliang Liu, error, MethodDeclaration, LOG.error(errorMsg);
131: Mingliang Liu, error, MethodDeclaration, LOG.error(errorMsg);
139: Mingliang Liu, error, MethodDeclaration, LOG.error(errorMsg);
163: Mingliang Liu, error, CatchClause, LOG.error(errorMsg);
249: Mingliang Liu, error, CatchClause, LOG.error(errorMsg);
270: Mingliang Liu, error, CatchClause, LOG.error(errorMsg);
165: Mingliang Liu, debug, MethodDeclaration, LOG.debug("SecureWasbRemoteCallHelper#getHttpRequest() {}", uriBuilder.build().toURL());
201: Mingliang Liu, debug, IfStmt, LOG.debug("{} token found in cache : {}", WasbDelegationTokenIdentifier.TOKEN_KIND, iterToken);
206: Mingliang Liu, debug, IfStmt, LOG.debug("UGI Information: {}", userGroupInformation.toString());
212: Mingliang Liu, debug, IfStmt, LOG.debug("Using UGI token: {}", token);
217: Mingliang Liu, debug, IfStmt, LOG.debug("Delegation token from cache - {}", delegationToken != null ? delegationToken.encodeToUrlString() : "null");
92: cnauroth, info, IfStmt, LOG.info("Caught exception when trying to get lease on blob " + blobWrapper.getUri().toString() + ". " + e.getMessage());
114: cnauroth, debug, ConstructorDeclaration, LOG.debug("Acquired lease " + leaseID + " on " + blob.getUri() + " managed by thread " + renewer.getName());
136: cnauroth, warn, IfStmt, LOG.warn("Unanticipated exception when trying to free lease " + leaseID + " on " + blobWrapper.getStorageUri());
146: cnauroth, debug, TryStmt, LOG.debug("Freed lease " + leaseID + " on " + blobWrapper.getUri() + " managed by thread " + renewer.getName());
171: cnauroth, debug, MethodDeclaration, LOG.debug("Starting lease keep-alive thread.");
180: cnauroth, debug, CatchClause, LOG.debug("Keep-alive thread for lease " + leaseID + " interrupted.");
115: Chris Nauroth, debug, IfStmt, LOG.debug(String.format("SelfThrottlingIntercept:: ResponseReceived: threadId=%d, Status=%d, Elapsed(ms)=%d, ETAG=%s, contentLength=%d, requestMethod=%s", threadId, statusCode, elapsed, etag, contentLength, requestMethod));
167: Chris Nauroth, debug, IfStmt, LOG.debug(String.format(" SelfThrottlingIntercept:: SendingRequest:   threadId=%d, requestType=%s, isFirstRequest=%b, sleepDuration=%d", threadId, operationIsRead ? "read " : "write", isFirstRequest, sleepDuration));
52: cnauroth, warn, CatchClause, LOG.warn("Unable to get key from credential providers.", ioe);
218: Mingliang Liu, debug, CatchClause, LOG.debug(e.getMessage(), e);
227: Mingliang Liu, error, CatchClause, LOG.error(message, ioex);
285: Mingliang Liu, warn, CatchClause, LOG.warn(e.getMessage(), e);
289: Mingliang Liu, warn, CatchClause, LOG.warn("Original exception is ", ioe);
277: Mingliang Liu, debug, IfStmt, LOG.debug("Retrying connect to Remote service:{}. Already tried {}" + " time(s); retry policy is {}, " + "delay {}ms.", url, retry, retryPolicy, a.delayMillis);
292: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Not retrying anymore, already retried the urls {} time(s)", retry);
43: Mingliang Liu, debug, CatchClause, LOG.debug("JSON Parsing exception: {} while parsing {}", e.getMessage(), jsonString);
46: Mingliang Liu, error, IfStmt, LOG.error("Internal Server Error was encountered while making a request");
54: Mingliang Liu, debug, IfStmt, LOG.debug("Read url string param - {}", urlString);
69: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Renewing the delegation token");
83: Mingliang Liu, debug, MethodDeclaration, LOG.debug("Cancelling the delegation token");
172: Steve Loughran, info, MethodDeclaration, LOG.info("\n\n{}: {}\n", methodName.getMethodName(), String.format(text, args));
329: Steve Loughran, warn, IfStmt, LOG.warn("Skipping emulator Azure test because configuration " + "doesn't indicate that it's running.");
495: Steve Loughran, warn, IfStmt, LOG.warn("Skipping live Azure test because of missing key for" + " account '" + accountName + "'.");
530: Steve Loughran, warn, IfStmt, LOG.warn("Skipping live Azure test because of missing test account");
115: Steve Loughran, error, CatchClause, LOG.error("DatablockWriter thread encountered a storage exception." + e.getMessage(), e);
118: Steve Loughran, error, CatchClause, LOG.error("DatablockWriter thread encountered an I/O exception." + e.getMessage(), e);
138: Steve Loughran, info, IfStmt, LOG.info("Reusing test file: {}", testFileStatus);
150: Steve Loughran, info, MethodDeclaration, LOG.info("Creating test file {} of size: {}", TEST_FILE_PATH, TEST_FILE_SIZE);
160: Steve Loughran, info, TryStmt, LOG.info("Closing stream {}", outputStream);
711: Steve Loughran, info, ForStmt, LOG.info(String.format("v1ElapsedMs=%1$d, v2ElapsedMs=%2$d, ratio=%3$.2f", (long) v1ElapsedMs, (long) v2ElapsedMs, ratio));
745: Steve Loughran, info, ForStmt, LOG.info(String.format("beforeSeekElapsedMs=%1$d, afterSeekElapsedMs=%2$d, ratio=%3$.2f", (long) beforeSeekElapsedMs, (long) afterSeekElapsedMs, ratio));
784: Steve Loughran, info, TryStmt, LOG.info(String.format("v%1$d: bytesRead=%2$d, elapsedMs=%3$d, Mbps=%4$.2f," + " afterReverseSeek=%5$s", version, totalBytesRead, elapsedTimeMs, toMbps(totalBytesRead, elapsedTimeMs), afterReverseSeek));
812: Steve Loughran, info, ForStmt, LOG.info(String.format("v1ElapsedMs=%1$d, v2ElapsedMs=%2$d, ratio=%3$.2f", (long) v1ElapsedMs, (long) v2ElapsedMs, ratio));
848: Steve Loughran, info, TryStmt, LOG.info(String.format("v%1$d: totalBytesRead=%2$d, elapsedTimeMs=%3$d, Mbps=%4$.2f", version, totalBytesRead, elapsedTimeMs, toMbps(totalBytesRead, elapsedTimeMs)));
213: Mingliang Liu, error, IfStmt, LOG.error(message);
228: Mingliang Liu, error, IfStmt, LOG.error(message);
81: Steve Loughran, info, IfStmt, LOG.info("rename succeeded for thread " + threadNumber);
112: Steve Loughran, info, MethodDeclaration, LOG.info("Success, only one rename operation succeeded!");
146: cnauroth, info, MethodDeclaration, LOG.info("Starting test");
167: cnauroth, warn, CatchClause, LOG.warn("Lease acqusition thread unable to acquire lease", e);
165: cnauroth, info, TryStmt, LOG.info("Lease acquired: " + lease.getLeaseID());
193: cnauroth, warn, CatchClause, LOG.warn("Unable to free lease.", se);
189: cnauroth, info, IfStmt, LOG.info("Freeing lease");
253: Steve Loughran, info, MethodDeclaration, LOG.info("Writing " + numWrites * recordLength + " bytes to " + blobPath.getName());
275: cnauroth, debug, TryStmt, LOG.debug("close duration = " + (end - start) + " msec.");
326: cnauroth, debug, ForStmt, LOG.debug("total writes = " + (i + 1));
337: Steve Loughran, debug, MethodDeclaration, LOG.debug("Total bytes written to " + blobPath + " = " + status[0].getLen());
1661: cnauroth, info, MethodDeclaration, LOG.info("starting thread " + name);
1696: cnauroth, info, TryStmt, LOG.info(name + " before getting lease");
1699: cnauroth, info, TryStmt, LOG.info(name + " acquired lease " + lease.getLeaseID());
1706: cnauroth, info, TryStmt, LOG.info(name + " freed lease " + lease.getLeaseID());
1668: cnauroth, info, TryStmt, LOG.info(name + " acquired lease " + lease.getLeaseID());
1683: cnauroth, info, TryStmt, LOG.info(name + " freed lease " + lease.getLeaseID());
1714: cnauroth, info, MethodDeclaration, LOG.info(name + " is exiting.");
451: Steve Loughran, error, CatchClause, LOG.error("Failed to delete {}", path, e);
57: Chris Nauroth, info, CatchClause, LOG.info("Received an expected exception: " + e.getMessage());
49: Steve Loughran, debug, MethodDeclaration, LOG.debug("Scale test operation count = {}", getOperationCount());
384: Steve Loughran, warn, IfStmt, LOG.warn(message);
426: Steve Loughran, warn, CatchClause, LOG.warn("When deleting {}", path, e);
461: Steve Loughran, error, CatchClause, LOG.error("While cleaning up test account: ", e);
60: Steve Loughran, info, ForeachStmt, LOG.info("Container {} URI {}", container.getName(), container.getUri());
64: Steve Loughran, info, MethodDeclaration, LOG.info("Found {} test containers", count);
76: Steve Loughran, info, ForeachStmt, LOG.info("Container {} URI {}", container.getName(), container.getUri());
83: Steve Loughran, info, MethodDeclaration, LOG.info("Deleted {} test containers", count);
141: Steve Loughran, info, MethodDeclaration, LOG.info("Time per {}: {} nS", operation, toHuman(timer.duration() / count));
173: Steve Loughran, info, WhileStmt, LOG.info("{} = {}", next.getName(), next.getValue());
233: Steve Loughran, info, IfStmt, LOG.info(String.format("[%02d%%] Buffered %.2f MB out of %d MB;" + " elapsedTime=%.2fs; write to buffer bandwidth=%.2f MB/s", percentage, writtenMB, filesizeMB, elapsedTime, writtenMB / elapsedTime));
243: Steve Loughran, info, TryStmt, LOG.info("Closing stream {}", out);
289: Steve Loughran, info, TryStmt, LOG.info("Final stream state: {}", in);
295: Steve Loughran, info, MethodDeclaration, LOG.info("Time per positioned read = {} nS", toHuman(timer.nanosPerOperation(ops)));
333: Steve Loughran, info, TryStmt, LOG.info("Final stream state: {}", in);
338: Steve Loughran, info, MethodDeclaration, LOG.info("Time per MB to read = {} nS", toHuman(timer.nanosPerOperation(mb)));
392: Steve Loughran, warn, IfStmt, LOG.warn("0 bytes returned by read() operation #{}", reads);
384: Steve Loughran, debug, IfStmt, LOG.debug("Bytes in read #{}: {} , block bytes: {}," + " remaining in block: {}" + " duration={} nS; ns/byte: {}, bandwidth={} MB/s", reads, bytesRead, blockSize - remaining, remaining, readTimer.duration(), readTimer.nanosPerOperation(bytesRead), readTimer.bandwidthDescription(bytesRead));
397: Steve Loughran, info, ForStmt, LOG.info("Bandwidth of block {}: {} MB/s: ", blockId, bw);
399: Steve Loughran, warn, IfStmt, LOG.warn("Bandwidth {} too low on block {}: resetting connection", bw, blockId);
411: Steve Loughran, info, MethodDeclaration, LOG.info("Overall Bandwidth {} MB/s; reset connections {}", timer2.bandwidth(totalToRead), resetCount);
427: Steve Loughran, info, MethodDeclaration, LOG.info("Time per MB to rename = {} nS", toHuman(timer.nanosPerOperation(mb)));
438: Steve Loughran, info, MethodDeclaration, LOG.info("Time per MB to rename = {} nS", toHuman(timer2.nanosPerOperation(mb)));
172: Steve Loughran, info, MethodDeclaration, LOG.info("Upload rate: " + uploadRate + " bytes/second.");
182: Steve Loughran, info, MethodDeclaration, LOG.info("Upload latency: {}", uploadLatency);
219: Steve Loughran, info, MethodDeclaration, LOG.info("Download rate: " + downloadRate + " bytes/second.");
229: Steve Loughran, info, MethodDeclaration, LOG.info("Download latency: " + downloadLatency);
277: Steve Loughran, info, MethodDeclaration, LOG.info("Upload rate: " + uploadRate + " bytes/second.");
280: Steve Loughran, info, MethodDeclaration, LOG.info("Upload latency: " + uploadLatency);
303: Steve Loughran, info, MethodDeclaration, LOG.info("Download rate: " + downloadRate + " bytes/second.");
306: Steve Loughran, info, MethodDeclaration, LOG.info("Download latency: " + downloadLatency);
441: Steve Loughran, info, MethodDeclaration, LOG.info("{}  took {} web responses to complete.", opName, getCurrentWebResponses() - base);
145: John Zhuge, warn, CatchClause, LOG.warn("Got exception when getting Hadoop user name." + " Set the user name to '" + userName + "'.", e);
996: Steve Loughran, debug, MethodDeclaration, LOG.debug("Propagating entries under {}", accountPrefix);
1014: Steve Loughran, debug, ForeachStmt, LOG.debug("Updating {} from {}", generic, origin);
285: Mingliang Liu, info, MethodDeclaration, Arrays.stream(statuses).forEach(s -> LOG.info(s.getPath().toString()));
117: Todd Lipcon, info, IfStmt, LOG.info("key: " + key.toString() + " this.largestNumOfValues: " + this.largestNumOfValues);
138: Todd Lipcon, info, MethodDeclaration, LOG.info(getReport());
94: Yongjun Zhang, info, MethodDeclaration, LOG.info("Number of paths in the copy list: " + this.getNumberOfPaths());
213: Yongjun Zhang, debug, IfStmt, LOG.debug("Copy list entry " + idx + ": " + lastFileStatus.getPath().toUri().getPath());
146: Mahadev Konar, error, CatchClause, LOG.error("Invalid arguments: ", e);
144: Mingliang Liu, info, TryStmt, LOG.info("Input Options: " + context);
155: Mahadev Konar, error, CatchClause, LOG.error("Invalid input: ", e);
158: Mahadev Konar, error, CatchClause, LOG.error("Duplicate files in input path: ", e);
161: Chris Nauroth, error, CatchClause, LOG.error("ACLs not supported on at least one file system: ", e);
164: Uma Maheswara Rao G, error, CatchClause, LOG.error("XAttrs not supported on at least one file system: ", e);
167: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
217: Mahadev Konar, info, MethodDeclaration, LOG.info("DistCp job-id: " + jobID);
270: Yongjun Zhang, info, MethodDeclaration, LOG.info("Set " + DistCpConstants.CONF_LABEL_SIMPLE_LISTING_RANDOMIZE_FILES + " to false since " + DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch() + " is passed.");
350: Mahadev Konar, info, IfStmt, LOG.info("DistCp job log path: " + logPath);
414: Mahadev Konar, debug, BlockStmt, LOG.debug("Meta folder location: " + metaFolderPath);
435: Mahadev Konar, error, CatchClause, LOG.error("Couldn't complete DistCp operation: ", e);
463: Mahadev Konar, error, CatchClause, LOG.error("Unable to cleanup meta folder: " + metaFolder, e);
518: Mingliang Liu, info, MethodDeclaration, LOG.info("Enabling preserving blocksize since " + DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch() + " is passed.");
522: Mingliang Liu, info, MethodDeclaration, LOG.info("Set " + DistCpOptionSwitch.APPEND.getSwitch() + " to false since " + DistCpOptionSwitch.BLOCKS_PER_CHUNK.getSwitch() + " is passed.");
174: Jing Zhao, warn, CatchClause, DistCp.LOG.warn("Failed to use snapshot diff for distcp", e);
232: Yongjun Zhang, warn, CatchClause, DistCp.LOG.warn("Failed to compute snapshot diff on " + ssDir, e);
268: Jing Zhao, error, CatchClause, DistCp.LOG.error("Unable to cleanup tmp dir: " + tmpDir, e);
289: Yongjun Zhang, warn, CatchClause, DistCp.LOG.warn("Failed to compute snapshot diff on " + path + " at snapshot " + context.getFromSnapshot(), e);
282: Jing Zhao, warn, IfStmt, DistCp.LOG.warn("The target has been modified since snapshot " + context.getFromSnapshot());
51: Mahadev Konar, debug, IfStmt, LOG.debug("Adding option " + option.getOption());
204: Mingliang Liu, warn, IfStmt, LOG.warn(DistCpOptionSwitch.FILE_LIMIT.getSwitch() + " is a deprecated" + " option. Ignoring.");
209: Mingliang Liu, warn, IfStmt, LOG.warn(DistCpOptionSwitch.SIZE_LIMIT.getSwitch() + " is a deprecated" + " option. Ignoring.");
219: Mingliang Liu, info, TryStmt, LOG.info("Set distcp blocksPerChunk to " + csize);
75: Jing Zhao, error, CatchClause, LOG.error("Can't find filters file " + filtersFile);
77: Jing Zhao, error, CatchClause, LOG.error("An error occurred while attempting to read from " + filtersFile);
98: Chris Nauroth, debug, IfStmt, LOG.debug("numListstatusThreads=" + numListstatusThreads + ", fileStatusLimit=" + fileStatusLimit + ", randomizeFileListing=" + randomizeFileListing);
290: Yongjun Zhang, debug, IfStmt, LOG.debug("Adding source dir for traverse: " + sourceStatus.getPath());
370: Mahadev Konar, debug, IfStmt, LOG.debug("Recording source-path: " + sourceStatus.getPath() + " for copy.");
388: Ravi Prakash, debug, IfStmt, LOG.debug("Adding source dir for traverse: " + sourceStatus.getPath());
402: Ravi Prakash, info, TryStmt, LOG.info("Build file listing completed.");
433: Chris Nauroth, debug, IfStmt, LOG.debug("Adding " + fileStatusInfo.fileStatus.getPath());
439: Chris Nauroth, debug, IfStmt, LOG.debug("Number of paths written to fileListing=" + fileStatusInfoList.size());
593: Ravi Prakash, error, CatchClause, LOG.error("FileNotFoundException exception in listStatus: " + fnf.getMessage());
598: Ravi Prakash, error, CatchClause, LOG.error("Exception in listStatus. Will send for retry.");
587: Ravi Prakash, debug, CatchClause, LOG.debug("Interrupted while sleeping in exponential backoff.");
608: Ravi Prakash, info, MethodDeclaration, LOG.info("Paths (files+dirs) cnt = " + totalPaths + "; dirCnt = " + totalDirs);
632: Chris Nauroth, debug, IfStmt, LOG.debug("Starting thread pool of " + numListstatusThreads + " listStatus workers.");
685: Ravi Prakash, error, CatchClause, LOG.error("Could not get item from childQueue. Retrying...");
653: Ravi Prakash, debug, IfStmt, LOG.debug("Recording source-path: " + child.getPath() + " for copy.");
680: Ravi Prakash, error, IfStmt, LOG.error("Giving up on " + child.getPath() + " after " + retry + " retries.");
675: Ravi Prakash, debug, IfStmt, LOG.debug("Traversing into source dir: " + child.getPath());
701: Yongjun Zhang, debug, IfStmt, LOG.debug("Skip " + fs.getPath());
713: Mahadev Konar, debug, IfStmt, LOG.debug("REL PATH: " + DistCpUtils.getRelativePath(sourcePathRoot, fileStatus.getPath()) + ", FULL PATH: " + fileStatus.getPath());
152: Mahadev Konar, warn, CatchClause, LOG.warn("Unable to cleanup temp files", t);
168: Mahadev Konar, info, ForeachStmt, LOG.info("Cleaning up " + file.getPath());
186: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", ignore);
183: Mahadev Konar, info, TryStmt, LOG.info("Cleaning up temporary work folder: " + metaFolder);
210: Yongjun Zhang, info, MethodDeclaration, LOG.info("concat file chunks ...");
237: Yongjun Zhang, debug, IfStmt, LOG.debug("  add " + targetFileChunkPath + " to concat.");
278: Yongjun Zhang, warn, IfStmt, LOG.warn(emsg + ", skipping concat this set.");
256: Yongjun Zhang, warn, IfStmt, LOG.warn(emsg, e);
299: Mahadev Konar, info, MethodDeclaration, LOG.info("About to preserve attributes: " + attrSymbols);
341: Mahadev Konar, info, MethodDeclaration, LOG.info("Preserved status on " + preservedEntries + " dir entries on target");
360: Steve Loughran, info, MethodDeclaration, LOG.info("Tracking file changes to directory {}", trackDir);
365: Steve Loughran, info, MethodDeclaration, LOG.info("Source listing {}", sourceSortedListing);
375: Steve Loughran, info, MethodDeclaration, LOG.info("Target listing {}", sortedTargetListing);
387: Mahadev Konar, info, MethodDeclaration, LOG.info("-delete option is enabled. About to remove entries from " + "target that are missing in source");
412: Steve Loughran, info, MethodDeclaration, LOG.info("Listing completed in {}", formatDuration(deletionStart - listingStart));
438: Steve Loughran, debug, WhileStmt, LOG.debug("Comparing {} and {}", srcFileStatus.getPath(), targetEntry);
478: Steve Loughran, debug, IfStmt, LOG.debug("Skipping deletion of {}", targetEntry);
470: Steve Loughran, info, IfStmt, LOG.info("Failed to delete {}, ignoring exception {}", targetEntry, e.toString());
472: Steve Loughran, debug, IfStmt, LOG.debug("Failed to delete {}", targetEntry, e);
449: Steve Loughran, info, IfStmt, LOG.info("Deleted " + targetEntry + " - missing at source");
490: Steve Loughran, info, TryStmt, LOG.info("Completed deletion of files from {}", targetFS);
497: Steve Loughran, info, MethodDeclaration, LOG.info("Deleted from target: files: {} directories: {};" + " skipped deletions {}; deletions already missing {};" + " failed deletes {}", deletedFileCount, deletedDirectories, skippedDeletes, missingDeletes, failedDeletes);
502: Steve Loughran, info, MethodDeclaration, LOG.info("Number of tracked deleted directories {}", tracker.size());
503: Steve Loughran, info, MethodDeclaration, LOG.info("Duration of deletions: {}", formatDuration(deletionEnd - deletionStart));
505: Steve Loughran, info, MethodDeclaration, LOG.info("Total duration of deletion operation: {}", formatDuration(deletionEnd - listingStart));
566: Mahadev Konar, info, MethodDeclaration, LOG.info("Atomic commit enabled. Moving " + workDir + " to " + finalDir);
568: Mahadev Konar, error, IfStmt, LOG.error("Pre-existing final-path found at: " + finalDir);
575: Mahadev Konar, warn, IfStmt, LOG.warn("Rename failed. Perhaps data already moved. Verifying...");
582: Mahadev Konar, error, IfStmt, LOG.error("Unable to commit data to " + finalDir);
579: Mahadev Konar, info, IfStmt, LOG.info("Data committed successfully to " + finalDir);
597: Yongjun Zhang, debug, IfStmt, LOG.debug("concat " + targetFile + " allChunkSize+ " + allChunkPaths.size());
606: Yongjun Zhang, debug, IfStmt, LOG.debug("concat: firstchunk: " + dstfs.getFileStatus(firstChunkFile));
609: Yongjun Zhang, debug, ForeachStmt, LOG.debug("concat: other chunk: " + i + ": " + dstfs.getFileStatus(f));
615: Yongjun Zhang, debug, IfStmt, LOG.debug("concat: result: " + dstfs.getFileStatus(firstChunkFile));
141: Mahadev Konar, debug, BlockStmt, LOG.debug("DistCpMapper::map(): Received " + sourcePath + ", " + relPath);
154: Mahadev Konar, info, MethodDeclaration, LOG.info(description);
179: Mahadev Konar, debug, BlockStmt, LOG.debug("Path could not be found: " + target, ignore);
215: Yongjun Zhang, debug, IfStmt, LOG.debug("copying " + sourceCurrStatus + " " + tmpTarget);
198: Mahadev Konar, info, IfStmt, LOG.info("Skipping copy of " + sourceCurrStatus.getPath() + " to " + target);
296: Yongjun Zhang, error, MethodDeclaration, LOG.error("Failure in copying " + sourceFileStatus.getPath() + (sourceFileStatus.isSplit() ? "," + " offset=" + sourceFileStatus.getChunkOffset() + " chunkLength=" + sourceFileStatus.getChunkLength() : "") + " to " + target, exception);
112: Chris Douglas, debug, IfStmt, LOG.debug("Copying " + source.getPath() + " to " + target);
113: Jing Zhao, debug, IfStmt, LOG.debug("Target file path: " + targetPath);
260: Mahadev Konar, info, MethodDeclaration, LOG.info("Creating temp file: " + new Path(root, ".distcp.tmp." + context.getTaskAttemptID().toString()));
93: Mahadev Konar, debug, IfStmt, LOG.debug("Average bytes per map: " + nBytesPerSplit + ", Number of maps: " + numSplits + ", total size: " + totalSizeBytes);
107: Mahadev Konar, debug, IfStmt, LOG.debug("Creating split : " + split + ", bytes in split: " + currentSplitSize);
120: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Creating split : " + split + ", bytes in split: " + currentSplitSize);
155: Mahadev Konar, error, CatchClause, LOG.error("Couldn't find listing file at: " + listingFilePath, exception);
92: Mahadev Konar, warn, IfStmt, LOG.warn(chunkFilePath + " could not be assigned to " + taskId);
123: Mahadev Konar, error, IfStmt, LOG.error("Unable to release chunk at path: " + chunkFilePath);
88: Kihwal Lee, info, IfStmt, LOG.info("Acquiring pre-assigned chunk: " + acquiredFilePath);
94: Kihwal Lee, info, IfStmt, LOG.info(taskId + " acquired " + chunkFile.getPath());
74: Mahadev Konar, info, MethodDeclaration, LOG.info("DynamicInputFormat: Getting splits for job:" + jobContext.getJobID());
178: Mahadev Konar, info, MethodDeclaration, LOG.info("Number of dynamic-chunk-files created: " + chunksFinal.size());
259: Tsz-wo Sze, warn, IfStmt, LOG.warn(DistCpConstants.CONF_LABEL_MAX_CHUNKS_TOLERABLE + " should be positive. Fall back to default value: " + DistCpConstants.MAX_CHUNKS_TOLERABLE_DEFAULT);
272: Tsz-wo Sze, warn, IfStmt, LOG.warn(DistCpConstants.CONF_LABEL_MAX_CHUNKS_IDEAL + " should be positive. Fall back to default value: " + DistCpConstants.MAX_CHUNKS_IDEAL_DEFAULT);
285: Tsz-wo Sze, warn, IfStmt, LOG.warn(DistCpConstants.CONF_LABEL_MIN_RECORDS_PER_CHUNK + " should be positive. Fall back to default value: " + DistCpConstants.MIN_RECORDS_PER_CHUNK_DEFAULT);
298: Tsz-wo Sze, warn, IfStmt, LOG.warn(DistCpConstants.CONF_LABEL_SPLIT_RATIO + " should be positive. Fall back to default value: " + DistCpConstants.SPLIT_RATIO_DEFAULT);
329: Mahadev Konar, warn, IfStmt, LOG.warn("nMaps == 1. Why use DynamicInputFormat?");
105: Mahadev Konar, debug, BlockStmt, LOG.debug(taskId + ": RecordReader is null. No records to be read.");
115: Mahadev Konar, debug, BlockStmt, LOG.debug(taskId + ": Current chunk exhausted. " + " Attempting to pick up new one.");
71: Mahadev Konar, debug, BlockStmt, LOG.debug("Retrieving file size for: " + path);
335: Yongjun Zhang, debug, IfStmt, LOG.debug("toCopyListing: " + fileStatus + " chunkSize: " + blocksPerChunk + " isDFS: " + (fileSystem instanceof DistributedFileSystem));
375: Yongjun Zhang, debug, IfStmt, LOG.debug("  add file/dir " + clfs);
366: Yongjun Zhang, debug, IfStmt, LOG.debug("  add file chunk " + clfs1);
351: Yongjun Zhang, debug, IfStmt, LOG.debug("  add file " + clfs);
579: Mahadev Konar, error, CatchClause, LOG.error("Unable to retrieve checksum for " + source + " or " + target, e);
74: Yongjun Zhang, warn, IfStmt, LOG.warn("Shutdown() is called but there are still unprocessed work!");
115: Ravi Prakash, error, CatchClause, LOG.error("Could not put workRequest into inputQueue. Retrying...");
146: Ravi Prakash, debug, CatchClause, LOG.debug("Retrying in blockingTake...");
194: Yongjun Zhang, debug, CatchClause, LOG.debug("Worker thread was interrupted while processing an item," + " or putting into outputQueue. Retrying...");
89: Mahadev Konar, error, CatchClause, LOG.error("Failure in Retriable command: " + description, exception);
133: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
162: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered in test", e);
219: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
296: Chris Nauroth, debug, IfStmt, LOG.debug("val=" + fs.makeQualified(srcFiles.get(idx)));
342: Mahadev Konar, error, CatchClause, LOG.error("Unexpected exception: ", e);
214: Yongjun Zhang, info, MethodDeclaration, LOG.info("Comparing " + srcStat + " and " + dstStat);
253: Yongjun Zhang, info, IfStmt, LOG.info("______ compared src and dst files for " + totalComparedBytes + " bytes, content match.");
278: Yongjun Zhang, info, WhileStmt, LOG.info("______ compared src and dst files for " + totalComparedBytes + " bytes, content match. FileLength: " + srcStat.getLen());
282: Yongjun Zhang, info, IfStmt, LOG.info("______ Final:" + srcIdx + " " + srcBytesRead + " " + tgtIdx + " " + tgtBytesRead);
325: Yongjun Zhang, info, MethodDeclaration, LOG.info("ls before distcp");
326: Yongjun Zhang, info, MethodDeclaration, LOG.info(execCmd(shell, "-lsr", testRoot));
328: Yongjun Zhang, info, MethodDeclaration, LOG.info("_____ running distcp: " + args[0] + " " + args[1]);
331: Yongjun Zhang, info, MethodDeclaration, LOG.info("ls after distcp");
332: Yongjun Zhang, info, MethodDeclaration, LOG.info(execCmd(shell, "-lsr", testRoot));
372: Yongjun Zhang, info, MethodDeclaration, LOG.info("Modify a file and copy again");
375: Yongjun Zhang, info, IfStmt, LOG.info("Modifying " + srcStats[i].getPath());
456: Yongjun Zhang, info, MethodDeclaration, LOG.info("_____ running distcp: " + args[0] + " " + args[1]);
71: Robert Joseph Evans, error, CatchClause, LOG.error("Exception encountered ", e);
424: Robert Joseph Evans, error, CatchClause, LOG.error("Exception encountered ", e);
64: Robert Joseph Evans, error, CatchClause, LOG.error("Exception encountered ", e);
118: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
144: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
171: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
197: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
219: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
241: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
268: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
294: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
316: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
338: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
365: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
392: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
421: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
446: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
471: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing build listing", e);
84: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
104: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
127: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
151: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
174: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
193: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
212: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
236: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
259: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
278: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
297: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
317: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
336: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
355: Thomas White, error, CatchClause, LOG.error("Exception encountered while running distcp", e);
387: Thomas White, error, CatchClause, LOG.error("Exception encountered while running distcp", e);
410: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing distcp", e);
432: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while running distcp", e);
456: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while running distcp", e);
480: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while running distcp", e);
510: Thomas White, error, CatchClause, LOG.error("Exception encountered ", e);
573: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
279: Steve Loughran, info, MethodDeclaration, LOG.info("Source directory = {}, dest={}", srcDir, destDir);
410: Steve Loughran, info, WhileStmt, LOG.info("{}: {}", key, path);
416: Steve Loughran, info, WhileStmt, LOG.info("{}: {}", key, path);
437: Steve Loughran, info, MethodDeclaration, LOG.info("{}: {}:", description, dir);
446: Steve Loughran, info, MethodDeclaration, LOG.info("{}", sb);
526: Steve Loughran, info, MethodDeclaration, getLog().info("{} with file size {}", testName.getMethodName(), fileSizeMb);
335: Mahadev Konar, info, CatchClause, LOG.info("Atomic-commit Test pass.");
114: Mahadev Konar, debug, MethodDeclaration, LOG.debug("fs.default.name  == " + configuration.get("fs.default.name"));
115: Mahadev Konar, debug, MethodDeclaration, LOG.debug("dfs.http.address == " + configuration.get("dfs.http.address"));
508: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
582: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
532: Chris Nauroth, error, CatchClause, LOG.error("Exception encountered ", e);
556: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
648: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
606: Chris Nauroth, error, CatchClause, LOG.error("Exception encountered ", e);
625: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
727: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
670: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
700: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
813: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
749: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
781: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
842: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
968: Jing Zhao, error, CatchClause, LOG.error("Unexpected exception encountered. ", e);
916: Jing Zhao, error, CatchClause, LOG.error("Exception encountered when get stub context", e);
938: Jing Zhao, error, CatchClause, LOG.error("Exception encountered when get FileSystem.", e);
956: Jing Zhao, error, CatchClause, LOG.error("Unexpected exception encountered. ", e);
961: Jing Zhao, error, CatchClause, LOG.error("Exception encountered when the mapper copies file.", e);
52: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while running test", e);
72: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while running test", e);
85: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
128: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing checkoutput specs", e);
131: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered while testing checkoutput specs", e);
73: Steve Loughran, info, MethodDeclaration, LOG.info(tracker.toString());
160: Steve Loughran, info, IfStmt, LOG.info("Delete {}", status.getPath());
164: Steve Loughran, info, MethodDeclaration, LOG.info("After proposing to delete {} paths, {} directories and {} files" + " were explicitly deleted from a cache {}", statusList.size(), deletedDirs, deletedFiles, tracker);
75: Mahadev Konar, debug, MethodDeclaration, LOG.debug("fs.default.name  == " + configuration.get("fs.default.name"));
76: Mahadev Konar, debug, MethodDeclaration, LOG.debug("dfs.http.address == " + configuration.get("dfs.http.address"));
1167: Mahadev Konar, warn, CatchClause, LOG.warn("Exception encountered ", e);
1187: Allen Wittenauer, warn, IfStmt, LOG.warn("Could not create directory " + dirPath + " this might cause test failures.");
66: Mahadev Konar, error, CatchClause, LOG.error("Exception encountered ", e);
92: Mahadev Konar, info, TryStmt, LOG.info(in);
258: Todd Lipcon, info, MethodDeclaration, LOG.info("numSplits=" + numSplits + ", splits.size()=" + splits.size());
303: Todd Lipcon, info, CatchClause, LOG.info(s);
402: Todd Lipcon, error, CatchClause, LOG.error("Input error:", e);
405: Todd Lipcon, error, CatchClause, LOG.error(NAME + " failed: ", e);
373: Todd Lipcon, info, TryStmt, LOG.info("ops=" + ops);
374: Todd Lipcon, info, TryStmt, LOG.info("isIgnoreFailures=" + isIgnoreFailures);
435: Todd Lipcon, info, MethodDeclaration, LOG.info(JOB_DIR_LABEL + "=" + jobdir);
441: Todd Lipcon, info, MethodDeclaration, LOG.info("log=" + log);
480: Todd Lipcon, info, MethodDeclaration, LOG.info(OP_COUNT_LABEL + "=" + opCount);
140: Virajith Jalaparti, warn, CatchClause, LOG.warn("Exact path handle not supported by filesystem " + fs.toString());
141: Virajith Jalaparti, info, IfStmt, LOG.info("Creating directory: " + imageDir);
156: Virajith Jalaparti, info, TryStmt, LOG.info("Creating " + newFile.toString());
250: Virajith Jalaparti, info, MethodDeclaration, LOG.info("providedPath: " + providedPath);
373: Virajith Jalaparti, info, ForeachStmt, LOG.info("path: " + hp.toUri().getPath());
415: Virajith Jalaparti, info, ForeachStmt, LOG.info("path: " + hp.toUri().getPath());
531: Virajith Jalaparti, info, MethodDeclaration, LOG.info("Setting replication of file {} to {}", filename, newReplication);
541: Virajith Jalaparti, info, MethodDeclaration, LOG.info("Setting replication of file {} back to {}", filename, newReplication);
917: Virajith Jalaparti, info, ForeachStmt, LOG.info("Using policy: " + packageName + "." + policy);
62: Amar Kamat, Error, CatchClause, LOG.info("Error in processing cluster status at " + FastDateFormat.getInstance().format(time));
163: Todd Lipcon, Error, CatchClause, LOG.error("Error while adding input path ", e);
279: Todd Lipcon, info, IfStmt, LOG.info("GridMix is configured to generate compressed input data with " + " a compression ratio of " + ratio);
339: Todd Lipcon, info, MethodDeclaration, LOG.info("Gridmix is configured to use compressed input data.");
341: Todd Lipcon, info, MethodDeclaration, LOG.info("Total size of compressed input data : " + StringUtils.humanReadableInt(compressedDataSize));
343: Todd Lipcon, info, MethodDeclaration, LOG.info("Total number of compressed input data files : " + numCompressedFiles);
362: Todd Lipcon, info, IfStmt, LOG.info("Input Data Compression Ratio : " + ratio);
196: Todd Lipcon, warn, IfStmt, LOG.warn("Gridmix will not emulate Distributed Cache load " + "because the ascendant directory (of distributed cache " + "directory) " + cur + " doesn't have execute permission " + "for others.");
183: Todd Lipcon, warn, IfStmt, LOG.warn("Gridmix will not emulate Distributed Cache load because " + "<iopath> provided is on local file system.");
178: Todd Lipcon, warn, IfStmt, LOG.warn("Gridmix will not emulate Distributed Cache load because " + "the input trace source is a stream instead of file.");
213: Todd Lipcon, warn, CatchClause, LOG.warn("Gridmix will not emulate Distributed Cache load because " + "creation of pseudo local file system failed.");
463: Todd Lipcon, info, MethodDeclaration, LOG.info("Number of HDFS based distributed cache files to be generated is " + fileCount + ". Total size of HDFS based distributed cache files " + "to be generated is " + byteCount);
468: Todd Lipcon, error, IfStmt, LOG.error("Missing " + fileCount + " distributed cache files under the " + " directory\n" + distCachePath + "\nthat are needed for gridmix" + " to emulate distributed cache load. Either use -generate\noption" + " to generate distributed cache data along with input data OR " + "disable\ndistributed cache emulation by configuring '" + DistributedCacheEmulator.GRIDMIX_EMULATE_DISTRIBUTEDCACHE + "' to false.");
35: Todd Lipcon, info, ConstructorDeclaration, LOG.info(" Current user resolver is EchoUserResolver ");
228: Todd Lipcon, debug, ConstructorDeclaration, LOG.debug(size + " bytes in " + thisDir.getPath());
162: Todd Lipcon, info, MethodDeclaration, LOG.info("Total size of input data : " + StringUtils.humanReadableInt(dataSize));
164: Todd Lipcon, info, MethodDeclaration, LOG.info("Total number of input data files : " + fileCount);
198: Todd Lipcon, Error, CatchClause, LOG.error("Error while adding input path ", e);
122: Todd Lipcon, Error, CatchClause, LOG.error("Error while adding input path ", e);
187: Steve Loughran, error, IfStmt, LOG.error("Gridmix input data directory {} already exists " + "when -generate option is used.", inputDir);
196: Steve Loughran, info, IfStmt, LOG.info("Generating {} of test data...", StringUtils.TraditionalBinaryPrefix.long2String(genbytes, "", 1));
205: Ravi Gummadi, error, CatchClause, LOG.error("Couldnt change the file permissions ", e);
202: Steve Loughran, info, TryStmt, LOG.info("Changing the permissions for inputPath {}", inputDir);
209: Ravi Gummadi, info, IfStmt, LOG.info("Input data generation successful.");
227: Todd Lipcon, info, IfStmt, LOG.info("Generating distributed cache data of size " + conf.getLong(GenerateDistCacheData.GRIDMIX_DISTCACHE_BYTE_COUNT, -1));
330: Todd Lipcon, error, CatchClause, LOG.error(" Exception at start ", e);
298: Todd Lipcon, info, TryStmt, LOG.info(" Submission policy is " + policy.name());
391: Ravi Gummadi, error, IfStmt, LOG.error("Too few arguments to Gridmix.\n");
439: Ravi Gummadi, error, CatchClause, LOG.error(e.toString() + "\n");
415: Ravi Gummadi, error, IfStmt, LOG.error("Unknown option " + argv[i] + " specified.\n");
408: Ravi Gummadi, error, IfStmt, LOG.error("size of input data to be generated specified using " + "-generate option should be nonnegative.\n");
433: Todd Lipcon, warn, IfStmt, LOG.warn("Ignoring the user resource '" + userRsrc + "'.");
427: Ravi Gummadi, error, IfStmt, LOG.error(userResolver.getClass() + " needs target user list. Use -users option.\n");
424: Todd Lipcon, warn, IfStmt, LOG.warn("Ignoring the user resource '" + userRsrc + "'.");
459: Ravi Gummadi, error, IfStmt, LOG.error("Failed creation of <ioPath> directory " + ioPath + "\n");
530: Ravi Gummadi, error, CatchClause, LOG.error("Startup failed. " + e.toString() + "\n");
531: Steve Loughran, debug, CatchClause, LOG.debug("Startup failed", e);
543: Todd Lipcon, Error, IfStmt, LOG.error("Error in trace", badTraceException);
644: Todd Lipcon, warn, CatchClause, LOG.warn("Interrupted waiting for " + component);
651: Todd Lipcon, info, MethodDeclaration, LOG.info("Exiting...");
665: Todd Lipcon, info, TryStmt, LOG.info("Killing running jobs...");
680: Todd Lipcon, warn, CatchClause, LOG.warn("Failure killing " + job.getJobName(), e);
682: Allen Wittenauer, error, CatchClause, LOG.error("Unexpected exception", e);
671: Todd Lipcon, info, IfStmt, LOG.info("Killed " + job.getJobName() + " (" + job.getJobID() + ")");
685: Todd Lipcon, info, TryStmt, LOG.info("Done.");
250: Todd Lipcon, debug, IfStmt, LOG.debug("For the job configuration parameter '" + jobValueKey + "' and the cluster configuration parameter '" + clusterValueKey + "', the original job's configuration value" + " is scaled from '" + originalJobValue + "' to '" + simulatedJobValue + "' using the default (unit) value of " + "'" + originalClusterDefaultValue + "' for the original " + " cluster and '" + simulatedClusterDefaultValue + "' for the" + " simulated cluster.");
59: Todd Lipcon, warn, IfStmt, LOG.warn("Using " + inputBytes + "/" + mapBytes + " bytes");
108: Todd Lipcon, debug, IfStmt, LOG.debug(" The submission thread name is " + rThread.getName());
210: Amar Kamat, debug, IfStmt, LOG.debug("Ignoring job " + job.getJobID() + " from the input trace." + " Reason: " + StringUtils.join(reason, ","));
100: Amar Kamat, info, MethodDeclaration, LOG.info("Job submission failed notification for job " + jobID);
110: Todd Lipcon, info, MethodDeclaration, LOG.info(job.getJobName() + " (" + job.getJobID() + ")" + " success");
117: Todd Lipcon, info, MethodDeclaration, LOG.info(job.getJobName() + " (" + job.getJobID() + ")" + " failure");
245: Todd Lipcon, warn, CatchClause, LOG.warn("Unexpected exception: ", e);
223: Todd Lipcon, warn, IfStmt, LOG.warn("Lost job " + (null == job.getJobName() ? "<unknown>" : job.getJobName()), e);
187: Amar Kamat, debug, IfStmt, LOG.debug("Status polling for job " + job.getJobID() + " took " + (end - start) + "ms.");
156: Amar Kamat, info, CatchClause, LOG.info(" Job " + job.getJob().getJobID() + " submission failed ", e);
96: Todd Lipcon, warn, CatchClause, LOG.warn("Failed to submit " + job.getJob().getJobName() + " as " + job.getUgi(), e);
101: Todd Lipcon, warn, CatchClause, LOG.warn("Failed to submit " + job.getJob().getJobName() + " as " + job.getUgi(), e);
93: Amar Kamat, info, TryStmt, LOG.info("[JobSubmitter] Time taken to build splits for job " + job.getJob().getJobID() + ": " + (end - start) + " ms.");
137: Todd Lipcon, warn, CatchClause, LOG.warn("Failed to submit " + job.getJob().getJobName() + " as " + job.getUgi(), e);
145: Todd Lipcon, warn, CatchClause, LOG.warn("Failed to submit " + job.getJob().getJobName(), e);
117: Amar Kamat, info, TryStmt, LOG.info("[JobSubmitter] Time taken to submit the job " + job.getJob().getJobID() + ": " + (end - start) + " ms.");
131: Amar Kamat, debug, IfStmt, LOG.debug("Original job '" + jobID + "' is being simulated as '" + job.getJob().getJobID() + "'");
133: Amar Kamat, debug, IfStmt, LOG.debug("SUBMIT " + job + "@" + System.currentTimeMillis() + " (" + job.getJob().getJobID() + ")");
171: Amar Kamat, info, IfStmt, LOG.info("Total number of queued jobs: " + (queueDepth - sem.availablePermits()));
203: Amar Kamat, info, MethodDeclaration, LOG.info("Resource usage matcher thread started.");
219: Amar Kamat, info, CatchClause, LOG.info("Exception while running the resource-usage-emulation matcher" + " thread! Exiting.", e);
217: Amar Kamat, info, TryStmt, LOG.info("Resource usage emulation complete! Matcher exiting");
248: Amar Kamat, info, MethodDeclaration, LOG.info("Status reporter thread started.");
262: Amar Kamat, info, CatchClause, LOG.info("Exception while running the status reporter thread!", e);
260: Amar Kamat, info, TryStmt, LOG.info("Status reporter thread exiting");
344: Amar Kamat, info, IfStmt, LOG.info("GridMix is configured to use a compression ratio of " + compressionRatio + " for the job output data.");
302: Amar Kamat, info, IfStmt, LOG.info("GridMix is configured to use a compression ratio of " + compressionRatio + " for the map output data.");
396: Amar Kamat, Error, CatchClause, LOG.debug("Error in resource usage emulation! Message: ", e);
404: Amar Kamat, info, MethodDeclaration, LOG.info("Starting the cleanup phase.");
418: Amar Kamat, Error, CatchClause, LOG.debug("Error in resource usage emulation! Message: ", e);
428: Amar Kamat, info, IfStmt, LOG.info("Boosting the map phase progress.");
473: Todd Lipcon, info, IfStmt, LOG.info("Spec output bytes w/o records. Using input record count");
484: Todd Lipcon, info, IfStmt, LOG.info("GridMix is configured to use a compression ratio of " + compressionRatio + " for the reduce output data.");
519: Amar Kamat, Error, CatchClause, LOG.debug("Error in resource usage emulation! Message: ", e);
536: Amar Kamat, Error, CatchClause, LOG.debug("Error in resource usage emulation! Message: ", e);
638: Amar Kamat, debug, IfStmt, LOG.debug(String.format("SPEC(%d) %d -> %d %d %d %d %d %d %d", id(), i, i + j * maps, info.getOutputRecords(), info.getOutputBytes(), info.getResourceUsageMetrics().getCumulativeCpuUsage(), info.getResourceUsageMetrics().getPhysicalMemoryUsage(), info.getResourceUsageMetrics().getVirtualMemoryUsage(), info.getResourceUsageMetrics().getHeapUsage()));
108: Todd Lipcon, debug, IfStmt, LOG.debug("Random text data generator is configured to use a dictionary " + " with " + listSize + " words");
127: Todd Lipcon, debug, IfStmt, LOG.debug("Random text data generator is configured to use a dictionary " + " with words of length " + wordSize);
82: Todd Lipcon, info, TryStmt, LOG.info("START REPLAY @ " + initTime);
96: Todd Lipcon, warn, IfStmt, LOG.warn("Job " + job.getJobID() + " out of order");
88: Todd Lipcon, Error, CatchClause, LOG.error("Error while creating a proxy user ", ioe);
87: Todd Lipcon, info, TryStmt, LOG.info("START SERIAL @ " + System.currentTimeMillis());
97: Todd Lipcon, debug, IfStmt, LOG.debug("Serial mode submitting job " + job.getName());
108: Todd Lipcon, info, TryStmt, LOG.info(" Submitted the job " + prevJob);
127: Todd Lipcon, error, CatchClause, LOG.error(" Error in SerialJobFactory while waiting for job completion ", ie);
133: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug(" job " + job.getName() + " completed ");
175: Todd Lipcon, info, MethodDeclaration, LOG.info(" Starting Serial submission ");
204: Todd Lipcon, info, MethodDeclaration, LOG.info(msg);
267: Todd Lipcon, info, MethodDeclaration, LOG.info(msg);
368: Todd Lipcon, warn, IfStmt, LOG.warn("No sucessful attempts tasktype " + type + " task " + task);
390: Todd Lipcon, debug, IfStmt, LOG.debug(String.format("SPEC(%d) %d -> %d %d/%d", id(), i, i + j * maps, redDurations[j], info.getRuntime()));
145: Amar Kamat, info, IfStmt, LOG.info("Not tracking job " + stats.getJob().getJobName() + " as seq id is less than zero: " + seq);
169: Amar Kamat, error, IfStmt, LOG.error("[Statistics] Missing entry for job " + job.getJob().getJobID());
182: Todd Lipcon, debug, IfStmt, LOG.debug(" Reached maximum limit of jobs in a polling interval " + completedJobsInCurrentInterval);
232: Todd Lipcon, error, CatchClause, LOG.error("Statistics Error while waiting for other threads to get ready ", ie);
242: Todd Lipcon, error, IfStmt, LOG.error("Statistics interrupt while waiting for completion of " + "a job.", ie);
257: Todd Lipcon, error, CatchClause, LOG.error("Statistics io exception while polling JT ", e);
247: Amar Kamat, error, CatchClause, LOG.error("[STRESS] Interrupted in the main block!", e);
159: Amar Kamat, warn, IfStmt, LOG.warn("[STRESS] Interrupted before start!. Exiting..");
162: Todd Lipcon, info, TryStmt, LOG.info("START STRESS @ " + System.currentTimeMillis());
168: Amar Kamat, debug, IfStmt, LOG.debug("Updating the overload status.");
173: Amar Kamat, warn, CatchClause, LOG.warn("[STRESS] Check failed!", ioe);
180: Amar Kamat, debug, IfStmt, LOG.debug("[STRESS] Cluster overloaded in run! Sleeping...");
187: Amar Kamat, warn, CatchClause, LOG.warn("[STRESS] Interrupted while sleeping! Exiting.", ie);
195: Amar Kamat, debug, IfStmt, LOG.debug("[STRESS] Cluster underloaded in run! Stressing...");
236: Amar Kamat, error, CatchClause, LOG.error("[STRESS] Error while submitting the job ", e);
201: Amar Kamat, warn, IfStmt, LOG.warn("[STRESS] Finished consuming the input trace. " + "Exiting..");
206: Amar Kamat, debug, IfStmt, LOG.debug("Job Selected: " + job.getJobID());
275: Amar Kamat, error, CatchClause, LOG.error("Couldn't get the new Status", e);
307: Amar Kamat, debug, IfStmt, LOG.debug(System.currentTimeMillis() + " [JobLoad] Overloaded is " + Boolean.TRUE.toString() + " NumJobsBackfill is " + loadStatus.getJobLoad());
334: Amar Kamat, debug, IfStmt, LOG.debug("Total submitted map tasks: " + totalMapTasks);
335: Amar Kamat, debug, IfStmt, LOG.debug("Total submitted reduce tasks: " + totalReduceTasks);
336: Amar Kamat, debug, IfStmt, LOG.debug("Max map load: " + maxMapLoad);
337: Amar Kamat, debug, IfStmt, LOG.debug("Max reduce load: " + maxReduceLoad);
365: Amar Kamat, warn, IfStmt, LOG.warn("Ignoring blacklisted job: " + id);
429: Amar Kamat, warn, IfStmt, LOG.warn("Blacklisting empty job: " + id);
381: Amar Kamat, warn, IfStmt, LOG.warn("Blacklisting completed job: " + id);
405: Amar Kamat, debug, IfStmt, LOG.debug("Terminating overload check due to high map load.");
424: Amar Kamat, debug, IfStmt, LOG.debug("Terminating overload check due to high reduce load.");
444: Amar Kamat, debug, IfStmt, LOG.debug("Blacklisted jobs count: " + blacklistedJobs.size());
454: Amar Kamat, debug, IfStmt, LOG.debug(System.currentTimeMillis() + " [MAP-LOAD] Overloaded is " + Boolean.TRUE.toString() + " MapSlotsBackfill is " + loadStatus.getMapLoad());
463: Amar Kamat, debug, IfStmt, LOG.debug(System.currentTimeMillis() + " [REDUCE-LOAD] Overloaded is " + Boolean.TRUE.toString() + " ReduceSlotsBackfill is " + loadStatus.getReduceLoad());
471: Amar Kamat, debug, IfStmt, LOG.debug(System.currentTimeMillis() + " [OVERALL] Overloaded is " + Boolean.FALSE.toString() + "Current load Status is " + loadStatus);
606: Todd Lipcon, info, MethodDeclaration, LOG.info(" Starting Stress submission ");
36: Todd Lipcon, info, ConstructorDeclaration, LOG.info(" Current user resolver is SubmitterUserResolver ");
107: Thomas Graves, info, MethodDeclaration, LOG.info(" Job Success " + job);
233: Thomas Graves, info, SwitchStmt, LOG.info(String.format(type + " SPEC: %9d -> %9d :: %5d -> %5d\n", specInputBytes[i], specOutputBytes[i], specInputRecords[i], specOutputRecords[i]));
236: Thomas Graves, info, SwitchStmt, LOG.info(String.format(type + " RUN:  %9d -> %9d :: %5d -> %5d\n", runInputBytes[i], runOutputBytes[i], runInputRecords[i], runOutputRecords[i]));
259: Thomas Graves, info, SwitchStmt, LOG.info(String.format(type + " SPEC: (%9d) -> %9d :: %5d -> %5d\n", specInfo.getInputBytes(), specOutputBytes[i], specInputRecords[i], specOutputRecords[i]));
262: Thomas Graves, info, SwitchStmt, LOG.info(String.format(type + " RUN:  (%9d) -> %9d :: %5d -> %5d\n", counters.findCounter(TaskCounter.REDUCE_SHUFFLE_BYTES).getValue(), runOutputBytes[i], runInputRecords[i], runOutputRecords[i]));
125: Suresh Srinivas, info, MethodDeclaration, LOG.info("DIST: " + Arrays.toString(recs) + " " + tot_recs + "/" + totalrecs + " " + Arrays.toString(bytes) + " " + tot_bytes + "/" + totalbytes);
150: Todd Lipcon, info, ConstructorDeclaration, LOG.info(name + " (" + seed + ")");
196: Todd Lipcon, debug, IfStmt, LOG.debug(String.format("%s: M (%03d) %6d/%10d -> %6d/%10d" + " R (%03d) %6d/%10d -> %6d/%10d @%d", name, m_bytesIn.length, iMapRTotal, iMapBTotal, oMapRTotal, oMapBTotal, r_bytesIn.length, iRedRTotal, iRedBTotal, oRedRTotal, oRedBTotal, submitTime));
99: Thomas Graves, info, IfStmt, LOG.info("Creating Home directory : " + homeDirectory);
108: Thomas Graves, info, TryStmt, LOG.info("Creating Staging root directory : " + stagingArea);
67: Todd Lipcon, info, MethodDeclaration, LOG.info("seed: " + seed);
857: Thomas Graves, info, MethodDeclaration, LOG.info("start:" + start);
862: Thomas Graves, info, MethodDeclaration, LOG.info("finish:" + System.currentTimeMillis());
42: Todd Lipcon, info, MethodDeclaration, LOG.info("length: " + seed);
71: Todd Lipcon, info, MethodDeclaration, LOG.info("randReplay: " + seed);
102: Todd Lipcon, info, MethodDeclaration, LOG.info("eqSeed: " + s);
127: Todd Lipcon, info, MethodDeclaration, LOG.info("sort: " + s);
165: Todd Lipcon, info, MethodDeclaration, LOG.info("spec: " + s);
134: Thomas Graves, info, TryStmt, LOG.info("Verifying JobStory from compressed trace...");
139: Thomas Graves, info, TryStmt, LOG.info("Verifying JobStory from uncompressed trace...");
144: Thomas Graves, info, TryStmt, LOG.info("Verifying JobStory from trace in standard input...");
159: Thomas Graves, info, MethodDeclaration, LOG.info(" Replay started at " + System.currentTimeMillis());
161: Thomas Graves, info, MethodDeclaration, LOG.info(" Replay ended at " + System.currentTimeMillis());
168: Thomas Graves, info, MethodDeclaration, LOG.info(" Stress started at " + System.currentTimeMillis());
170: Thomas Graves, info, MethodDeclaration, LOG.info(" Stress ended at " + System.currentTimeMillis());
63: Thomas Graves, info, MethodDeclaration, LOG.info("Serial started at " + System.currentTimeMillis());
66: Thomas Graves, info, MethodDeclaration, LOG.info("Serial ended at " + System.currentTimeMillis());
75: Thomas Graves, info, MethodDeclaration, LOG.info(" Replay started at " + System.currentTimeMillis());
78: Thomas Graves, info, MethodDeclaration, LOG.info(" Replay ended at " + System.currentTimeMillis());
39: Todd Lipcon, info, MethodDeclaration, LOG.info("Target bytes/records: " + targetBytes + "/" + targetRecs);
98: Thomas Graves, info, MethodDeclaration, LOG.info("Serial started at " + System.currentTimeMillis());
100: Thomas Graves, info, MethodDeclaration, LOG.info("Serial ended at " + System.currentTimeMillis());
106: Thomas Graves, info, MethodDeclaration, LOG.info(" Replay started at " + System.currentTimeMillis());
108: Thomas Graves, info, MethodDeclaration, LOG.info(" Replay ended at " + System.currentTimeMillis());
114: Thomas Graves, info, MethodDeclaration, LOG.info(" Replay started at " + System.currentTimeMillis());
116: Thomas Graves, info, MethodDeclaration, LOG.info(" Replay ended at " + System.currentTimeMillis());
83: Allen Wittenauer, debug, IfStmt, LOG.debug("Broker list " + brokerList);
87: Allen Wittenauer, debug, IfStmt, LOG.debug("Kafka brokers: " + brokerList);
93: Allen Wittenauer, debug, IfStmt, LOG.debug("Kafka topic " + topic);
111: Allen Wittenauer, Error, CatchClause, LOG.warn("Error getting Hostname, going to continue");
155: Allen Wittenauer, debug, MethodDeclaration, LOG.debug("kafka message: " + jsonLines.toString());
186: Allen Wittenauer, debug, MethodDeclaration, LOG.debug("Kafka seems not to have any flush() mechanism!");
131: Allen Wittenauer, debug, IfStmt, LOG.debug("kafka message: " + jsonLines.toString());
148: Allen Wittenauer, debug, IfStmt, LOG.debug("kafka result: " + jsonResult);
166: Allen Wittenauer, Error, CatchClause, LOG.warn("Error getting Hostname, going to continue");
94: Steve Loughran, warn, CatchClause, LOG.warn("Unable to wrap exception of type " + clazz + ": it has no (String) constructor", e);
74: Steve Loughran, Debug, ConstructorDeclaration, constructionStack = LOG.isDebugEnabled() ? new Exception("stack") : null;
103: Steve Loughran, debug, TryStmt, LOG.debug("Releasing connection to {}:  {}", uri, reason, ex);
138: Steve Loughran, debug, CatchClause, LOG.debug("Exception during release: {}", operation, ioe);
174: Steve Loughran, debug, CatchClause, LOG.debug("EOF exception", e);
199: Steve Loughran, debug, CatchClause, LOG.debug("EOF exception", e);
224: Steve Loughran, warn, CatchClause, LOG.warn("Exception while releasing {} in finalizer", uri, e);
219: Steve Loughran, warn, IfStmt, LOG.warn("input stream of {}" + " not closed properly -cleaned up in finalize()", uri);
142: Steve Loughran, debug, IfStmt, LOG.debug("Filesystem " + fsURI + " is using configuration keys " + prefix);
265: Steve Loughran, debug, IfStmt, LOG.debug(String.format("setAuth: endpoint=%s; objectURI=%s; token=%s", endpoint, objectLocation, authToken));
572: Steve Loughran, debug, IfStmt, LOG.debug(serviceDescription);
631: Steve Loughran, debug, IfStmt, LOG.debug("getData:" + range);
747: Steve Loughran, warn, CatchClause, LOG.warn("Failed to get the location of " + path + ": " + e, e);
1099: Steve Loughran, debug, MethodDeclaration, LOG.debug("started authentication");
1169: Steve Loughran, debug, IfStmt, LOG.debug("Catalog entry " + descr);
1176: Steve Loughran, debug, IfStmt, LOG.debug("Found swift catalog as " + name + " => " + type);
1189: Steve Loughran, debug, IfStmt, LOG.debug("Endpoint " + descr);
1236: Steve Loughran, debug, IfStmt, LOG.debug("authenticated against " + endpointURI);
1248: Steve Loughran, debug, IfStmt, LOG.debug("Authenticating with " + authenticationRequest);
1334: Steve Loughran, trace, IfStmt, LOG.trace("Executing " + operation);
1472: Steve Loughran, error, IfStmt, LOG.debug(errorMessage);
1678: Akira Ajisaka, debug, IfStmt, LOG.debug("Operation failed with status " + statusCode + " attempting keystone auth");
1701: Steve Loughran, debug, IfStmt, LOG.debug("Reauthenticating");
1706: Steve Loughran, debug, IfStmt, LOG.debug("Retrying original request");
1729: fang zhenyi, debug, IfStmt, LOG.debug(builder.toString());
1733: Akira Ajisaka, debug, IfStmt, LOG.debug("Status code = " + resp.getStatusLine().getStatusCode());
122: Steve Loughran, debug, IfStmt, LOG.debug("Initializing SwiftNativeFileSystem against URI " + uri + " and working dir " + workingDir);
126: Steve Loughran, debug, MethodDeclaration, LOG.debug("SwiftFileSystem initialized");
160: Steve Loughran, debug, IfStmt, LOG.debug("SwiftFileSystem.setWorkingDirectory to " + dir);
282: Steve Loughran, debug, IfStmt, LOG.debug("No locations returned for " + file.getPath());
327: Steve Loughran, debug, IfStmt, LOG.debug("SwiftFileSystem.mkdirs: " + path);
408: Steve Loughran, debug, IfStmt, LOG.debug("skipping mkdir(" + directory + ") as it exists already");
428: Steve Loughran, debug, IfStmt, LOG.debug("Making dir '" + absolutePath + "' in Swift");
445: Steve Loughran, debug, IfStmt, LOG.debug("SwiftFileSystem.listStatus for: " + path);
456: Steve Loughran, debug, MethodDeclaration, LOG.debug("SwiftFileSystem.append");
469: Steve Loughran, debug, MethodDeclaration, LOG.debug("SwiftFileSystem.create");
495: Steve Loughran, debug, IfStmt, LOG.debug("Overwriting either an empty file or a directory");
320: Steve Loughran, debug, IfStmt, LOG.debug("" + "File/Directory not found " + path);
469: Steve Loughran, debug, IfStmt, LOG.debug("Not deleting root directory entry");
536: Steve Loughran, debug, IfStmt, LOG.debug("mv " + src + " " + dst);
554: Steve Loughran, debug, CatchClause, LOG.debug("Destination does not exist");
569: Steve Loughran, debug, CatchClause, LOG.debug("destination parent directory " + dstParent + " doesn't exist");
660: Steve Loughran, info, IfStmt, LOG.info("mv  " + srcObject + " " + targetPath);
691: Steve Loughran, info, CatchClause, LOG.info("Skipping rename of " + copySourcePath);
703: Steve Loughran, warn, CatchClause, LOG.warn("Source directory deleted during rename", e);
601: Steve Loughran, debug, IfStmt, LOG.debug("Renaming file onto self: no-op => success");
721: Steve Loughran, debug, IfStmt, LOG.debug(message + ": listing of " + objectPath);
723: fang zhenyi, debug, ForeachStmt, LOG.debug(fileStatus.getPath().toString());
949: Steve Loughran, debug, IfStmt, LOG.debug("Multiple child entries but entry has data: assume partitioned");
147: Steve Loughran, debug, CatchClause, LOG.debug(msg, e);
174: Steve Loughran, info, CatchClause, LOG.info("Received IOException while reading '" + path + "', attempting to reopen: " + e);
176: Steve Loughran, debug, CatchClause, LOG.debug("IOE on read()" + e, e);
226: Steve Loughran, debug, IfStmt, LOG.debug("Closing HTTP input stream : " + reason);
263: Steve Loughran, error, IfStmt, LOG.error("Input stream is leaking handles by not being closed() properly: " + httpStream.toString());
313: Steve Loughran, debug, IfStmt, LOG.debug("Seek to " + targetPos + "; current pos =" + pos + "; offset=" + offset);
317: Steve Loughran, debug, IfStmt, LOG.debug("seek is no-op");
345: Steve Loughran, debug, IfStmt, LOG.debug("Seek is beyond buffer size of " + bufferSize);
336: Steve Loughran, debug, CatchClause, LOG.debug("while chomping ", e);
332: Steve Loughran, debug, TryStmt, LOG.debug("chomping ");
339: Steve Loughran, trace, IfStmt, LOG.trace("chomping successful");
342: Steve Loughran, trace, IfStmt, LOG.trace("chomping failed");
322: Steve Loughran, debug, IfStmt, LOG.debug("seek is backwards");
162: Steve Loughran, info, CatchClause, LOG.info("Upload failed " + e, e);
189: Steve Loughran, warn, IfStmt, LOG.warn("stream not closed");
192: Steve Loughran, warn, IfStmt, LOG.warn("Leaking backing file " + backupFile);
200: Steve Loughran, warn, IfStmt, LOG.warn("Could not delete " + file);
304: Steve Loughran, info, CatchClause, LOG.info("Upload failed " + e, e);
212: Steve Loughran, warn, IfStmt, LOG.warn(message);
231: Steve Loughran, warn, ForStmt, LOG.warn(line);
285: Steve Loughran, Error, CatchClause, LOG.error("Error deleting in " + action + " - " + cleanupPath + ": " + e, e);
291: Steve Loughran, debug, IfStmt, LOG.debug("==============  " + action + " =============");
303: Steve Loughran, warn, MethodDeclaration, LOG.warn("Downgrading test " + message, failure);
103: Steve Loughran, debug, IfStmt, log.debug(String.format(text, args));
115: Steve Loughran, debug, IfStmt, log.debug(text + ex, ex);
129: Steve Loughran, trace, IfStmt, log.trace(String.format(text, args));
102: Steve Loughran, info, ForeachStmt, LOG.info(stat.toString());
264: Steve Loughran, debug, CatchClause, LOG.debug("Rename failed (expected):" + e);
266: Steve Loughran, debug, CatchClause, LOG.debug("Rename failed (expected):" + e);
37: Steve Loughran, info, MethodDeclaration, LOG.info(msg);
140: Steve Loughran, warn, TryStmt, LOG.warn("Seek to -1 returned a position of " + p);
125: Steve Loughran, warn, CatchClause, LOG.warn("deleting " + path, e);
122: Steve Loughran, warn, IfStmt, LOG.warn("Failed to delete " + path);
135: Steve Loughran, warn, CatchClause, LOG.warn("deleting " + path, e);
132: Steve Loughran, warn, IfStmt, LOG.warn("Failed to delete " + path);
250: Steve Loughran, debug, CatchClause, LOG.debug("Expected Exception", expected);
52: Steve Loughran, info, MethodDeclaration, LOG.info("{}", location);
144: Steve Loughran, info, MethodDeclaration, LOG.info("Filesystem is " + fs + "; target is " + status);
69: Steve Loughran, warn, CatchClause, LOG.warn("deletion thread:" + e, e);
83: Steve Loughran, warn, CatchClause, LOG.warn("writer thread:" + e, e);
99: Steve Loughran, info, TryStmt, LOG.info("concurrency test failed to trigger a failure");
48: Steve Loughran, debug, CatchClause, LOG.debug("Expected: " + fnfe, fnfe);
120: Steve Loughran, info, ForeachStmt, LOG.info(header.toString());
124: Steve Loughran, info, TryStmt, LOG.info("Read dataset from " + path + ": data length =" + len);
196: Steve Loughran, info, ForeachStmt, LOG.info(header.toString());
200: Steve Loughran, info, TryStmt, LOG.info("Read dataset from " + path + ": data length =" + len);
55: Steve Loughran, info, IfStmt, LOG.info(ls(path("/test/new")));
56: Steve Loughran, info, IfStmt, LOG.info(ls(path("/test/hadoop")));
108: Steve Loughran, info, MethodDeclaration, LOG.info("Inital Hadoop Path =" + initialpath);
109: Steve Loughran, info, MethodDeclaration, LOG.info("Merged URI=" + uri);
96: Steve Loughran, info, MethodDeclaration, LOG.info("head request duration " + head);
98: Steve Loughran, info, ForeachStmt, LOG.info(header.toString());
113: fang zhenyi, info, ForeachStmt, LOG.info(stats.toString());
84: Steve Loughran, info, MethodDeclaration, LOG.info(String.format("'filesystem','%s'", fs.getUri()));
85: Steve Loughran, info, MethodDeclaration, LOG.info(writeStats.toString());
86: Steve Loughran, info, MethodDeclaration, LOG.info(readStats.toString());
87: Steve Loughran, info, MethodDeclaration, LOG.info(String.format("'rm1',%d,'ls1',%d", rm1.value(), ls1.value()));
91: Steve Loughran, info, MethodDeclaration, LOG.info(String.format("'rm2',%d,'ls2',%d", rm2.value(), ls2.value()));
141: Xiaoyu Yao, error, CatchClause, LOG.error(msg, ue);
120: Chen Liang, trace, TryStmt, LOG.trace("Ozone URI for ozfs initialization is " + uri);
167: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("open() path:{}", f);
183: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("create() path:{}", f);
204: Xiaoyu Yao, trace, TryStmt, LOG.trace("parent key:{} status:{}", key, parentStatus);
195: Xiaoyu Yao, trace, IfStmt, LOG.trace("Overwriting file {}", f);
255: Xiaoyu Yao, trace, ConstructorDeclaration, LOG.trace("rename from:{} to:{}", srcKey, dstKey);
293: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("rename() from:{} to:{}", src, dst);
297: Xiaoyu Yao, trace, IfStmt, LOG.trace("Cannot rename the root of a filesystem");
365: Xiaoyu Yao, trace, IfStmt, LOG.trace("Cannot rename a directory to a subdirectory of self");
392: Xiaoyu Yao, trace, IfStmt, LOG.trace("deleting key:" + key);
389: Xiaoyu Yao, trace, IfStmt, LOG.trace("Skipping deleting root directory");
403: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("delete() path:{} recursive:{}", f, recursive);
408: Mukul Kumar Singh, debug, CatchClause, LOG.debug("Couldn't delete {} - does not exist", f);
447: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("listStatus() path:{}", f);
476: Xiaoyu Yao, trace, DoStmt, LOG.trace("validating path:{}", fPart);
492: Xiaoyu Yao, trace, CatchClause, LOG.trace("creating directory for fpart:{}", fPart);
484: Xiaoyu Yao, trace, IfStmt, LOG.trace("Found a file with same name as directory, path:{}", fPart);
513: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("mkdir() path:{} ", f);
523: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("getFileStatus() path:{}", f);
540: Xiaoyu Yao, trace, IfStmt, LOG.trace("File:{} not found", f);
561: Xiaoyu Yao, trace, CatchClause, LOG.trace("Key:{} does not exists", key);
572: Mukul Kumar Singh, trace, MethodDeclaration, LOG.trace("key name:{} size:{}", key.getName(), key.getDataSize());
589: Mukul Kumar Singh, error, CatchClause, LOG.error("create key failed for key:{}", keyName, ioe);
585: Anu Engineer, trace, TryStmt, LOG.trace("creating dir for key:{}", keyName);
600: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("issuing delete for key" + keyName);
605: Mukul Kumar Singh, error, CatchClause, LOG.error("delete key failed " + ioe.getMessage());
623: Xiaoyu Yao, trace, MethodDeclaration, LOG.trace("path for key:{} is:{}", key, path);
671: Mukul Kumar Singh, trace, MethodDeclaration, LOG.trace("Iterating path {}", path);
683: Xiaoyu Yao, trace, IfStmt, LOG.trace("iterating file:{}", path);
673: Xiaoyu Yao, trace, IfStmt, LOG.trace("Iterating directory:{}", pathKey);
676: Anu Engineer, trace, WhileStmt, LOG.trace("iterating key:{}", key.getName());
53: Chen Liang, info, MethodDeclaration, getLog().info("FS details {}", getFileSystem());
124: Subru Krishnan, Error, CatchClause, LOGGER.error("Error starting ResourceEstimatorServer", t);
142: Subru Krishnan, info, MethodDeclaration, LOGGER.info("Stopping resourceestimator service at: {}.", baseURI.toString());
98: Arun Suresh, error, CatchClause, LOGGER.error("Server initialization failed due to: {}", ex.getMessage());
128: Subru Krishnan, debug, MethodDeclaration, LOGGER.debug("Parse logFile: {}.", logFile);
161: Subru Krishnan, debug, MethodDeclaration, LOGGER.debug("Predict resource requests for pipelineId: {}." + pipelineId);
191: Subru Krishnan, debug, MethodDeclaration, LOGGER.debug("Query the skyline store for recurrenceId: {}." + recurrenceId);
211: Subru Krishnan, debug, MethodDeclaration, LOGGER.debug("Query the skyline store for pipelineId: {}." + pipelineId);
232: Subru Krishnan, info, MethodDeclaration, LOGGER.info("Delete ResourceSkyline for recurrenceId: {}.", recurrenceId);
42: Subru Krishnan, error, CatchClause, LOGGER.error("HttpServer fails to shut down!");
114: Subru Krishnan, info, IfStmt, LOGGER.info("Successfully addHistory new resource skylines for {}.", recurrenceId);
104: Subru Krishnan, error, IfStmt, LOGGER.error(errMsg.toString());
110: Subru Krishnan, info, IfStmt, LOGGER.info("Successfully addHistory new resource skylines for {}.", recurrenceId);
130: Subru Krishnan, info, TryStmt, LOGGER.info("Successfully add estimated resource allocation for {}.", pipelineId);
150: Subru Krishnan, error, IfStmt, LOGGER.error(errMsg.toString());
144: Subru Krishnan, warn, IfStmt, LOGGER.warn("Delete resource skylines for {}.", recurrenceId);
183: Subru Krishnan, error, IfStmt, LOGGER.error(errMsg.toString());
175: Subru Krishnan, error, IfStmt, LOGGER.error(errMsg.toString());
169: Subru Krishnan, info, IfStmt, LOGGER.info("Successfully updateHistory resource skylines for {}.", recurrenceId);
199: Subru Krishnan, info, IfStmt, LOGGER.info("Successfully query resource skylines for {}.", recurrenceId);
224: Subru Krishnan, warn, IfStmt, LOGGER.warn("Trying to getHistory non-existing resource skylines for {}.", recurrenceId);
220: Subru Krishnan, info, IfStmt, LOGGER.info("Successfully query resource skylines for {}.", recurrenceId);
234: Subru Krishnan, warn, IfStmt, LOGGER.warn("Trying to getHistory non-existing resource skylines for {}.", recurrenceId);
239: Subru Krishnan, info, TryStmt, LOGGER.info("Successfully query resource skylines for {}.", recurrenceId);
56: Subru Krishnan, error, IfStmt, LOGGER.error(sb.toString());
73: Subru Krishnan, error, IfStmt, LOGGER.error(sb.toString());
95: Subru Krishnan, error, IfStmt, LOGGER.error(sb.toString());
114: Subru Krishnan, error, IfStmt, LOGGER.error(sb.toString());
306: Subru Krishnan, debug, ForStmt, LOGGER.debug("time interval: {}, container: {}.", indexTimeK, lpResult.doubleValue(indexTimeK));
64: Subru Krishnan, error, IfStmt, LOGGER.error("Job resource skyline history is invalid, please try again with" + " valid resource skyline history.");
71: Subru Krishnan, error, IfStmt, LOGGER.error("Solver timeInterval {} is invalid, please specify a positive value.", timeInterval);
209: Subru Krishnan, error, IfStmt, LOGGER.error("Solver requires job resource skyline history for at least {} runs," + " but it only receives history info for {}  runs.", minJobRuns, numJobs);
79: Subru Krishnan, warn, IfStmt, LOGGER.warn("find duplicate container launch time for {}, so we replace" + " it with {}.", containerId, time);
95: Subru Krishnan, warn, IfStmt, LOGGER.warn("find duplicate container release time for {}, so we replace" + " it with {}.", containerId, time);
154: Subru Krishnan, warn, IfStmt, LOGGER.warn("container release time not found for {}.", entry.getKey());
98: Subru Krishnan, error, IfStmt, LOGGER.error("Input validation fails, please specify with" + " valid input parameters.");
113: Subru Krishnan, debug, CatchClause, LOGGER.debug("Data field not found", e);
115: Subru Krishnan, debug, CatchClause, LOGGER.debug("Date conversion error", e);
159: Todd Lipcon, error, WhileStmt, LOG.error("The current job was submitted earlier than the previous one");
160: Todd Lipcon, error, WhileStmt, LOG.error("Its jobID is " + result.getJobID());
161: Todd Lipcon, error, WhileStmt, LOG.error("Its submit time is " + result.getSubmitTime() + ",but the previous one was " + returnedLatestSubmitTime);
175: Todd Lipcon, error, IfStmt, LOG.error("You must have an input cycle length.");
194: Todd Lipcon, warn, IfStmt, LOG.warn("This run effectively has a -seed of " + randomSeed);
242: Todd Lipcon, error, IfStmt, LOG.error("The job trace is empty");
250: Todd Lipcon, info, IfStmt, LOG.info("starts-after time is specified. Initial job submit time : " + job.getSubmitTime());
261: Todd Lipcon, debug, IfStmt, LOG.debug("Considering jobs with submit time greater than " + startsAfter + " ms. Skipped " + skippedCount + " jobs.");
265: Todd Lipcon, error, IfStmt, LOG.error("No more jobs to process in the trace with 'starts-after'" + " set to " + startsAfter + "ms.");
269: Todd Lipcon, info, IfStmt, LOG.info("The first job has a submit time of " + job.getSubmitTime());
283: Todd Lipcon, debug, IfStmt, LOG.debug("The first job has a submit time of " + firstJobSubmitTime);
311: Todd Lipcon, debug, IfStmt, LOG.debug("The next segment name is " + nextSegment);
336: Todd Lipcon, debug, IfStmt, LOG.debug("Creating " + nextSegment + " for a job with a submit time of " + job.getSubmitTime());
371: Todd Lipcon, error, IfStmt, LOG.error("All of your job[s] have the same submit time." + "  Please just use your input file.");
379: Todd Lipcon, warn, TryStmt, LOG.warn("Your input trace spans " + (lastJobSubmitTime - firstJobSubmitTime) + " ticks.");
386: Todd Lipcon, warn, IfStmt, LOG.warn("run: submitTimeSpan = " + submitTimeSpan + ", numberJobs = " + numberJobs + ", inputCycle = " + inputCycle);
391: Todd Lipcon, warn, IfStmt, LOG.warn("You needed a -skew-buffer-length of " + reader.neededSkewBufferSize() + " but no more, for this input.");
398: Todd Lipcon, warn, IfStmt, LOG.warn("run: timeDilation = " + timeDilation + ", concentration = " + concentration + ", foldingRatio = " + foldingRatio);
400: Todd Lipcon, warn, IfStmt, LOG.warn("The transcription probability is " + tProbability);
422: Todd Lipcon, debug, IfStmt, LOG.debug("A job with submit time of " + streamFirstJob.getSubmitTime() + " is in interval # " + thisIndex);
430: Todd Lipcon, debug, IfStmt, LOG.debug("That job's submit time is adjusted to " + streamFirstJob.getSubmitTime());
444: Todd Lipcon, debug, IfStmt, LOG.debug("The most recent job has an adjusted submit time of " + next.first().getSubmitTime());
446: Todd Lipcon, debug, IfStmt, LOG.debug(" Its replacement in the heap will come from input engine " + next.second());
462: Todd Lipcon, debug, IfStmt, LOG.debug("The replacement has an adjusted submit time of " + replacement.getSubmitTime());
456: Todd Lipcon, debug, IfStmt, LOG.debug("That input engine is depleted.");
484: Todd Lipcon, info, IfStmt, LOG.info("We dropped " + (inputDirectoryFiles.length - dropPoint) + " crc files.");
532: Todd Lipcon, info, IfStmt, LOG.info("File closed: " + currentFileName);
552: Todd Lipcon, info, MethodDeclaration, LOG.info("\nOpening file " + currentFileName + "  *************************** .");
554: Todd Lipcon, info, MethodDeclaration, LOG.info("This file, " + (inputDirectoryCursor + 1) + "/" + inputDirectoryFiles.length + ", starts with line " + lineNumber + ".");
952: Todd Lipcon, warn, CatchClause, LOG.warn("HadoopLogsAnalyzer.processJobLine: bad numerical format, at line " + lineNumber + ".", e);
1021: Todd Lipcon, error, CatchClause, LOG.error("A task status you don't know about is \"" + status + "\".", e);
1033: Todd Lipcon, error, CatchClause, LOG.error("A task type you don't know about is \"" + taskType + "\".", e);
1285: Todd Lipcon, error, CatchClause, LOG.error("A map attempt status you don't know about is \"" + status + "\".", e);
1375: Todd Lipcon, warn, CatchClause, LOG.warn("HadoopLogsAnalyzer.processMapAttemptLine: bad numerical format, at line" + lineNumber + ".", e);
1438: Todd Lipcon, warn, CatchClause, LOG.warn("A map attempt status you don't know about is \"" + status + "\".", e);
1524: Todd Lipcon, error, CatchClause, LOG.error("HadoopLogsAnalyzer.processReduceAttemptLine: bad numerical format, at line" + lineNumber + ".", e);
1703: Todd Lipcon, debug, IfStmt, LOG.debug("" + lineNumber + " " + line.second());
1716: Todd Lipcon, warn, CatchClause, LOG.warn("anomalous line #" + lineNumber + ":" + line, e);
1837: Todd Lipcon, error, CatchClause, LOG.error("", e);
1841: Todd Lipcon, error, CatchClause, LOG.error("", e);
1845: Todd Lipcon, error, CatchClause, LOG.error("", e);
70: Todd Lipcon, warn, CatchClause, LOG.warn("The counter string, \"" + counters + "\" is badly formatted.");
78: Todd Lipcon, warn, IfStmt, LOG.warn("HistoryEventEmitters: null counter detected:");
147: Jian He, warn, IfStmt, LOG.warn("NormalizedResourceEvent should be ignored in history server.");
162: Amar Kamat, info, MethodDeclaration, LOG.info("ParsedJob details:" + obtainTotalCounters() + ";" + obtainMapCounters() + ";" + obtainReduceCounters() + "\n" + obtainJobConfpath() + "\n" + obtainJobAcls() + ";Q=" + (getQueue() == null ? "null" : getQueue().getValue()));
119: Amar Kamat, info, MethodDeclaration, LOG.info("ParsedTask details:" + obtainCounters() + "\n" + obtainFailedDueToAttemptId() + "\nPreferred Locations are:");
124: Amar Kamat, info, ForeachStmt, LOG.info(l.getLayers() + ";" + l.toString());
113: Amar Kamat, info, MethodDeclaration, LOG.info("ParsedTaskAttempt details:" + obtainCounters() + ";DiagnosticInfo=" + obtainDiagnosticInfo() + "\n" + obtainTrackerName() + ";" + obtainHttpPort() + ";" + obtainShufflePort() + ";rack=" + getHostName().getRackName() + ";host=" + getHostName().getHostName());
221: Todd Lipcon, warn, CatchClause, LOG.warn("Unable to bind Path " + p + " .  Skipping...", e);
273: Todd Lipcon, Trace, IfStmt, LOG.warn("TraceBuilder got an error while processing the [possibly virtual] file " + filePair.first() + " within Path " + p, t);
238: Todd Lipcon, warn, IfStmt, LOG.warn("File skipped: Invalid file name: " + filePair.first());
256: Todd Lipcon, warn, IfStmt, LOG.warn("File skipped: Cannot find suitable parser: " + filePair.first());
284: Todd Lipcon, warn, IfStmt, LOG.warn("No job found in traces: ");
157: Todd Lipcon, warn, IfStmt, LOG.warn("TaskType for a MapTask is not Map. task=" + mapTask.getTaskID() + " type=" + ((taskType == null) ? "null" : taskType.toString()));
168: Todd Lipcon, warn, IfStmt, LOG.warn("Bad location layer format for task " + mapTask.getTaskID());
173: Todd Lipcon, warn, IfStmt, LOG.warn("Bad location layer format for task " + mapTask.getTaskID() + ": " + layers);
183: Todd Lipcon, warn, IfStmt, LOG.warn("InputBytes for task " + mapTask.getTaskID() + " is not defined.");
194: Todd Lipcon, warn, IfStmt, LOG.warn("TotalMaps for job " + job.getJobID() + " is less than the total number of map task descriptions (" + totalMaps + "<" + splitsList.size() + ").");
246: Todd Lipcon, warn, IfStmt, LOG.warn(name + " not defined for " + id);
330: Todd Lipcon, warn, IfStmt, LOG.warn("Task " + task.getTaskID() + " has nulll TaskType");
334: Todd Lipcon, warn, IfStmt, LOG.warn("Task " + task.getTaskID() + " has nulll TaskStatus");
345: Todd Lipcon, warn, IfStmt, LOG.warn("TaskAttempt " + attempt.getResult() + " has nulll Result");
520: Todd Lipcon, warn, IfStmt, LOG.warn("Negative running time for task " + id + ": " + time);
365: Inigo Goiri, error, CatchClause, LOG.error("Got an error while adding node", e);
388: Akira Ajisaka, info, WhileStmt, LOG.info("SLSRunner is waiting for all nodes RUNNING." + " {} of {} NMs initialized.", numRunningNodes, numNMs);
392: Akira Ajisaka, info, MethodDeclaration, LOG.info("SLSRunner takes {} ms to launch all nodes.", System.currentTimeMillis() - startTimeMS);
439: Akira Ajisaka, error, CatchClause, LOG.error("Failed to create an AM: {}", e.getMessage());
590: Akira Ajisaka, error, CatchClause, LOG.error("Failed to create an AM: {}", e.getMessage());
612: Akira Ajisaka, Warn, IfStmt, LOG.warn("Warning: reset job {} start time to 0.", oldJobId);
698: Carlo Curino, Warn, IfStmt, LOG.warn("Warning: reset job {} start time to 0.", oldJobId);
819: Alejandro Abdelnur, info, IfStmt, LOG.info("------------------------------------");
820: Akira Ajisaka, info, IfStmt, LOG.info("# nodes = {}, # racks = {}, capacity " + "of each node {}.", numNMs, numRacks, nodeManagerResource);
823: Alejandro Abdelnur, info, IfStmt, LOG.info("------------------------------------");
825: Akira Ajisaka, info, IfStmt, LOG.info("# applications = {}, # total " + "tasks = {}, average # tasks per application = {}", numAMs, numTasks, (int) (Math.ceil((numTasks + 0.0) / numAMs)));
828: Alejandro Abdelnur, info, IfStmt, LOG.info("JobId\tQueue\tAMType\tDuration\t#Tasks");
831: Wangda Tan, info, ForeachStmt, LOG.info(entry.getKey() + "\t" + am.getQueue() + "\t" + am.getAMType() + "\t" + am.getDuration() + "\t" + am.getNumTasks());
834: Alejandro Abdelnur, info, IfStmt, LOG.info("------------------------------------");
836: Akira Ajisaka, info, IfStmt, LOG.info("number of queues = {}  average number of apps = {}", queueAppNumMap.size(), (int) (Math.ceil((numAMs + 0.0) / queueAppNumMap.size())));
839: Alejandro Abdelnur, info, IfStmt, LOG.info("------------------------------------");
841: Akira Ajisaka, info, IfStmt, LOG.info("estimated simulation time is {} seconds", (long) (Math.ceil(maxRuntime / 1000.0)));
843: Alejandro Abdelnur, info, IfStmt, LOG.info("------------------------------------");
871: Alejandro Abdelnur, info, IfStmt, LOG.info("SLSRunner tears down.");
156: Wangda Tan, warn, CatchClause, LOG.warn("Unable to place reservation: " + y.getMessage());
186: Wangda Tan, info, MethodDeclaration, LOG.info("RESERVATION SUCCESSFULLY SUBMITTED " + reservationRequest.getReservationId());
214: Akira Ajisaka, info, MethodDeclaration, LOG.info("Application {} is shutting down.", appId);
226: Sunil G, info, IfStmt, LOG.info("AM container is null");
222: Akira Ajisaka, info, IfStmt, LOG.info("AM container = {} reported to finish", amContainer.getId());
344: Akira Ajisaka, info, MethodDeclaration, LOG.info("Submit a new application {}", appId);
371: Akira Ajisaka, info, MethodDeclaration, LOG.info("Register the application master for application {}", appId);
146: Akira Ajisaka, info, MethodDeclaration, LOG.info("Added new job with {} mapper and {} reducers", allMaps.size(), allReduces.size());
206: Akira Ajisaka, info, IfStmt, LOG.info("Application {}'s AM is " + "going to be killed. Waiting for rescheduling...", appId);
202: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} has one reducer killed ({}).", appId, containerId);
198: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} has one mapper killed ({}).", appId, containerId);
189: Akira Ajisaka, info, IfStmt, LOG.info("Application {} goes to finish.", appId);
181: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} has one reducer finished ({}).", appId, containerId);
175: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} has one mapper finished ({}).", appId, containerId);
218: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} sends out event to clean up" + " its AM container.", appId);
235: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} starts to launch a reducer ({}).", appId, container.getId());
228: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} starts to launch a mapper ({}).", appId, container.getId());
322: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} sends out request for {} failed reducers.", appId, pendingFailedReduces.size());
315: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} sends out requests for {} reducers.", appId, pendingReduces.size());
305: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} sends out requests for {} failed mappers.", appId, pendingFailedMaps.size());
298: Akira Ajisaka, debug, IfStmt, LOG.debug("Application {} sends out request for {} mappers.", appId, pendingMaps.size());
109: Carlo Curino, info, MethodDeclaration, LOG.info("Added new job with {} streams, running for {}", allStreams.size(), duration);
147: Carlo Curino, info, IfStmt, LOG.info("Application {}'s AM is " + "going to be killed. Waiting for rescheduling...", appId);
144: Carlo Curino, info, IfStmt, LOG.info("Application {} goes to finish.", appId);
158: Carlo Curino, debug, IfStmt, LOG.debug("Application {} sends out event to clean up" + " its AM container.", appId);
169: Carlo Curino, debug, IfStmt, LOG.debug("Application {} starts to launch a stream ({}).", appId, container.getId());
211: Carlo Curino, debug, IfStmt, LOG.debug("Application {} sends out request for {} streams.", appId, pendingStreams.size());
125: Akira Ajisaka, debug, WhileStmt, LOG.debug("Container {} has completed", cs.getId());
170: Akira Ajisaka, debug, IfStmt, LOG.debug("NodeManager {} releases a container ({}).", node.getNodeID(), containerId);
164: Akira Ajisaka, debug, IfStmt, LOG.debug("NodeManager {} releases an AM ({}).", node.getNodeID(), containerId);
205: Akira Ajisaka, debug, ForeachStmt, LOG.debug("NodeManager {} completed container ({}).", node.getNodeID(), cId);
215: Akira Ajisaka, debug, ForeachStmt, LOG.debug("NodeManager {} released container ({}).", node.getNodeID(), cId);
243: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("NodeManager {} launches a new container ({}).", node.getNodeID(), container.getId());
104: Sunil G, info, TryStmt, LOG.info("Notify AM launcher launched:" + amContainer.getId());
472: Akira Ajisaka, error, IfStmt, LOG.error("Cannot create directory {}", dir.getAbsoluteFile());
515: Robert Kanter, info, CatchClause, LOG.info(e.getMessage());
534: Robert Kanter, info, CatchClause, LOG.info(e.getMessage());
671: Robert Kanter, info, CatchClause, LOG.info(e.getMessage());
176: Wangda Tan, debug, ConstructorDeclaration, LOG.debug(name + " (" + seed + ")");
178: Wangda Tan, info, ConstructorDeclaration, LOG.info("JOB TIMING`: job: " + name + " submission:" + submitTime + " deadline:" + deadline + " duration:" + duration + " deadline-submission: " + (deadline - submitTime));
82: Wangda Tan, Trace, ConstructorDeclaration, LOG.info("SynthTraceJobProducer");
110: Carlo Curino, info, ConstructorDeclaration, LOG.info("Generated " + listStoryParams.size() + " deadlines for " + this.numJobs.get() + " jobs");
184: Carlo Curino, info, IfStmt, LOG.info("Detected old JobDefinition format. Converting.");
219: Carlo Curino, Error, CatchClause, LOG.warn("Error converting old JobDefinition format", e);
76: Carlo Curino, info, ForStmt, LOG.info("Generated time " + time);
95: Carlo Curino, info, MethodDeclaration, LOG.info("bucket0 {}, bucket1 {}, bucket2 {}, bucket3 {}", bucket0, bucket1, bucket2, bucket3);
110: Carlo Curino, info, MethodDeclaration, LOG.info(stjp.toString());
117: Carlo Curino, info, WhileStmt, LOG.info(js.toString());
135: Carlo Curino, info, MethodDeclaration, LOG.info(stjp.toString());
142: Carlo Curino, info, WhileStmt, LOG.info(js.toString());
160: Carlo Curino, info, MethodDeclaration, LOG.info(stjp.toString());
167: Carlo Curino, info, WhileStmt, LOG.info(js.toString());
119: Todd Lipcon, info, IfStmt, LOG.info(getContext(), io);
220: Todd Lipcon, error, CatchClause, LOG.error("configuration exception", e);
223: Todd Lipcon, error, CatchClause, LOG.error("configuration exception", e);
198: Todd Lipcon, info, TryStmt, LOG.info("PipeMapRed exec " + Arrays.asList(argvSplit));
232: Todd Lipcon, info, IfStmt, LOG.info("JobConf set minRecWrittenToEnableSkip_ =" + minRecWrittenToEnableSkip_);
247: Robert Kanter, warn, IfStmt, LOG.warn("Environment variable " + name + " truncated to " + lenLimit + " to  fit system limits.");
278: Todd Lipcon, info, IfStmt, LOG.info("Skip env entry:" + nv[i]);
287: Todd Lipcon, debug, IfStmt, LOG.debug("Add  env entry:" + name + "=" + value);
328: Todd Lipcon, info, IfStmt, LOG.info("PipeMapRed.waitOutputThreads(): subprocess exited with " + "code " + exitVal + " in " + PipeMapRed.class.getName());
400: Todd Lipcon, warn, CatchClause, LOG.warn(th);
408: Todd Lipcon, info, CatchClause, LOG.info(io);
395: Todd Lipcon, info, IfStmt, LOG.info(hline);
469: Todd Lipcon, warn, CatchClause, LOG.warn(th);
479: Todd Lipcon, info, CatchClause, LOG.info(io);
447: Todd Lipcon, warn, IfStmt, LOG.warn("Cannot parse reporter line: " + lineStr);
465: Todd Lipcon, Error, IfStmt, LOG.info("MRErrorThread done");
508: Todd Lipcon, warn, IfStmt, LOG.warn("Cannot parse counter line: " + line);
504: Todd Lipcon, warn, CatchClause, LOG.warn("Cannot parse counter increment '" + columns[2] + "' from line: " + line);
545: Todd Lipcon, info, CatchClause, LOG.info("PipeMapRed failed!", e);
526: Todd Lipcon, info, IfStmt, LOG.info("mapRedFinished");
534: Robert Joseph Evans, warn, CatchClause, LOG.warn(io);
540: Todd Lipcon, warn, CatchClause, LOG.warn(io);
543: Todd Lipcon, info, TryStmt, LOG.info("mapRedFinished");
553: Todd Lipcon, info, IfStmt, LOG.info(info);
108: Todd Lipcon, info, IfStmt, LOG.info(status);
47: Todd Lipcon, info, MethodDeclaration, LOG.info("getRecordReader start.....split=" + split);
252: Todd Lipcon, error, CatchClause, LOG.error(oe.getMessage());
289: Todd Lipcon, warn, IfStmt, LOG.warn("-file option is deprecated, please use generic option" + " -files instead.");
321: Todd Lipcon, warn, IfStmt, LOG.warn("-dfs option is deprecated, please use -fs instead.");
337: Todd Lipcon, warn, IfStmt, LOG.warn("-cacheArchive option is deprecated, please use -archives instead.");
345: Todd Lipcon, warn, IfStmt, LOG.warn("-cacheFile option is deprecated, please use -files instead.");
353: Todd Lipcon, warn, IfStmt, LOG.warn("-jobconf option is deprecated, please use -D instead.");
733: Todd Lipcon, warn, IfStmt, LOG.warn("-additionalconfspec option is deprecated, please use -conf instead.");
1026: Todd Lipcon, Error, CatchClause, LOG.error("Error launching job , bad input path : " + fe.getMessage());
1029: Todd Lipcon, Error, CatchClause, LOG.error("Error launching job , Invalid job conf : " + je.getMessage());
1032: Alejandro Abdelnur, Error, CatchClause, LOG.error("Error launching job , Output path already exists : " + fae.getMessage());
1036: Todd Lipcon, Error, CatchClause, LOG.error("Error Launching job : " + ioe.getMessage());
1039: Todd Lipcon, Error, CatchClause, LOG.error("Error monitoring job : " + ie.getMessage());
1021: Allen Wittenauer, error, IfStmt, LOG.error("Job not successful!");
1019: Todd Lipcon, info, IfStmt, LOG.info("Job is running in background.");
1024: Todd Lipcon, info, TryStmt, LOG.info("Output directory: " + output_);
68: Todd Lipcon, info, MethodDeclaration, LOG.info("StreamBaseRecordReader.init: " + " start_=" + start_ + " end_=" + end_ + " length_=" + length_ + " start_ > in_.getPos() =" + (start_ > in_.getPos()) + " " + start_ + " > " + in_.getPos());
113: Robert Joseph Evans, info, IfStmt, LOG.info(status);
73: Robert Joseph Evans, info, MethodDeclaration, LOG.info("StreamBaseRecordReader.init: " + " start_=" + start_ + " end_=" + end_ + " length_=" + length_ + " start_ > in_.getPos() =" + (start_ > in_.getPos()) + " " + start_ + " > " + in_.getPos());
134: Todd Lipcon, info, ForStmt, LOG.info("Adding output from file: " + fileList[i]);
102: Todd Lipcon, info, MethodDeclaration, LOG.info(runningJob.getCounters().toString());
311: Todd Lipcon, warn, IfStmt, LOG.warn("Encountered BAD record");
307: Todd Lipcon, warn, IfStmt, LOG.warn("Encountered BAD record");
303: Todd Lipcon, warn, IfStmt, LOG.warn("Encountered BAD record");
116: Todd Lipcon, warn, IfStmt, LOG.warn("No perl; skipping test.");
136: Todd Lipcon, warn, IfStmt, LOG.warn("No perl; skipping test.");
155: Todd Lipcon, warn, IfStmt, LOG.warn("No perl; skipping test.");
175: Todd Lipcon, warn, IfStmt, LOG.warn("No perl; skipping test.");
137: Todd Lipcon, warn, CatchClause, LOG.warn("Could not run perl: " + e);
134: Todd Lipcon, warn, IfStmt, LOG.warn("Perl is installed, but isn't behaving as expected.");
244: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exception in creating socket address " + addr, e);
305: bibinchundatt, trace, IfStmt, LOG.trace("getConfValueForRMInstance: prefix = {};" + " confKey being looked up = {};" + " value being set to = {}", prefix, confKey, retVal);
94: Wangda Tan, warn, IfStmt, LOG.warn("Attempt to define resource '" + key + "', but it is not allowed.");
129: Wangda Tan, debug, IfStmt, LOG.debug("Adding resource type - name = " + MEMORY + ", units = " + ResourceInformation.MEMORY_MB.getUnits() + ", type = " + ResourceTypes.COUNTABLE);
139: Wangda Tan, debug, IfStmt, LOG.debug("Adding resource type - name = " + VCORES + ", units = , type = " + ResourceTypes.COUNTABLE);
179: Daniel Templeton, debug, IfStmt, LOG.debug("Mandatory Resource '" + resourceTypesKey + "' is not " + "configured in resource-types config file. Setting allocation " + "specified using '" + schedulerKey + "'");
244: Varun Vasudev, info, ForeachStmt, LOG.info("Adding resource type - name = " + resourceName + ", units = " + resourceUnits + ", type = " + resourceTypeName);
418: Daniel Templeton, info, CatchClause, LOG.info("Unable to find '" + resourceFile + "'.");
420: bibinchundatt, error, CatchClause, LOG.error("Exception trying to read resource types configuration '" + resourceFile + "'.", ex);
414: Wangda Tan, debug, IfStmt, LOG.debug("Found " + resourceFile + ", adding to configuration");
520: Sunil G, info, IfStmt, LOG.info("Found resource entry " + prop);
533: Wangda Tan, debug, IfStmt, LOG.debug("Setting value for resource type " + resourceType + " to " + resourceValue + " with units " + units);
648: Daniel Templeton, error, IfStmt, LOG.error(errorMsg);
385: Akira Ajisaka, Error, CatchClause, LOG.error("Error running ApplicationMaster", t);
377: Arun Murthy, info, TryStmt, LOG.info("Initializing ApplicationMaster");
393: Arun Murthy, info, IfStmt, LOG.info("Application Master failed. exiting");
390: Arun Murthy, info, IfStmt, LOG.info("Application Master completed successfully. exiting");
403: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Dump debug output");
406: Arun Murthy, info, ForeachStmt, LOG.info("System env: key=" + env.getKey() + ", val=" + env.getValue());
418: Arun Murthy, info, WhileStmt, LOG.info("System CWD content: " + line);
498: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Can not set up custom log4j properties. " + e);
513: Wangda Tan, info, IfStmt, LOG.info("Placement Spec received [{}]", placementSpec);
515: Wangda Tan, info, IfStmt, LOG.info("Total num containers requested [{}]", numTotalContainers);
555: Hitesh Shah, info, MethodDeclaration, LOG.info("Application master for app" + ", appId=" + appAttemptID.getApplicationId().getId() + ", clustertimestamp=" + appAttemptID.getApplicationId().getClusterTimestamp() + ", attemptId=" + appAttemptID.getAttemptId());
605: Hitesh Shah, error, IfStmt, LOG.error("Illegal values in env for shell script path" + ", path=" + scriptPath + ", len=" + shellScriptPathLen + ", timestamp=" + shellScriptPathTimestamp);
675: Zhijie Shen, warn, IfStmt, LOG.warn("Timeline service is not enabled");
687: Weiwei Yang, info, MethodDeclaration, LOG.info("Decode placement spec: " + decodedSpec);
715: Arun Murthy, info, MethodDeclaration, LOG.info("Starting ApplicationMaster");
725: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Executing with tokens:");
728: Akira Ajisaka, info, WhileStmt, LOG.info(token.toString());
793: Akira Ajisaka, info, MethodDeclaration, LOG.info("Max mem capability of resources in this cluster " + maxMem);
796: Akira Ajisaka, info, MethodDeclaration, LOG.info("Max vcores capability of resources in this cluster " + maxVCores);
800: Bikas Saha, info, IfStmt, LOG.info("Container memory specified above max threshold of cluster." + " Using max value." + ", specified=" + containerMemory + ", max=" + maxMem);
807: Luke Lu, info, IfStmt, LOG.info("Container virtual cores specified above max threshold of cluster." + " Using max value." + ", specified=" + containerVirtualCores + ", max=" + maxVCores);
815: Jian He, info, MethodDeclaration, LOG.info(appAttemptID + " received " + previousAMRunningContainers.size() + " previous attempts' running containers on AM registration.");
878: Jian He, warn, IfStmt, LOG.warn("Timeline service is not enabled");
866: Rohith Sharma K S, info, IfStmt, LOG.info("Timeline service V1 client is enabled");
873: Sangjin Lee, info, IfStmt, LOG.info("Timeline service V2 client is enabled");
920: Bikas Saha, info, CatchClause, LOG.info("Exception thrown in thread join: " + e.getMessage());
926: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Application completed. Stopping running containers");
945: Zhijie Shen, info, IfStmt, LOG.info(appMessage);
951: Bikas Saha, error, CatchClause, LOG.error("Failed to unregister application", ex);
953: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Failed to unregister application", e);
974: Bikas Saha, info, MethodDeclaration, LOG.info("Got response from RM for container ask, completedCnt=" + completedContainers.size());
977: Jian He, info, ForeachStmt, LOG.info(appAttemptID + " got container status for containerID=" + containerStatus.getContainerId() + ", state=" + containerStatus.getState() + ", exitStatus=" + containerStatus.getExitStatus() + ", diagnostics=" + containerStatus.getDiagnostics());
988: Jian He, info, IfStmt, LOG.info("Ignoring completed status of " + containerStatus.getContainerId() + "; unknown container(probably launched by previous attempt)");
1021: Bikas Saha, info, IfStmt, LOG.info("Container completed successfully." + ", containerId=" + containerStatus.getContainerId());
1063: Bikas Saha, info, MethodDeclaration, LOG.info("Got response from RM for container ask, allocatedCnt=" + allocatedContainers.size());
1074: Billie Rinaldi, info, IfStmt, LOG.info("Launching shell command on a new container." + ", containerId=" + allocatedContainer.getId() + ", yarnShellId=" + yarnShellId + ", containerNode=" + allocatedContainer.getNodeId().getHost() + ":" + allocatedContainer.getNodeId().getPort() + ", containerNodeURI=" + allocatedContainer.getNodeHttpAddress() + ", containerResourceMemory" + allocatedContainer.getResource().getMemorySize() + ", containerResourceVirtualCores" + allocatedContainer.getResource().getVirtualCores());
1067: Billie Rinaldi, info, IfStmt, LOG.info("The requested number of containers have been allocated." + " Releasing the extra container allocation from the RM.");
1114: Weiwei Yang, info, ForeachStmt, LOG.info("Container {} updated, updateType={}, resource={}, " + "execType={}", container.getContainer().getId(), container.getUpdateType().toString(), container.getContainer().getResource().toString(), container.getContainer().getExecutionType());
1135: Wangda Tan, info, ForeachStmt, LOG.info("Scheduling Request {} has been rejected. Reason {}", rejReq.getRequest(), rejReq.getReason());
1141: Wangda Tan, info, IfStmt, LOG.info("Exiting, since retries are exhausted !!");
1166: Junping Du, Error, MethodDeclaration, LOG.error("Error in RMCallbackHandler: ", e);
1189: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Succeeded to stop Container " + containerId);
1198: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Container Status: id=" + containerId + ", status=" + containerStatus);
1209: Weiwei Yang, info, IfStmt, LOG.info("Promoting container {} to {}", container.getId(), container.getExecutionType());
1225: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Succeeded to start Container " + containerId);
1247: Daniel Templeton, error, MethodDeclaration, LOG.error("Failed to start Container " + containerId, t);
1256: Vinod Kumar Vavilapalli, error, MethodDeclaration, LOG.error("Failed to query the status of Container " + containerId);
1261: Vinod Kumar Vavilapalli, error, MethodDeclaration, LOG.error("Failed to stop Container " + containerId);
1316: Hitesh Shah, info, MethodDeclaration, LOG.info("Setting up container launch container for containerid=" + container.getId() + " with shellid=" + shellId);
1338: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Not able to add suffix (.bat/.sh) to the shell script filename", e);
1352: Hitesh Shah, Error, CatchClause, LOG.error("Error when trying to use shell script path specified" + " in env, path=" + renamedScriptPath, e);
1430: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("User " + appSubmitterUgi.getUserName() + " added suffix(.sh/.bat) to script file as " + renamedScriptPath);
1452: Hitesh Shah, info, MethodDeclaration, LOG.info("Requested container ask: " + request.toString());
1465: Wangda Tan, info, MethodDeclaration, LOG.info("Scheduling Request made: " + sReq.toString());
1506: Zhijie Shen, error, CatchClause, LOG.error("Container start event could not be published for " + container.getId().toString(), e);
1535: Zhijie Shen, error, CatchClause, LOG.error("Container end event could not be published for " + container.getContainerId().toString(), e);
1570: Zhijie Shen, error, CatchClause, LOG.error("App Attempt " + (appEvent.equals(DSEvent.DS_APP_ATTEMPT_START) ? "start" : "end") + " event could not be published for " + appAttemptID, e);
1584: Jian He, Error, ForeachStmt, LOG.error("Error when publishing entity [" + error.getEntityType() + "," + error.getEntityId() + "], server side error code: " + error.getErrorCode());
1581: Jian He, debug, IfStmt, LOG.debug("Timeline entities are successfully put");
1650: Zhijie Shen, error, CatchClause, LOG.error("Container start event could not be published for " + container.getId().toString(), e instanceof UndeclaredThrowableException ? e.getCause() : e);
1684: Zhijie Shen, error, CatchClause, LOG.error("Container end event could not be published for " + container.getContainerId().toString(), e instanceof UndeclaredThrowableException ? e.getCause() : e);
1720: Zhijie Shen, error, CatchClause, LOG.error("App Attempt " + (appEvent.equals(DSEvent.DS_APP_ATTEMPT_START) ? "start" : "end") + " event could not be published for " + appAttemptID, e instanceof UndeclaredThrowableException ? e.getCause() : e);
267: Akira Ajisaka, Error, CatchClause, LOG.error("Error running Client", t);
254: Arun Murthy, info, TryStmt, LOG.info("Initializing Client");
271: Arun Murthy, info, IfStmt, LOG.info("Application completed successfully");
274: Arun Murthy, error, MethodDeclaration, LOG.error("Application failed to complete successfully");
425: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Can not set up custom log4j properties. " + e);
440: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("keep_containers_across_application_attempts");
630: Siddharth Seth, info, MethodDeclaration, LOG.info("Running Client");
634: Arun Murthy, info, MethodDeclaration, LOG.info("Got Cluster metric info from ASM" + ", numNodeManagers=" + clusterMetrics.getNumNodeManagers());
639: Arun Murthy, info, MethodDeclaration, LOG.info("Got Cluster node info from ASM");
641: Arun Murthy, info, ForeachStmt, LOG.info("Got node report from ASM for" + ", nodeId=" + node.getNodeId() + ", nodeAddress=" + node.getHttpAddress() + ", nodeRackName=" + node.getRackName() + ", nodeNumContainers=" + node.getNumContainers());
649: Arun Murthy, info, MethodDeclaration, LOG.info("Queue info" + ", queueName=" + queueInfo.getQueueName() + ", queueCurrentCapacity=" + queueInfo.getCurrentCapacity() + ", queueMaxCapacity=" + queueInfo.getMaximumCapacity() + ", queueApplicationCount=" + queueInfo.getApplications().size() + ", queueChildQueueCount=" + queueInfo.getChildQueues().size());
659: Arun Murthy, info, ForeachStmt, LOG.info("User ACL Info for Queue" + ", queueName=" + aclInfo.getQueueName() + ", userAcl=" + userAcl.name());
683: Sunil G, error, IfStmt, LOG.error(message);
689: Sunil G, error, IfStmt, LOG.error(message);
704: Akira Ajisaka, info, MethodDeclaration, LOG.info("Max mem capability of resources in this cluster " + maxMem);
708: Arun Murthy, info, IfStmt, LOG.info("AM memory specified above max threshold of cluster. Using max value." + ", specified=" + amMemory + ", max=" + maxMem);
715: Akira Ajisaka, info, MethodDeclaration, LOG.info("Max virtual cores capability of resources in this cluster " + maxVCores);
718: Luke Lu, info, IfStmt, LOG.info("AM virtual cores specified above max threshold of cluster. " + "Using max value." + ", specified=" + amVCores + ", max=" + maxVCores);
763: Arun Murthy, info, MethodDeclaration, LOG.info("Copy App Master jar from local filesystem and add to local environment");
854: Arun Murthy, info, MethodDeclaration, LOG.info("Setting up app master command");
886: Weiwei Yang, info, IfStmt, LOG.info("Encode placement spec: " + encodedSpec);
912: Zhijie Shen, info, MethodDeclaration, LOG.info("Completed setting up app master command " + command.toString());
940: Hitesh Shah, info, ForeachStmt, LOG.info("Got dt for " + fs.getUri() + "; " + token);
1009: Arun Murthy, debug, CatchClause, LOG.debug("Thread sleep in monitoring loop interrupted");
1015: Arun Murthy, info, WhileStmt, LOG.info("Got application report from ASM for" + ", appId=" + appId.getId() + ", clientToAMToken=" + report.getClientToAMToken() + ", appDiagnostics=" + report.getDiagnostics() + ", appMasterHost=" + report.getHost() + ", appQueue=" + report.getQueue() + ", appMasterRpcPort=" + report.getRpcPort() + ", appStartTime=" + report.getStartTime() + ", yarnAppState=" + report.getYarnApplicationState().toString() + ", distributedFinalState=" + report.getFinalApplicationStatus().toString() + ", appTrackingUrl=" + report.getTrackingUrl() + ", appUser=" + report.getUser());
1044: Arun Murthy, info, IfStmt, LOG.info("Application did not finish." + " YarnState=" + state.toString() + ", DSFinalStatus=" + dsStatus.toString() + ". Breaking monitoring loop");
1036: Arun Murthy, info, IfStmt, LOG.info("Application did finished unsuccessfully." + " YarnState=" + state.toString() + ", DSFinalStatus=" + dsStatus.toString() + ". Breaking monitoring loop");
1032: Arun Murthy, info, IfStmt, LOG.info("Application has completed successfully. Breaking monitoring loop");
1051: Arun Murthy, info, IfStmt, LOG.info("Reached client specified timeout for application. Killing application");
1112: Zhijie Shen, warn, IfStmt, LOG.warn("Cannot put the domain " + domainId + " because the timeline service is not enabled");
1129: Zhijie Shen, Error, CatchClause, LOG.error("Error when putting the timeline domain", e);
1126: Zhijie Shen, info, TryStmt, LOG.info("Put the timeline domain: " + TimelineUtils.dumpTimelineRecordtoJSON(domain));
1173: Sunil G, warn, IfStmt, LOG.warn("AM Memory not specified, use " + DEFAULT_AM_MEMORY + " mb as AM memory");
1178: Sunil G, warn, IfStmt, LOG.warn("AM vcore not specified, use " + DEFAULT_AM_VCORES + " mb as AM vcores");
1185: Sunil G, warn, MethodDeclaration, LOG.warn("AM Resource capability=" + capability);
73: Wangda Tan, info, MethodDeclaration, LOG.info("Parsing Placement Specs: [{}]", specs);
80: Weiwei Yang, info, ForeachStmt, LOG.info("Parsed source tag: {}, number of allocations: {}", entry.getKey().getTag(), entry.getKey().getNumOfAllocations());
82: Weiwei Yang, info, ForeachStmt, LOG.info("Parsed constraint: {}", entry.getValue().getConstraintExpr().getClass().getSimpleName());
72: Akira Ajisaka, Error, CatchClause, LOG.error("Error running ApplicationMaster", t);
64: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Initializing ApplicationMaster");
79: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Application Master failed. exiting");
76: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Application Master completed successfully. exiting");
145: Arun Murthy, info, MethodDeclaration, LOG.info("Starting up YARN cluster");
253: Arun Murthy, info, CatchClause, LOG.info("setup thread sleep interrupted. message=" + e.getMessage());
368: Zhijie Shen, info, IfStmt, LOG.info("Setup: Using timeline v2!");
371: Arun Murthy, info, MethodDeclaration, LOG.info("Initializing DS Client");
375: Arun Murthy, info, MethodDeclaration, LOG.info("Running DS Client");
425: Sangjin Lee, info, MethodDeclaration, LOG.info("Client run completed for testDSShell. Result=" + result);
517: Sangjin Lee, info, MethodDeclaration, LOG.info("Started checkTimelineV2 ");
536: Varun Saxena, info, TryStmt, LOG.info("basePath: " + basePath);
784: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client");
789: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Running DS Client");
792: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Client run completed. Result=" + result);
820: XuanGong, info, MethodDeclaration, LOG.info("Initializing DS Client");
827: XuanGong, info, MethodDeclaration, LOG.info("Running DS Client");
830: XuanGong, info, MethodDeclaration, LOG.info("Client run completed. Result=" + result);
858: XuanGong, info, MethodDeclaration, LOG.info("Initializing DS Client");
865: XuanGong, info, MethodDeclaration, LOG.info("Running DS Client");
868: XuanGong, info, MethodDeclaration, LOG.info("Client run completed. Result=" + result);
888: Vinod Kumar Vavilapalli, debug, MethodDeclaration, fileWriter.write("log4j.rootLogger=debug,stdout");
914: Vinod Kumar Vavilapalli, Info, MethodDeclaration, Assert.assertTrue(LOG_Client.isInfoEnabled());
915: Vinod Kumar Vavilapalli, Debug, MethodDeclaration, Assert.assertFalse(LOG_Client.isDebugEnabled());
917: Vinod Kumar Vavilapalli, Info, MethodDeclaration, Assert.assertTrue(LOG_AM.isInfoEnabled());
918: Vinod Kumar Vavilapalli, Debug, MethodDeclaration, Assert.assertFalse(LOG_AM.isDebugEnabled());
920: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client");
925: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Running DS Client");
927: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Client run completed. Result=" + result);
930: Vinod Kumar Vavilapalli, Info, MethodDeclaration, Assert.assertTrue(LOG_Client.isInfoEnabled());
931: Vinod Kumar Vavilapalli, Debug, MethodDeclaration, Assert.assertTrue(LOG_Client.isDebugEnabled());
932: Vinod Kumar Vavilapalli, Info, MethodDeclaration, Assert.assertTrue(LOG_AM.isInfoEnabled());
933: Vinod Kumar Vavilapalli, Debug, MethodDeclaration, Assert.assertTrue(LOG_AM.isDebugEnabled());
955: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client");
960: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Running DS Client");
962: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Client run completed. Result=" + result);
989: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client");
994: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Running DS Client");
996: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Client run completed. Result=" + result);
1037: Zhijie Shen, info, MethodDeclaration, LOG.info("Initializing DS Client");
1042: Zhijie Shen, info, MethodDeclaration, LOG.info("Running DS Client");
1044: Zhijie Shen, info, MethodDeclaration, LOG.info("Client run completed. Result=" + result);
1054: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client with no args");
1063: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client with no jar file");
1082: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client with no shell command");
1101: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client with invalid no. of containers");
1122: Luke Lu, info, MethodDeclaration, LOG.info("Initializing DS Client with invalid no. of vcores");
1148: Zhijie Shen, info, MethodDeclaration, LOG.info("Initializing DS Client with --shell_command and --shell_script");
1176: Zhijie Shen, info, MethodDeclaration, LOG.info("Initializing DS Client without --shell_command and --shell_script");
1200: Weiwei Yang, info, MethodDeclaration, LOG.info("Initializing DS Client with invalid container_type argument");
1286: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client");
1291: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Running DS Client");
1294: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Client run completed. Result=" + result);
1319: Chris Nauroth, info, MethodDeclaration, LOG.info("Initializing DS Client");
1322: Chris Nauroth, info, MethodDeclaration, LOG.info("Running DS Client");
1412: Sunil G, info, ForStmt, LOG.info("Initializing DS Client");
1415: Sunil G, info, ForStmt, LOG.info("Running DS Client");
1501: Sunil G, info, MethodDeclaration, LOG.info("Initializing DS Client");
1504: Sunil G, info, MethodDeclaration, LOG.info("Running DS Client");
112: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing DS Client");
117: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Running DS Client");
119: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Client run completed. Result=" + result);
45: Zhijie Shen, info, IfStmt, LOG.info("NumAllocatedContainers is " + numAllocatedContainers.get() + " and NumRequestedContainers is " + numAllocatedContainers.get() + ".Application Master failed. exiting");
78: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Application Master failed. exiting");
75: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Application Master completed successfully. exiting");
56: XuanGong, info, IfStmt, LOG.info("Application Master failed. exiting");
53: XuanGong, info, IfStmt, LOG.info("Application Master completed successfully. exiting");
114: Akira Ajisaka, Error, CatchClause, LOG.error("Error running Client", t);
107: Arun Murthy, info, TryStmt, LOG.info("Initializing Client");
255: Arun Murthy, Error, CatchClause, LOG.warn("Error reading the error stream", ioe);
269: Arun Murthy, Error, CatchClause, LOG.warn("Error reading the out stream", ioe);
281: Arun Murthy, info, TryStmt, LOG.info("AM process exited with value: " + exitCode);
297: Arun Murthy, info, CatchClause, LOG.info("ShellExecutor: Interrupted while reading the error/out stream", ie);
300: Arun Murthy, Error, CatchClause, LOG.warn("Error while closing the error/out stream", ioe);
306: Arun Murthy, info, MethodDeclaration, LOG.info("Starting Client");
312: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Setting up application submission context for ASM");
335: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Setting unmanaged AM");
338: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Submitting application to ASM");
353: Zhijie Shen, info, IfStmt, LOG.info("Launching AM with application attempt id " + attemptId);
365: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("App ended with state: " + appReport.getYarnApplicationState() + " and status: " + appStatus);
374: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Application did finished unsuccessfully." + " YarnState=" + appState.toString() + ", FinalStatus=" + appStatus.toString());
371: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Application has completed successfully.");
403: Zhijie Shen, info, WhileStmt, LOG.info("Current attempt state of " + appId + " is " + (attemptReport == null ? " N/A " : attemptReport.getYarnApplicationAttemptState()) + ", waiting for current attempt to reach " + attemptState);
409: Zhijie Shen, warn, CatchClause, LOG.warn("Interrupted while waiting for current attempt of " + appId + " to reach " + attemptState);
416: Zhijie Shen, error, IfStmt, LOG.error(errmsg);
454: Arun Murthy, debug, CatchClause, LOG.debug("Thread sleep in monitoring loop interrupted");
460: Arun Murthy, info, WhileStmt, LOG.info("Got application report from ASM for" + ", appId=" + appId.getId() + ", appAttemptId=" + report.getCurrentApplicationAttemptId() + ", clientToAMToken=" + report.getClientToAMToken() + ", appDiagnostics=" + report.getDiagnostics() + ", appMasterHost=" + report.getHost() + ", appQueue=" + report.getQueue() + ", appMasterRpcPort=" + report.getRpcPort() + ", appStartTime=" + report.getStartTime() + ", yarnAppState=" + report.getYarnApplicationState().toString() + ", distributedFinalState=" + report.getFinalApplicationStatus().toString() + ", appTrackingUrl=" + report.getTrackingUrl() + ", appUser=" + report.getUser());
484: Zhijie Shen, warn, IfStmt, LOG.warn("Waited " + AM_STATE_WAIT_TIMEOUT_MS / 1000 + " seconds after process completed for AppReport" + " to reach desired final state. Not waiting anymore." + "CurrentState = " + state + ", ExpectedStates = " + expectedFinalState.toString());
60: Arun Murthy, info, MethodDeclaration, LOG.info("Starting up YARN cluster");
69: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MiniYARN ResourceManager published address: " + yarnClusterConfig.get(YarnConfiguration.RM_ADDRESS));
71: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("MiniYARN ResourceManager published web address: " + yarnClusterConfig.get(YarnConfiguration.RM_WEBAPP_ADDRESS));
76: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Yarn webapp is at " + webapp);
96: Arun Murthy, info, CatchClause, LOG.info("setup thread sleep interrupted. message=" + e.getMessage());
112: Arun Murthy, info, MethodDeclaration, LOG.info("Trying to generate classpath for app master from current thread's classpath");
131: Akira Ajisaka, error, IfStmt, LOG.error("JAVA_HOME not defined. Test not running.");
145: Arun Murthy, info, MethodDeclaration, LOG.info("Initializing Launcher");
160: Arun Murthy, info, MethodDeclaration, LOG.info("Running Launcher");
163: Arun Murthy, info, MethodDeclaration, LOG.info("Launcher run completed. Result=" + result);
173: Akira Ajisaka, error, IfStmt, LOG.error("JAVA_HOME not defined. Test not running.");
187: Bikas Saha, info, MethodDeclaration, LOG.info("Initializing Launcher");
192: Bikas Saha, info, MethodDeclaration, LOG.info("Running Launcher");
95: Billie Rinaldi, info, MethodDeclaration, LOG.info("Instantiated ClientAMService at " + bindAddress);
113: Billie Rinaldi, info, ForeachStmt, LOG.info("Flexing component {} to {}", component.getName(), component.getNumberOfContainers());
130: Jian He, info, MethodDeclaration, LOG.info("Stop the service by {}", UserGroupInformation.getCurrentUser());
144: Billie Rinaldi, error, CatchClause, LOG.error("Interrupted while stopping", e);
162: Eric Yang, info, TryStmt, LOG.info("Upgrading service to version {} by {}", request.getVersion(), UserGroupInformation.getCurrentUser());
176: Eric Yang, info, MethodDeclaration, LOG.info("Restart service by {}", UserGroupInformation.getCurrentUser());
190: Eric Yang, info, ForeachStmt, LOG.info("Upgrade container {}", containerId);
76: Billie Rinaldi, info, IfStmt, LOG.info("[COMPONENT {}]: Failed {} times on this host, blacklisted {}." + " Current list of blacklisted nodes: {}", component.getName(), num, host, blackListedNodes);
87: Billie Rinaldi, info, MethodDeclaration, LOG.info("[COMPONENT {}]: Clearing blacklisted nodes {} ", component.getName(), blackListedNodes);
115: Eric Yang, error, CatchClause, LOG.error(MessageFormat.format("[SERVICE]: Invalid event {1} at {2}.", event.getType(), oldState), e);
120: Eric Yang, info, IfStmt, LOG.info("[SERVICE] Transitioned from {} to {} on {} event.", oldState, getState(), event.getType());
153: Eric Yang, error, CatchClause, LOG.error("[SERVICE]: Upgrade to version {} failed", event.getVersion(), e);
176: Eric Yang, info, IfStmt, LOG.info("Service def state changed from {} -> {}", currState, serviceManager.serviceSpec.getState());
205: Eric Yang, error, CatchClause, LOG.error("Upgrade did not complete because unable to re-write the" + " service definition", e);
213: Eric Yang, warn, CatchClause, LOG.warn("Unable to delete upgrade definition for service {} " + "version {}", getName(), upgradeVersion);
106: Billie Rinaldi, info, MethodDeclaration, LOG.info("Service AppAttemptId: " + attemptId);
140: Eric Yang, info, WhileStmt, LOG.info(token.toString());
163: Eric Yang, info, IfStmt, LOG.info("No keytab localized at " + keytab);
171: Eric Yang, info, IfStmt, LOG.info("Using pre-installed keytab from localhost: " + preInstalledKeytab);
177: Eric Yang, info, IfStmt, LOG.info("No keytab exists: " + keytab);
184: Eric Yang, info, IfStmt, LOG.info("No principal name specified.  Will use AM " + "login identity {} to attempt keytab-based login", principal);
190: Eric Yang, info, MethodDeclaration, LOG.info("User before logged in is: " + UserGroupInformation.getCurrentUser());
198: Eric Yang, info, MethodDeclaration, LOG.info("User after logged in is: " + UserGroupInformation.getCurrentUser());
209: Eric Yang, error, IfStmt, LOG.error("AM is not holding on a keytab in a secure deployment:" + " service will fail when tokens expire");
219: Eric Yang, info, IfStmt, LOG.info("Remove HDFS delegation token {}.", token);
244: Billie Rinaldi, info, MethodDeclaration, LOG.info(context.service.toString());
249: Eric Yang, info, MethodDeclaration, LOG.info("Starting service as user " + UserGroupInformation.getCurrentUser());
260: Billie Rinaldi, info, MethodDeclaration, LOG.info("Stopping app master");
294: Eric Yang, info, IfStmt, LOG.info("Service state changed from {} -> {}", curState, scheduler.getApp().getState());
301: Billie Rinaldi, info, ForeachStmt, LOG.info("{} = {}", envs.getKey(), envs.getValue());
324: Billie Rinaldi, Error, CatchClause, LOG.error("Error starting service master", t);
181: Eric Yang, info, IfStmt, LOG.info("Set registry user accounts: sasl:" + username);
228: Billie Rinaldi, info, IfStmt, LOG.info("Timeline v2 is enabled.");
276: Billie Rinaldi, info, MethodDeclaration, LOG.info("Stopping service scheduler");
300: Eric Yang, info, IfStmt, LOG.info("Service {} unregistered with RM, with attemptId = {} " + ", diagnostics = {} ", app.getName(), context.attemptId, diagnostics);
340: Jian He, info, IfStmt, LOG.info("Triggering initial evaluation of component {}", component.getName());
352: Jian He, info, MethodDeclaration, LOG.info("Received {} containers from previous attempt.", containersFromPrevAttempt.size());
361: Jian He, info, CatchClause, LOG.info("Could not read component paths: {}", e.getMessage());
358: Jian He, info, TryStmt, LOG.info("Found {} containers from ZK registry: {}", existingComps.size(), existingComps);
370: Jian He, warn, CatchClause, LOG.warn("Could not resolve record for component {}: {}", existingComp, e);
376: Billie Rinaldi, info, ForeachStmt, LOG.info("Handling {} from previous attempt", container.getId());
389: Jian He, info, IfStmt, LOG.info("Record not found in registry for container {} from previous" + " attempt, releasing", container.getId());
421: Jian He, info, LambdaExpr, LOG.info("{}, wait on container {} expired", instance.getCompInstanceId(), containerId);
494: Billie Rinaldi, info, MethodDeclaration, LOG.info("Registering " + attemptId + ", " + service.getName() + " into registry");
518: Billie Rinaldi, error, CatchClause, LOG.error("Failed to register app " + app.getName() + " in registry", e);
507: Billie Rinaldi, info, TryStmt, LOG.info("Registered service under {}; absolute path {}", yarnRegistryOperations.getSelfRegistrationPath(), yarnRegistryOperations.getAbsoluteSelfRegistrationPath());
556: Eric Yang, error, CatchClause, LOG.error(MessageFormat.format("[SERVICE]: Error in handling event type {0}", event.getType()), t);
570: Billie Rinaldi, error, IfStmt, LOG.error("No component exists for " + event.getName());
576: Billie Rinaldi, error, CatchClause, LOG.error(MessageFormat.format("[COMPONENT {0}]: Error in handling event type {1}", component.getName(), event.getType()), t);
590: Billie Rinaldi, error, IfStmt, LOG.error("No component instance exists for " + event.getContainerId());
596: Billie Rinaldi, error, CatchClause, LOG.error(instance.getCompInstanceId() + ": Error in handling event type " + event.getType(), t);
606: Billie Rinaldi, info, MethodDeclaration, LOG.info(containers.size() + " containers allocated. ");
616: Billie Rinaldi, info, TryStmt, LOG.info("[COMPONENT {}]: remove {} outstanding container requests " + "for allocateId " + container.getAllocationRequestId(), comp.getName(), requests.size());
654: Jian He, info, IfStmt, LOG.info("Not waiting to recover container {}, releasing", container.getId());
667: Jian He, warn, IfStmt, LOG.warn("Container {} Completed. No component instance exists. exitStatus={}. diagnostics={} ", containerId, status.getExitStatus(), status.getDiagnostics());
695: Billie Rinaldi, warn, MethodDeclaration, LOG.warn(str.toString());
713: Billie Rinaldi, Error, MethodDeclaration, LOG.error("Error in AMRMClient callback handler ", e);
719: Wangda Tan, Error, MethodDeclaration, LOG.error("Error in AMRMClient callback handler. Following scheduling " + "requests were rejected: {}", rejectedSchedulingRequests);
730: Billie Rinaldi, error, IfStmt, LOG.error("No component instance exists for " + containerId);
752: Billie Rinaldi, error, IfStmt, LOG.error("No component instance exists for " + containerId);
755: Billie Rinaldi, error, MethodDeclaration, LOG.error("Failed to start " + containerId, t);
765: Eric Yang, error, IfStmt, LOG.error("No component instance exists for {}", containerId);
778: Eric Yang, error, IfStmt, LOG.error("No component instance exists for {}", containerId);
184: Billie Rinaldi, info, MethodDeclaration, LOG.info("Loading service definition from local FS: " + filePath);
248: Eric Yang, error, IfStmt, LOG.error(message);
257: Eric Yang, error, IfStmt, LOG.error(message);
281: Eric Yang, error, IfStmt, LOG.error("Service {} upgrade to version {} failed because {}", service.getName(), service.getVersion(), responseProto.getError());
309: Eric Yang, error, IfStmt, LOG.error(message);
320: Eric Yang, info, MethodDeclaration, LOG.info("instances to upgrade {}", containerIdsToUpgrade);
395: Billie Rinaldi, warn, IfStmt, LOG.warn(MessageFormat.format("[COMPONENT {0}]: component count goes to negative ({1}{2} = {3})," + " ignore and reset it to 0.", component.getName(), orig, newNumber, ret));
457: Eric Yang, error, IfStmt, LOG.error(message);
466: Billie Rinaldi, error, IfStmt, LOG.error(message);
476: Eric Yang, error, IfStmt, LOG.error(message);
487: Billie Rinaldi, info, ForeachStmt, LOG.info("[COMPONENT {}]: number of containers changed from {} to {}", entry.getKey(), entry.getValue(), componentCounts.get(entry.getKey()));
505: Eric Yang, info, IfStmt, LOG.info("Application ID doesn't exist for service {}", serviceName);
511: Billie Rinaldi, info, IfStmt, LOG.info("Service {} is already in a terminated state {}", serviceName, report.getYarnApplicationState());
520: Billie Rinaldi, info, IfStmt, LOG.info(msg);
527: Billie Rinaldi, info, MethodDeclaration, LOG.info("Stopping service {}, with appId = {}", serviceName, currentAppId);
572: Eric Yang, info, CatchClause, LOG.info("Failed to stop " + serviceName + " gracefully due to: " + e.getMessage() + ", forcefully kill the app.");
540: Billie Rinaldi, info, IfStmt, LOG.info("Forcefully kill the service: " + serviceName);
536: Billie Rinaldi, info, IfStmt, LOG.info("Service " + serviceName + " is being gracefully stopped...");
556: Billie Rinaldi, info, IfStmt, LOG.info("Service " + serviceName + " is stopped.");
561: Billie Rinaldi, info, IfStmt, LOG.info("Stop operation timeout stopping, forcefully kill the app " + serviceName);
568: Billie Rinaldi, info, IfStmt, LOG.info("Waiting for service " + serviceName + " to be stopped.");
602: Billie Rinaldi, info, IfStmt, LOG.info("Service '" + serviceName + "' doesn't exist at hdfs path: " + appDir);
598: Billie Rinaldi, info, IfStmt, LOG.info(message);
593: Billie Rinaldi, info, IfStmt, LOG.info("Successfully deleted service dir for " + serviceName + ": " + appDir);
625: Eric Yang, Error, IfStmt, LOG.error("Error on destroy '" + serviceName + "': error cleaning up " + "registry.");
622: Eric Yang, Error, IfStmt, LOG.error("Error on destroy '" + serviceName + "': not found.");
619: Eric Yang, info, IfStmt, LOG.info("Successfully destroyed service {}", serviceName);
644: Billie Rinaldi, Error, CatchClause, LOG.warn("Error deleting registry entry {}", registryPath, e);
638: Billie Rinaldi, info, IfStmt, LOG.info("Service '" + serviceName + "' doesn't exist at ZK registry path: " + registryPath);
679: Billie Rinaldi, info, IfStmt, LOG.info("Service '" + serviceName + "' doesn't exist at ZK path: " + zkPath);
676: Billie Rinaldi, info, IfStmt, LOG.info("Deleted zookeeper path: " + zkPath);
834: Billie Rinaldi, debug, MethodDeclaration, LOG.debug("Added LocalResource for localization: ");
841: Billie Rinaldi, debug, MethodDeclaration, LOG.debug(builder.toString());
871: Billie Rinaldi, debug, MethodDeclaration, LOG.debug("AM launch command: {}", cmdStr);
890: Billie Rinaldi, debug, IfStmt, LOG.debug("Run as user " + userName);
895: Billie Rinaldi, debug, MethodDeclaration, LOG.debug("AM env: \n{}", stringifyMap(env));
912: Jian He, warn, IfStmt, LOG.warn("Property {} has a value {}, but is not a valid file", YarnServiceConf.DEPENDENCY_TARBALL_PATH, dependencyLibTarGzip);
916: Jian He, info, IfStmt, LOG.info("Uploading all dependency jars to HDFS. For faster submission of" + " apps, set config property {} to the dependency tarball location." + " Dependency tarball can be uploaded to any HDFS path directly" + " or by using command: yarn app -{} [<Destination Folder>]", YarnServiceConf.DEPENDENCY_TARBALL_PATH, ApplicationCLI.ENABLE_FAST_LAUNCH);
908: Jian He, info, IfStmt, LOG.info("Loading lib tar from " + dependencyLibTarGzip);
952: Billie Rinaldi, warn, IfStmt, LOG.warn("AM log4j property file doesn't exist: " + localFile);
976: Eric Yang, info, IfStmt, LOG.info("Finalize service {} upgrade");
973: Eric Yang, info, IfStmt, LOG.info("Persisted service " + service.getName() + " at " + appJson);
1038: Jason Lowe, debug, ForeachStmt, LOG.debug("Got DT: " + token);
1065: Eric Yang, warn, IfStmt, LOG.warn("No Kerberos principal name specified for " + service.getName());
1069: Eric Yang, warn, IfStmt, LOG.warn("No Kerberos keytab specified for " + service.getName());
1084: Eric Yang, warn, IfStmt, LOG.warn(service.getName() + "'s keytab (principalName = " + principalName + ") doesn't exist at: " + keytabOnhdfs);
1092: Eric Yang, debug, SwitchStmt, LOG.debug("Adding " + service.getName() + "'s keytab for " + "localization, uri = " + keytabOnhdfs);
1096: Eric Yang, debug, SwitchStmt, LOG.debug("Using a keytab from localhost: " + keytabURI);
1099: Eric Yang, warn, SwitchStmt, LOG.warn("Unsupported URI scheme " + keytabURI);
1115: Billie Rinaldi, info, MethodDeclaration, LOG.info("Updating lifetime of an service: serviceName = " + serviceName + ", appId = " + appId + ", lifetime = " + lifetime);
1124: Billie Rinaldi, info, MethodDeclaration, LOG.info("Successfully updated lifetime for an service: serviceName = " + serviceName + ", appId = " + appId + ". New expiry time in ISO8601 format is " + newTimeout);
1188: Eric Yang, info, IfStmt, LOG.info("Service {} does not have an application ID", serviceName);
1200: Billie Rinaldi, info, IfStmt, LOG.info("Service {} is at {} state", serviceName, appReport.getYarnApplicationState());
1205: Billie Rinaldi, warn, IfStmt, LOG.warn(serviceName + " AM hostname is empty");
1230: Billie Rinaldi, info, MethodDeclaration, LOG.info("Running command as user {}", currentUser);
1271: Eric Yang, error, CatchClause, LOG.error("Got exception creating tarball and uploading to HDFS", e);
1276: Eric Yang, warn, IfStmt, LOG.warn("Failed to delete tmp file {}", tempLibTarGzipFile);
1266: Eric Yang, info, TryStmt, LOG.info("To let apps use this tarball, in yarn-site set config " + "property {} to {}", YarnServiceConf.DEPENDENCY_TARBALL_PATH, dependencyLibTarGzip);
1294: Eric Yang, error, IfStmt, LOG.error("User must be on the {} or {} list to have permission to " + "upload AM dependency tarball", YarnConfiguration.YARN_ADMIN_ACL, DFSConfigKeys.DFS_ADMIN);
1306: Eric Yang, error, IfStmt, LOG.error("Parent directory {} of {} tarball location {} does not " + "have world read/execute permission", parent, YarnServiceConf.DEPENDENCY_TARBALL_PATH, dependencyLibTarGzip);
234: Eric Yang, info, IfStmt, LOG.info("No health threshold monitor enabled for component {}", componentSpec.getName());
240: Eric Yang, error, IfStmt, LOG.error("Invalid health threshold percent {}% for component {}. Monitor not " + "enabled.", healthThresholdPercent, componentSpec.getName());
260: Eric Yang, error, IfStmt, LOG.error("Invalid health monitor window {} secs for component {}. Monitor not " + "enabled.", window, componentSpec.getName());
267: Eric Yang, error, IfStmt, LOG.error("Invalid health monitor init delay {} secs for component {}. " + "Monitor not enabled.", initDelay, componentSpec.getName());
272: Eric Yang, error, IfStmt, LOG.error("Invalid health monitor poll frequency {} secs for component {}. " + "Monitor not enabled.", pollFrequency, componentSpec.getName());
278: Eric Yang, info, MethodDeclaration, LOG.info("Scheduling the health threshold monitor for component {} with percent " + "= {}%, window = {} secs, poll freq = {} secs, init-delay = {} " + "secs", componentSpec.getName(), healthThresholdPercent, window, pollFrequency, initDelay);
302: Billie Rinaldi, info, IfStmt, LOG.info("[FLEX COMPONENT {}]: Flex deferred because dependencies not" + " satisfied.", component.getName());
308: Billie Rinaldi, info, IfStmt, LOG.info("[INIT COMPONENT " + component.getName() + "]: " + event.getDesired() + " instances.");
348: Billie Rinaldi, info, IfStmt, LOG.info("[FLEX COMPONENT " + component.getName() + "]: already has " + event.getDesired() + " instances, ignoring");
329: Billie Rinaldi, info, IfStmt, LOG.info("[FLEX DOWN COMPONENT " + component.getName() + "]: scaling down from " + before + " to " + event.getDesired());
318: Billie Rinaldi, info, IfStmt, LOG.info("[FLEX UP COMPONENT " + component.getName() + "]: scaling up from " + before + " to " + event.getDesired());
368: Jian He, info, IfStmt, LOG.info("[COMPONENT {}]: Trying to recover {} but event did not " + "specify component instance", component.getName(), container.getId());
382: Billie Rinaldi, info, MethodDeclaration, LOG.info("[COMPONENT {}]: Recovered {} for component instance {} on " + "host {}, num pending component instances reduced to {} ", component.getName(), container.getId(), instance.getCompInstanceName(), container.getNodeId(), component.pendingInstances.size());
453: Eric Yang, info, IfStmt, LOG.info("[COMPONENT {}] state changed from {} -> {}", component.componentSpec.getName(), curState, component.componentSpec.getState());
438: Eric Yang, info, IfStmt, LOG.info("[COMPONENT {}] state changed from {} -> {}", component.componentSpec.getName(), curState, component.componentSpec.getState());
478: Eric Yang, info, IfStmt, LOG.info("Service def state changed from {} -> {}", ServiceState.STABLE, ServiceState.STARTED);
541: Billie Rinaldi, info, IfStmt, LOG.info("[COMPONENT {}]: No pending component instance left, release surplus container {}", getName(), container.getId());
548: Billie Rinaldi, info, MethodDeclaration, LOG.info("[COMPONENT {}]: {} allocated, num pending component instances reduced to {}", getName(), container.getId(), pendingInstances.size());
553: Billie Rinaldi, info, MethodDeclaration, LOG.info("[COMPONENT {}]: Assigned {} to component instance {} and launch on host {} ", getName(), container.getId(), instance.getCompInstanceName(), container.getNodeId());
583: Wangda Tan, info, MethodDeclaration, LOG.info("[COMPONENT {}] Requesting for {} container(s)", componentSpec.getName(), count);
602: Wangda Tan, warn, IfStmt, LOG.warn("Please set memory/vcore in the main section of resource, " + "ignoring this entry=" + resourceName);
691: Wangda Tan, debug, ForeachStmt, LOG.debug("[COMPONENT {}] Placement constraint: {}", componentSpec.getName(), constraint.getConstraintExpr().toString());
696: Wangda Tan, debug, IfStmt, LOG.debug("[COMPONENT {}] Resource sizing: {}", componentSpec.getName(), resourceSizing);
705: Wangda Tan, info, IfStmt, LOG.info("[COMPONENT {}] Submitting scheduling request: {}", componentSpec.getName(), request);
622: Wangda Tan, info, ForStmt, LOG.info("[COMPONENT {}] Submitting container request : {}", componentSpec.getName(), request);
763: Billie Rinaldi, error, IfStmt, LOG.error("Couldn't find dependency {} for {} (should never happen)", dependency, getName());
769: Billie Rinaldi, info, IfStmt, LOG.info("[COMPONENT {}]: Dependency {} not satisfied, only {} of {}" + " instances are ready.", getName(), dependency, dependentComponent.getNumReadyInstances(), dependentComponent.getNumDesiredInstances());
862: Billie Rinaldi, info, MethodDeclaration, LOG.info("[COMPONENT {}]: Reset container failure count from {} to 0.", getName(), currentContainerFailure.get());
915: Billie Rinaldi, error, CatchClause, LOG.error(MessageFormat.format("[COMPONENT {0}]: Invalid event {1} at {2}", componentSpec.getName(), event.getType(), oldState), e);
919: Billie Rinaldi, info, IfStmt, LOG.info("[COMPONENT {}] Transitioned from {} to {} on {} event.", componentSpec.getName(), oldState, getState(), event.getType());
166: Jian He, info, CatchClause, LOG.info("Could not get container creation time, using current time");
266: Billie Rinaldi, warn, IfStmt, LOG.warn(exitDiag);
293: Billie Rinaldi, info, MethodDeclaration, LOG.info(compInstance.getCompInstanceId() + ": {} completed. Reinsert back to pending list and requested " + "a new container." + System.lineSeparator() + " exitStatus={}, diagnostics={}.", event.getContainerId(), event.getStatus().getExitStatus(), event.getStatus().getDiagnostics());
305: Billie Rinaldi, error, CatchClause, LOG.error("Interrupted on sleep while exiting.", e);
347: Billie Rinaldi, error, CatchClause, LOG.error(getCompInstanceId() + ": Invalid event " + event.getType() + " at " + oldState, e);
351: Billie Rinaldi, info, IfStmt, LOG.info(getCompInstanceId() + " Transitioned from " + oldState + " to " + getState() + " on " + event.getType() + " event");
446: Billie Rinaldi, error, CatchClause, LOG.error("Failed to update service record in registry: " + containerId + "");
456: Billie Rinaldi, info, MethodDeclaration, LOG.info(getCompInstanceId() + ": Flexed down by user, destroying.");
470: Billie Rinaldi, info, IfStmt, LOG.info(getCompInstanceId() + " no container is assigned when " + "destroying");
494: Billie Rinaldi, error, CatchClause, LOG.error(getCompInstanceId() + ": Failed to delete registry", e);
514: Billie Rinaldi, warn, CatchClause, LOG.warn(getCompInstanceId() + ": Failed to delete directory", e);
509: Billie Rinaldi, info, IfStmt, LOG.info(getCompInstanceId() + ": Deleted component instance dir: " + compInstanceDir);
505: Billie Rinaldi, error, IfStmt, LOG.error(getCompInstanceId() + ": Failed to delete component instance dir: " + compInstanceDir);
542: Billie Rinaldi, error, CatchClause, LOG.error(instance.compInstanceId + " Failed to get container status on " + nodeId + ", will try again", e);
551: Billie Rinaldi, info, MethodDeclaration, LOG.info(instance.compInstanceId + " IP = " + status.getIPs() + ", host = " + status.getHost() + ", cancel container status retriever");
111: Jian He, debug, MethodDeclaration, log.debug("Completed setting up container command {}", cmdStr);
116: Jian He, debug, IfStmt, log.debug("Environment variables");
118: Jian He, debug, ForeachStmt, log.debug("    \"{}\"=\"{}\"", envPair.getKey(), envPair.getValue());
125: Jian He, debug, IfStmt, log.debug("Service Data size");
127: Jian He, debug, ForeachStmt, log.debug("\"{}\"=> {} bytes of data", entry.getKey(), entry.getValue().array().length);
166: Jian He, info, IfStmt, log.info("yarn docker env var has been set {}", containerLaunchContext.getEnvironment().toString());
185: Jian He, debug, IfStmt, log.debug("{} resources: ", localResources.size());
190: Billie Rinaldi, debug, ForeachStmt, log.debug(key + "=" + ServiceUtils.stringify(val.getResource()));
119: Billie Rinaldi, error, CatchClause, LOG.error(instance.getCompInstanceId() + ": Failed to launch container. ", e);
113: Eric Yang, info, IfStmt, LOG.info("reInitializing container {}", container.getId());
108: Eric Yang, info, IfStmt, LOG.info("launching container {}", container.getId());
60: Eric Yang, debug, MethodDeclaration, LOG.debug("ComponentHealthThresholdMonitor run method");
135: Eric Yang, debug, IfStmt, LOG.debug(logMsg, component.getName(), healthThresholdPercent, readyContainerPercentStr, readyContainerCount, desiredContainerCount);
131: Eric Yang, info, IfStmt, LOG.info(logMsg, component.getName(), healthThresholdPercent, readyContainerPercentStr, readyContainerCount, desiredContainerCount);
144: Eric Yang, info, IfStmt, LOG.info("[COMPONENT {}] Health recovered above threshold at ts = {} ({})", component.getName(), date.getTime(), date);
88: Eric Yang, info, IfStmt, LOG.info("[COMPONENT {}] Health has gone below threshold. Starting health " + "threshold timer at ts = {} ({})", component.getName(), date.getTime(), date);
96: Eric Yang, warn, IfStmt, LOG.warn("[COMPONENT {}] Current health {}% is below health threshold of " + "{}% for {} secs (threshold window = {} secs)", component.getName(), readyContainerPercentStr, healthThresholdPercent, elapsedTimeSecs, healthThresholdWindowSecs);
102: Eric Yang, warn, IfStmt, LOG.warn("[COMPONENT {}] Current health {}% has been below health " + "threshold of {}% for {} secs (threshold window = {} secs)", component.getName(), readyContainerPercentStr, healthThresholdPercent, elapsedTimeSecs, healthThresholdWindowSecs);
116: Eric Yang, warn, IfStmt, LOG.warn(exitDiag);
123: Eric Yang, error, CatchClause, LOG.error("Interrupted on sleep while exiting.", e);
120: Eric Yang, info, IfStmt, LOG.info("Readiness check failed for {}: {}", instance.getCompInstanceName(), status);
113: Eric Yang, info, IfStmt, LOG.info("Readiness check succeeded for {}: {}", instance.getCompInstanceName(), status);
134: Billie Rinaldi, info, IfStmt, LOG.info("[COMPONENT {}]: Dependencies satisfied, ramping up.", component.getName());
105: Jian He, error, CatchClause, log.info(error, e);
97: Jian He, error, IfStmt, log.info(error);
91: Jian He, error, CatchClause, log.debug(error, e);
82: Billie Rinaldi, debug, IfStmt, log.debug(instance.getCompInstanceName() + ": Connecting " + sockAddr.toString() + ", timeout=" + MonitorUtils.millisToHumanTime(timeout));
59: Jian He, debug, IfStmt, LOG.debug("Loading service provider type default");
62: Jian He, debug, MethodDeclaration, LOG.debug("Loading service provider type {}", artifact.getType());
191: Billie Rinaldi, info, IfStmt, log.info("Component instance conf dir already exists: " + compInstanceDir);
187: Billie Rinaldi, info, IfStmt, log.info(instance.getCompInstanceId() + ": Creating dir on hdfs: " + compInstanceDir);
195: Billie Rinaldi, debug, IfStmt, log.debug("Tokens substitution for component instance: " + instance.getCompInstanceName() + System.lineSeparator() + tokensForSubstitution);
224: Billie Rinaldi, info, IfStmt, log.info("Saving config file on hdfs for component " + instance.getCompInstanceName() + ": " + configFile);
241: Billie Rinaldi, info, SwitchStmt, log.info("Not supporting loading src_file for " + configFile);
315: Billie Rinaldi, info, IfStmt, log.info("Added file for localization: " + symlink + " -> " + localResource.getResource().getFile());
310: Billie Rinaldi, info, IfStmt, log.info("Added file for localization: " + symlink + " -> " + localResource.getResource().getFile() + ", dest mount path: " + destFile);
348: Billie Rinaldi, info, IfStmt, log.info("Component instance = " + instance.getCompInstanceName() + ", config file already exists: " + remoteFile);
363: Billie Rinaldi, info, CatchClause, log.info("Failed to load config file: " + configFile, e);
390: Billie Rinaldi, info, TryStmt, log.info("Reading config from: " + configFile.getSrcFile() + ", writing to: " + remoteFile);
405: Billie Rinaldi, info, CatchClause, log.info("Failed to load config file: " + configFile, e);
414: Billie Rinaldi, info, CatchClause, log.info("Failed to create " + remoteFile);
43: Jian He, info, MethodDeclaration, log.info("Adding resource {}", artifact);
159: Jian He, info, MethodDeclaration, LOG.info("Resolving path {}", path);
225: Billie Rinaldi, info, MethodDeclaration, LOG.info(instanceId + ": Deleting registry path " + path);
59: Jian He, warn, IfStmt, log.warn("ServiceTimelinePublisher has stopped. " + "Not publishing any more metrics to ATS.");
88: Jian He, debug, IfStmt, log.debug("Publishing Component metrics. " + record);
81: Jian He, debug, IfStmt, log.debug("Publishing service metrics. " + record);
375: Jian He, Error, CatchClause, log.error("Error when publishing entity " + entity, e);
365: Jian He, debug, IfStmt, log.debug("Publishing the entity " + entity + ", JSON-style content: " + TimelineUtils.dumpTimelineRecordtoJSON(entity));
371: Jian He, error, IfStmt, log.error("Seems like client has been removed before the entity " + "could be published for " + entity);
181: Jian He, debug, CatchClause, log.debug("looking for API {}", api, e);
118: Billie Rinaldi, debug, IfStmt, log.debug("failed to find {} on the classpath", resource);
115: Billie Rinaldi, debug, IfStmt, log.debug("loaded resources from {}", resURL);
220: Jian He, debug, MethodDeclaration, log.debug("mkdir {} with perms {}", dir, clusterPerms);
257: Jian He, error, IfStmt, log.error("Dir {} exists: {}", clusterDirectory, listFSDir(clusterDirectory));
285: Jian He, warn, CatchClause, log.warn("Failed to create file {}: {}", tempFile, e);
461: Jian He, debug, MethodDeclaration, log.debug("Copying {} (size={} bytes) to {}", localFile, localFile.length(), destPath);
499: Jian He, info, MethodDeclaration, log.info("Copying file {} to {}", localPath.toURI(), destPath);
512: Jian He, info, MethodDeclaration, log.info("Copying file {} to {}", hdfsPath.toUri(), destFile.toURI());
89: Jian He, error, CatchClause, log.error("Exception while parsing json : " + e + "\n" + json, e);
107: Jian He, error, CatchClause, log.error("Exception while parsing json file {}", absoluteFile, e);
127: Jian He, error, CatchClause, log.error("Exception while parsing json resource {}", resource, e);
142: Jian He, error, CatchClause, log.error("Exception while parsing json input stream", e);
157: Jian He, info, IfStmt, LOG.info("Marking {} for removal", comp.getName());
177: Jian He, info, IfStmt, LOG.info("Adding component {} from external {}", c.getName(), comp.getName());
168: Jian He, info, IfStmt, LOG.info("Merging external component {} from external {}", c.getName(), comp.getName());
235: Billie Rinaldi, info, IfStmt, LOG.info("The supplied Docker client config is " + dockerClientConfig);
322: Billie Rinaldi, info, MethodDeclaration, LOG.info("Loading service definition from " + serviceJson);
330: Eric Yang, info, MethodDeclaration, LOG.info("Loading service definition from {}", versionedDef);
336: Billie Rinaldi, info, MethodDeclaration, LOG.info("Loading service definition from " + appDefPath);
494: Eric Yang, info, MethodDeclaration, LOG.info("Persisted service {} version {} at {}", service.getName(), service.getVersion(), appJson);
110: Eric Yang, error, CatchClause, LOG.error("Got exception when performing DNS lookup", e);
142: Jian He, info, IfStmt, log.info("could not locate JAR containing {} URL={}", my_class, url);
405: Billie Rinaldi, debug, MethodDeclaration, log.debug("Loading all dependencies from {}", srcPath);
415: Eric Yang, debug, IfStmt, log.debug("File does not exist, skipping: " + jarFile);
494: Gour Saha, info, MethodDeclaration, log.info("Tar-gzipping folders {} to {}", libDirs, tarGzipFile.getAbsolutePath());
125: Jian He, info, MethodDeclaration, LOG.info("Service path: {}", path);
176: Jian He, info, IfStmt, LOG.info("Allocated container {} ", c.getId());
165: Jian He, info, IfStmt, LOG.info("Allocating........ no containers");
155: Jian He, info, MethodDeclaration, LOG.info("Starting up YARN cluster");
191: Eric Yang, info, MethodDeclaration, LOG.info("ZK cluster: " + zkCluster.getConnectString());
234: Jian He, info, IfStmt, LOG.info("Write yarn-site.xml configs to: " + url);
245: Jian He, info, CatchClause, LOG.info("setup thread sleep interrupted. message=" + e.getMessage());
86: Jian He, info, MethodDeclaration, LOG.info("ZK cluster: {}", zkCluster.getConnectString());
124: Jian He, info, MethodDeclaration, LOG.info("Fail the container 1");
260: Billie Rinaldi, error, CatchClause, LOG.error("service attributes specified should be valid here", e);
133: Billie Rinaldi, info, MethodDeclaration, LOG.info("Stop the service");
146: Billie Rinaldi, info, MethodDeclaration, LOG.info("Destroy the service");
338: Jian He, info, MethodDeclaration, LOG.info("Restart the resource manager");
351: Jian He, info, MethodDeclaration, LOG.info("Fail the application attempt {}", applicationAttemptId);
370: Jian He, info, MethodDeclaration, LOG.info("Stop/destroy service {}", exampleApp);
415: Eric Yang, info, MethodDeclaration, LOG.info("Stop/destroy service {}", service);
512: Wangda Tan, info, MethodDeclaration, LOG.info("Stop/destroy service {}", exampleApp);
686: Eric Yang, info, MethodDeclaration, LOG.info("Destroy service {}", exampleApp);
705: Billie Rinaldi, info, MethodDeclaration, LOG.info("containerList: " + containerList);
792: Billie Rinaldi, info, TryStmt, LOG.info("Num Components " + retrievedApp.getComponents().size());
794: Billie Rinaldi, info, ForeachStmt, LOG.info("looking for  " + component.getName());
795: Jian He, info, ForeachStmt, LOG.info(component.toString());
810: Billie Rinaldi, info, IfStmt, LOG.info(component.getName() + " Expected number of containers " + exampleApp.getComponent(component.getName()).getNumberOfContainers() + ", current = " + component.getContainers());
800: Billie Rinaldi, info, ForeachStmt, LOG.info("Container state " + container.getState() + ", component " + component.getName());
806: Billie Rinaldi, info, IfStmt, LOG.info("Found 1 ready container " + container.getId());
817: Billie Rinaldi, info, TryStmt, LOG.info("Exit loop, totalReadyContainers= " + totalReadyContainers + " expected = " + expectedTotalContainers);
90: Eric Yang, info, MethodDeclaration, LOG.info("running CLI: yarn {}", Arrays.asList(args));
144: Eric Yang, debug, ConstructorDeclaration, LOG.debug("mocking service client for {}", appId);
69: Jian He, info, MethodDeclaration, LOG.info("worker = {}", worker);
84: Jian He, info, MethodDeclaration, LOG.info("global = {}", global);
107: Jian He, info, MethodDeclaration, LOG.info("master = {}", master);
125: Jian He, info, MethodDeclaration, LOG.info("worker = {}", worker);
190: Jian He, info, MethodDeclaration, LOG.info("worker = {}", worker);
127: Jian He, debug, CatchClause, LOG.debug("Fail to connect to: " + host, e);
112: Jian He, debug, CatchClause, LOG.debug("Fail to resolve username: {}", e);
212: Billie Rinaldi, error, IfStmt, LOG.error("Authentication required");
216: Jian He, error, IfStmt, LOG.error("YARN Service is unavailable or disabled.");
232: Billie Rinaldi, error, IfStmt, LOG.error(output);
229: Billie Rinaldi, info, IfStmt, LOG.info(output);
284: Billie Rinaldi, info, MethodDeclaration, LOG.info("Loading service definition from local FS: " + filePath);
319: Billie Rinaldi, error, CatchClause, LOG.error("Fail to launch application: ", e);
342: Billie Rinaldi, error, CatchClause, LOG.error("Fail to stop application: ", e);
365: Billie Rinaldi, error, CatchClause, LOG.error("Fail to start application: ", e);
392: Billie Rinaldi, error, CatchClause, LOG.error("Fail to save application: ", e);
411: Billie Rinaldi, error, CatchClause, LOG.error("Fail to destroy application: ", e);
443: Billie Rinaldi, error, CatchClause, LOG.error("Fail to flex application: ", e);
498: Billie Rinaldi, error, CatchClause, LOG.error("Fail to check application status: ", e);
520: Eric Yang, error, CatchClause, LOG.error("Failed to upgrade application: ", e);
544: Eric Yang, error, CatchClause, LOG.error("Failed to upgrade component instance: ", e);
112: Wangda Tan, info, IfStmt, LOG.info("System Service Directory is configured to {}", systemServiceDir);
118: Wangda Tan, Info, IfStmt, LOG.info("UserGroupInformation initialized to {}", loginUGI);
135: Wangda Tan, info, MethodDeclaration, LOG.info("Stopping {}", getName());
143: Wangda Tan, warn, CatchClause, LOG.warn("Interrupted Exception while stopping", ie);
183: Wangda Tan, warn, CatchClause, LOG.warn("System service launcher thread interrupted", e);
186: Wangda Tan, Error, CatchClause, LOG.error("Error while submitting services for user " + user, e);
192: Wangda Tan, Error, CatchClause, LOG.warn("Error while closing serviceClient for user {}", user);
169: Wangda Tan, info, ForeachStmt, LOG.info("POST: createService = {} user = {}", service, userUgi);
178: Wangda Tan, error, IfStmt, LOG.error(message, e);
174: Wangda Tan, warn, IfStmt, LOG.warn(e.getCause().getMessage());
235: Wangda Tan, info, IfStmt, LOG.info("Service {} submitted with Application ID: {}", service.getName(), applicationId);
224: Wangda Tan, info, IfStmt, LOG.info("Service {} version {} saved.", service.getName(), service.getVersion());
278: Wangda Tan, warn, CatchClause, LOG.warn("System service directory {} doesn't not exist.", systemServiceDir);
260: Wangda Tan, info, TryStmt, LOG.info("Scan for launch type on {}", systemServiceDir);
265: Wangda Tan, debug, IfStmt, LOG.debug("Scanner skips for unknown file {}", launchType.getPath());
274: Wangda Tan, debug, IfStmt, LOG.debug("Scanner skips for unknown dir {}.", launchType.getPath());
288: Wangda Tan, info, MethodDeclaration, LOG.info("Scan for users on {}", userDirPath);
294: Wangda Tan, info, IfStmt, LOG.info("Service definition {} doesn't belong to any user. Ignoring.. ", userDir.getPath().getName());
300: Wangda Tan, info, WhileStmt, LOG.info("Scanning service definitions for user {}.", userName);
308: Wangda Tan, info, IfStmt, LOG.info("Scanner skips for unknown dir {}", filename);
312: Wangda Tan, info, IfStmt, LOG.info("Scanner skips for unknown file extension, filename = {}", filename);
332: Sunil G, info, IfStmt, LOG.info("Added service {} for the user {}, filename = {}", service.getName(), userName, filename);
328: Wangda Tan, warn, IfStmt, LOG.warn("Ignoring service {} for the user {} as it is already present," + " filename = {}", service.getName(), userName, filename);
348: Wangda Tan, Error, CatchClause, LOG.info("Error while loading service definition from FS: {}", e);
344: Wangda Tan, debug, IfStmt, LOG.debug("Loading service definition from FS: " + filePath);
108: Billie Rinaldi, info, MethodDeclaration, LOG.info(version);
164: Billie Rinaldi, error, CatchClause, LOG.error(message, e);
169: Billie Rinaldi, error, CatchClause, LOG.error(message, e);
121: Billie Rinaldi, info, TryStmt, LOG.info("POST: createService = {} user = {}", service, ugi);
208: Billie Rinaldi, error, CatchClause, LOG.error("Get service failed: {}", e);
211: Billie Rinaldi, error, CatchClause, LOG.error("Get service failed: {}", e);
192: Billie Rinaldi, info, TryStmt, LOG.info("GET: getService for appName = {} user = {}", appName, ugi);
236: Billie Rinaldi, error, CatchClause, LOG.error("Fail to stop service: {}", e);
242: Billie Rinaldi, error, CatchClause, LOG.error("Fail to stop service: {}", e);
228: Billie Rinaldi, info, TryStmt, LOG.info("DELETE: deleteService for appName = {} user = {}", appName, ugi);
263: Eric Yang, info, CatchClause, LOG.info("Got exception stopping service", e);
260: Eric Yang, info, IfStmt, LOG.info("Successfully stopped service {}", appName);
269: Eric Yang, info, IfStmt, LOG.info("Successfully deleted service {}", appName);
423: Billie Rinaldi, error, CatchClause, LOG.error(message, e);
427: Billie Rinaldi, error, CatchClause, LOG.error(message, e);
431: Billie Rinaldi, error, CatchClause, LOG.error(message, e);
379: Billie Rinaldi, info, TryStmt, LOG.info("PUT: updateService for app = {} with data = {} user = {}", appName, updateServiceData, ugi);
451: Eric Yang, info, TryStmt, LOG.info("PUT: update component instance {} for component = {}" + " service = {} user = {}", compInstanceName, componentName, serviceName, ugi);
515: Eric Yang, info, IfStmt, LOG.info("PUT: upgrade component instances {} for service = {} " + "user = {}", toUpgrade, serviceName, ugi);
561: Billie Rinaldi, info, IfStmt, LOG.info(message);
606: Billie Rinaldi, info, MethodDeclaration, LOG.info("Successfully started service " + appName);
624: Eric Yang, info, MethodDeclaration, LOG.info("Service {} version {} upgrade initialized", service.getName(), service.getVersion());
65: Jian He, error, CatchClause, logger.error("Got exception starting", e);
78: Billie Rinaldi, info, MethodDeclaration, logger.info("YARN API server running on " + bindAddress);
157: Billie Rinaldi, error, CatchClause, logger.error("Hadoop HttpServer2 App **failed**", ex);
143: Billie Rinaldi, info, TryStmt, logger.info("Service starting up. Logging start...");
145: Billie Rinaldi, info, TryStmt, logger.info("Server status = {}", apiServer.toString());
148: Billie Rinaldi, info, ForeachStmt, logger.info("Configurations = {}", conf);
150: Billie Rinaldi, info, TryStmt, logger.info("Context Path = {}", Collections.singletonList(apiServer.getWebAppContext().getContextPath()));
152: Billie Rinaldi, info, TryStmt, logger.info("ResourceBase = {}", Collections.singletonList(apiServer.getWebAppContext().getResourceBase()));
154: Billie Rinaldi, info, TryStmt, logger.info("War = {}", Collections.singletonList(apiServer.getWebAppContext().getWar()));
849: Zhijie Shen, debug, IfStmt, LOG.debug("Check the condition for main loop.");
854: Zhijie Shen, info, IfStmt, LOG.info("Exits the main loop.");
858: Zhijie Shen, info, IfStmt, LOG.info("Waiting in main loop.");
457: Zhijie Shen, debug, IfStmt, LOG.debug("Check the condition for main loop.");
462: Zhijie Shen, info, IfStmt, LOG.info("Exits the main loop.");
466: Zhijie Shen, info, IfStmt, LOG.info("Waiting in main loop.");
145: Bikas Saha, Error, CatchClause, LOG.error("Error joining with heartbeat thread", ex);
308: Zhijie Shen, info, CatchClause, LOG.info("Shutdown requested. Stopping callback.");
311: Bikas Saha, error, CatchClause, LOG.error("Exception on heartbeat", ex);
320: Zhijie Shen, debug, CatchClause, LOG.debug("Interrupted while waiting to put on response queue", ex);
328: Bikas Saha, debug, CatchClause, LOG.debug("Heartbeater interrupted", ex);
349: Daniel Templeton, debug, CatchClause, LOG.debug("Interrupted while waiting for queue", ex);
138: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Upper bound of the thread pool size is " + maxThreadPoolSize);
167: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Returning, thread interrupted", e);
191: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Set NMClientAsync thread pool size to " + newThreadPoolSize + " as the number of nodes to talk to is " + nodeNum);
225: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("The thread of " + eventDispatcherThread.getName() + " didn't finish normally.", e);
257: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exception when scheduling the event of starting Container " + container.getId());
266: Wangda Tan, error, IfStmt, LOG.error("Callback handler does not implement container resource " + "increase callback methods");
281: Wangda Tan, warn, CatchClause, LOG.warn("Exception when scheduling the event of increasing resource of " + "Container " + container.getId());
290: Arun Suresh, error, IfStmt, LOG.error("Callback handler does not implement container resource " + "increase callback methods");
305: Arun Suresh, warn, CatchClause, LOG.warn("Exception when scheduling the event of increasing resource of " + "Container " + container.getId());
315: Jian He, error, IfStmt, LOG.error("Callback handler does not implement container re-initialize " + "callback methods");
330: Jian He, warn, CatchClause, LOG.warn("Exception when scheduling the event of re-initializing of " + "Container " + containerId);
339: Jian He, error, IfStmt, LOG.error("Callback handler does not implement container restart " + "callback methods");
354: Jian He, warn, CatchClause, LOG.warn("Exception when scheduling the event of restart of " + "Container " + containerId);
363: Jian He, error, IfStmt, LOG.error("Callback handler does not implement container rollback " + "callback methods");
378: Jian He, warn, CatchClause, LOG.warn("Exception when scheduling the event Rollback re-initialization" + " of Container " + containerId);
387: Jian He, error, IfStmt, LOG.error("Callback handler does not implement container commit last " + "re-initialization callback methods");
402: Jian He, warn, CatchClause, LOG.warn("Exception when scheduling the event Commit re-initialization" + " of Container " + containerId);
418: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exception when scheduling the event of stopping Container " + containerId);
429: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exception when scheduling the event of querying the status" + " of Container " + containerId);
635: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Unchecked exception is thrown from onContainerStarted for " + "Container " + containerId, thr);
655: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Unchecked exception is thrown from onStartContainerError for " + "Container " + event.getContainerId(), thr);
673: Wangda Tan, error, IfStmt, LOG.error("Callback handler does not implement container resource " + "update callback methods");
716: Wangda Tan, info, CatchClause, LOG.info("Unchecked exception is thrown from " + "onUpdateContainerResourceError for Container " + event.getContainerId(), thr);
702: Wangda Tan, info, CatchClause, LOG.info("Unchecked exception is thrown from " + "onContainerResourceUpdated for Container " + event.getContainerId(), thr);
822: Jian He, warn, SwitchStmt, LOG.warn("Event of type [" + containerEvent.getType() + "] not" + " expected here..");
827: Jian He, info, IfStmt, LOG.info("Unchecked exception is thrown in handler for event [" + containerEvent.getType() + "] for Container " + containerId, handlerError);
739: Jian He, error, IfStmt, LOG.error("Unexpected Event.. [" + containerEvent.getType() + "]");
780: Jian He, warn, SwitchStmt, LOG.warn("Event of type [" + containerEvent.getType() + "] not" + " expected here..");
785: Jian He, info, IfStmt, LOG.info("Unchecked exception is thrown in handler for event [" + containerEvent.getType() + "] for Container " + containerId, handlerError);
853: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Unchecked exception is thrown from onContainerStopped for " + "Container " + event.getContainerId(), thr);
873: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Unchecked exception is thrown from onStopContainerError for " + "Container " + event.getContainerId(), thr);
894: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Unchecked exception is thrown from onStartContainerError for " + "Container " + event.getContainerId(), thr);
924: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Can't handle this event at current state", e);
955: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Processing Event " + event + " for Container " + containerId);
979: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Container " + containerId + " is already stopped or failed");
965: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Unchecked exception is thrown from onContainerStatusReceived" + " for Container " + event.getContainerId(), thr);
994: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Unchecked exception is thrown from onGetContainerStatusError" + " for Container " + containerId, thr);
319: Jian He, warn, CatchClause, LOG.warn("ApplicationMaster is out of sync with ResourceManager," + " hence resyncing.");
568: Wangda Tan, debug, IfStmt, LOG.debug("RM has confirmed changed resource allocation for " + "container " + containerId + ". Current resource allocation:" + changedContainer.getContainer().getResource() + ". Remove pending change request:" + pendingChange.get(containerId).getValue());
587: Robert Kanter, debug, IfStmt, LOG.debug("Received new token for : " + nodeId);
585: Robert Kanter, debug, IfStmt, LOG.debug("Replacing token for : " + nodeId);
614: Bikas Saha, info, CatchClause, LOG.info("Interrupted while waiting for application" + " to be removed from RMStateStore");
617: Jian He, warn, CatchClause, LOG.warn("ApplicationMaster is out of sync with ResourceManager," + " hence resyncing.");
610: Bikas Saha, info, WhileStmt, LOG.info("Waiting for application to be successfully unregistered.");
634: Alejandro Abdelnur, warn, IfStmt, LOG.warn("ContainerRequest has duplicate racks: " + joiner.join(req.getRacks()));
663: Alejandro Abdelnur, warn, IfStmt, LOG.warn("ContainerRequest has duplicate nodes: " + joiner.join(req.getNodes()));
726: Arun Suresh, info, MethodDeclaration, LOG.info("Requesting Container update : " + "container=" + container + ", " + "updateType=" + updateContainerRequest.getContainerUpdateType() + ", " + "targetCapability=" + updateContainerRequest.getCapability() + ", " + "targetExecType=" + updateContainerRequest.getExecutionType());
859: Alejandro Abdelnur, warn, IfStmt, LOG.warn("Failed to resolve rack for node " + node + ".");
1031: Arun Suresh, debug, IfStmt, LOG.debug("Adding request to ask " + resourceRequestInfo.remoteRequest);
1032: Siddharth Seth, debug, IfStmt, LOG.debug("addResourceRequest:" + " applicationId=" + " priority=" + priority.getPriority() + " resourceName=" + resourceName + " numContainers=" + resourceRequestInfo.remoteRequest.getNumContainers() + " #asks=" + ask.size());
1071: Wangda Tan, info, IfStmt, LOG.info("No remoteRequestTable found with allocationRequestId=" + req.getAllocationRequestId());
1062: Wangda Tan, debug, IfStmt, LOG.debug("AFTER decResourceRequest:" + " allocationRequestId=" + req.getAllocationRequestId() + " priority=" + priority.getPriority() + " resourceName=" + resourceName + " numContainers=" + resourceRequestInfo.remoteRequest.getNumContainers() + " #asks=" + ask.size());
84: Robert Kanter, debug, IfStmt, LOG.debug(YarnConfiguration.NM_CLIENT_MAX_NM_PROXIES + " : " + maxConnectedNMs);
114: Robert Kanter, debug, IfStmt, LOG.debug("Refreshing proxy as NMToken got updated for node : " + containerManagerBindAddr);
153: Jian He, debug, IfStmt, LOG.debug("Cleaning up the proxy cache, size=" + cmProxy.size() + " max=" + maxConnectedNMs);
197: Robert Kanter, debug, IfStmt, LOG.debug("Closing proxy : " + proxy.containerManagerBindAddr);
229: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error closing connection", t);
269: Robert Kanter, debug, IfStmt, LOG.debug("Opening proxy : " + containerManagerBindAddr);
125: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Failed to stop Container " + startedContainer.getContainerId() + "when stopping NMClientImpl");
129: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Failed to stop Container " + startedContainer.getContainerId() + "when stopping NMClientImpl");
141: Arun Suresh, debug, IfStmt, LOG.debug("Added priority=" + priority);
150: Arun Suresh, debug, IfStmt, LOG.debug("Added resourceName=" + resourceName);
159: Arun Suresh, debug, IfStmt, LOG.debug("Added Execution Type=" + execType);
172: Arun Suresh, debug, IfStmt, LOG.debug("No such priority=" + priority);
180: Arun Suresh, debug, IfStmt, LOG.debug("No such resourceName=" + resourceName);
188: Arun Suresh, debug, IfStmt, LOG.debug("No such Execution Type=" + execType);
290: Arun Suresh, debug, IfStmt, LOG.debug("Adding request to ask " + resourceRequestInfo.remoteRequest);
302: Arun Suresh, debug, IfStmt, LOG.debug("Not decrementing resource as ResourceRequestInfo with" + "priority=" + priority + ", " + "resourceName=" + resourceName + ", " + "executionType=" + execTypeReq + ", " + "capability=" + capability + " is not present in request table");
312: Arun Suresh, debug, IfStmt, LOG.debug("BEFORE decResourceRequest:" + " applicationId=" + " priority=" + priority.getPriority() + " resourceName=" + resourceName + " numContainers=" + resourceRequestInfo.remoteRequest.getNumContainers());
88: Karthik Kambatla, debug, IfStmt, LOG.debug("Connecting to Shared Cache Manager at " + this.scmAddress);
306: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Submitted application " + applicationId);
320: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Application submission is not finished, " + "submitted application " + applicationId + " is still in " + state);
329: Naganarasimha, error, CatchClause, LOG.error(msg);
369: Daniel Templeton, debug, IfStmt, LOG.debug("Add timeline delegation token into credentials: " + timelineDelegationToken);
399: Jason Lowe, warn, IfStmt, LOG.warn("Failed to get delegation token from the timeline server: " + e.getMessage());
441: Jason Lowe, info, MethodDeclaration, LOG.info("Failing application attempt " + attemptId);
494: Naganarasimha, error, CatchClause, LOG.error(msg);
474: Sanford Ryza, info, IfStmt, LOG.info("Killed application " + applicationId);
486: Naganarasimha, info, IfStmt, LOG.info("Waiting for application " + applicationId + " to be killed.");
944: Xuan, info, MethodDeclaration, LOG.info("Signalling container " + containerId + " with command " + command);
521: Junping Du, Info, ForStmt, Object ob = log.get("containerLogInfo");
1323: Junping Du, INFO, MethodDeclaration, outStream.printf(LogCLIHelpers.PER_LOG_FILE_INFO_PATTERN, "LogFile", "LogLength", "LastModificationTime", "LogAggregationType");
1329: Junping Du, INFO, ForeachStmt, outStream.printf(LogCLIHelpers.PER_LOG_FILE_INFO_PATTERN, info.getKey().getFileName(), info.getKey().getFileSize(), info.getKey().getLastModifiedTime(), info.getValue());
385: Jian He, error, CatchClause, LOG.error("Caught exception", e);
463: Jian He, error, CatchClause, LOG.error("Unable to parse options", e);
548: Jian He, warn, IfStmt, LOG.warn("Delay set too low, using default");
607: Jian He, warn, CatchClause, LOG.warn("Couldn't determine terminal width, setting to 80", ne);
621: Jian He, warn, CatchClause, LOG.warn("Couldn't determine terminal height, setting to 24", ne);
691: Jian He, error, CatchClause, LOG.error("Unable to fetch cluster metrics", ie);
694: Jian He, error, CatchClause, LOG.error("Unable to fetch cluster metrics", ye);
725: Jian He, error, CatchClause, LOG.error("Unable to get queue information", ie);
715: Jian He, error, CatchClause, LOG.error("Unable to get queue information", ie);
771: Jian He, error, CatchClause, LOG.error("Could not fetch RM start time", e);
1042: Jian He, error, CatchClause, LOG.error("Unable to get application information", e);
47: Rohith Sharma K S, Info, MethodDeclaration, UserGroupInformation.setLoginUser(UserGroupInformation.createRemoteUser(UserGroupInformation.getCurrentUser().getUserName()));
190: Jian He, Error, CatchClause, LOG.error("Error joining with failover thread", ex);
235: Jian He, error, CatchClause, LOG.error(e.getMessage());
82: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("ResourceManager RMAdmin address: " + conf.get(YarnConfiguration.RM_ADMIN_ADDRESS));
95: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Stopping ResourceManager...");
109: Jonathan Turner Eagles, info, MethodDeclaration, LOG.info("ResourceManager RMAdmin address: " + configuration.get(YarnConfiguration.RM_ADMIN_ADDRESS));
203: Jonathan Turner Eagles, info, IfStmt, LOG.info("Stopping ResourceManager...");
117: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
499: Bikas Saha, error, CatchClause, LOG.error("Interrupted during wait", ex);
515: Wangda Tan, error, CatchClause, LOG.error("Interrupted during wait", ex);
530: Bikas Saha, error, CatchClause, LOG.error("Interrupted during wait", ex);
530: Robert Kanter, info, WhileStmt, Log.getLog().info("Allocated " + allocatedContainerCount + " containers" + " with " + iterationsLeft + " iterations left");
719: Robert Kanter, info, WhileStmt, Log.getLog().info("Allocated " + allocatedContainerCount + " containers" + " with " + iterationsLeft + " iterations left");
93: Jian He, info, TryStmt, LOG.info("testAMRMProxyE2E - Register Application Master");
112: Jian He, info, TryStmt, LOG.info("testAMRMProxyE2E - Allocate Resources Application Master");
131: Jian He, info, TryStmt, LOG.info("testAMRMPRoxy - Finish Application Master");
184: Subru Krishnan, info, TryStmt, LOG.info("testAMRMProxyTokenRenewal - Allocate Resources Application Master");
212: Jian He, info, TryStmt, LOG.info("testAMRMPRoxy - Finish Application Master");
136: Haibo Chen, info, IfStmt, LOG.info("***** " + id + " Transition from " + beforeState + " to " + afterState + "sum:" + sum);
79: Karthik Kambatla, info, CatchClause, LOG.info("IO exception in closing file system)");
410: Akira Ajisaka, DEBUG, MethodDeclaration, GenericTestUtils.setRootLogLevel(Level.DEBUG);
425: Akira Ajisaka, DEBUG, MethodDeclaration, GenericTestUtils.setRootLogLevel(Level.DEBUG);
356: Robert Kanter, info, MethodDeclaration, Log.getLog().info("ExpectedOutput");
357: Robert Kanter, info, MethodDeclaration, Log.getLog().info("[" + appReportStr + "]");
358: Robert Kanter, info, MethodDeclaration, Log.getLog().info("OutputFrom command");
360: Robert Kanter, info, MethodDeclaration, Log.getLog().info("[" + actualOutput + "]");
64: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(filePath + " not found");
58: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(filePath + " not found");
68: Thomas Graves, error, IfStmt, LOG.error("Thread " + t + " threw an Exception.", e);
51: Thomas Graves, fatal, TryStmt, LOG.fatal("Thread " + t + " threw an Error.  Shutting down now...", e);
47: Thomas Graves, error, IfStmt, LOG.error("Thread " + t + " threw an Throwable, but we are shutting " + "down, so ignoring this", e);
142: Wangda Tan, warn, IfStmt, LOG.warn("Got unknown resource type: " + entry.getKey() + "; skipping");
42: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Connecting to Application History server at " + ahsAddress);
107: Bikas Saha, error, IfStmt, LOG.error(message);
79: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Unable to create proxy to the ResourceManager " + rmServiceIds[currentProxyIndex], ioe);
100: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Failing over to " + rmServiceIds[currentProxyIndex]);
89: Xuan, info, MethodDeclaration, LOG.info("Created wrapped proxy for " + combinedInfo);
101: Subru Krishnan, error, CatchClause, LOG.error("Unable to create proxy to the ResourceManager " + HAUtil.getRMHAId(conf), ioe);
147: Junping Du, info, MethodDeclaration, LOG.info("Looking for the active RM in " + Arrays.toString(rmServiceIds) + "...");
177: Subru Krishnan, warn, CatchClause, LOG.warn("Invocation returned exception: " + rootCause.toString() + " on " + "[" + pInfo + "], so propagating back to caller.");
171: Junping Du, info, TryStmt, LOG.info("Found active RM [" + pInfo + "]");
197: Junping Du, info, MethodDeclaration, LOG.info("Connection lost with " + successfulProxy + ", trying to fail over.");
133: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Connecting to ResourceManager at " + rmAddress);
218: Arun Murthy, warn, IfStmt, LOG.warn(YarnConfiguration.RESOURCEMANAGER_CONNECT_MAX_WAIT_MS + " is smaller than " + YarnConfiguration.RESOURCEMANAGER_CONNECT_RETRY_INTERVAL_MS + ". Only try connect once.");
188: Junping Du, debug, IfStmt, LOG.debug(debugMSG.toString());
228: Junping Du, debug, IfStmt, LOG.debug("Writing summary log for " + appAttemptId.toString() + " to " + summaryLogPath);
239: Junping Du, debug, IfStmt, LOG.debug("Writing entity log for " + groupId.toString() + " to " + entityLogPath);
267: Li Lu, debug, IfStmt, LOG.debug("Closing cache");
276: Li Lu, debug, IfStmt, LOG.debug("Flushing cache");
296: Li Lu, debug, IfStmt, LOG.debug("Writing domains for " + appAttemptId.toString() + " to " + domainLogPath);
328: Li Lu, debug, IfStmt, LOG.debug("Writing entity list of size " + entities.size());
466: Li Lu, warn, IfStmt, LOG.warn("The specific " + YarnConfiguration.TIMELINE_SERVICE_CLIENT_INTERNAL_TIMERS_TTL_SECS + " : " + timerTaskRetainTTL + " is invalid, because it is less than or " + "equal to " + YarnConfiguration.TIMELINE_SERVICE_CLIENT_FD_RETAIN_SECS + " : " + ttl + ". Use " + YarnConfiguration.TIMELINE_SERVICE_CLIENT_FD_RETAIN_SECS + " : " + ttl + " + 120s instead.");
562: Junping Du, debug, IfStmt, LOG.debug(e);
639: Junping Du, warn, CatchClause, LOG.warn(e);
1001: Junping Du, debug, IfStmt, LOG.debug("New attempt directory created - " + attemptDir);
1013: Junping Du, debug, IfStmt, LOG.debug("New app directory created - " + appDir);
1027: Junping Du, debug, IfStmt, LOG.debug("New user directory created - " + userDir);
129: Vrushali C, info, MethodDeclaration, LOG.info("Timeline service address: " + getTimelineServiceAddress());
328: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("File [" + jsonFile.getAbsolutePath() + "] doesn't exist");
341: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when reading  " + e.getMessage());
385: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when putting the timeline data", e);
387: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when putting the timeline data", e);
376: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when putting domain " + domain.getId(), e);
381: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Timeline domains are successfully put");
365: Vinod Kumar Vavilapalli, error, ForeachStmt, LOG.error("TimelineEntity [" + error.getEntityType() + ":" + error.getEntityId() + "] is not successfully put. Error code: " + error.getErrorCode());
362: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Timeline entities are successfully put");
148: Sangjin Lee, debug, CatchClause, LOG.debug("Cannot load customized ssl related configuration. " + "Fallback to system-generic settings.", e);
354: Sangjin Lee, warn, CatchClause, LOG.warn("Client retry sleep interrupted! ");
369: Sangjin Lee, info, IfStmt, LOG.info("ConnectionException caught by TimelineClientConnectionRetry," + " will keep retrying.\nMessage: " + e.getMessage());
364: Sangjin Lee, info, IfStmt, LOG.info("Exception caught by TimelineClientConnectionRetry," + " will try " + leftRetries + " more time(s).\nMessage: " + e.getMessage());
173: Jian He, warn, IfStmt, LOG.warn("Not setting collector info as it is null.");
188: Jian He, info, IfStmt, LOG.info("Updated timeline service address to " + timelineServiceAddress);
198: Jian He, warn, IfStmt, LOG.warn("Timeline token to be updated should be of kind " + TimelineDelegationTokenIdentifier.KIND_NAME);
209: Jian He, warn, IfStmt, LOG.warn("Timeline token does not have service and timeline service " + "address is not yet set. Not updating the token");
236: Jian He, info, MethodDeclaration, LOG.info("Updated timeline delegation token " + timelineToken);
282: Sangjin Lee, error, IfStmt, LOG.error(msg.toString());
321: Sangjin Lee, error, IfStmt, LOG.error(msg);
335: Sangjin Lee, error, IfStmt, LOG.error(errMessage);
438: Sangjin Lee, info, IfStmt, LOG.info("Yet to publish " + timelineEntityQueue.size() + " timelineEntities, draining them now. ");
450: Sangjin Lee, warn, IfStmt, LOG.warn("Time to drain elapsed! Remaining " + timelineEntityQueue.size() + "timelineEntities will not" + " be published");
428: Sangjin Lee, info, CatchClause, LOG.info("Timeline dispatcher thread was interrupted ");
562: Sangjin Lee, info, MethodDeclaration, LOG.info("Stopping TimelineClient.");
133: Junping Du, error, IfStmt, LOG.error(msg);
138: Li Lu, debug, IfStmt, LOG.debug("HTTP error code: " + resp.getStatus() + " Server response : \n" + output);
162: Li Lu, debug, IfStmt, LOG.debug("PUT to " + resURI + "/" + path);
153: Li Lu, debug, IfStmt, LOG.debug("POST to " + resURI);
121: Jason Darrell Lowe, warn, IfStmt, LOG.warn("AsyncDispatcher thread interrupted", ie);
155: Naganarasimha, info, IfStmt, LOG.info("AsyncDispatcher is draining to stop, ignoring any new events.");
165: Wangda Tan, info, WhileStmt, LOG.info("Waiting for AsyncDispatcher to drain. Thread state is :" + eventHandlingThread.getState());
176: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Interrupted Exception while stopping", ie);
188: Siddharth Seth, debug, IfStmt, LOG.debug("Dispatching the event " + event.getClass().getName() + "." + event.toString());
203: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.fatal("Error in dispatcher thread", t);
223: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Registering " + eventType + " for " + handler.getClass());
257: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Size of event-queue is " + qSize);
261: Siddharth Seth, warn, IfStmt, LOG.warn("Very low remaining capacity in the event-queue: " + remCapacity);
268: Jason Darrell Lowe, warn, IfStmt, LOG.warn("AsyncDispatcher thread interrupted", e);
307: Jian He, info, MethodDeclaration, LOG.info("Exiting, bbye..");
61: Arun Suresh, error, CatchClause, LOG.error("Returning, interrupted : " + e);
72: Arun Suresh, warn, IfStmt, LOG.warn("Exception during shutdown: ", t);
75: Arun Suresh, Error, CatchClause, LOG.fatal("Error in handling event type " + event.getType() + " to the Event Dispatcher", t);
79: Arun Suresh, info, IfStmt, LOG.info("Exiting, bbye..");
126: Arun Suresh, info, CatchClause, LOG.info("Interrupted. Trying to exit gracefully.");
117: Arun Suresh, info, IfStmt, LOG.info("Size of " + getName() + " event-queue is " + qSize);
121: Arun Suresh, info, IfStmt, LOG.info("Very low remaining capacity on " + getName() + "" + "event queue: " + remCapacity);
103: junping_du, error, CatchClause, LOG.error("Cannot call close method due to Exception. " + "Ignoring.", e);
173: Siddharth Seth, info, MethodDeclaration, LOG.info("Adding protocol " + pbProtocol.getCanonicalName() + " to the server");
47: Arun Murthy, debug, MethodDeclaration, LOG.debug("Creating a HadoopYarnProtoRpc proxy for protocol " + protocol);
62: Arun Murthy, debug, MethodDeclaration, LOG.debug("Creating a HadoopYarnProtoRpc server for protocol " + protocol + " with " + numHandlers + " handlers");
59: Arun Murthy, debug, MethodDeclaration, LOG.debug("Creating YarnRPC for " + conf.get(YarnConfiguration.IPC_RPC_IMPL));
79: Thomas Graves, info, MethodDeclaration, LOG.info("aggregated log deletion started.");
92: Thomas Graves, info, MethodDeclaration, LOG.info("aggregated log deletion finished.");
140: Jason Lowe, info, TryStmt, LOG.info("Deleting aggregated logs in " + appDir.getPath());
200: Jason Lowe, error, IfStmt, LOG.error(comment, t);
198: Thomas Graves, warn, IfStmt, LOG.warn(comment + " " + message);
241: Jason Darrell Lowe, warn, IfStmt, LOG.warn("Failed to execute refreshLogRetentionSettings : Aggregated Log Deletion Service is not started");
256: Jason Darrell Lowe, info, IfStmt, LOG.info("Log Aggregation deletion is disabled because retention is" + " too small (" + retentionSecs + ")");
241: Zhijie Shen, warn, IfStmt, LOG.warn(logFile.getAbsolutePath() + " is a directory. Ignore it.");
280: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Aggregated logs truncated by approximately " + (newLength - fileLength) + " bytes.");
301: Zhijie Shen, error, MethodDeclaration, LOG.error(message, e);
556: Junping Du, warn, CatchClause, LOG.warn("Exception closing writer", e);
367: Wangda Tan, Info, ForeachStmt, logTypes.add(fileInfo);
268: Junping Du, warn, IfStmt, LOG.warn("Remote Root Log Dir [" + remoteRootLogDir + "] already exist, but with incorrect permissions. " + "Expected: [" + TLDIR_PERMISSIONS + "], Found: [" + perms + "]." + " The cluster may have problems with multiple users.");
284: Junping Du, warn, IfStmt, LOG.warn("Remote Root Log Dir [" + remoteRootLogDir + "] does not exist. Attempting to create it.");
298: Junping Du, warn, CatchClause, LOG.warn("No primary group found. The remote root log directory" + " will be created with the HDFS superuser being its group " + "owner. JobHistoryServer may be unable to read the directory.");
363: Junping Du, error, CatchClause, LOG.error("Failed to setup application log directory for " + appId, e);
480: Junping Du, error, CatchClause, LOG.error("Failed to clean old logs", e);
475: Junping Du, error, CatchClause, LOG.error("Failed to delete " + remove.getPath(), e);
102: Junping Du, error, CatchClause, LOG.error(ex.getMessage());
110: Junping Du, Error, CatchClause, LOG.error("Error getting logs for " + logEntity, ex);
120: Junping Du, Error, CatchClause, LOG.error("Error getting logs for " + logEntity, ex);
277: Junping Du, Error, CatchClause, LOG.error("Error getting logs for " + logEntity, ex);
141: Junping Du, warn, CatchClause, LOG.warn("Can not load log meta from the log file:" + thisNodeFile.getPath());
156: Junping Du, error, IfStmt, LOG.error("User [" + remoteUser + "] is not authorized to view the logs for " + logEntity);
258: Junping Du, Error, CatchClause, LOG.error("Error getting logs for " + logEntity, ex);
383: Junping Du, warn, IfStmt, LOG.warn("Aggregated logs truncated by approximately " + (newLength - fileLength) + " bytes.");
527: Junping Du, warn, CatchClause, LOG.warn("Can not load log meta from the log file:" + thisNodeFile.getPath() + "\n" + ex.getMessage());
647: Junping Du, warn, CatchClause, LOG.warn("Can not get log meta from the log file:" + thisNodeFile.getPath() + "\n" + ex.getMessage());
726: Wangda Tan, warn, CatchClause, LOG.warn(ex.getMessage());
841: Wangda Tan, warn, IfStmt, LOG.warn("The log meta size read from " + remoteLogPath + " is " + offset);
853: Wangda Tan, debug, IfStmt, LOG.debug("the length of loaded UUID:" + uuidReadLen);
854: Wangda Tan, debug, IfStmt, LOG.debug("the loaded UUID:" + new String(uuidRead, Charset.forName("UTF-8")));
856: Wangda Tan, debug, IfStmt, LOG.debug("the expected UUID:" + new String(this.uuid, Charset.forName("UTF-8")));
1054: Junping Du, error, MethodDeclaration, LOG.error(message, e);
1088: Wangda Tan, warn, CatchClause, LOG.warn(e.getMessage());
1168: Junping Du, info, CatchClause, LOG.info("Exception while executing an FS operation.", e);
1170: Junping Du, info, IfStmt, LOG.info("Maxed out FS retries. Giving up!");
1173: Junping Du, info, CatchClause, LOG.info("Retrying operation on FS. Retry no. " + retry);
147: Junping Du, error, CatchClause, LOG.error("Failed to move temporary log file to final location: [" + record.getRemoteNodeTmpLogFileForApp() + "] to [" + renamedPath + "]", e);
167: Junping Du, Error, CatchClause, LOG.error("Error getting logs for " + logEntity, e);
148: Junping Du, Error, CatchClause, LOG.error("Error getting logs for " + logEntity, ex);
124: Junping Du, Error, CatchClause, LOG.error("Error getting logs for " + logEntity, e);
134: Junping Du, error, IfStmt, LOG.error("User [" + remoteUser + "] is not authorized to view the logs for " + logEntity);
201: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Failed to store label modification to storage");
307: Tsuyoshi Ozawa, error, IfStmt, LOG.error(NODE_LABELS_NOT_ENABLED_ERR);
335: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Add labels: [" + StringUtils.join(labels.iterator(), ",") + "]");
371: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(msg);
388: Jian He, error, IfStmt, LOG.error(msg);
403: Tsuyoshi Ozawa, error, IfStmt, LOG.error(NODE_LABELS_NOT_ENABLED_ERR);
459: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Remove labels: [" + StringUtils.join(labelsToRemove.iterator(), ",") + "]");
473: Tsuyoshi Ozawa, error, IfStmt, LOG.error(NODE_LABELS_NOT_ENABLED_ERR);
497: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(msg);
522: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(msg);
537: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(msg);
664: Jian He, info, MethodDeclaration, LOG.info(op.name() + " labels on nodes:");
666: Vinod Kumar Vavilapalli, info, ForeachStmt, LOG.info("  NM=" + entry.getKey() + ", labels=[" + StringUtils.join(entry.getValue().iterator(), ",") + "]");
681: Tsuyoshi Ozawa, error, IfStmt, LOG.error(NODE_LABELS_NOT_ENABLED_ERR);
711: Jian He, error, IfStmt, LOG.error(msg);
720: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(msg);
734: Tsuyoshi Ozawa, error, IfStmt, LOG.error(NODE_LABELS_NOT_ENABLED_ERR);
914: Wangda Tan, warn, IfStmt, LOG.warn("getLabelsToNodes : Label [" + label + "] cannot be found");
963: Jian He, error, IfStmt, LOG.error(message);
289: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finished write mirror at:" + mirrorPath.toString());
290: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finished create editlog file at:" + editLogPath.toString());
64: Jian He, debug, IfStmt, LOG.debug("Exception while removing old mirror", e);
72: Jian He, info, MethodDeclaration, LOG.info("Node label store recover is completed");
73: Arun Murthy, warn, CatchClause, LOG.warn("Could not add current user to admin:" + e);
46: Arun Murthy, debug, MethodDeclaration, LOG.debug("Looking for a token with service " + service.toString());
48: Arun Murthy, debug, ForeachStmt, LOG.debug("Token kind is " + token.getKind().toString() + " and the token's service name is " + token.getService());
322: Arun Murthy, debug, MethodDeclaration, LOG.debug("Writing ContainerTokenIdentifier to RPC layer: " + this);
49: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Looking for service: " + service + ". Current token is " + token);
96: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("Writing NMTokenIdentifier to RPC layer: " + this);
45: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Looking for service: " + service + ". Current token is " + token);
58: Naganarasimha, info, IfStmt, LOG.info(authorizerClass.getName() + " is instantiated.");
72: Daniel Templeton, debug, IfStmt, LOG.debug(authorizer.getClass().getName() + " is destroyed.");
42: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("Looking for a token with service " + service.toString());
44: Vinod Kumar Vavilapalli, debug, ForeachStmt, LOG.debug("Token kind is " + token.getKind().toString() + " and the token's service name is " + token.getService());
54: Mahadev Konar, debug, MethodDeclaration, LOG.debug("Looking for a token with service " + service.toString());
56: Mahadev Konar, debug, ForeachStmt, LOG.debug("Token kind is " + token.getKind().toString() + " and the token's service name is " + token.getService());
47: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Looking for a token with service " + service.toString());
51: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Token kind is " + token.getKind().toString() + " and the token's service name is " + token.getService());
102: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Verifying access-type " + applicationAccessType + " for " + callerUGI + " on application " + applicationId + " owned by " + applicationOwner);
126: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("ACL not found for access-type " + applicationAccessType + " for application " + applicationId + " owned by " + applicationOwner + ". Using default [" + YarnConfiguration.DEFAULT_YARN_APP_ACL + "]");
116: Zhijie Shen, debug, IfStmt, LOG.debug("ACL not found for application " + applicationId + " owned by " + applicationOwner + ". Using default [" + YarnConfiguration.DEFAULT_YARN_APP_ACL + "]");
148: Jian He, info, IfStmt, LOG.info("Expired:" + entry.getKey().toString() + " Timed out after " + interval / 1000 + " secs");
156: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info(getName() + " thread interrupted");
59: Xuan, info, IfStmt, LOG.info("Attempt to dump logs when appender is already running");
78: Xuan, Error, CatchClause, LOG.warn("Error creating file, can't dump logs to " + file.getAbsolutePath(), ie);
100: Xuan, info, IfStmt, LOG.info("Dumping adhoc logs for " + name + " to " + file.getAbsolutePath() + " for " + timePeriod + " milliseconds");
134: Xuan, info, IfStmt, LOG.info("Done dumping adhoc logs for " + name);
121: Billie Rinaldi, info, ForStmt, LOG.info("Token read from Docker client configuration file: " + token.toString());
144: Jason Lowe, debug, ForeachStmt, LOG.debug("Token read from token storage: " + token.toString());
175: Jian He, debug, IfStmt, LOG.debug("Prepared token for write: " + tk.toString());
341: Jason Lowe, warn, IfStmt, LOG.warn("Cannot unpack " + source);
367: Jason Lowe, warn, IfStmt, LOG.warn("Cannot unpack " + source);
363: Jason Lowe, warn, IfStmt, LOG.warn("Treating [" + source + "] as an archive even though it " + "was specified as PATTERN");
357: Jason Lowe, warn, IfStmt, LOG.warn("Treating [" + source + "] as an archive even though it " + "was specified as PATTERN");
397: Jason Lowe, debug, IfStmt, LOG.debug(String.format("Starting to download %s %s %s", sCopy, resource.getType(), resource.getPattern()));
423: Jason Lowe, debug, IfStmt, LOG.debug(String.format("File has been downloaded to %s from %s", new Path(destDirPath, sCopy.getName()), sCopy));
473: Yufei Gu, debug, IfStmt, LOG.debug("Changing permissions for path " + path + " to perm " + perm);
183: Miklos Szegedi, warn, CatchClause, LOG.warn("Failed to get Operating System name.", se);
178: Todd Lipcon, info, IfStmt, LOG.info("ProcfsBasedProcessTree currently is supported only on " + "Linux.");
267: Miklos Szegedi, debug, IfStmt, LOG.debug(this);
407: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug(" total(" + olderThanAge + "): PID : " + p.getPid() + ", info : " + info.toString() + ", total : " + (total * KB_TO_BYTES));
413: Miklos Szegedi, Info, IfStmt, LOG.debug(procMemInfo);
420: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("SmapBasedCumulativeRssmem (bytes) : " + total);
472: Haibo Chen, debug, IfStmt, LOG.debug("Process " + pid + " jiffies:" + processTotalJiffies);
552: Miklos Szegedi, Error, CatchClause, LOG.warn("Error reading the stream", io);
564: Miklos Szegedi, Error, CatchClause, LOG.warn("Error closing the stream", i);
561: Miklos Szegedi, Error, CatchClause, LOG.warn("Error closing the stream", i);
547: Todd Lipcon, warn, IfStmt, LOG.warn("Unexpected: procfs stat file is not in the expected format" + " for process with pid " + pinfo.getPid());
686: Tsz-wo Sze, warn, IfStmt, LOG.warn("Sum of stime (" + this.stime + ") and utime (" + this.utime + ") is greater than " + Long.MAX_VALUE);
741: Miklos Szegedi, Error, CatchClause, LOG.warn("Error reading the stream", io);
753: Miklos Szegedi, Error, CatchClause, LOG.warn("Error closing the stream", i);
750: Miklos Szegedi, Error, CatchClause, LOG.warn("Error closing the stream", i);
810: Miklos Szegedi, error, CatchClause, LOG.error(f);
812: Miklos Szegedi, error, CatchClause, LOG.error(e);
814: Miklos Szegedi, error, CatchClause, LOG.error(t);
805: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.warn("Error parsing smaps line : " + line + "; " + t.getMessage());
797: Vinod Kumar Vavilapalli, Info, IfStmt, LOG.debug("MemInfo : " + key + " : Value  : " + value);
938: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error in parsing : " + info + " : value" + value.trim());
945: Vinod Kumar Vavilapalli, Info, IfStmt, LOG.debug("setMemInfo : memInfo : " + info);
112: BELUGA BEHR, debug, IfStmt, LOG.debug("Resolved {} to {}", hostName, rName);
108: BELUGA BEHR, debug, IfStmt, LOG.debug("Could not resolve {}. Falling back to {}", hostName, NetworkTopology.DEFAULT_RACK);
194: Naganarasimha, warn, CatchClause, LOG.warn("Failed to instantiate default resource calculator. " + ue.getMessage());
197: Gera Shegalov, warn, CatchClause, LOG.warn(t + ": Failed to instantiate default resource calculator.", t);
64: Junping Du, warn, IfStmt, LOG.warn("Finished time " + finished + " is ahead of started time " + started);
75: Junping Du, warn, IfStmt, LOG.warn("Current time " + current + " is ahead of started time " + started);
68: Suresh Srinivas, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
110: Suresh Srinivas, error, CatchClause, LOG.error(StringUtils.stringifyException(e));
139: Suresh Srinivas, debug, IfStmt, LOG.debug("Expected split length of proc info to be " + procInfoSplitCount + ". Got " + procInfo.length);
136: Suresh Srinivas, Error, CatchClause, LOG.debug("Error parsing procInfo." + nfe);
104: Suresh Srinivas, debug, MethodDeclaration, LOG.debug("version: " + getVersion());
79: Daniel Templeton, error, IfStmt, LOG.error("Memory cannot be allocated in increments of zero. Assuming " + minimumResource.getMemorySize() + "MB increment size. " + "Please ensure the scheduler configuration is correct.");
146: Sunil G, error, CatchClause, LOG.error("A problem was encountered while calculating resource " + "availability that should not occur under normal circumstances. " + "Please report this error to the Hadoop community by opening a " + "JIRA ticket at http://issues.apache.org/jira and including the " + "following information:\n* Exception encountered: " + out + "* " + "Cluster resources: " + Arrays.toString(clusterRes) + "\n* " + "LHS resource: " + Arrays.toString(lhs.getResources()) + "\n* " + "RHS resource: " + Arrays.toString(rhs.getResources()));
154: Sunil G, error, CatchClause, LOG.error("The resource manager is in an inconsistent state. It is safe " + "for the resource manager to be restarted as the error encountered " + "should be transitive. If high availability is enabled, failing " + "over to a standby resource manager is also safe.");
248: Daniel Templeton, warn, CatchClause, LOG.warn("Resource is missing:" + ye.getMessage());
272: Daniel Templeton, warn, CatchClause, LOG.warn("Resource is missing:" + ye.getMessage());
312: Sunil G, warn, CatchClause, LOG.warn("Resource is missing:" + ye.getMessage());
343: Daniel Templeton, warn, CatchClause, LOG.warn("Resource is missing:" + ye.getMessage());
373: Sunil G, warn, CatchClause, LOG.warn("Resource is missing:" + ye.getMessage());
490: Daniel Templeton, warn, CatchClause, LOG.warn("Resource is missing:" + ye.getMessage());
519: Daniel Templeton, warn, CatchClause, LOG.warn("Resource is missing:" + ye.getMessage());
543: Daniel Templeton, warn, CatchClause, LOG.warn("Resource is missing:" + ye.getMessage());
220: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("{}: {}", MimeType.JSON, object);
241: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("{}: {}", MimeType.TEXT, s);
89: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("dev mode restart requested");
171: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("error handling URI: " + uri, e);
198: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("removing cookie {} on {}", name, path);
218: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("parts={}, params={}", parts, dest.pathParams);
246: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("WebAppp /{} exiting...", webApp.name());
56: Vinod Kumar Vavilapalli, trace, IfStmt, LOG.trace("GOT EXCEPITION", e);
98: Vinod Kumar Vavilapalli, ERROR, IfStmt, LOG.warn("INTERNAL_SERVER_ERROR", e);
98: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("adding {}({})->{}#{}", new Object[] { path, names, cls, action });
169: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("prefix match2 for {}: {}", key, dest.action);
166: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("exact match for {}: {}", key, dest.action);
182: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("prefix match for {}: {}", lower.getKey(), dest.action);
203: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("checking prefix {}{} for path: {}", new Object[] { dest.prefix, dest.pathParams, path });
282: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("trying: {}", className);
286: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("found {}", className);
289: Vinod Kumar Vavilapalli, warn, TryStmt, LOG.warn("found a {} but it's not a {}", className, cls.getName());
110: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("interrupted", e);
272: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("setting webapp host class to {}", cls);
288: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("dev mode does NOT work with ephemeral port!");
282: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("no existing webapp instance found: {}", e.toString());
285: Vinod Kumar Vavilapalli, error, CatchClause, LOG.warn("error stopping existing instance: {}", e.toString());
279: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("stopping existing webapp instance");
349: Varun Vasudev, info, IfStmt, LOG.info("CSRF Protection has been enabled for the {} application. " + "Please ensure that there is an authentication mechanism " + "enabled (kerberos, custom, etc).", name);
387: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Registered webapp guice modules");
392: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("in dev mode!");
432: Jonathan Eagles, info, TryStmt, LOG.info("Web app " + name + " started at " + httpServer.getConnectorAddress(0).getPort());
444: Wangda Tan, info, IfStmt, LOG.info("CSRF Protection has been enabled for the {} application. " + "Please ensure that there is an authentication mechanism " + "enabled (kerberos, custom, etc).", name);
468: Vinod Kumar Vavilapalli, warn, MethodDeclaration, LOG.warn("could not infer host class from", t);
83: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Generating {} using {} and {}", new Object[] { outputName, specClass, implClass });
116: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Generating {} methods", hamlet);
120: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Wrote {} bytes to {}.java", bytes, outputName);
159: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Generating class {}<T>", className);
81: Akira Ajisaka, info, MethodDeclaration, LOG.info("Generating {} using {} and {}", new Object[] { outputName, specClass, implClass });
114: Akira Ajisaka, info, MethodDeclaration, LOG.info("Generating {} methods", hamlet);
118: Akira Ajisaka, info, MethodDeclaration, LOG.info("Wrote {} bytes to {}.java", bytes, outputName);
157: Akira Ajisaka, info, IfStmt, LOG.info("Generating class {}<T>", className);
68: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("Rendering {} @{}", getClass(), nestLevel);
135: Robert Joseph Evans, info, CatchClause, LOG.info(StringUtils.stringifyException(e));
172: Robert Joseph Evans, error, CatchClause, LOG.error(e);
41: Jason Lowe, info, MethodDeclaration, claLog.info("message1");
122: Jian He, info, CatchClause, LOG.info(StringUtils.stringifyException(e));
189: Jian He, error, CatchClause, LOG.error(e);
251: Chris Douglas, info, IfStmt, LOG.info(String.format("New property: %s type: %s", gsp.toString(), gsp.type));
253: Chris Douglas, info, IfStmt, LOG.info(String.format(" testValue: %s\n", gsp.testValue));
246: Sunil G, info, IfStmt, LOG.info(String.format("Excluding potential property(present in exclusion list): %s\n", gsp.propertyName));
243: Junping Du, info, IfStmt, LOG.info(String.format("Exclude potential property: %s\n", gsp.propertyName));
262: Chris Douglas, info, MethodDeclaration, LOG.info(String.format("Validate %s %s\n", recordClass.getName(), protoClass.getName()));
67: Zhijie Shen, info, MethodDeclaration, LOG.info("Entities in JSON:");
68: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(entities, true));
107: Zhijie Shen, info, MethodDeclaration, LOG.info("Events in JSON:");
108: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(events, true));
149: Zhijie Shen, Error, MethodDeclaration, LOG.info("Errors in JSON:");
150: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(TimelinePutErrors, true));
185: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Domain in JSON:");
186: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(domains, true));
147: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(entity, true));
154: Junping Du, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(entities, true));
238: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(cluster, true));
239: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(flow1, true));
240: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(flow2, true));
241: Junping Du, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(app1, true));
242: Junping Du, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(app2, true));
243: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(appAttempt, true));
244: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(container, true));
295: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(user, true));
310: Zhijie Shen, info, MethodDeclaration, LOG.info(TimelineUtils.dumpTimelineRecordtoJSON(queue, true));
72: Junping Du, info, MethodDeclaration, LOG.info("Created activeDir in " + localActiveDir.getAbsolutePath());
413: Sangjin Lee, info, ForStmt, LOG.info("Entities Published @ index " + i + " : " + entitiesPerPublish.toString());
39: Mahadev Konar, info, MethodDeclaration, LOG.info("Dispatching the event " + event.getClass().getName() + "." + event.toString());
88: Thomas Graves, info, MethodDeclaration, LOG.info("Cleaning test directory [" + workDirPath + "]");
231: Jason Lowe, error, TryStmt, doThrow(new IOException("Mock can not open FileInputStream")).when(spyLogValue).secureOpenFile(errorFile);
339: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info(line);
61: Xuan, debug, MethodDeclaration, LOG.debug("test message 1");
62: Xuan, info, MethodDeclaration, LOG.info("test message 2");
83: Xuan, info, IfStmt, LOG.info("Couldn't clean up after test");
134: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Create jar file " + p);
137: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Create jar out stream ");
151: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Done writing jar stream ");
56: Wangda Tan, fatal, SwitchStmt, logger.fatal(message);
59: Wangda Tan, error, SwitchStmt, logger.error(message);
62: Wangda Tan, warn, SwitchStmt, logger.warn(message);
65: Wangda Tan, info, SwitchStmt, logger.info(message);
68: Wangda Tan, debug, SwitchStmt, logger.debug(message);
71: Wangda Tan, trace, SwitchStmt, logger.trace(message);
80: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 1", 1);
95: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 1", 3);
96: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 2", 2);
102: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 3", 3);
114: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 1", 2);
115: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 2", 3);
123: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 3", 2);
139: Wangda Tan, WARN, MethodDeclaration, logMessages(Level.WARN, "test message 1", 2);
140: Wangda Tan, WARN, MethodDeclaration, logMessages(Level.WARN, "test message 2", 3);
148: Wangda Tan, WARN, MethodDeclaration, logMessages(Level.WARN, "test message 3", 2);
164: Wangda Tan, WARN, MethodDeclaration, logMessages(Level.WARN, "test message 1", 2);
165: Wangda Tan, WARN, MethodDeclaration, logMessages(Level.WARN, "test message 2", 3);
182: Wangda Tan, WARN, MethodDeclaration, logMessages(Level.WARN, "test message 3", 2);
204: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 1", 2);
205: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 2", 3);
222: Wangda Tan, ERROR, MethodDeclaration, logMessages(Level.ERROR, "test message 3", 2);
244: Wangda Tan, INFO, MethodDeclaration, logMessages(Level.INFO, "test message 1", 2);
245: Wangda Tan, DEBUG, MethodDeclaration, logMessages(Level.DEBUG, "test message 2", 2);
246: Wangda Tan, TRACE, MethodDeclaration, logMessages(Level.TRACE, "test message 3", 2);
89: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Shell Command exit with a non-zero exit code. This is" + " expected as we are killing the subprocesses of the" + " task intentionally. " + ee);
93: Todd Lipcon, Error, CatchClause, LOG.info("Error executing shell command " + ioe);
95: Todd Lipcon, info, TryStmt, LOG.info("Exit code: " + shexec.getExitCode());
126: Todd Lipcon, info, CatchClause, LOG.info(StringUtils.stringifyException(e));
164: Todd Lipcon, info, MethodDeclaration, LOG.info("Root process pid: " + pid);
167: Miklos Szegedi, info, MethodDeclaration, LOG.info("ProcessTree: " + p);
180: Miklos Szegedi, info, MethodDeclaration, LOG.info("ProcessTree: " + p);
184: Jason Lowe, info, MethodDeclaration, LOG.info("Orphaned pid: " + lostpid);
210: Todd Lipcon, info, MethodDeclaration, LOG.info("Process-tree dump follows: \n" + processTreeDump);
230: Todd Lipcon, info, CatchClause, LOG.info("Interrupted while joining RogueTaskThread.");
228: Todd Lipcon, info, TryStmt, LOG.info("RogueTaskThread successfully joined.");
274: Todd Lipcon, debug, CatchClause, LOG.debug("PidFile doesn't exist : " + pidFileName);
281: Todd Lipcon, error, CatchClause, LOG.error("Failed to read from " + pidFileName);
295: Todd Lipcon, Error, CatchClause, LOG.warn("Error closing the stream " + fReader);
292: Todd Lipcon, Error, CatchClause, LOG.warn("Error closing the stream " + pidFile);
792: Todd Lipcon, info, TryStmt, LOG.info("Process-tree dump follows: \n" + processTreeDump);
829: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("setsid is not available on this machine. So not using it.");
832: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("setsid exited with exit code " + shexec.getExitCode());
912: Miklos Szegedi, info, ForeachStmt, LOG.info("created pid dir: " + pidDir);
942: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("wrote stat file for " + pids[i] + " with contents: " + procs[i].getStatLine());
960: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("wrote smap file for " + pids[i] + " with contents: " + smaps[i].toString());
982: Todd Lipcon, info, TryStmt, LOG.info("wrote command-line file for " + pids[i] + " with contents: " + cmdLines[i]);
61: Siddharth Seth, info, MethodDeclaration, LOG.info("Received resolve request for " + hostList.get(0));
99: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("request: {}", req);
100: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("response: {}", res);
101: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("writer: {}", out);
466: Steve Loughran, debug, IfStmt, LOG.debug("Operation {} on path {} failed with exception {}", operation, pathArg, e, e);
214: Steve Loughran, debug, IfStmt, LOG.debug("stat failed on {}: moved? {}", child, pnfe, pnfe);
328: Steve Loughran, debug, IfStmt, LOG.debug("data too short for {}", path);
332: Steve Loughran, debug, IfStmt, LOG.debug("Invalid record at {}", path);
336: Steve Loughran, debug, IfStmt, LOG.debug("No record at {}", path);
83: Subru Krishnan, error, CatchClause, LOG.error("Failed to get FileSystem for registry", e);
80: Subru Krishnan, info, TryStmt, LOG.info("Initialized Yarn-registry with Filesystem " + fs.getClass().getCanonicalName());
155: Subru Krishnan, info, IfStmt, LOG.info("Bound record to path " + dataPath);
160: Steve Loughran, debug, IfStmt, LOG.debug("Creating Registry with root {}", registryRoot);
268: Billie Rinaldi, info, MethodDeclaration, LOG.info("Creating CuratorService with connection {}", connectionDescription);
292: Eric Yang, debug, IfStmt, LOG.debug(securityConnectionDiagnostics);
483: Steve Loughran, debug, IfStmt, LOG.debug("Stat {}", fullpath);
508: Steve Loughran, debug, IfStmt, LOG.debug("GetACLS {}", fullpath);
591: Steve Loughran, debug, IfStmt, LOG.debug("path already present: {}", path, e);
579: Steve Loughran, debug, IfStmt, LOG.debug("Creating path {} with mode {} and ACL {}", path, mode, aclInfo);
634: Steve Loughran, debug, IfStmt, LOG.debug("Creating {} with {} bytes of data and ACL {}", fullpath, data.length, new RegistrySecurity.AclListInfo(acls));
657: Steve Loughran, debug, IfStmt, LOG.debug("Updating {} with {} bytes", path, data.length);
712: Steve Loughran, debug, IfStmt, LOG.debug("Deleting {}", fullpath);
741: Steve Loughran, debug, IfStmt, LOG.debug("ls {}", fullpath);
763: Steve Loughran, debug, IfStmt, LOG.debug("Reading {}", fullpath);
817: Steve Loughran, debug, CatchClause, LOG.debug("Ignoring exception:  {}", e);
845: Jian He, Info, SwitchStmt, LOG.info("Informing listener of added node {}", path);
851: Jian He, Info, SwitchStmt, LOG.info("Informing listener of removed node {}", path);
857: Jian He, Info, SwitchStmt, LOG.info("Informing listener of updated node {}", path);
112: Billie Rinaldi, debug, IfStmt, LOG.debug("Bound at {} : ServiceRecord = {}", path, record);
148: Steve Loughran, debug, IfStmt, LOG.debug("Stat {} => {}", path, status);
320: Steve Loughran, debug, IfStmt, LOG.debug("Registry has no security");
252: Eric Yang, info, IfStmt, LOG.info("Registry default system acls: " + System.lineSeparator() + systemACLs);
268: Eric Yang, info, IfStmt, LOG.info("Registry User ACLs " + System.lineSeparator() + userACLs);
283: Steve Loughran, debug, IfStmt, LOG.debug("Auth is SASL user=\"{}\" JAAS context=\"{}\"", jaasClientIdentity, jaasClientEntry);
303: Steve Loughran, debug, IfStmt, LOG.debug("Auth is Digest ACL: {}", aclToString(acl));
311: Steve Loughran, debug, IfStmt, LOG.debug("Auth is anonymous");
348: Steve Loughran, debug, IfStmt, LOG.debug("Ignoring added ACL - registry is insecure{}", aclToString(acl));
342: Steve Loughran, debug, IfStmt, LOG.debug("Added ACL {}", aclToString(acl));
360: Steve Loughran, debug, IfStmt, LOG.debug("Cleared digest ACLs");
684: Steve Loughran, debug, IfStmt, LOG.debug("Binding {} to {}", Environment.JAAS_CONF_KEY, path);
779: Eric Yang, info, IfStmt, LOG.info("Using existing ZK sasl configuration: " + "jaasClientEntry = " + System.getProperty(ZooKeeperSaslClient.LOGIN_CONTEXT_NAME_KEY, "Client") + ", sasl client = " + System.getProperty(ZooKeeperSaslClient.ENABLE_CLIENT_SASL_KEY, ZooKeeperSaslClient.ENABLE_CLIENT_SASL_DEFAULT) + ", jaas = " + existingJaasConf);
930: Steve Loughran, warn, CatchClause, LOG.warn("Failed to get current user {}, {}", e);
926: Steve Loughran, info, TryStmt, LOG.info("Current user = {}", currentUser);
928: Steve Loughran, info, TryStmt, LOG.info("Real User = {}", realUser);
1065: Steve Loughran, debug, IfStmt, LOG.debug("Creating ACL For ", new UgiInfo(ugi));
1085: Steve Loughran, debug, IfStmt, LOG.debug("Appending kerberos realm to make {}", username);
1100: Steve Loughran, info, CatchClause, LOG.info("Failed to get current user {}", e, e);
64: Billie Rinaldi, info, IfStmt, LOG.info(serviceRecord.description + ": No external endpoints defined.");
61: Jian He, Error, CatchClause, LOG.error("Error initializing Registry DNS", e);
191: Jian He, info, MethodDeclaration, LOG.info("Opening TCP and UDP channels on {} port {}", addr, port);
235: Billie Rinaldi, error, CatchClause, LOG.error("Can not resolve DNS servers: ", e);
249: Billie Rinaldi, error, IfStmt, LOG.error("Not simple resolver!!!?" + check);
266: Billie Rinaldi, info, SynchronizedStmt, LOG.info(message.toString());
288: Jian He, Error, CatchClause, LOG.error("Error initializing Registry DNS Server", e);
319: Jian He, info, MethodDeclaration, LOG.info(builder.toString());
458: Jian He, warn, IfStmt, LOG.warn("Zone subnet is not configured.  Reverse lookups disabled");
534: Jian He, warn, CatchClause, LOG.warn("Unable to convert {} to DNS name", reverseLookupZoneName);
643: Jian He, info, IfStmt, LOG.info("Registering {}", dnskeyRecord);
698: Jian He, info, MethodDeclaration, LOG.info("Adding {}", record);
778: Billie Rinaldi, info, TryStmt, LOG.info("received TCP query {}", query.getQuestion());
902: Jian He, Error, CatchClause, LOG.error("Error initializing DNS TCP listener", e);
928: Jian He, Error, CatchClause, LOG.error("Error initializing DNS UDP listener", e);
958: Jian He, Error, CatchClause, LOG.debug("Error during message receipt", e);
969: Billie Rinaldi, info, TryStmt, LOG.info("{}: received UDP query {}", remoteAddress, query.getQuestion());
982: Billie Rinaldi, debug, WhileStmt, LOG.debug("{}:  sending response", remoteAddress);
1070: Jian He, debug, IfStmt, LOG.debug("returning null");
1106: Jian He, debug, MethodDeclaration, LOG.debug("calling addAnswer");
1164: Billie Rinaldi, error, CatchClause, LOG.error("Fail to lookup: " + name, e);
1189: Jian He, info, IfStmt, LOG.info("Received query {}.  Forwarding query {}", name, qualifiedName);
1333: Jian He, debug, MethodDeclaration, LOG.debug("finding record");
1341: Billie Rinaldi, info, MethodDeclaration, LOG.info("found local record? {}", sr != null && sr.isSuccessful());
1397: Jian He, warn, CatchClause, LOG.warn("Unable to obtain default zone for unknown name response", e);
1376: Jian He, info, IfStmt, LOG.info("found answers {}", rrsets);
1369: Jian He, info, IfStmt, LOG.info("No data found the given name {} and type {}", name, type);
1360: Jian He, warn, CatchClause, LOG.warn("Unable to add NXTRecord to AUTHORITY Section", e);
1591: Jian He, warn, IfStmt, LOG.warn("Yarn Registry record {} does not contain {} attribute ", record.toString(), YarnRegistryAttributes.YARN_PERSISTENCE);
1583: Gour Saha, debug, IfStmt, LOG.debug("Creating ApplicationServiceRecordProcessor for {}", yarnPersistanceValue);
1683: Jian He, warn, IfStmt, LOG.warn("Unable to find zone matching record {}", record);
1658: Jian He, info, TryStmt, LOG.info("Registered {}", record);
1671: Jian He, info, TryStmt, LOG.info("Adding {}", rrsigRecord);
1709: Jian He, info, MethodDeclaration, LOG.info("Adding {}", dsRecord);
1730: Jian He, error, IfStmt, LOG.error("Unable to remove record because zone is null: {}", record);
1734: Jian He, info, MethodDeclaration, LOG.info("Removed {}", record);
164: Jian He, warn, CatchClause, LOG.warn("Unable to monitor the registry.  DNS support disabled.", e);
182: Jian He, info, IfStmt, LOG.info("Registering DNS records for {}", path);
195: Jian He, info, IfStmt, LOG.info("Deleting DNS records for {}", path);
250: Jian He, Error, CatchClause, LOG.error("Error starting Registry DNS Server", t);
88: Varun Vasudev, error, CatchClause, LOG.error("The supplied range is not a valid integer: Supplied range: ", range);
95: Varun Vasudev, error, IfStmt, LOG.error(msg);
106: Varun Vasudev, error, CatchClause, LOG.error("The subnet or mask is invalid: Subnet: {} Mask: {}", subnet, mask);
153: Varun Vasudev, error, CatchClause, LOG.error("Base IP address is invalid");
45: Steve Loughran, debug, IfStmt, LOG.debug("Delete event {}", event);
147: Steve Loughran, debug, MethodDeclaration, LOG.debug("Instance directory is {}", instanceDir);
235: Steve Loughran, info, MethodDeclaration, LOG.info("Starting Local Zookeeper service");
241: Steve Loughran, info, MethodDeclaration, LOG.info("In memory ZK started at {}\n", connectString);
248: Steve Loughran, debug, IfStmt, LOG.debug(sw.toString());
161: Steve Loughran, debug, IfStmt, LOG.debug("Submitting {}", callable);
200: Steve Loughran, info, IfStmt, LOG.info("Registry System ACLs:", RegistrySecurity.aclsToString(registrySecurity.getSystemACLs()));
227: Steve Loughran, error, CatchClause, LOG.error(" Failure {}", e, e);
228: Steve Loughran, error, CatchClause, LOG.error(message);
244: Steve Loughran, info, MethodDeclaration, LOG.info("System ACLs {}", RegistrySecurity.aclsToString(systemACLs));
349: Steve Loughran, debug, IfStmt, LOG.debug("Started Registry operations in realm {}", realm);
427: Steve Loughran, debug, IfStmt, LOG.debug("Match on record @ {} with children ", path);
434: Steve Loughran, debug, IfStmt, LOG.debug("Skipping deletion");
441: Steve Loughran, debug, IfStmt, LOG.debug("Scheduling for deletion with children");
448: Steve Loughran, debug, IfStmt, LOG.debug("Failing deletion operation");
513: Steve Loughran, debug, IfStmt, LOG.debug("Executing {}", this);
114: Steve Loughran, info, MethodDeclaration, LOG.info("Logged in as {}:\n {}", name, subject);
248: Steve Loughran, info, MethodDeclaration, LOG.info(" {} = \n{}\n", name, recordMarshal.toJson(record));
300: Steve Loughran, info, MethodDeclaration, log.info("\n=======================================");
301: Steve Loughran, info, MethodDeclaration, log.info(text, args);
302: Steve Loughran, info, MethodDeclaration, log.info("=======================================\n");
317: Steve Loughran, warn, CatchClause, LOG.warn("Exception logging out: {}", e, e);
313: Steve Loughran, debug, IfStmt, LOG.debug("Logging out login context {}", login.toString());
331: Steve Loughran, info, MethodDeclaration, LOG.info("Logging in as {} from {}", user, keytab);
60: Steve Loughran, info, MethodDeclaration, LOG.info(marshal.toJson(record));
50: Steve Loughran, info, MethodDeclaration, LOG.info("received {}", event);
172: Steve Loughran, info, MethodDeclaration, LOG.info("took {}", taken);
223: Steve Loughran, info, MethodDeclaration, LOG.info("\n" + jaas);
289: Steve Loughran, info, MethodDeclaration, LOG.info(secureZK.getDiagnostics());
335: Steve Loughran, info, MethodDeclaration, LOG.info("Logging in as {} in context {} with keytab {}", principal, context, keytab);
182: Steve Loughran, info, MethodDeclaration, LOG.info("Realm {}", realm);
190: Steve Loughran, info, MethodDeclaration, LOG.info("User {} has ACL {}", user, acl);
61: Steve Loughran, info, MethodDeclaration, LOG.info("ZK principal = {}", getPrincipalAndRealm(ZOOKEEPER_LOCALHOST));
92: Steve Loughran, info, TryStmt, LOG.info("{}=\n{}", confFilename, config);
131: Steve Loughran, info, MethodDeclaration, LOG.info("krb5.conf at {}:\n{}", krb5conf, krbConfig);
184: Steve Loughran, info, MethodDeclaration, LOG.info("Default Realm '{}'", defaultRealm);
193: Steve Loughran, info, MethodDeclaration, LOG.info(rules);
212: Steve Loughran, info, MethodDeclaration, LOG.info("logged in as: {}", ugiInfo);
129: Steve Loughran, info, TryStmt, LOG.info(curator.toString());
178: Steve Loughran, info, MethodDeclaration, LOG.info("Curator Binding {}", curatorService.bindingDiagnosticDetails());
201: Steve Loughran, info, TryStmt, LOG.info(curator.toString());
207: Steve Loughran, info, TryStmt, LOG.info(pathDumper.toString());
111: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Instantiated ApplicationHistoryClientService at " + this.bindAddress);
153: Jian He, error, CatchClause, LOG.error(e.getMessage(), e);
178: Jian He, error, CatchClause, LOG.error(e.getMessage(), e);
210: Jian He, error, CatchClause, LOG.error(e.getMessage(), e);
61: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("ApplicationHistory Init");
71: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Starting ApplicationHistory");
78: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Stopping ApplicationHistory");
131: Xuan, Error, CatchClause, LOG.error("Error on generating application report for " + entity.getEntityId(), e);
691: Jian He, info, IfStmt, LOG.info("No application attempt found for " + app.appReport.getApplicationId() + ". Use a placeholder for its latest attempt id. ", e);
687: Jian He, warn, IfStmt, LOG.warn("Failed to authorize when generating application report for " + app.appReport.getApplicationId() + ". Use a placeholder for its latest attempt id. ", e);
180: Akira Ajisaka, Error, CatchClause, LOG.error("Error starting ApplicationHistoryServer", t);
213: junping_du, warn, IfStmt, LOG.warn("The filesystem based application history store is deprecated.");
321: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(msg, e);
310: Robert Kanter, info, ForeachStmt, LOG.info("Hosting " + name + " from " + onDiskPath + " at " + webPath);
318: Jonathan Eagles, info, TryStmt, LOG.info("Instantiating AHSWebApp at " + getPort());
129: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when initializing FileSystemHistoryStorage", e);
188: Zhijie Shen, Error, CatchClause, LOG.error("Error when reading history file of application " + appId, e);
180: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Start information is missing for application " + appId);
183: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Finish information is missing for application " + appId);
185: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Completed reading history information of application " + appId);
254: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.info("Error when reading history information of some application" + " attempts of application " + appId);
251: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Completed reading history information of all application" + " attempts of application " + appId);
304: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when reading history file of application attempt" + appAttemptId, e);
293: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Start information is missing for application attempt " + appAttemptId);
297: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Finish information is missing for application attempt " + appAttemptId);
300: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Completed reading history information of application attempt " + appAttemptId);
353: Zhijie Shen, Error, CatchClause, LOG.error("Error when reading history file of container " + containerId, e);
344: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Start information is missing for container " + containerId);
347: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Finish information is missing for container " + containerId);
349: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Completed reading history information of container " + containerId);
407: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.info("Error when reading history information of some containers" + " of application attempt " + appAttemptId);
404: Naganarasimha, info, TryStmt, LOG.info("Completed reading history information of all containers" + " of application attempt " + appAttemptId);
428: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when openning history file of application " + appStart.getApplicationId(), e);
425: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Opened history file of application " + appStart.getApplicationId());
445: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when writing start information of application " + appStart.getApplicationId(), e);
442: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Start information of application " + appStart.getApplicationId() + " is written");
464: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when writing finish information of application " + appFinish.getApplicationId(), e);
461: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Finish information of application " + appFinish.getApplicationId() + " is written");
488: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when writing start information of application attempt " + appAttemptStart.getApplicationAttemptId(), e);
485: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Start information of application attempt " + appAttemptStart.getApplicationAttemptId() + " is written");
509: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when writing finish information of application attempt " + appAttemptFinish.getApplicationAttemptId(), e);
506: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Finish information of application attempt " + appAttemptFinish.getApplicationAttemptId() + " is written");
529: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when writing start information of container " + containerStart.getContainerId(), e);
526: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Start information of container " + containerStart.getContainerId() + " is written");
549: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when writing finish information of container " + containerFinish.getContainerId(), e);
546: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Finish information of container " + containerFinish.getContainerId() + " is written");
290: Junping Du, debug, IfStmt, LOG.debug(ex.getMessage());
430: Junping Du, debug, IfStmt, LOG.debug(ex.getMessage());
589: Junping Du, Info, ForeachStmt, containersLogsInfo.add(logInfo);
101: Xuan, info, IfStmt, LOG.info("Service stopped, return null for the storage");
192: Xuan, info, IfStmt, LOG.info("Service stopped, return null for the storage");
214: Xuan, info, IfStmt, LOG.info("Service stopped, return null for the storage");
263: Xuan, info, IfStmt, LOG.info("Service stopped, return null for the storage");
285: Xuan, info, IfStmt, LOG.info("Service stopped, return null for the storage");
328: Xuan, info, IfStmt, LOG.info("Service stopped, return null for the storage");
465: Xuan, info, IfStmt, LOG.info("Service stopped, return null for the storage");
244: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Using leveldb path " + dbPath);
251: Naganarasimha, warn, CatchClause, LOG.warn("Incurred exception while loading LevelDb database. Backing " + "up at " + backupPath, ioe);
254: Naganarasimha, warn, CatchClause, LOG.warn("Going to try repair");
278: Zhijie Shen, info, IfStmt, LOG.info("Waiting for deletion thread to complete its current action");
282: Zhijie Shen, warn, CatchClause, LOG.warn("Interrupted while waiting for deletion thread to complete," + " closing db now", e);
310: Zhijie Shen, info, ConstructorDeclaration, LOG.info("Starting deletion thread with ttl " + ttl + " and cycle " + "interval " + ttlInterval);
322: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
324: Zhijie Shen, info, CatchClause, LOG.info("Deletion thread received interrupt, exiting");
478: Zhijie Shen, warn, IfStmt, LOG.warn(String.format("Found unexpected column for entity %s of " + "type %s (0x%02x)", entityId, entityType, key[prefixlen]));
917: Jason Lowe, Error, CatchClause, LOG.error("Error putting entity " + entity.getEntityId() + " of type " + entity.getEntityType(), de);
921: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error putting entity " + entity.getEntityId() + " of type " + entity.getEntityType(), e);
954: Jason Lowe, Error, CatchClause, LOG.error("Error putting related entity " + relatedEntity.getId() + " of type " + relatedEntity.getType() + " for entity " + entity.getEntityId() + " of type " + entity.getEntityType(), de);
959: Zhijie Shen, Error, CatchClause, LOG.error("Error putting related entity " + relatedEntity.getId() + " of type " + relatedEntity.getType() + " for entity " + entity.getEntityId() + " of type " + entity.getEntityType(), e);
1428: Zhijie Shen, debug, IfStmt, LOG.debug("Deleting entity type:" + entityType + " id:" + entityId);
1487: Zhijie Shen, warn, IfStmt, LOG.warn("Found no start time for reverse " + "related entity " + id + " of type " + type + " while " + "deleting " + entityId + " of type " + entityType);
1495: Zhijie Shen, debug, IfStmt, LOG.debug("Deleting entity type:" + entityType + " id:" + entityId + " from related entity entry of type:" + type + " id:" + id);
1467: Zhijie Shen, warn, IfStmt, LOG.warn("Found no start time for " + "related entity " + id + " of type " + type + " while " + "deleting " + entityId + " of type " + entityType);
1475: Zhijie Shen, debug, IfStmt, LOG.debug("Deleting entity type:" + entityType + " id:" + entityId + " from invisible reverse related entity " + "entry of type:" + type + " id:" + id);
1456: Zhijie Shen, debug, IfStmt, LOG.debug("Deleting entity type:" + entityType + " id:" + entityId + " primary filter entry " + name + " " + value);
1560: Zhijie Shen, info, TryStmt, LOG.info("Discarded " + totalCount + " entities for timestamp " + timestamp + " and earlier in " + (t2 - t1) / 1000.0 + " seconds");
1547: Zhijie Shen, error, CatchClause, LOG.error("Got IOException while deleting entities for type " + entityType + ", continuing to next type", e);
1553: Zhijie Shen, info, IfStmt, LOG.info("Deleted " + typeCount + " entities of type " + entityType);
1620: Zhijie Shen, info, MethodDeclaration, LOG.info("Loaded timeline store version info " + loadedVersion);
1631: Akira Ajisaka, error, IfStmt, LOG.error(incompatibleMessage);
1625: Zhijie Shen, info, IfStmt, LOG.info("Storing timeline store version info " + getCurrentVersion());
1840: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Unrecognized domain column: " + key[prefix.length]);
187: Zhijie Shen, info, MethodDeclaration, LOG.info("Next rolling time for " + getName() + " is " + fdf.format(nextRollingCheckMillis));
192: Zhijie Shen, info, MethodDeclaration, LOG.info("Initializing RollingLevelDB for " + getName());
237: Zhijie Shen, warn, CatchClause, LOG.warn("Failed to initialize rolling leveldb " + dbName + " for " + getName());
259: Zhijie Shen, info, MethodDeclaration, LOG.info("Initializing rolling leveldb instance :" + rollingInstanceDBPath + " for start time: " + dbStartTime);
269: Zhijie Shen, warn, CatchClause, LOG.warn("Failed to open rolling leveldb instance :" + new File(rollingInstanceDBPath.toUri().getPath()), ioe);
267: Zhijie Shen, info, TryStmt, LOG.info("Added rolling leveldb instance " + dbName + " to " + getName());
312: Zhijie Shen, info, MethodDeclaration, LOG.info("Rolling new DB instance for " + getName());
329: Zhijie Shen, info, MethodDeclaration, LOG.info("Scheduling " + getName() + " DBs older than " + fdf.format(evictionThreshold) + " for eviction");
336: Zhijie Shen, info, IfStmt, LOG.info("Scheduling " + getName() + " eviction for " + fdf.format(entry.getKey()));
345: Zhijie Shen, info, MethodDeclaration, LOG.info("Evicting " + getName() + " DBs scheduled for eviction");
357: Zhijie Shen, warn, CatchClause, LOG.warn("Failed to evict old db " + path, ioe);
354: Zhijie Shen, info, TryStmt, LOG.info("Removing old db directory contents in " + path);
329: Zhijie Shen, info, MethodDeclaration, LOG.info("Using leveldb path " + dbPath);
363: Zhijie Shen, info, IfStmt, LOG.info("Waiting for deletion thread to complete its current action");
367: Zhijie Shen, warn, CatchClause, LOG.warn("Interrupted while waiting for deletion thread to complete," + " closing db now", e);
389: Zhijie Shen, info, ConstructorDeclaration, LOG.info("Starting deletion thread with ttl " + ttl + " and cycle " + "interval " + ttlInterval);
402: Akira Ajisaka, error, CatchClause, LOG.error(e.toString());
404: Zhijie Shen, info, CatchClause, LOG.info("Deletion thread received interrupt, exiting");
526: Zhijie Shen, warn, IfStmt, LOG.warn(String.format("Found unexpected column for entity %s of " + "type %s (0x%02x)", entityId, entityType, key[prefixlen]));
503: Jason Lowe, Error, CatchClause, LOG.warn("Error while decoding " + entityId + ":otherInfo:" + keyStr, e);
1064: Zhijie Shen, Error, CatchClause, LOG.error("Error putting entity " + entity.getEntityId() + " of type " + entity.getEntityType(), e);
1123: Zhijie Shen, Error, CatchClause, LOG.error("Error putting related entity " + relatedEntity.getId() + " of type " + relatedEntity.getType() + " for entity " + entity.getEntityId() + " of type " + entity.getEntityType(), e);
1161: Zhijie Shen, debug, IfStmt, LOG.debug("Starting put");
1197: Zhijie Shen, debug, IfStmt, LOG.debug("Put " + entityCount + " new leveldb entity entries and " + indexCount + " new leveldb index entries from " + entities.getEntities().size() + " timeline entities");
1377: Jason Lowe, Error, CatchClause, LOG.warn("Error while decoding " + tstype, e);
1413: Jason Lowe, Error, CatchClause, LOG.warn("Error while decoding " + name, e);
1489: Zhijie Shen, info, MethodDeclaration, LOG.info("Searching for start times to evict earlier than " + minStartTime);
1519: Zhijie Shen, debug, IfStmt, LOG.debug("Preparing to delete a batch of " + batchSize + " old start times");
1524: Zhijie Shen, debug, IfStmt, LOG.debug("Deleted batch of " + batchSize + ". Total start times deleted so far this cycle: " + startTimesCount);
1536: Zhijie Shen, debug, IfStmt, LOG.debug("Preparing to delete a batch of " + batchSize + " old start times");
1541: Zhijie Shen, debug, IfStmt, LOG.debug("Deleted batch of " + batchSize + ". Total start times deleted so far this cycle: " + startTimesCount);
1545: Zhijie Shen, info, TryStmt, LOG.info("Deleted " + startTimesCount + "/" + totalCount + " start time entities earlier than " + minStartTime);
1568: Zhijie Shen, info, TryStmt, LOG.info("Discarded " + totalCount + " entities for timestamp " + timestamp + " and earlier in " + (t2 - t1) / 1000.0 + " seconds");
1614: Zhijie Shen, info, MethodDeclaration, LOG.info("Loaded timeline store version info " + loadedVersion);
1625: Akira Ajisaka, error, IfStmt, LOG.error(incompatibleMessage);
1619: Zhijie Shen, info, IfStmt, LOG.info("Storing timeline store version info " + getCurrentVersion());
1818: Zhijie Shen, error, IfStmt, LOG.error("Unrecognized domain column: " + key[prefix.length]);
110: Jonathan Eagles, Error, CatchClause, LOG.info("Error when verifying access for user " + ugi + " on the events of the timeline entity " + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()), e);
294: Zhijie Shen, Error, CatchClause, LOG.warn("Error when verifying access for user " + callerUGI + " on the events of the timeline entity " + new EntityIdentifier(eventsOfOneEntity.getEntityId(), eventsOfOneEntity.getEntityType()), e);
371: Zhijie Shen, warn, CatchClause, LOG.warn("Skip the timeline entity: { id: " + entity.getEntityId() + ", type: " + entity.getEntityType() + " }", e);
119: Jian He, info, TryStmt, LOG.info("Creating a new database at th path: " + dbPath.toString());
112: Jian He, info, TryStmt, LOG.info("Loading the existing database at th path: " + dbPath.toString());
139: Jian He, info, MethodDeclaration, LOG.info("Loading timeline service state from leveldb");
144: Jian He, info, MethodDeclaration, LOG.info("Loaded " + numKeys + " master keys and " + numTokens + " tokens from leveldb, and latest sequence number is " + state.getLatestSequenceNumber());
404: Jian He, info, MethodDeclaration, LOG.info("Loaded timeline state store version info " + loadedVersion);
415: Akira Ajisaka, error, IfStmt, LOG.error(incompatibleMessage);
409: Jian He, info, IfStmt, LOG.info("Storing timeline state store version info " + getCurrentVersion());
107: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Verifying the access of " + (callerUGI == null ? null : callerUGI.getShortUserName()) + " on the timeline entity " + new EntityIdentifier(entity.getEntityId(), entity.getEntityType()));
131: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("ACL not found for access-type " + applicationAccessType + " for domain " + entity.getDomainId() + " owned by " + owner + ". Using default [" + YarnConfiguration.DEFAULT_YARN_APP_ACL + "]");
152: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Verifying the access of " + (callerUGI == null ? null : callerUGI.getShortUserName()) + " on the timeline domain " + domain);
143: Jian He, debug, IfStmt, LOG.debug("Storing master key " + key.getKeyId());
150: Jian He, error, CatchClause, LOG.error("Unable to store master key " + key.getKeyId(), e);
157: Jian He, debug, IfStmt, LOG.debug("Removing master key " + key.getKeyId());
164: Jian He, error, CatchClause, LOG.error("Unable to remove master key " + key.getKeyId(), e);
172: Jian He, debug, IfStmt, LOG.debug("Storing token " + tokenId.getSequenceNumber());
179: Jian He, error, CatchClause, LOG.error("Unable to store token " + tokenId.getSequenceNumber(), e);
187: Jian He, debug, IfStmt, LOG.debug("Storing token " + tokenId.getSequenceNumber());
194: Jian He, error, CatchClause, LOG.error("Unable to remove token " + tokenId.getSequenceNumber(), e);
202: Jian He, debug, IfStmt, LOG.debug("Updating token " + tokenId.getSequenceNumber());
209: Jian He, error, CatchClause, LOG.error("Unable to update token " + tokenId.getSequenceNumber(), e);
214: Jian He, info, MethodDeclaration, LOG.info("Recovering " + getClass().getSimpleName());
138: Zhijie Shen, Error, CatchClause, LOG.error("Error getting entities", e);
168: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error getting entity", e);
211: Zhijie Shen, Error, CatchClause, LOG.error("Error getting entity timelines", e);
233: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(msg);
241: Zhijie Shen, Error, CatchClause, LOG.error("Error putting entities", e);
264: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(msg);
272: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(e.getMessage(), e);
275: Junping Du, Error, CatchClause, LOG.error("Error putting domain", e);
279: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error putting domain", e);
307: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error getting domain", e);
343: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error getting domains", e);
99: Zhijie Shen, info, MethodDeclaration, LOG.info("Starting testReadWriteHistoryData");
201: Zhijie Shen, info, MethodDeclaration, LOG.info("Starting testWriteAfterApplicationFinish");
238: Zhijie Shen, info, MethodDeclaration, LOG.info("Starting testMassiveWriteContainerHistoryData");
257: Zhijie Shen, info, MethodDeclaration, LOG.info("Starting testMissingContainerHistoryData");
264: Zhijie Shen, info, MethodDeclaration, LOG.info("Starting testMissingApplicationAttemptHistoryData");
271: Zhijie Shen, info, MethodDeclaration, LOG.info("Starting testInitExistingWorkingDirectoryInSafeMode");
293: Zhijie Shen, info, MethodDeclaration, LOG.info("Starting testInitNonExistingWorkingDirectoryInSafeMode");
874: Junping Du, Info, IfStmt, List<ContainerLogFileInfo> logMeta = logInfo.getContainerLogsInfo();
902: Junping Du, Info, IfStmt, List<ContainerLogFileInfo> logMeta = logInfo.getContainerLogsInfo();
371: Robert Kanter, info, MethodDeclaration, Log.getLog().info("Start test for " + num);
417: Robert Kanter, info, MethodDeclaration, Log.getLog().info("Duration for " + num + ": " + duration);
90: Bikas Saha, error, IfStmt, LOG.error(message);
106: Jian He, warn, CatchClause, LOG.warn("Could not get information of requester, ignoring for now.");
103: Jian He, info, TryStmt, LOG.info("Initialized Federation proxy for user: {}", this.originalUser.getUserName());
154: Jian He, error, CatchClause, LOG.error("Exception while trying to create proxy to the ResourceManager" + " for SubClusterId: {}", subClusterId, e);
124: Jian He, info, TryStmt, LOG.info("Failing over to the ResourceManager for SubClusterId: {}", subClusterId);
145: Subru Krishnan, info, MethodDeclaration, LOG.info("Connecting to {} subClusterId {} with protocol {} as user {}", rmAddress, subClusterId, protocol.getSimpleName(), originalUser);
133: Subru Krishnan, info, IfStmt, LOG.info("Connecting to {} subClusterId {} with protocol {}" + " without a proxy user", rmAddress, subClusterId, protocol.getSimpleName());
209: Subru Krishnan, warn, CatchClause, LOG.warn("Exception while trying to close proxy", e);
101: Subru Krishnan, warn, CatchClause, LOG.warn("Failed to get policy from FederationFacade with queue " + queue + ": " + e.getMessage());
109: Subru Krishnan, info, IfStmt, LOG.info("No policy configured for queue {} in StateStore," + " fallback to default queue", queue);
115: Subru Krishnan, warn, CatchClause, LOG.warn("No fallback behavior defined in store, defaulting to XML " + "configuration fallback behavior.");
122: Subru Krishnan, info, IfStmt, LOG.info("No policy configured for default queue {} in StateStore," + " fallback to local config", queue);
168: Subru Krishnan, info, MethodDeclaration, LOG.info("Creating policy manager of type: " + configuration.getType());
75: Subru Krishnan, warn, CatchClause, LOG.warn("No fallback behavior defined in store, defaulting to XML " + "configuration fallback behavior.");
159: Subru Krishnan, warn, CatchClause, LOG.warn(errMsg, e);
166: Subru Krishnan, warn, IfStmt, LOG.warn("There is no policies configured for queue: " + queue + " we" + " fallback to default policy for: " + YarnConfiguration.DEFAULT_FEDERATION_POLICY_KEY);
176: Subru Krishnan, warn, CatchClause, LOG.warn(errMsg, e);
260: Subru Krishnan, ERROR, IfStmt, LOG.debug("ERROR resolving sub-cluster for resourceName: " + rr.getResourceName() + " we are falling back to homeSubCluster:" + homeSubcluster);
274: Subru Krishnan, debug, IfStmt, LOG.debug("The homeSubCluster (" + homeSubcluster + ") we are " + "defaulting to is not active, the ResourceRequest " + "will be ignored.");
75: Subru Krishnan, Error, CatchClause, LOG.error("Error parsing the policy.", e);
142: Subru Krishnan, error, CatchClause, LOG.error("Failed to parse file " + fileName, e);
93: Subru Krishnan, info, IfStmt, LOG.info("The machine list file path is not specified in the configuration");
104: Subru Krishnan, info, CatchClause, LOG.info("The configured machine list file path {} does not exist", fileName);
131: Subru Krishnan, warn, IfStmt, LOG.warn("Skipping malformed line in machine list: " + line);
122: Subru Krishnan, debug, IfStmt, LOG.debug("Loading node into resolver: {} --> {}", nodeName, subClusterId);
124: Subru Krishnan, debug, IfStmt, LOG.debug("Loading rack into resolver: {} --> {} ", rackName, subClusterId);
139: Subru Krishnan, info, TryStmt, LOG.info("Successfully loaded file {}", fileName);
168: Subru Krishnan, warn, IfStmt, LOG.warn("The queried SubCluster: {} does not exist.", subClusterId);
276: Subru Krishnan, warn, IfStmt, LOG.warn("Policy for queue: {} does not exist.", queue);
174: Carlo Curino, info, MethodDeclaration, LOG.info("Initialized connection pool to the Federation StateStore " + "database at address: " + url);
229: Carlo Curino, info, TryStmt, LOG.info("Registered the SubCluster " + subClusterId + " into the StateStore");
290: Carlo Curino, info, TryStmt, LOG.info("Deregistered the SubCluster " + subClusterId + " state to " + state.toString());
353: Carlo Curino, info, TryStmt, LOG.info("Heartbeated the StateStore for the specified SubCluster " + subClusterId);
411: Subru Krishnan, warn, IfStmt, LOG.warn("The queried SubCluster: {} does not exist.", subClusterId);
440: Carlo Curino, debug, IfStmt, LOG.debug("Got the information about the specified SubCluster " + subClusterInfo.toString());
589: Carlo Curino, info, IfStmt, LOG.info("Application: " + appId + " already present with SubCluster:  " + subClusterHome);
579: Carlo Curino, info, IfStmt, LOG.info("Insert into the StateStore the application: " + appId + " in SubCluster:  " + subClusterHome);
651: Carlo Curino, info, TryStmt, LOG.info("Update the SubCluster to {} for application {} in the StateStore", subClusterId, appId);
704: Carlo Curino, debug, IfStmt, LOG.debug("Got the information about the specified application  " + request.getApplicationId() + ". The AM is running in " + homeRM);
809: Carlo Curino, info, TryStmt, LOG.info("Delete from the StateStore the application: {}", request.getApplicationId());
860: Subru Krishnan, warn, IfStmt, LOG.warn("Policy for queue: {} does not exist.", request.getQueue());
856: Carlo Curino, debug, IfStmt, LOG.debug("Selected from StateStore the policy for the queue: " + subClusterPolicyConfiguration.toString());
922: Carlo Curino, info, TryStmt, LOG.info("Insert into the state store the policy for the queue: " + policyConf.getQueue());
117: Subru Krishnan, info, MethodDeclaration, LOG.info("Initializing ZooKeeper connection");
126: Subru Krishnan, error, CatchClause, LOG.error("Cannot initialize the ZK connection", e);
344: Subru Krishnan, warn, IfStmt, LOG.warn("The queried SubCluster: {} does not exist.", subClusterId);
391: Subru Krishnan, warn, IfStmt, LOG.warn("Policy for queue: {} does not exist.", queue);
577: Subru Krishnan, error, IfStmt, LOG.error("{} does not exist", znode);
609: Subru Krishnan, debug, IfStmt, LOG.debug("{} not created", znode);
611: Subru Krishnan, info, IfStmt, LOG.info("{} already existed and we are not updating", znode);
97: Arun Suresh, debug, ForeachStmt, LOG.debug("Registering Federation StateStore Client metrics for {}", methodName);
125: Arun Suresh, ERROR, IfStmt, LOG.error(UNKOWN_FAIL_ERROR_MSG, methodName);
140: Arun Suresh, ERROR, IfStmt, LOG.error(UNKNOWN_SUCCESS_ERROR_MSG, methodName);
80: Carlo Curino, error, CatchClause, LOG.error("Invalid SubCluster State value in the StateStore does not" + " match with the YARN Federation standard.");
60: Subru Krishnan, warn, IfStmt, LOG.warn(message);
83: Subru Krishnan, warn, IfStmt, LOG.warn(message);
105: Subru Krishnan, warn, IfStmt, LOG.warn(message);
128: Subru Krishnan, warn, IfStmt, LOG.warn(message);
152: Subru Krishnan, warn, IfStmt, LOG.warn(message);
176: Subru Krishnan, warn, IfStmt, LOG.warn(message);
64: Subru Krishnan, warn, IfStmt, LOG.warn(message);
89: Subru Krishnan, warn, IfStmt, LOG.warn(message);
99: Subru Krishnan, warn, IfStmt, LOG.warn(message);
120: Subru Krishnan, warn, IfStmt, LOG.warn(message);
150: Subru Krishnan, warn, IfStmt, LOG.warn(message);
173: Subru Krishnan, warn, IfStmt, LOG.warn(message);
211: Subru Krishnan, warn, IfStmt, LOG.warn(message);
228: Subru Krishnan, warn, IfStmt, LOG.warn(message);
246: Subru Krishnan, warn, IfStmt, LOG.warn(message);
253: Subru Krishnan, warn, IfStmt, LOG.warn(message);
270: Subru Krishnan, warn, IfStmt, LOG.warn(message);
282: Subru Krishnan, warn, CatchClause, LOG.warn(message);
292: Subru Krishnan, warn, IfStmt, LOG.warn(message);
310: Subru Krishnan, warn, IfStmt, LOG.warn(message);
56: Subru Krishnan, warn, IfStmt, LOG.warn(message);
79: Subru Krishnan, warn, IfStmt, LOG.warn(message);
100: Subru Krishnan, warn, IfStmt, LOG.warn(message);
122: Subru Krishnan, warn, IfStmt, LOG.warn(message);
138: Subru Krishnan, warn, IfStmt, LOG.warn(message);
115: Subru Krishnan, error, IfStmt, log.error(errMsg);
112: Subru Krishnan, error, IfStmt, log.error(errMsg, t);
130: Carlo Curino, error, MethodDeclaration, log.error(errMsg);
144: Carlo Curino, error, MethodDeclaration, log.error(errMsg);
163: Carlo Curino, error, IfStmt, log.error(errMsg);
160: Carlo Curino, error, IfStmt, log.error(errMsg, t);
178: Carlo Curino, debug, MethodDeclaration, LOG.debug("Setting property {} with value {}", property, value);
196: Carlo Curino, debug, IfStmt, LOG.debug("NULL Username specified for Store connection, so ignoring");
194: Carlo Curino, debug, IfStmt, LOG.debug("Setting non NULL Username for Store connection");
211: Carlo Curino, debug, IfStmt, LOG.debug("NULL Credentials specified for Store connection, so ignoring");
209: Carlo Curino, debug, IfStmt, LOG.debug("Setting non NULL Credentials for Store connection");
72: Subru Krishnan, info, ConstructorDeclaration, LOG.info("Using registry {} with base directory: {}", this.registry.getClass().getName(), this.registryBaseDir);
89: Subru Krishnan, warn, CatchClause, LOG.warn("Unexpected exception from listDirRegistry", e);
107: Subru Krishnan, warn, CatchClause, LOG.warn("Unexpected exception from removeKeyRegistry", e);
129: Subru Krishnan, debug, IfStmt, LOG.debug("Same amrmToken received from {}, skip writing registry for {}", subClusterId, appId);
134: Subru Krishnan, info, MethodDeclaration, LOG.info("Writing/Updating amrmToken for {} to registry for {}", subClusterId, appId);
144: Subru Krishnan, error, CatchClause, LOG.error("Failed writing AMRMToken to registry for subcluster " + subClusterId, e);
167: Subru Krishnan, warn, CatchClause, LOG.warn("Unexpected exception from listDirRegistry", e);
171: Subru Krishnan, info, IfStmt, LOG.info("Application {} does not exist in registry", appId);
177: Subru Krishnan, info, ForeachStmt, LOG.info("Reading amrmToken for subcluster {} for {}", scId, appId);
191: Subru Krishnan, error, CatchClause, LOG.error("Failed reading registry key " + key + ", skipping subcluster " + scId, e);
209: Subru Krishnan, info, MethodDeclaration, LOG.info("Removing all registry entries for {}", appId);
221: Subru Krishnan, error, CatchClause, LOG.error("Failed removing registry directory key " + key, e);
249: Subru Krishnan, error, IfStmt, LOG.error("Registry resolve key " + key + " failed", e);
273: Subru Krishnan, error, IfStmt, LOG.error("Registry remove key " + key + " failed", e);
302: Subru Krishnan, error, IfStmt, LOG.error("Registry write key " + key + " failed", e);
326: Subru Krishnan, error, IfStmt, LOG.error("Registry list key " + key + " failed", e);
121: Jian He, error, CatchClause, LOG.error("Failed to initialize the FederationStateStoreFacade object", ex);
188: Jian He, info, IfStmt, LOG.info("Creating a JCache Manager with name " + this.getClass().getSimpleName());
258: Jian He, info, IfStmt, LOG.info("Flushing subClusters from cache and rehydrating from store," + " most likely on account of RM failover.");
369: Akira Ajisaka, info, IfStmt, LOG.info("Opportunistic allocation requested for [priority={}, " + "allocationRequestId={}, num_containers={}, capability={}] " + "allocated = {}", anyAsk.getPriority(), anyAsk.getAllocationRequestId(), anyAsk.getNumContainers(), anyAsk.getCapability(), containers.keySet());
387: Arun Suresh, info, IfStmt, LOG.info("No nodes currently available to " + "allocate OPPORTUNISTIC containers.");
413: Arun Suresh, info, IfStmt, LOG.info("Nodes for scheduling has a blacklisted node" + " [" + rNodeHost + "]..");
441: Arun Suresh, info, ForeachStmt, LOG.info("Allocated [" + container.getId() + "] as opportunistic at " + "location [" + location + "]");
456: Arun Suresh, warn, IfStmt, LOG.warn("Unable to allocate any opportunistic containers.");
151: Wangda Tan, info, IfStmt, LOG.info("# of outstandingOpReqs in ANY (at " + "priority = " + schedulerKey.getPriority() + ", allocationReqId = " + schedulerKey.getAllocationRequestId() + ", with capability = " + request.getCapability() + " ) : " + ", with location = " + request.getResourceName() + " ) : " + ", numContainers = " + eReq.getRequest().getNumContainers());
89: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("Creating password for {} for user {} to be run on NM {}", identifier.getContainerID(), identifier.getUser(), identifier.getNmHostAddress());
116: Jason Lowe, debug, IfStmt, LOG.debug("Retrieving password for {} for user {} to be run on NM {}", identifier.getContainerID(), identifier.getUser(), identifier.getNmHostAddress());
74: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("creating password for {} for user {} to run on NM {}", identifier.getApplicationAttemptId(), identifier.getApplicationSubmitter(), identifier.getNodeId());
99: Akira Ajisaka, debug, MethodDeclaration, LOG.debug("retriving password for {} for user {} to run on NM {}", identifier.getApplicationAttemptId(), identifier.getApplicationSubmitter(), identifier.getNodeId());
47: Karthik Kambatla, warn, IfStmt, LOG.warn("Specified cache depth was less than or equal to zero." + " Using default value instead. Default: {}, Specified: {}", YarnConfiguration.DEFAULT_SHARED_CACHE_NESTED_LEVEL, cacheDepth);
110: Subru Krishnan, warn, MethodDeclaration, LOG.warn("Abnormal shutdown of UAMPoolManager, still {} UAMs in map", addressList.size());
122: Subru Krishnan, error, CatchClause, LOG.error("Failed to kill unmanaged application master", e);
118: Subru Krishnan, info, TryStmt, LOG.info("Force-killing UAM id " + uamId + " for application " + appIdMap.get(uamId));
134: Subru Krishnan, error, CatchClause, LOG.error("Failed to kill unmanaged application master", e);
178: Subru Krishnan, info, TryStmt, LOG.info("Received new application ID {} from RM", appId);
227: Subru Krishnan, info, TryStmt, LOG.info("Launching UAM id {} for application {}", uamId, appId);
268: Subru Krishnan, info, TryStmt, LOG.info("Reattaching UAM id {} for application {}", uamId, appId);
314: Subru Krishnan, info, MethodDeclaration, LOG.info("Registering UAM id {} for application {}", uamId, this.appIdMap.get(uamId));
353: Subru Krishnan, info, MethodDeclaration, LOG.info("Finishing UAM id {} for application {}", uamId, this.appIdMap.get(uamId));
362: Subru Krishnan, info, IfStmt, LOG.info("UAM id {} is unregistered", uamId);
220: Subru Krishnan, info, ForeachStmt, LOG.info("RegisterUAM returned existing running container " + container.getId());
224: Subru Krishnan, info, ForeachStmt, LOG.info("RegisterUAM returned existing NM token for node " + nmToken.getNodeId());
303: Subru Krishnan, debug, CatchClause, LOG.debug("Interrupted while waiting to put on response queue", ex);
313: Subru Krishnan, info, IfStmt, LOG.info("Unmanaged AM still not successfully launched/registered yet." + " Saving the allocate request and send later.");
411: Subru Krishnan, info, MethodDeclaration, LOG.info("Submitting unmanaged application {}", appId);
449: Subru Krishnan, info, IfStmt, LOG.info("Current application state of {} is {}, will retry later.", appId, state);
464: Subru Krishnan, info, IfStmt, LOG.info("Current attempt state of " + appAttemptId + " is " + attemptReport.getYarnApplicationAttemptState() + ", waiting for current attempt to reach " + attemptState);
472: Subru Krishnan, warn, CatchClause, LOG.warn("Interrupted while waiting for current attempt of " + appId + " to reach " + attemptState);
498: Subru Krishnan, warn, IfStmt, LOG.warn("AMRMToken not found in the application report for application: {}", this.applicationId);
623: Subru Krishnan, debug, IfStmt, LOG.debug("Interrupted while waiting for queue", ex);
626: Subru Krishnan, warn, CatchClause, LOG.warn("IO Error occurred while processing heart beat for " + applicationId, ex);
629: Subru Krishnan, Error, CatchClause, LOG.warn("Error occurred while processing heart beat for " + applicationId, ex);
589: Subru Krishnan, debug, IfStmt, LOG.debug("Sending Heartbeat to Unmanaged AM. AskList:" + ((request.getAskList() == null) ? " empty" : request.getAskList().size()));
606: Subru Krishnan, debug, IfStmt, LOG.debug("Received new AMRMToken");
612: Subru Krishnan, debug, IfStmt, LOG.debug("Received Heartbeat reply from RM. Allocated Containers:" + ((response.getAllocatedContainers() == null) ? " empty" : response.getAllocatedContainers().size()));
635: Subru Krishnan, info, MethodDeclaration, LOG.info("UnmanagedApplicationManager has been stopped for {}. " + "AMRequestHandlerThread thread is exiting", applicationId);
647: Subru Krishnan, error, MethodDeclaration, LOG.error("Heartbeat thread {} for application {} crashed!", t.getName(), applicationId, e);
66: Jian He, info, MethodDeclaration, LOG.info("Filter initializers set for timeline service: " + actualInitializers);
74: Subru Krishnan, info, MethodDeclaration, LOG.info("App attempt {} not registered, most likely due to RM failover. " + " Trying to re-register.", appId);
83: Subru Krishnan, Error, IfStmt, LOG.error("Error trying to re-register AM", e);
81: Subru Krishnan, info, IfStmt, LOG.info("Concurrent thread successfully registered, moving on.");
163: Subru Krishnan, info, TryStmt, LOG.info("Creating RMProxy to RM {} for protocol {} for user {}", rmClusterId, protocol.getSimpleName(), user);
70: Jian He, warn, CatchClause, LOG.warn(msg);
92: Jian He, warn, IfStmt, LOG.warn(message);
156: Jian He, debug, ForeachStmt, LOG.debug(tk.getService() + " = " + tk.toString());
98: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(message, e);
124: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(message, e);
161: Wangda Tan, error, CatchClause, LOG.error(message, e);
333: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(message, e);
322: Jonathan Eagles, warn, CatchClause, LOG.warn(ex.getMessage());
141: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(message, e);
88: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(message, e);
252: Subru Krishnan, info, MethodDeclaration, LOG.info("Registering application attempt: " + attemptId);
285: Subru Krishnan, info, IfStmt, LOG.info("Register call in RM start waiting");
290: Subru Krishnan, info, CatchClause, LOG.info("Register call in RM wait interrupted", e);
288: Subru Krishnan, info, TryStmt, LOG.info("Register call in RM wait finished");
307: Subru Krishnan, info, MethodDeclaration, LOG.info("Finishing application attempt: " + attemptId);
311: Subru Krishnan, warn, IfStmt, LOG.warn(message);
350: Subru Krishnan, info, MethodDeclaration, LOG.info("Allocate from application attempt: " + attemptId);
354: Subru Krishnan, warn, IfStmt, LOG.warn(message);
394: Subru Krishnan, info, IfStmt, LOG.info("Releasing containers: " + request.getReleaseList().size());
423: Subru Krishnan, info, MethodDeclaration, LOG.info("Allocating containers: " + containerList.size() + " for application attempt: " + conf.get("AMRMTOKEN"));
490: Subru Krishnan, info, MethodDeclaration, LOG.info("Application submitted: " + appId);
516: Subru Krishnan, info, MethodDeclaration, LOG.info("Force killing application: " + appId);
155: Subru Krishnan, info, MethodDeclaration, LOG.info("Initial headroom");
179: Subru Krishnan, info, MethodDeclaration, LOG.info("After headroom update");
220: Subru Krishnan, info, MethodDeclaration, LOG.info("Performed " + numIterations + " policy invocations (and " + "validations) in " + (tend - tstart) + "ms");
515: Subru Krishnan, info, ForeachStmt, LOG.info(entry.getKey() + " --> " + str);
209: Carlo Curino, ERROR, CatchClause, LOG.error("ERROR: failed to init HSQLDB " + e1.getMessage());
239: Carlo Curino, ERROR, CatchClause, LOG.error("ERROR: failed to inizialize HSQLDB " + e.getMessage());
214: Carlo Curino, info, TryStmt, LOG.info("Database Init: Start");
236: Carlo Curino, info, TryStmt, LOG.info("Database Init: Complete");
247: Carlo Curino, ERROR, CatchClause, LOG.error("ERROR: failed to close connection to HSQLDB DB " + e.getMessage());
65: Subru Krishnan, error, CatchClause, LOG.error("Cannot initialize ZooKeeper store", e);
40: Arun Suresh, info, MethodDeclaration, LOG.info("Test: aggregate metrics are initialized correctly");
47: Arun Suresh, info, MethodDeclaration, LOG.info("Test: aggregate metrics are updated correctly");
52: Arun Suresh, info, MethodDeclaration, LOG.info("Test: Aggregate and method successful calls updated correctly");
70: Arun Suresh, info, MethodDeclaration, LOG.info("Test: Running stats correctly calculated for 2 metrics");
94: Arun Suresh, info, MethodDeclaration, LOG.info("Test: Aggregate and method failed calls updated correctly");
113: Arun Suresh, info, MethodDeclaration, LOG.info("Calling Metrics class directly");
117: Arun Suresh, info, MethodDeclaration, LOG.info("Test: Aggregate and method calls did not update");
133: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: failed registerSubCluster call");
141: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: successful registerSubCluster call with duration {}", duration);
161: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
176: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
194: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
212: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
230: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
282: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
300: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
321: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
338: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
356: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
374: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
392: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
410: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
427: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
444: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
466: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
483: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
500: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
516: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
532: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
549: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
566: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
582: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
610: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
624: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
638: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
652: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
666: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
693: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
707: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
722: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
736: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
751: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
765: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
779: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
807: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
821: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
835: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
897: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
914: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
991: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
1008: Subru Krishnan, info, CatchClause, LOG.info(e.getMessage());
183: Subru Krishnan, info, CatchClause, LOG.info("Register thread exception", e);
193: Subru Krishnan, info, SynchronizedStmt, LOG.info("Starting register thread");
200: Subru Krishnan, info, CatchClause, LOG.info("Test main wait interrupted", e);
196: Subru Krishnan, info, TryStmt, LOG.info("Test main starts waiting");
198: Subru Krishnan, info, TryStmt, LOG.info("Test main wait finished");
213: Subru Krishnan, info, MethodDeclaration, LOG.info("Test main wait for register thread to finish");
215: Subru Krishnan, info, MethodDeclaration, LOG.info("Register thread finished");
264: Junping Du, warn, IfStmt, LOG.warn(containerId + " is not active, returning terminated error");
275: Junping Du, info, MethodDeclaration, LOG.info("Reacquiring " + containerId + " with pid " + pid);
296: Junping Du, info, IfStmt, LOG.info(containerId + " was deactivated");
541: Vinod Kumar Vavilapalli, info, ForeachStmt, LOG.info(str);
749: Varun Vasudev, error, CatchClause, LOG.error("Unable to get Local hostname and ip for " + container.getContainerId(), e);
777: Arun Suresh, warn, MethodDeclaration, LOG.warn(container.getContainerId() + " doesn't support pausing.");
788: Arun Suresh, warn, MethodDeclaration, LOG.warn(container.getContainerId() + " doesn't support resume.");
808: Varun Vasudev, error, CatchClause, LOG.error("Got exception reading pid from pid-file " + pidFile, e);
865: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn(message);
166: Robert Kanter, info, MethodDeclaration, LOG.info("Copying from " + nmPrivateContainerTokensPath + " to " + tokenDst);
174: Jason Lowe, info, MethodDeclaration, LOG.info("Localizer CWD set to " + appStorageDir + " = " + localizerFc.getWorkingDirectory());
276: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Container " + containerIdStr + " pid file not set. Returning terminated error");
305: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exit code from container " + containerId + " is : " + exitCode);
311: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Exception from container-launch with container ID: " + containerId + " and exit code: " + exitCode, e);
296: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Container " + containerIdStr + " was marked as inactive. Returning terminated error");
370: Jian He, info, MethodDeclaration, LOG.info("launchContainer: " + Arrays.toString(command));
558: Varun Saxena, debug, IfStmt, LOG.debug("Sending signal " + signal.getValue() + " to pid " + pid + " as user " + user);
634: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Deleting absolute path : " + subDir);
637: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("delete returned false for path: [" + subDir + "]");
643: Vinod Kumar Vavilapalli, info, ForeachStmt, LOG.info("Deleting path : " + del);
646: Jason Lowe, warn, IfStmt, LOG.warn("delete returned false for path: [" + del + "]");
729: Karthik Kambatla, warn, CatchClause, LOG.warn("Unable to get Free Space for " + curBase.toString(), e);
809: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to create the user directory : " + localDir, e);
836: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing user " + user);
851: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to create app cache directory : " + appDir, e);
859: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to create file cache directory : " + distDir, e);
897: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to create app directory " + fullAppDir.toString(), e);
928: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to create the app-log directory : " + appLogDir, e);
962: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to create the container-log directory : " + appLogDir, e);
90: Varun Vasudev, debug, IfStmt, LOG.debug(msg);
120: Junping Du, error, IfStmt, LOG.error("Unable to locate dependency task for deletion task " + info.getTask().getTaskId());
161: Varun Vasudev, error, CatchClause, LOG.error("Unable to store deletion task " + task.getTaskId(), e);
187: Haibo Chen, info, TryStmt, LOG.info("Disk Validator '" + diskValidatorName + "' is loaded.");
342: Robert Joseph Evans, warn, CatchClause, LOG.warn("Unable to create directory " + dir + " error " + e.getMessage() + ", removing from the list of valid directories.");
412: Vinod Kumar Vavilapalli, warn, SwitchStmt, LOG.warn(entry.getValue().cause + " is unknown for disk error.");
418: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Directory " + dir + " error, " + errorInformation.message + ", removing from list of valid directories");
430: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Directory " + dir + " passed disk check, adding to list of valid directories.");
439: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Directory " + dir + " error " + dirsFailedCheck.get(dir).message);
446: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Directory " + dir + " error " + dirsFailedCheck.get(dir).message);
210: Allen Wittenauer, warn, IfStmt, LOG.warn(YarnConfiguration.NM_NONSECURE_MODE_LIMIT_USERS + ": impersonation without authentication enabled");
304: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exit code from container executor initialization is : " + exitCode, e);
323: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Failed to bootstrap configured resource subsystems! ", e);
315: I am also known as @tshooter.), debug, IfStmt, LOG.debug("Resource handler chain enabled = " + (resourceHandlerChain != null));
319: I am also known as @tshooter.), debug, IfStmt, LOG.debug("Bootstrapping resource handler chain");
336: Varun Vasudev, error, CatchClause, LOG.error("Failed to initialize linux container runtime(s)!", e);
407: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exit code from container " + locId + " startLocalizer is : " + exitCode, e);
550: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("ResourceHandlerChain.preStart() failed!", e);
530: Varun Vasudev, warn, SwitchStmt, LOG.warn("PrivilegedOperation type unsupported in launch: " + op.getOperationType());
542: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Failed to squash cgroup operations!", e);
582: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("ResourceHandlerChain.postComplete failed for " + "containerId: " + containerId + ". Exception: " + e);
568: Varun Vasudev, info, IfStmt, LOG.info("Container was marked as inactive. Returning terminated error");
593: Eric Yang, warn, MethodDeclaration, LOG.warn("Exit code from container " + containerId + " is : " + exitCode);
599: Eric Yang, warn, IfStmt, LOG.warn("Exception from container-launch with container ID: " + containerId + " and exit code: " + exitCode, e);
728: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("ResourceHandlerChain.postComplete failed for " + "containerId: " + containerId + " Exception: " + e);
716: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("ResourceHandlerChain.reacquireContainer failed for " + "containerId: " + containerId + " Exception: " + e);
762: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.warn("Error in signalling container " + pid + " with " + signal + "; exit = " + retCode, e);
796: Eric Yang, Error, CatchClause, LOG.warn("Error in reaping container " + container.getContainerId().toString() + " exit = " + retCode, e);
833: Vinod Kumar Vavilapalli, info, ForeachStmt, LOG.info("Deleting path : " + del);
828: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Deleting absolute path : " + dir);
848: Jason Lowe, error, CatchClause, LOG.error("DeleteAsUser for " + StringUtils.join(" ", pathsToDelete) + " returned with exit code: " + exitCode, e);
885: Karthik Kambatla, error, CatchClause, LOG.error("ListAsUser for " + dir + " returned with exit code: " + e.getExitCode(), e);
937: Varun Vasudev, warn, CatchClause, LOG.warn("Exception in LinuxContainerExecutor mountCgroups ", e);
968: Eric Yang, warn, CatchClause, LOG.warn("Unable to remove docker container: " + containerId);
962: Eric Yang, info, IfStmt, LOG.info("Removing Docker container : " + containerId);
129: Jason Lowe, warn, IfStmt, LOG.warn("Using " + YarnConfiguration.NM_MAX_PER_DISK_UTILIZATION_PERCENTAGE + " as " + YarnConfiguration.NM_WM_LOW_PER_DISK_UTILIZATION_PERCENTAGE + ", because " + YarnConfiguration.NM_WM_LOW_PER_DISK_UTILIZATION_PERCENTAGE + " is not configured properly.");
173: Jason Lowe, Error, CatchClause, LOG.warn("Error while checking local directories: ", t);
356: Sunil G, Error, MethodDeclaration, List<String> erroredLogDirsList = logDirs.getErroredDirs();
467: Jason Lowe, error, IfStmt, LOG.error("Most of the disks failed. " + getDisksHealthReport(false));
474: Jason Lowe, info, IfStmt, LOG.info("Disk(s) failed: " + report);
478: Jason Lowe, info, IfStmt, LOG.info("Disk(s) turned good: " + report);
577: Jason Lowe, warn, CatchClause, LOG.warn("Failed to find " + pathStr + " at " + dir, ie);
625: Siddharth Seth, warn, CatchClause, LOG.warn(e.getMessage());
618: Siddharth Seth, warn, IfStmt, LOG.warn(paths[i] + " is not a valid path. Path should be with " + FILE_SCHEME + " scheme or without scheme");
94: Arun Murthy, info, IfStmt, LOG.info(createSuccessLog(user, operation, target, appId, containerId));
111: Arun Murthy, info, IfStmt, LOG.info(createSuccessLog(user, operation, target, null, null));
155: Arun Murthy, warn, IfStmt, LOG.warn(createFailureLog(user, operation, target, description, appId, containerId));
175: Arun Murthy, warn, IfStmt, LOG.warn(createFailureLog(user, operation, target, description, null, null));
196: Wangda Tan, error, CatchClause, LOG.error("Failed to create NodeLabelsProvider based on Configuration", e);
203: Wangda Tan, debug, IfStmt, LOG.debug("Distributed Node Labels is enabled" + " with provider class as : " + provider.getClass().toString());
291: Jason Lowe, info, IfStmt, LOG.info("Removing state store due to decommission");
295: Jason Lowe, info, IfStmt, LOG.info("Removing state store at " + recoveryRoot + " due to decommission");
299: Jason Lowe, warn, IfStmt, LOG.warn("Unable to delete " + recoveryRoot);
319: Wangda Tan, info, IfStmt, LOG.info("Node Manager health check script is not available " + "or doesn't have execute permission, so not " + "starting the node health script runner.");
508: Jason Lowe, Error, CatchClause, LOG.error("Error while shutting down NodeManager", t);
540: Akira Ajisaka, Error, CatchClause, LOG.error("Error while rebooting NodeStatusUpdater.", e);
533: Jian He, info, IfStmt, LOG.info("Preserving containers on resync");
526: Jian He, info, IfStmt, LOG.info("Cleaning up running containers on resync");
572: Varun Saxena, debug, IfStmt, LOG.debug("Remove collector data for done app " + entry.getKey());
567: Varun Saxena, debug, IfStmt, LOG.debug(entry.getKey() + " : " + data.getCollectorAddr() + "@<" + data.getRMIdentifier() + ", " + data.getVersion() + ">");
921: Akira Ajisaka, Error, CatchClause, LOG.error("Error starting NodeManager", t);
902: Akira Ajisaka, error, IfStmt, LOG.error(message);
936: Vinod Kumar Vavilapalli, warn, SwitchStmt, LOG.warn("Invalid shutdown event " + event.getType() + ". Ignoring.");
75: Karthik Kambatla, info, MethodDeclaration, LOG.info(" Using ResourceCalculatorPlugin : " + this.resourceCalculatorPlugin);
85: Naganarasimha, info, IfStmt, LOG.info("Node Resource monitoring interval is <=0. " + this.getClass().getName() + " is disabled.");
90: Karthik Kambatla, info, IfStmt, LOG.info("ResourceCalculatorPlugin is unavailable on this system. " + this.getClass().getName() + " is disabled.");
118: Karthik Kambatla, warn, CatchClause, LOG.warn("Could not wait for the thread to join");
167: Karthik Kambatla, warn, CatchClause, LOG.warn(NodeResourceMonitorImpl.class.getName() + " is interrupted. Exiting.");
192: Sunil G, info, MethodDeclaration, LOG.info("Nodemanager resources is set to: " + totalResource);
228: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(message);
232: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug(YARN_NODEMANAGER_DURATION_TO_TRACK_STOPPED_CONTAINERS + " :" + durationToTrackStoppedContainers);
236: Devaraj K, info, MethodDeclaration, LOG.info("Initialized nodemanager with :" + " physical-memory=" + memoryMb + " virtual-memory=" + virtualMemoryMb + " virtual-cores=" + virtualCores);
250: Devaraj K, info, MethodDeclaration, LOG.info("Node ID assigned is : " + this.nodeId);
262: Jason Darrell Lowe, error, CatchClause, LOG.error(errorMessage, e);
301: Junping Du, warn, CatchClause, LOG.warn("Unregistration of the Node " + this.nodeId + " failed.", e);
298: Junping Du, info, TryStmt, LOG.info("Successfully Unregistered the Node " + this.nodeId + " with ResourceManager.");
309: Eric Payne, info, IfStmt, LOG.info("Currently being shutdown. Aborting reboot");
323: Eric Payne, error, CatchClause, LOG.error(errorMessage, e);
320: Eric Payne, info, TryStmt, LOG.info("NodeStatusUpdater thread is reRegistered and restarted");
382: Jian He, info, IfStmt, LOG.info("Registering with RM using containers :" + containerReports);
390: Wangda Tan, debug, IfStmt, LOG.debug("The cache log aggregation status size:" + logAggregationReports.size());
466: Akira Ajisaka, info, MethodDeclaration, LOG.info(successfullRegistrationMsg.toString());
501: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Node's health-status : " + nodeHealthStatus.getIsNodeHealthy() + ", " + nodeHealthStatus.getHealthReport());
585: Jian He, debug, IfStmt, LOG.debug(applicationId + " is completing, " + " remove " + containerId + " from NM context.");
607: Zhijie Shen, debug, IfStmt, LOG.debug("Sending out " + containerStatuses.size() + " container statuses: " + containerStatuses);
641: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Sending out " + containerStatuses.size() + " NM container statuses: " + containerStatuses);
696: Jason Lowe, info, IfStmt, LOG.info("Removed completed containers from NM context: " + removedContainers);
760: Jian He, error, CatchClause, LOG.error("Unable to remove container " + cid + " in store", e);
790: Zhijie Shen, debug, ForeachStmt, LOG.debug("Retrieved credentials form RM for " + entry.getKey() + ": " + entry.getValue().getAllTokens());
807: Ravi Prakash, warn, IfStmt, LOG.warn("Received SHUTDOWN signal from Resourcemanager as part of" + " heartbeat, hence shutting down.");
809: Arun Suresh, warn, IfStmt, LOG.warn("Message from ResourceManager: " + response.getDiagnosticsMessage());
817: Arun Suresh, warn, IfStmt, LOG.warn("Node is out of sync with ResourceManager," + " hence resyncing.");
819: Arun Suresh, warn, IfStmt, LOG.warn("Message from ResourceManager: " + response.getDiagnosticsMessage());
958: Rohith Sharma K S, error, IfStmt, LOG.error("NodeLabels sent from NM while registration were rejected by RM. " + ((errorMsgFromRM == null) ? "Seems like RM is configured with Centralized Labels." : "And with message " + regNMResponse.getDiagnosticsMessage()));
987: Wangda Tan, debug, IfStmt, LOG.debug("Labels from provider: " + StringUtils.join(",", previousNodeLabels));
1024: Wangda Tan, error, IfStmt, LOG.error("Invalid Node Label(s) from Provider : " + errorMsg);
1047: Weiwei Yang, debug, IfStmt, LOG.debug("Node Labels {" + StringUtils.join(",", previousNodeLabels) + "} were Accepted by RM ");
1169: Daniel Templeton, debug, IfStmt, LOG.debug("Node's resource is updated to " + newResource.toString());
1210: Daniel Templeton, debug, IfStmt, LOG.debug("No collectors to update RM");
1229: Sangjin Lee, debug, IfStmt, LOG.debug("Sync a new collector address: " + collectorData.getCollectorAddr() + " for application: " + appId + " from RM.");
90: Jian He, info, CatchClause, LOG.info("Unable to initialize WSCE Native libraries", t);
323: cnauroth, debug, IfStmt, LOG.debug(String.format("EFS:mkOneDirWithMode: %s %s", path, permission));
336: cnauroth, debug, IfStmt, LOG.debug(String.format("EFS:mkOneDirWithMode: %s", org.apache.hadoop.util.StringUtils.stringifyException(e)));
347: Jian He, debug, IfStmt, LOG.debug(String.format("EFS:setPermission: %s %s", p, permission));
356: Jian He, debug, IfStmt, LOG.debug(String.format("EFS:setOwner: %s %s %s", p, username, groupname));
366: cnauroth, debug, IfStmt, LOG.debug(String.format("EFS:createOutputStreamWithMode: %s %b %s", f, append, permission));
385: Jian He, debug, IfStmt, LOG.debug(String.format("EFS:delete: %s %b", p, recursive));
493: Jian He, warn, IfStmt, LOG.warn(output.toString());
512: Robert Kanter, Error, CatchClause, LOG.error("Error occurred reading the process stdout", t);
578: Jian He, debug, IfStmt, LOG.debug(String.format("getRunCommand: %s exists:%b", command, f.exists()));
595: Jian He, debug, IfStmt, LOG.debug(String.format("copyFile: %s -> %s owner:%s", src.toString(), dst.toString(), owner));
611: Jian He, debug, IfStmt, LOG.debug(String.format("createDir: %s perm:%s owner:%s", dirPath.toString(), perms.toString(), owner));
623: Jian He, debug, IfStmt, LOG.debug(String.format("setScriptExecutable: %s owner:%s", script.toString(), owner));
634: Jian He, debug, IfStmt, LOG.debug(String.format("localizeClasspathJar: %s %s o:%s", jarPath, target, owner));
673: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug(String.format("cwdApp: %s", cwdApp));
724: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn(String.format("An exception occurred during the cleanup of localizer job %s:%n%s", localizerPid, org.apache.hadoop.util.StringUtils.stringifyException(e)));
145: Jian He, info, MethodDeclaration, LOG.info("Starting AMRMProxyService");
173: Jian He, info, MethodDeclaration, LOG.info("AMRMProxyService listening on address: " + this.server.getListenerAddress());
180: Jian He, info, MethodDeclaration, LOG.info("Stopping AMRMProxyService");
196: Arun Suresh, info, MethodDeclaration, LOG.info("Recovering AMRMProxyService");
203: Arun Suresh, info, MethodDeclaration, LOG.info("Recovering {} running applications for AMRMProxy", state.getAppContexts().size());
208: Arun Suresh, info, ForeachStmt, LOG.info("Recovering app attempt {}", attemptId);
265: Arun Suresh, error, CatchClause, LOG.error("Exception when recovering " + attemptId + ", removing it from NMStateStore and move on", e);
242: Subru Krishnan, debug, ForeachStmt, LOG.debug("From NM Context container " + container.getContainerId());
245: Subru Krishnan, debug, IfStmt, LOG.debug("Container type " + container.getContainerTokenIdentifier().getContainerType());
249: Subru Krishnan, info, IfStmt, LOG.info("AM container {} found in context, has credentials: {}", container.getContainerId(), (container.getCredentials() != null));
257: Subru Krishnan, error, IfStmt, LOG.error("No credentials found for AM container of {}. " + "Yarn registry access might not work", attemptId);
281: Jian He, info, MethodDeclaration, LOG.info("Registering application master." + " Host:" + request.getHost() + " Port:" + request.getRpcPort() + " Tracking Url:" + request.getTrackingUrl());
299: Jian He, info, MethodDeclaration, LOG.info("Finishing application master. Tracking Url:" + request.getTrackingUrl());
338: Jian He, info, MethodDeclaration, LOG.info("Callback received for initializing request " + "processing pipeline for an AM");
393: Jian He, warn, IfStmt, LOG.warn("Request to start an already existing appId was received. " + " This can happen if an application failed and a new attempt " + "was created on this machine.  ApplicationId: " + applicationAttemptId.toString());
416: Arun Suresh, Error, CatchClause, LOG.error("Error removing AMRMProxy application context for " + applicationAttemptId, e);
424: Subru Krishnan, warn, CatchClause, LOG.warn("Failed to shutdown the request processing pipeline for app:" + applicationAttemptId.getApplicationId(), ex);
470: Arun Suresh, Error, CatchClause, LOG.error("Error storing AMRMProxy application context entry for " + applicationAttemptId, e);
502: Jian He, info, IfStmt, LOG.info("Stopping the request processing pipeline for application: " + applicationId);
507: Jian He, warn, CatchClause, LOG.warn("Failed to shutdown the request processing pipeline for app:" + applicationId, ex);
518: Arun Suresh, Error, CatchClause, LOG.error("Error removing AMRMProxy application context for " + applicationId, e);
493: Subru Krishnan, info, IfStmt, LOG.info("No interceptor pipeline for application {}," + " likely because its AM is not run in this node.", applicationId);
535: Subru Krishnan, info, IfStmt, LOG.info("RM rolled master-key for amrm-tokens");
555: Arun Suresh, Error, CatchClause, LOG.error("Error storing AMRMProxy application context entry for " + context.getApplicationAttemptId(), e);
572: Jian He, info, IfStmt, LOG.info("The local AMRMToken has been rolled-over." + " Send new local AMRMToken back to application: " + pipeline.getApplicationId());
765: Jian He, warn, IfStmt, LOG.warn("Event " + event + " sent to absent application " + event.getApplicationID());
754: Jian He, info, SwitchStmt, LOG.info("Application stop event received for stopping AppId:" + event.getApplicationID().toString());
760: Varun Saxena, debug, IfStmt, LOG.debug("AMRMProxy is ignoring event: " + event.getType());
94: Jian He, info, MethodDeclaration, LOG.info("AMRMTokenKeyRollingInterval: " + this.rollingInterval + "ms and AMRMTokenKeyActivationDelay: " + this.activationDelay + " ms");
113: Arun Suresh, error, CatchClause, LOG.error("Unable to update current master key in state store", e);
133: Jian He, info, TryStmt, LOG.info("Application finished, removing password for " + appAttemptId);
153: Jian He, info, TryStmt, LOG.info("Rolling master-key for amrm-tokens");
160: Arun Suresh, error, CatchClause, LOG.error("Unable to update next master key in state store", e);
182: Jian He, info, TryStmt, LOG.info("Activating next master key with id: " + this.nextMasterKey.getMasterKey().getKeyId());
192: Arun Suresh, error, CatchClause, LOG.error("Unable to update current master key in state store", e);
215: Jian He, info, TryStmt, LOG.info("Create AMRMToken for ApplicationAttempt: " + appAttemptId);
252: Jian He, debug, IfStmt, LOG.debug("Trying to retrieve password for " + applicationAttemptId);
314: Jian He, info, TryStmt, LOG.info("Creating password for " + applicationAttemptId);
336: Arun Suresh, warn, IfStmt, LOG.warn("No current master key recovered from NM StateStore" + " for AMRMProxyTokenSecretManager");
88: Jian He, info, CatchClause, LOG.info(message);
125: Jian He, info, MethodDeclaration, LOG.info("Forwarding registration request to the real YARN RM");
133: Jian He, debug, IfStmt, LOG.debug("Forwarding allocate request to the real YARN RM");
151: Arun Suresh, info, IfStmt, LOG.info("Forwarding registerApplicationMasterForDistributedScheduling" + "request to the real YARN RM");
165: Arun Suresh, debug, IfStmt, LOG.debug("Forwarding allocateForDistributedScheduling request" + "to the real YARN RM");
188: Jian He, info, MethodDeclaration, LOG.info("Forwarding finish application request to " + "the real YARN Resource Manager");
199: Subru Krishnan, info, MethodDeclaration, LOG.info("Initializing Federation Interceptor");
243: Subru Krishnan, info, MethodDeclaration, LOG.info("Recovering data for FederationInterceptor");
257: Subru Krishnan, info, IfStmt, LOG.info("amRegistrationRequest recovered for {}", attemptId);
265: Subru Krishnan, info, IfStmt, LOG.info("amRegistrationResponse recovered for {}", attemptId);
286: Subru Krishnan, debug, IfStmt, LOG.debug("Recovered UAM in " + scId + " from NMSS");
289: Subru Krishnan, info, IfStmt, LOG.info("Found {} existing UAMs for application {} in NMStateStore", uamMap.size(), attemptId.getApplicationId());
273: Subru Krishnan, info, IfStmt, LOG.info("Found {} existing UAMs for application {} in Yarn Registry", uamMap.size(), attemptId.getApplicationId());
327: Subru Krishnan, Error, CatchClause, LOG.error("Error reattaching UAM to " + subClusterId + " for " + attemptId, e);
322: Subru Krishnan, info, TryStmt, LOG.info("Recovered {} running containers from UAM in {}", response.getContainersFromPreviousAttempts().size(), subClusterId);
348: Subru Krishnan, debug, ForeachStmt, LOG.debug("  From home RM " + this.homeSubClusterId + " running container " + container.getContainerId());
351: Subru Krishnan, info, TryStmt, LOG.info("{} running containers including AM recovered from home RM ", response.getContainerList().size(), this.homeSubClusterId);
354: Subru Krishnan, info, TryStmt, LOG.info("In all {} UAMs {} running containers including AM recovered for {}", uamMap.size(), containers, attemptId);
411: Subru Krishnan, Error, CatchClause, LOG.error("Error storing AMRMProxy application context entry for " + getApplicationContext().getApplicationAttemptId(), e);
460: Subru Krishnan, Error, CatchClause, LOG.error("Error storing AMRMProxy application context entry for " + getApplicationContext().getApplicationAttemptId(), e);
474: Subru Krishnan, info, IfStmt, LOG.info("Application " + appId + " belongs to queue " + queue);
469: Subru Krishnan, warn, IfStmt, LOG.warn("Received null queue for application " + appId + " from home subcluster. Will use default queue name " + YarnConfiguration.DEFAULT_QUEUE_NAME + " for getting AMRMProxyPolicy");
546: Subru Krishnan, error, CatchClause, LOG.error("Exception encountered while processing heart beat", ex);
522: Subru Krishnan, warn, CatchClause, LOG.warn("notifyOfResponse for policy failed for home sub-cluster " + this.homeSubClusterId, e);
528: Subru Krishnan, debug, IfStmt, LOG.debug("Received new AMRMToken");
575: Subru Krishnan, info, IfStmt, LOG.info("Sending finish application request to {} sub-cluster RMs", subClusterIds.size());
581: Subru Krishnan, info, MethodDeclaration, LOG.info("Sending finish application request to RM {}", subClusterId);
588: Subru Krishnan, warn, CatchClause, LOG.warn("Failed to finish unmanaged application master: " + "RM address: " + subClusterId + " ApplicationId: " + getApplicationContext().getApplicationAttemptId(), e);
631: Subru Krishnan, warn, CatchClause, LOG.warn("Failed to finish unmanaged application master: " + " ApplicationId: " + getApplicationContext().getApplicationAttemptId(), e);
618: Subru Krishnan, debug, IfStmt, LOG.debug("Received finish application response from RM: " + uamResponse.getSubClusterId());
762: Subru Krishnan, warn, IfStmt, LOG.warn("registryClient is null, skip attaching existing UAM if any");
771: Subru Krishnan, info, IfStmt, LOG.info("No existing UAM for application {} found in Yarn Registry", appId);
775: Subru Krishnan, info, MethodDeclaration, LOG.info("Found {} existing UAMs for application {} in Yarn Registry. " + "Reattaching in parallel", uamMap.size(), appId);
814: Subru Krishnan, error, CatchClause, LOG.error("Reattaching UAM " + subClusterId + " failed for " + appId, e);
812: Subru Krishnan, info, TryStmt, LOG.info("UAM {} reattached for {}", subClusterId, appId);
834: Subru Krishnan, warn, CatchClause, LOG.warn("Reattaching UAM failed for ApplicationId: " + appId, e);
830: Subru Krishnan, info, IfStmt, LOG.info("Merging register response for {}", appId);
844: Subru Krishnan, error, CatchClause, LOG.error("Failed to resolve sub-cluster for node " + nodeName + ", skipping this node", e);
849: Subru Krishnan, error, IfStmt, LOG.error("Failed to resolve sub-cluster for node {}, skipping this node", nodeName);
1027: Subru Krishnan, Error, CatchClause, LOG.error("Error storing UAM token as AMRMProxy " + "context entry in NMSS for " + getApplicationContext().getApplicationAttemptId(), e);
1040: Subru Krishnan, warn, CatchClause, LOG.warn("notifyOfResponse for policy failed for home sub-cluster " + subClusterId, e);
1106: Subru Krishnan, error, CatchClause, LOG.error("Failed to register application master: " + subClusterId + " Application: " + appContext.getApplicationAttemptId(), e);
1154: Subru Krishnan, warn, CatchClause, LOG.warn("Failed to register unmanaged application master: " + " ApplicationId: " + getApplicationContext().getApplicationAttemptId(), e);
1124: Subru Krishnan, debug, IfStmt, LOG.debug("Received register application response from RM: " + uamResponse.getSubClusterId());
1131: Subru Krishnan, info, IfStmt, LOG.info("Successfully registered unmanaged application master: " + uamResponse.getSubClusterId() + " ApplicationId: " + getApplicationContext().getApplicationAttemptId());
1204: Subru Krishnan, debug, ForeachStmt, LOG.debug("Completed container {}", container);
1362: Subru Krishnan, debug, ForeachStmt, LOG.debug("Adding container {}", container);
1378: Subru Krishnan, warn, IfStmt, LOG.warn("Duplicate containerID: {} found in the allocated containers" + " from same sub-cluster: {}, so ignoring.", container.getId(), subClusterId);
1452: Subru Krishnan, error, IfStmt, LOG.error("AM is trying to {} a container {} that does not exist. Might happen " + "shortly after NM restart when NM recovery is enabled", actionName, containerId.toString());
62: Eric Yang, debug, IfStmt, LOG.debug("Converting recovered DockerContainerDeletionTask");
56: Eric Yang, debug, IfStmt, LOG.debug("Converting recovered FileDeletionTask");
69: Eric Yang, debug, IfStmt, LOG.debug("Unable to get task type, trying FileDeletionTask");
101: Junping Du, info, MethodDeclaration, LOG.info("NMCollectorService started at " + collectorServerAddress);
138: Sangjin Lee, warn, IfStmt, LOG.warn("collectors are added when the registered collectors are " + "initialized");
103: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Adding auxiliary service " + service.getName() + ", \"" + name + "\"");
299: Akira Ajisaka, error, CatchClause, LOG.error("Failed to initialize " + sName, e);
224: Wangda Tan, info, IfStmt, LOG.info("delete old aux service jar dir:" + delPath.toString());
267: Sangjin Lee, info, IfStmt, LOG.info("The aux service:" + sName + " are using the custom classloader");
283: Robert Kanter, warn, IfStmt, LOG.warn("The Auxiliary Service named '" + sName + "' in the " + "configuration is for " + s.getClass() + " which has " + "a name of '" + s.getName() + "'. Because these are " + "not the same tools trying to send ServiceData and read " + "Service Meta Data may have issues unless the refer to " + "the name in the config.");
343: Akira Ajisaka, error, MethodDeclaration, LOG.error("Service " + service.getName() + " changed state: " + service.getServiceState());
350: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Got event " + event.getType() + " for appId " + event.getApplicationID());
354: Bikas Saha, info, SwitchStmt, LOG.info("Got APPLICATION_INIT for service " + event.getServiceID());
418: Bikas Saha, warn, MethodDeclaration, LOG.warn((null == service ? "The auxService is null" : "The auxService name is " + service.getName()) + " and it got an error at event: " + eventType, th);
446: Wangda Tan, warn, CatchClause, LOG.warn(msg);
266: Li Lu, info, IfStmt, LOG.info("YARN system metrics publishing service is enabled");
334: Jian He, info, IfStmt, LOG.info("AMRMProxyService is disabled");
328: Jian He, info, IfStmt, LOG.info("AMRMProxyService is enabled. " + "All the AM->RM requests will be intercepted by the proxy");
385: Varun Vasudev, info, IfStmt, LOG.info("Not a recoverable state store. Nothing to recover.");
361: Varun Vasudev, debug, IfStmt, LOG.debug("Recovering application with state: " + proto.toString());
368: Varun Vasudev, debug, IfStmt, LOG.debug("Recovering container with state: " + rcs);
425: Haibo Chen, debug, IfStmt, LOG.debug("No prior existing flow context found. Using default Flow context: " + fc + " for an application " + appId);
416: Haibo Chen, debug, IfStmt, LOG.debug("Recovering Flow context: " + fc + " for an application " + appId);
431: Junping Du, info, MethodDeclaration, LOG.info("Recovering application " + appId);
466: Junping Du, info, MethodDeclaration, LOG.info("Recovering " + containerId + " in state " + rcs.getStatus() + " with exit code " + rcs.getExitCode());
480: Junping Du, warn, IfStmt, LOG.warn(containerId + " has no corresponding application!");
482: Junping Du, info, IfStmt, LOG.info("Adding " + containerId + " to recently stopped containers");
517: Junping Du, info, WhileStmt, LOG.info("Waiting for containers: " + newContainers);
521: Junping Du, warn, IfStmt, LOG.warn("Timeout waiting for recovered containers");
657: Robert Joseph Evans, info, MethodDeclaration, LOG.info("ContainerManager started at " + connectAddress);
658: Xuan Gong, info, MethodDeclaration, LOG.info("ContainerManager bound to " + initialAddress);
703: Hitesh Shah, info, MethodDeclaration, LOG.info("Applications still running : " + applications.keySet());
719: Hitesh Shah, info, MethodDeclaration, LOG.info("Waiting for Applications to be Finished");
727: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Interrupted while sleeping on applications finish on shutdown", ex);
736: Jian He, info, IfStmt, LOG.info("Done waiting for Applications to be Finished. Still alive: " + applications.keySet());
734: Hitesh Shah, info, IfStmt, LOG.info("All applications in FINISHED state");
746: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Containers still running on " + CMgrCompletedContainersEvent.Reason.ON_NODEMANAGER_RESYNC + " : " + containers.keySet());
753: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Waiting for containers to be killed");
773: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Interrupted while sleeping on container kill on resync", ex);
784: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Done waiting for containers to be killed. Still alive: " + containers.keySet());
782: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("All containers in DONE state");
798: Siddharth Seth, warn, CatchClause, LOG.warn(msg);
894: Arun Murthy, error, IfStmt, LOG.error(msg);
1024: Junping Du, error, CatchClause, LOG.error("Cannot serialize credentials", e);
1061: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Start request for " + containerIdStr + " by user " + user);
1119: Haibo Chen, debug, IfStmt, LOG.debug("Flow context: " + flowContext + " created for an application " + applicationID);
1129: Sangjin Lee, info, IfStmt, LOG.info("Creating a new application reference for app " + applicationID);
1367: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Stopping container with container Id: " + containerIDStr);
1421: Siddharth Seth, info, MethodDeclaration, LOG.info("Getting container-status for " + containerIDStr);
1435: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Returning " + containerStatus);
1472: Jason Lowe, warn, IfStmt, LOG.warn(msg);
1489: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Event " + event + " sent to absent container " + event.getContainerID());
1507: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Event " + event + " sent to absent application " + event.getApplicationID());
1573: Daniel Templeton, info, IfStmt, LOG.info("couldn't find application " + appID + " while processing" + " FINISH_APPS event. The ResourceManager allocated resources" + " for this application to the NodeManager but no active" + " containers were found to process.");
1583: Jason Lowe, info, IfStmt, LOG.info("drop FINISH_APPS event to " + appID + " because " + "container " + container.getContainerId() + " is recovering");
1614: Jason Lowe, warn, IfStmt, LOG.warn("couldn't find app " + appId + " while processing" + " FINISH_CONTAINERS event");
1621: Jason Lowe, warn, IfStmt, LOG.warn("couldn't find container " + containerId + " while processing FINISH_CONTAINERS event");
1627: Jason Lowe, info, IfStmt, LOG.info("drop FINISH_CONTAINERS event to " + containerId + " because container is recovering");
1650: Jian He, error, CatchClause, LOG.error("Unable to decrease container resource", e);
1652: Jian He, error, CatchClause, LOG.error("Unable to update container resource in store", e);
1731: Varun Vasudev, Error, CatchClause, LOG.info("Error when parsing local resource URI for " + containerId, e);
1782: Arun Suresh, Error, CatchClause, LOG.info("Error when parsing local resource URI for upgrade of" + "Container [" + containerId + "]", e);
1866: Ming Ma, info, IfStmt, LOG.info("Container " + containerId + " no longer exists");
1860: Ming Ma, info, IfStmt, LOG.info(containerId + " signal request " + request.getCommand() + " by " + sentBy);
354: Robert Kanter, warn, CatchClause, LOG.warn("failed to update application state in state store", ex);
424: Jason Darrell Lowe, warn, MethodDeclaration, LOG.warn("Log Aggregation service failed to initialize, there will " + "be no logs for this application");
446: Siddharth Seth, info, MethodDeclaration, LOG.info("Adding " + container.getContainerId() + " to application " + app.toString());
489: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Removing " + containerEvent.getContainerID() + " from application " + app.toString());
486: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Removing unknown " + containerEvent.getContainerID() + " from application " + app.toString());
544: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Removing " + containerFinishEvent.getContainerID() + " from application " + app.toString());
607: Junping Du, error, CatchClause, LOG.error("Unable to remove application from state store", e);
620: Varun Saxena, debug, IfStmt, LOG.debug("Processing " + applicationID + " of type " + event.getType());
629: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Can't handle this event at current state", e);
632: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Application " + applicationID + " transitioned from " + oldState + " to " + newState);
277: Arun Suresh, info, IfStmt, LOG.info("Set restart interval to minimum value " + minimumRestartInterval + "ms for container " + containerId);
1053: Junping Du, warn, CatchClause, LOG.warn("Unable to update diagnostics in state store for " + containerId, e);
1090: Arun Suresh, warn, CatchClause, LOG.warn("Could not store container [" + container.containerId + "] update..", e);
1184: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Failed to parse resource-request", e);
1214: Varun Vasudev, info, IfStmt, LOG.info("Localized resource " + resourceRequest + " for container " + container.containerId);
1298: Arun Suresh, error, CatchClause, LOG.error("Container [" + container.getContainerId() + "]" + " re-initialization failure..", e);
1347: Arun Suresh, warn, MethodDeclaration, LOG.warn("Container [" + container.getContainerId() + "]" + " about to be explicitly Rolledback !!");
1415: Varun Vasudev, error, CatchClause, LOG.error(message, e);
1408: Varun Vasudev, info, IfStmt, LOG.info("Created symlink: " + linkFile + " -> " + rsrcEvent.getLocation());
1404: Varun Vasudev, info, IfStmt, LOG.info("Symlink file already exists: " + linkFile);
1451: Arun Suresh, error, MethodDeclaration, LOG.error("Container [" + container.getContainerId() + "] Re-init" + " failed !! Resource [" + failedEvent.getResource() + "] could" + " not be localized !!");
1486: Junping Du, info, IfStmt, LOG.info("Killing " + container.containerId + " due to recovered as killed");
1616: Arun Suresh, info, IfStmt, LOG.info("Rolling back Container reInitialization for [" + container.getContainerId() + "] !!");
1636: Arun Suresh, info, MethodDeclaration, LOG.info("Relaunching Container " + container.getContainerId() + ". Remaining retry attempts(after relaunch) : " + remainingRetryAttempts + ". Interval between retries is " + retryInterval + "ms");
1701: Arun Suresh, info, MethodDeclaration, LOG.info("Relaunching Container [" + container.getContainerId() + "] for re-initialization !!");
1937: Junping Du, warn, IfStmt, LOG.warn("Container exited with success despite being killed and not" + "actually running");
2078: Varun Saxena, debug, IfStmt, LOG.debug("Processing " + containerID + " of type " + event.getType());
2086: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Can't handle this event at current state: Current: [" + oldState + "], eventType: [" + event.getType() + "]," + " container: [" + containerID + "]", e);
2091: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Container " + containerID + " transitioned from " + oldState + " to " + newState);
2200: Wangda Tan, warn, CatchClause, LOG.warn("Unable to update finishTimeForRetryAttempts in state store for " + containerId, e);
2209: Wangda Tan, warn, CatchClause, LOG.warn("Unable to update remainingRetryAttempts in state store for " + containerId, e);
219: Varun Vasudev, error, CatchClause, LOG.error("Unable to remove deletion task " + taskId + " from state store", e);
57: Eric Yang, debug, IfStmt, LOG.debug(msg);
100: Varun Vasudev, debug, IfStmt, LOG.debug(msg);
150: Varun Vasudev, warn, CatchClause, LOG.warn("Failed to delete as user " + getUser(), e);
131: Varun Vasudev, debug, IfStmt, LOG.debug("Deleting path: [" + subDir + "] as user: [" + getUser() + "]");
118: Varun Vasudev, debug, IfStmt, LOG.debug("NM deleting path : " + del);
124: Varun Vasudev, warn, CatchClause, LOG.warn("Failed to delete " + subDir);
106: Varun Vasudev, debug, IfStmt, LOG.debug("NM deleting absolute path : " + subDir);
112: Varun Vasudev, warn, CatchClause, LOG.warn("Failed to delete " + subDir);
323: Daniel Templeton, error, CatchClause, LOG.error("Failed to launch container due to configuration error.", e);
331: Mahadev Konar, warn, CatchClause, LOG.warn("Failed to launch container.", e);
512: Arun Suresh, info, IfStmt, LOG.info("Container " + containerId + " not launched as it has already " + "been marked for Killing");
526: Varun Vasudev, info, IfStmt, LOG.info("Container " + containerId + " not launched as " + "cleanup already called");
545: Varun Vasudev, error, CatchClause, LOG.error("Unable to set exit code for container " + containerId);
554: Varun Vasudev, debug, IfStmt, LOG.debug("Container " + containerId + " completed with exit code " + exitCode);
578: Varun Vasudev, info, IfStmt, LOG.info("Container " + containerId + " succeeded ");
598: Wangda Tan, warn, MethodDeclaration, LOG.warn("Container launch failed : " + diagnosticInfo.toString());
623: Wangda Tan, error, CatchClause, LOG.error("Failed to get tail of the container's prelaunch error log file", e);
669: Gera Shegalov, error, CatchClause, LOG.error("Failed to get tail of the container's error log file", e);
734: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Cleaning up container " + containerIdStr);
739: Junping Du, error, CatchClause, LOG.error("Unable to mark container " + containerId + " killed in store", e);
747: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Container " + containerIdStr + " not launched." + " No cleanup needed to be done");
752: Varun Saxena, debug, IfStmt, LOG.debug("Marking container " + containerIdStr + " as inactive");
759: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Getting pid for container " + containerIdStr + " to kill" + " from pid file " + (pidFilePath != null ? pidFilePath.toString() : "null"));
808: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn(message);
784: Haibo Chen, warn, IfStmt, LOG.warn("Container clean up before pid file created " + containerIdStr);
833: Eric Yang, debug, IfStmt, LOG.debug("Timeout while waiting for the exit code file:  " + file.getAbsolutePath());
867: Xuan, info, IfStmt, LOG.info("ignore signal command " + command);
871: Xuan, info, MethodDeclaration, LOG.info("Sending signal " + command + " to container " + containerIdStr);
876: Xuan, info, IfStmt, LOG.info("Container " + containerIdStr + " not launched." + " Not sending the signal");
882: Xuan, debug, IfStmt, LOG.debug("Getting pid for container " + containerIdStr + " to send signal to from pid file " + (pidFilePath != null ? pidFilePath.toString() : "null"));
924: Xuan, warn, CatchClause, LOG.warn(message);
897: Xuan, debug, IfStmt, LOG.debug("Sending signal to pid " + processId + " as user " + user + " for container " + containerIdStr);
915: Xuan, info, IfStmt, LOG.info(diagnostics);
938: Eric Yang, debug, IfStmt, LOG.debug("Sending signal to pid " + processId + " as user " + user + " for container " + containerIdStr);
946: Eric Yang, debug, IfStmt, LOG.debug("Sent signal " + signal + " to pid " + processId + " as user " + user + " for container " + containerIdStr + ", result=" + (result ? "success" : "failed"));
959: Eric Yang, info, MethodDeclaration, LOG.info("Unable to obtain pid, but docker container request detected. " + "Attempting to reap container " + containerIdStr);
967: Eric Yang, debug, IfStmt, LOG.debug("Sent signal to docker container " + containerIdStr + " as user " + user + ", result=" + (result ? "success" : "failed"));
1001: Arun Suresh, info, MethodDeclaration, LOG.info("Pausing the container " + containerIdStr);
1008: Arun Suresh, info, IfStmt, LOG.info("Container " + containerId + " not paused as " + "resume already called");
1034: Arun Suresh, info, CatchClause, LOG.info(message);
1027: Arun Suresh, warn, CatchClause, LOG.warn("Could not store container [" + container.getContainerId() + "] state. The Container has been paused.", e);
1051: Arun Suresh, info, MethodDeclaration, LOG.info("Resuming the container " + containerIdStr);
1059: Arun Suresh, info, IfStmt, LOG.info("Container " + containerIdStr + " not paused." + " No resume necessary");
1084: Arun Suresh, info, CatchClause, LOG.info(message);
1077: Arun Suresh, warn, CatchClause, LOG.warn("Could not store container [" + container.getContainerId() + "] state. The Container has been resumed.", e);
1103: Varun Saxena, debug, IfStmt, LOG.debug("Accessing pid for container " + containerIdStr + " from pid file " + pidFilePath);
1121: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Could not get pid for " + containerIdStr + ". Waited for " + maxKillWaitTime + " ms.");
1115: Varun Saxena, debug, IfStmt, LOG.debug("Got pid " + processId + " for container " + containerIdStr);
1881: Eric Yang, debug, MethodDeclaration, LOG.debug("cleanup container {} files", containerWorkDir);
1895: Eric Yang, warn, CatchClause, LOG.warn("Failed to delete " + path, e);
129: Daniel Templeton, error, CatchClause, LOG.error("Failed to launch container due to configuration error.", e);
137: Varun Vasudev, warn, CatchClause, LOG.warn("Failed to relaunch container.", e);
87: Varun Vasudev, info, TryStmt, LOG.info("Relaunch container with " + "workDir = " + containerWorkDir.toString() + ", logDir = " + containerLogDir.toString() + ", nmPrivateContainerScriptPath = " + nmPrivateContainerScriptPath.toString() + ", nmPrivateTokensPath = " + nmPrivateTokensPath.toString() + ", pidFilePath = " + pidFilePath.toString());
163: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Got exception while cleaning container " + containerId + ". Ignoring.");
173: Xuan, info, IfStmt, LOG.info("Container " + containerId + " not running, nothing to signal.");
180: Xuan, warn, CatchClause, LOG.warn("Got exception while signaling container " + containerId + " with command " + signalEvent.getCommand());
195: Arun Suresh, info, CatchClause, LOG.info("Got exception while pausing container: " + StringUtils.stringifyException(e));
210: Arun Suresh, info, CatchClause, LOG.info("Got exception while resuming container: " + StringUtils.stringifyException(e));
94: Jason Lowe, warn, CatchClause, LOG.warn("Interrupted while waiting for exit code from " + containerId);
97: Jason Lowe, error, CatchClause, LOG.error("Unable to recover container " + containerIdStr, e);
106: Jason Lowe, error, CatchClause, LOG.error("Unable to set exit code for container " + containerId);
91: Junping Du, warn, IfStmt, LOG.warn("Unable to locate pid file for container " + containerIdStr);
112: Junping Du, warn, IfStmt, LOG.warn("Recovered container exited with a non-zero exit code " + retCode);
121: Junping Du, info, MethodDeclaration, LOG.info("Recovered container " + containerId + " succeeded");
89: Arun Suresh, warn, CatchClause, LOG.warn("Interrupted while waiting for exit code from " + containerId);
92: Arun Suresh, error, CatchClause, LOG.error("Unable to kill the paused container " + containerIdStr, e);
101: Arun Suresh, error, CatchClause, LOG.error("Unable to set exit code for container " + containerId);
85: Arun Suresh, warn, IfStmt, LOG.warn("Unable to locate pid file for container " + containerIdStr);
107: Arun Suresh, warn, IfStmt, LOG.warn("Recovered container exited with a non-zero exit code " + retCode);
116: Arun Suresh, info, MethodDeclaration, LOG.info("Recovered container " + containerId + " succeeded");
119: Junping Du, debug, IfStmt, LOG.debug("Privileged Execution Command Array: " + Arrays.toString(fullCommandArray));
174: Jason Lowe, warn, IfStmt, LOG.warn(logBuilder.toString());
182: Junping Du, warn, CatchClause, LOG.warn("IOException executing command: ", e);
154: Varun Vasudev, debug, IfStmt, LOG.debug("command array:");
155: Varun Vasudev, debug, IfStmt, LOG.debug(Arrays.toString(fullCommandArray));
156: Junping Du, debug, IfStmt, LOG.debug("Privileged Execution Operation Output:");
157: Junping Du, debug, IfStmt, LOG.debug(exec.getOutput());
236: Junping Du, warn, IfStmt, LOG.warn("Unsupported operation type: " + op.getOperationType());
243: Junping Du, warn, IfStmt, LOG.warn("Invalid number of args: " + args.size());
252: Junping Du, warn, IfStmt, LOG.warn("Invalid argument: " + arg);
80: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn(msg, e);
106: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to determine disk scheduler type for partition " + partition, ie);
101: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Device " + partition + " does not use the CFQ" + " scheduler; disk isolation using " + "CGroups will not work on this partition.");
140: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Could not update cgroup for container", re);
121: I am also known as @tshooter.), info, IfStmt, LOG.info("Removing CPU constraints for YARN containers.");
112: I am also known as @tshooter.), info, IfStmt, LOG.info("YARN containers restricted to " + yarnProcessors + " cores");
160: I am also known as @tshooter.), warn, IfStmt, LOG.warn("The quota calculated for the cgroup was too low." + " The minimum value is " + MIN_PERIOD_US + ", calculated value is " + quotaUS + ". Setting quota to minimum value.");
172: I am also known as @tshooter.), warn, IfStmt, LOG.warn("The period calculated for the cgroup was too low." + " The minimum value is " + MIN_PERIOD_US + ", calculated value is " + periodUS + ". Using all available CPU.");
218: I am also known as @tshooter.), warn, CatchClause, LOG.warn("Could not update cgroup for container", re);
163: Daniel Templeton, warn, CatchClause, LOG.warn("Failed to initialize controller paths! Exception: " + e);
245: Daniel Templeton, Error, IfStmt, LOG.warn("Error while reading " + mtab, e);
271: Karthik Kambatla, warn, IfStmt, LOG.warn(String.format("Skipping inaccessible cgroup mount point %s", e.getKey()));
329: Daniel Templeton, info, IfStmt, LOG.info("CGroup controller already mounted at: " + existingMountPath);
322: Junping Du, error, CatchClause, LOG.error("Failed to mount controller: " + controller.getName());
315: Junping Du, info, TryStmt, LOG.info("Mounting controller " + controller.getName() + " at " + requestedMountPath);
408: Daniel Templeton, info, MethodDeclaration, LOG.info("Initializing mounted controller " + controller.getName() + " " + "at " + yarnHierarchy);
418: Daniel Templeton, info, IfStmt, LOG.info("Yarn control group does not exist. Creating " + yarnHierarchy.getAbsolutePath());
467: Junping Du, debug, IfStmt, LOG.debug("createCgroup: " + path);
491: Junping Du, warn, CatchClause, LOG.warn("Failed to read cgroup tasks file. ", e);
488: Junping Du, debug, IfStmt, LOG.debug("First line in cgroup tasks file: " + cgf + " " + str);
521: Junping Du, warn, CatchClause, LOG.warn("Failed to read cgroup tasks file. ", e);
515: Junping Du, warn, IfStmt, LOG.warn("Failed attempt to delete cgroup: " + cgf);
533: Junping Du, debug, IfStmt, LOG.debug("deleteCGroup: " + cGroupPath);
550: Daniel Templeton, warn, IfStmt, LOG.warn(String.format("Unable to delete  %s, tried to delete for %d ms", cGroupPath, deleteCGroupTimeout));
562: Junping Du, debug, IfStmt, LOG.debug(String.format("updateCGroupParam for path: %s with value %s", cGroupParamPath, value));
155: Haibo Chen, warn, CatchClause, LOG.warn("Could not update cgroup for container", re);
149: Haibo Chen, debug, IfStmt, LOG.debug("Process " + pid + " jiffies:" + processTotalJiffies);
185: Haibo Chen, warn, CatchClause, LOG.warn("Failed to parse " + pid, e);
191: Haibo Chen, debug, IfStmt, LOG.debug("Swap cgroups monitoring is not compiled into the kernel " + memswStat.getAbsolutePath().toString());
229: Haibo Chen, warn, CatchClause, LOG.warn("Failed to get Operating System name. " + se);
217: Haibo Chen, info, IfStmt, LOG.info("CGroupsResourceCalculator currently is supported only on " + "Linux.");
224: Haibo Chen, info, IfStmt, LOG.info("CGroupsResourceCalculator requires enabling CGroups" + "cpu and memory");
244: Haibo Chen, warn, CatchClause, LOG.warn("Failed to parse cgroups " + memswStat, e);
304: Haibo Chen, warn, IfStmt, LOG.warn("Unexpected: cgroup file is not in the expected format" + " for process with pid " + pid);
299: Haibo Chen, warn, IfStmt, LOG.warn("Invalid cgroup path for " + pidCgroupFile);
65: Haibo Chen, debug, IfStmt, LOG.debug("CPU Comparison:" + procfsUsage + " " + cgroupUsage);
66: Haibo Chen, debug, IfStmt, LOG.debug("Jiffy Comparison:" + procfs.getCumulativeCpuTime() + " " + cgroup.getCumulativeCpuTime());
82: Haibo Chen, debug, IfStmt, LOG.debug("CPU Comparison:" + procfs.getCumulativeCpuTime() + " " + cgroup.getCumulativeCpuTime());
92: Haibo Chen, debug, IfStmt, LOG.debug("MEM Comparison:" + procfs.getRssMemorySize(olderThanAge) + " " + cgroup.getRssMemorySize(olderThanAge));
102: Haibo Chen, debug, IfStmt, LOG.debug("VMEM Comparison:" + procfs.getVirtualMemorySize(olderThanAge) + " " + cgroup.getVirtualMemorySize(olderThanAge));
141: Wangda Tan, info, MethodDeclaration, LOG.info("postComplete for container: " + containerId.toString());
151: Wangda Tan, debug, IfStmt, LOG.debug("teardown(): Nothing to do");
45: Wangda Tan, info, MethodDeclaration, LOG.info("Using NetworkTagMappingManager implementation - " + managerClass);
137: I am also known as @tshooter.), debug, IfStmt, LOG.debug("Creating new cgroups cpu handler");
157: Wangda Tan, info, IfStmt, LOG.info("Creating new traffic control bandwidth handler.");
182: Wangda Tan, info, IfStmt, LOG.info("Using traffic control bandwidth handler");
179: Wangda Tan, info, IfStmt, LOG.info("Using network-tagging-handler.");
192: Wangda Tan, info, IfStmt, LOG.info("Creating new network-tagging-handler.");
223: I am also known as @tshooter.), debug, IfStmt, LOG.debug("Creating new cgroups blkio handler");
362: Yufei Gu, warn, IfStmt, LOG.warn("The following cgroup is not a directory " + candidate.getAbsolutePath());
120: Akira Ajisaka, info, MethodDeclaration, LOG.info(logLine.toString());
189: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Attempting to reacquire classId for container: " + containerIdStr);
199: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Reacquired containerId -> classId mapping: " + containerIdStr + " -> " + classId);
224: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("No bytes sent metric found for container: " + containerId + " with classId: " + classId);
244: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("postComplete for container: " + containerId.toString());
264: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Not cleaning up tc rules. classId unknown for container: " + containerId.toString());
259: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Failed to delete tc rule for classId: " + classId);
275: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("teardown(): Nothing to do");
137: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Unable to create directory: " + tmpDirPath);
165: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("TC configuration is incomplete. Wiping tc state before proceeding");
158: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("TC configuration is already in place. Not wiping state.");
153: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("NM recovery is not enabled. We'll wipe tc state before proceeding.");
174: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Initializing tc state.");
189: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Failed to bootstrap outbound bandwidth configuration");
231: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn(logLine);
226: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Matched regex: " + regex);
236: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Bootstrap check succeeded");
267: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Failed to bootstrap outbound bandwidth rules");
262: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("TC state: %n" + output);
283: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Failed to wipe tc state. This could happen if the interface" + " is already in its default state. Ignoring.");
280: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Wiping tc state.");
318: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Unable to match classid in string:" + tcClass);
315: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Reacquired container classid: " + classId);
347: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Failed to get tc stats");
336: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("TC stats output:" + output);
342: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("classId -> bytes sent %n" + classIdBytesStats);
391: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Matched a 'bytes sent' line outside of a class stats " + "segment : " + line);
471: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("ClassId hex string : " + classIdStr);
644: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Failed to create or write to temporary file in dir: " + tmpDirPath);
277: Wangda Tan, info, MethodDeclaration, LOG.info("Add a list of FPGA Devices: " + list);
287: Wangda Tan, warn, IfStmt, LOG.warn("Failed to update FPGA due to unknown reason " + "that no record for this allocated device:" + device);
290: Wangda Tan, info, MethodDeclaration, LOG.info("Update IPID to " + newIPID + " for this allocated device:" + device);
97: Wangda Tan, info, MethodDeclaration, LOG.info("FPGA Plugin bootstrap success.");
119: Wangda Tan, info, MethodDeclaration, LOG.info(containerIdStr + " requested " + deviceCount + " Intel FPGA(s)");
190: Wangda Tan, warn, CatchClause, LOG.warn("Could not update cgroup for container", e);
127: Wangda Tan, info, TryStmt, LOG.info("FpgaAllocation:" + allocation);
161: Wangda Tan, info, IfStmt, LOG.info("IP file path:" + ipFilePath);
169: Wangda Tan, info, IfStmt, LOG.info("IP already in device \"" + allowed.get(i).getAliasDevName() + "," + majorMinorNumber + "\", skip reprogramming");
158: Wangda Tan, warn, IfStmt, LOG.warn("FPGA plugin failed to download IP but continue, please check the value of environment viable: " + REQUEST_FPGA_IP_ID_KEY + " if you want yarn to help");
78: Sunil G, error, CatchClause, LOG.error("Exception when trying to get usable GPU device", e);
74: Sunil G, error, IfStmt, LOG.error(message);
140: Sunil G, warn, CatchClause, LOG.warn("Could not update cgroup for container", e);
59: Miklos Szegedi, debug, MethodDeclaration, LOG.debug("Memory available:" + (totalMemory - usedMemory) + ", CPUs available:" + (totalCpus - usedCpus) + ", requested:" + resource);
123: Miklos Szegedi, info, IfStmt, LOG.info("Reading NUMA topology using configurations.");
89: Miklos Szegedi, info, IfStmt, LOG.info("Reading NUMA topology using 'numactl --hardware' command.");
140: Miklos Szegedi, info, MethodDeclaration, LOG.info("Available numa nodes with capacities : " + numaNodesList.size());
238: Miklos Szegedi, info, IfStmt, LOG.info("Assigning NUMA node " + numaNode.getNodeId() + " for memory, " + numaNode.getNodeId() + " for cpus for the " + containerId);
261: Miklos Szegedi, info, IfStmt, LOG.info("There is no available memory:" + resource.getMemorySize() + " in numa nodes for " + containerId);
283: Miklos Szegedi, info, IfStmt, LOG.info("There are no available cpus:" + resource.getVirtualCores() + " in numa nodes for " + containerId);
288: Miklos Szegedi, info, MethodDeclaration, LOG.info("Assigning multiple NUMA nodes (" + StringUtils.join(",", assignedNumaNodeInfo.getMemNodes()) + ") for memory, (" + StringUtils.join(",", assignedNumaNodeInfo.getCpuNodes()) + ") for cpus for " + containerId);
302: Miklos Szegedi, info, MethodDeclaration, LOG.info("Releasing the assigned NUMA resources for " + containerId);
332: Miklos Szegedi, error, IfStmt, LOG.error("Unexpected number:" + assignedResources.size() + " of assigned numa resources for " + containerId + " while recovering.");
48: Miklos Szegedi, info, ConstructorDeclaration, LOG.info("NUMA resources allocation is enabled, initializing NUMA resources" + " allocator.");
116: Varun Vasudev, debug, IfStmt, LOG.debug("Using container runtime: " + runtime.getClass().getSimpleName());
302: Jian He, info, IfStmt, LOG.info("cGroupsHandler is null - cgroups not in use.");
328: Varun Vasudev, warn, IfStmt, LOG.warn(message + ". Please check " + "configuration");
400: Sunil G, Error, CatchClause, LOG.error("Error when writing command to temp file, command=" + dockerVolumeCommand, e);
405: Sunil G, Error, CatchClause, LOG.error("Error when executing command, command=" + dockerVolumeCommand, e);
395: Sunil G, info, TryStmt, LOG.info("ContainerId=" + container.getContainerId() + ", docker volume output for " + dockerVolumeCommand + ": " + output);
462: Sunil G, info, IfStmt, LOG.info("Docker volume-name=" + volumeName + " driver-name=" + driverName + " already exists for container=" + container.getContainerId() + ", continue...");
476: Sunil G, error, MethodDeclaration, LOG.error(message);
479: Sunil G, debug, IfStmt, LOG.debug("All docker volumes in the system, command=" + dockerVolumeInspectCommand.toString());
520: Eric Yang, warn, IfStmt, LOG.warn("NOT requesting PID namespace. Value of " + ENV_DOCKER_CONTAINER_PID_NAMESPACE + "is invalid: " + pidNamespace);
532: Eric Yang, warn, IfStmt, LOG.warn(message);
568: Jian He, info, MethodDeclaration, LOG.info("setting hostname in container to: " + name);
585: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("cGroupsHandler is null. cgroups are not in use. nothing to" + " do.");
599: Varun Vasudev, debug, IfStmt, LOG.debug("using docker's cgroups options");
606: Varun Vasudev, debug, IfStmt, LOG.debug("using cgroup parent: " + cGroupPath);
594: Varun Vasudev, debug, IfStmt, LOG.debug("no resource restrictions specified. not using docker's " + "cgroup options");
642: Varun Vasudev, warn, IfStmt, LOG.warn("NOT running a privileged container. Value of " + ENV_DOCKER_CONTAINER_RUN_PRIVILEGED_CONTAINER + "is invalid: " + runPrivilegedContainerEnvVar);
648: Jian He, info, MethodDeclaration, LOG.info("Privileged container requested for : " + container.getContainerId().toString());
662: Varun Vasudev, warn, IfStmt, LOG.warn(message);
674: Varun Vasudev, warn, IfStmt, LOG.warn(message);
678: Jian He, info, MethodDeclaration, LOG.info("All checks pass. Launching privileged container for : " + container.getContainerId().toString());
882: Jian He, info, IfStmt, LOG.info("command override disabled");
1004: Eric Yang, warn, CatchClause, LOG.warn("Signal docker container failed. Exception: ", e);
1101: Varun Vasudev, Error, CatchClause, LOG.error("Error when writing command to temp file", e);
1103: Varun Vasudev, Error, CatchClause, LOG.error("Error when executing command.", e);
1060: Varun Vasudev, info, TryStmt, LOG.info("Docker inspect output for " + containerId + ": " + output);
1065: Varun Vasudev, error, IfStmt, LOG.error("Incorrect format for ip and host");
1091: Billie Rinaldi, error, CatchClause, LOG.error("Can not determine IP for container:" + containerId);
1150: Eric Yang, debug, IfStmt, LOG.debug("Launching container with cmd: " + command);
1203: Eric Yang, debug, IfStmt, LOG.debug("Container status is " + containerStatus.getName() + ", skipping stop - " + containerId);
1222: Eric Yang, debug, IfStmt, LOG.debug("Container status is " + containerStatus.getName() + ", skipping kill - " + containerId);
1234: Eric Yang, info, IfStmt, LOG.info("Delayed removal requested and allowed, skipping removal - " + containerId);
522: Robert Kanter, warn, IfStmt, LOG.warn("The container will run without the java security manager" + " due to an unsupported container command.  The command" + " will be permitted to run in Sandbox permissive mode: " + command);
64: Varun Vasudev, warn, IfStmt, LOG.warn("Unable to create directory: " + tmpDirPath);
101: Varun Vasudev, warn, CatchClause, LOG.warn("Unable to write docker command to temporary file!");
151: Eric Yang, warn, CatchClause, LOG.warn("Unable to write docker command to " + cmdDir);
89: Wangda Tan, debug, IfStmt, LOG.debug("Running docker command: " + dockerCommand);
160: Sidharta S, debug, IfStmt, LOG.debug("Container Status: " + DockerContainerStatus.NONEXISTENT.getName() + " ContainerId: " + containerId);
154: Sidharta S, debug, IfStmt, LOG.debug("Container Status: " + dockerContainerStatus.getName() + " ContainerId: " + containerId);
139: Ray Chiang, info, ConstructorDeclaration, LOG.info("Disk Validator: " + YarnConfiguration.DISK_VALIDATOR + " is loaded.");
294: Jonathan Turner Eagles, warn, CatchClause, LOG.warn("Failed to close filesystems: ", e);
329: Varun Vasudev, error, CatchClause, LOG.error("Heartbeat failed while dying: ", e);
477: Jian He, error, CatchClause, LOG.error("Exception in main:", e);
464: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Localization running as " + uid + " not " + user);
137: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Container " + container + " doesn't exist in the container list of the Resource " + this + " to which it sent RELEASE event");
195: Varun Saxena, debug, IfStmt, LOG.debug("Processing " + resourcePath + " of type " + event.getType());
202: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Can't handle this event at current state", e);
206: Robert Kanter, debug, IfStmt, LOG.debug("Resource " + resourcePath + (localPath != null ? "(->" + localPath + ")" : "") + " size : " + getSize() + " transitioned from " + oldState + " to " + newState);
144: Alejandro Abdelnur, info, IfStmt, LOG.info("Resource " + rsrc.getLocalPath() + " is missing, localizing it again");
160: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Container " + relEvent.getContainer() + " sent RELEASE event on a resource request " + req + " not present in cache.");
175: Junping Du, warn, IfStmt, LOG.warn("Ignoring attempt to recover existing resource " + rsrc);
184: Junping Du, warn, IfStmt, LOG.warn("Received " + event.getType() + " event for request " + req + " but localized resource is missing");
212: Junping Du, warn, IfStmt, LOG.warn("Resource " + rsrc + " localized without a location");
209: Junping Du, Error, CatchClause, LOG.error("Error storing resource state for " + rsrc, ioe);
386: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Attempt to remove absent resource: " + rem.getRequest() + " from " + getUser());
403: Jonathan Turner Eagles, info, IfStmt, LOG.info("Removed " + rsrc.getLocalPath() + " from localized cache");
393: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Attempt to remove resource: " + rsrc + " with non-zero refcount");
417: Junping Du, error, CatchClause, LOG.error("Unable to remove resource " + rsrc + " from state store", e);
434: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Random directory component did not match. " + "Deleting localized path only");
492: Jason Lowe, warn, WhileStmt, LOG.warn("Directory " + uniquePath + " already exists, " + "try next one.");
511: Junping Du, error, CatchClause, LOG.error("Unable to record localization start for " + rsrc, e);
240: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("per directory file limit = " + perDirFileLimit);
234: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error(YarnConfiguration.NM_LOCAL_CACHE_MAX_FILES_PER_DIRECTORY + " parameter is configured with very low value.");
269: Ray Chiang, info, MethodDeclaration, LOG.info("Disk Validator: " + YarnConfiguration.DISK_VALIDATOR + " is loaded.");
347: Jason Lowe, debug, IfStmt, LOG.debug("Recovering localized resource " + req + " at " + proto.getLocalPath());
362: Junping Du, info, ForeachStmt, LOG.info("Deleting in-progress localization for " + req + " at " + localPath);
386: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Localizer started on port " + server.getPort());
492: Varun Vasudev, warn, IfStmt, LOG.warn(c.getContainerId() + " is at " + c.getContainerState() + " state, do not localize resources.");
512: Karthik Kambatla, debug, IfStmt, LOG.debug("Localizing " + req.getPath() + " for container " + c.getContainerId());
542: Jason Lowe, info, IfStmt, LOG.info(stats.toString());
540: Jason Lowe, debug, IfStmt, LOG.debug(stats.toStringDetailed());
614: Jason Lowe, warn, CatchClause, LOG.warn("Local dir " + dir + " is an unsupported filesystem", ue);
642: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Removing uninitialized application " + application);
636: Junping Du, error, CatchClause, LOG.error("Unable to remove resource " + rsrc + " for " + appIDStr + " from state store", e);
747: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Unknown localizer with localizerId " + locId + " is sending heartbeat. Ordering it to DIE");
792: Jason Darrell Lowe, info, IfStmt, LOG.info("Created localizer for " + locId);
864: Yufei Gu, info, MethodDeclaration, LOG.info("Downloading public resource: " + key);
932: Yufei Gu, debug, IfStmt, LOG.debug("Skip downloading resource: " + key + " since it is locked" + " by other threads");
925: Yufei Gu, debug, IfStmt, LOG.debug("Skip downloading resource: " + key + " since it's in" + " state: " + rsrc.getState());
907: Mahadev Konar, error, CatchClause, LOG.error("Local path for public localization is not found. " + " May be disks failed.", e);
913: Jian He, error, CatchClause, LOG.error("Local path for public localization is not found. " + " Incorrect path. " + request.getResource().getRequest().getPath(), ie);
920: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Failed to submit rsrc " + rsrc + " for download." + " Either queue is full or threadpool is shutdown.", re);
989: Akira Ajisaka, Error, CatchClause, LOG.error("Error: Shutting down", t);
991: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Public cache exiting");
975: Hitesh Shah, info, CatchClause, LOG.info("Failed to download resource " + assoc.getResource(), e.getCause());
965: Hitesh Shah, error, IfStmt, LOG.error("Localized unknown resource to " + completed);
1097: Junping Du, error, CatchClause, LOG.error("Got exception in parsing URL of LocalResource:" + rsrc.getResource(), e);
1105: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Unknown resource reported: " + req);
1132: Jason Lowe, warn, SwitchStmt, LOG.warn(req + " failed: " + diagnostics);
1143: Vinod Kumar Vavilapalli, info, SwitchStmt, LOG.info("Unknown status: " + stat.getStatus());
1175: Xuan, error, CatchClause, LOG.error("local path for PRIVATE localization could not be " + "found. Disks might have failed.", e);
1178: Robert Kanter, error, CatchClause, LOG.error("Incorrect path for PRIVATE localization." + next.getResource().getFile(), e);
1181: Junping Du, error, CatchClause, LOG.error("Got exception in parsing URL of LocalResource:" + next.getResource(), e);
1249: bibinchundatt, info, IfStmt, LOG.info("Localizer failed for " + localizerId, exception);
1290: Zhijie Shen, debug, IfStmt, LOG.debug("Adding new framework-token for " + appId + " for localization: " + systemCredentials.getAllTokens());
1312: Arun Murthy, info, TryStmt, LOG.info("Writing credentials to the nmPrivate file " + nmPrivateCTokensPath.toString());
1315: Varun Saxena, debug, IfStmt, LOG.debug("Credentials list in " + nmPrivateCTokensPath.toString() + ": ");
1319: Xuan, debug, ForeachStmt, LOG.debug(tk + " : " + buildTokenFingerprint(tk));
1403: Jason Lowe, warn, CatchClause, LOG.warn(msg, ie);
1412: Jason Lowe, warn, CatchClause, LOG.warn(msg, e);
1423: Jason Lowe, warn, CatchClause, LOG.warn(msg, ie);
1444: Jason Lowe, warn, CatchClause, LOG.warn(msg, e);
1454: Jason Lowe, warn, CatchClause, LOG.warn("failed to cleanup app log dir " + logDir, e);
1493: Jason Lowe, info, IfStmt, LOG.info("delete app log dir," + appName);
1521: Jason Lowe, warn, CatchClause, LOG.warn("Failed to delete localDir: " + localDir);
1535: Siddharth Seth, warn, CatchClause, LOG.warn("Failed to rename the local file under " + localDir + "/" + localSubDir);
1562: Siddharth Seth, warn, CatchClause, LOG.warn("Failed to delete this local Directory: " + status.getPath().getName());
1549: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("usercache path : " + status.getPath().toString());
1611: Jason Lowe, info, ForeachStmt, LOG.info("Attempting to initialize " + dir);
1618: Jason Lowe, warn, CatchClause, LOG.warn(msg, e);
1636: Jason Lowe, warn, CatchClause, LOG.warn(msg, e);
1645: Jason Lowe, warn, IfStmt, LOG.warn(msg);
59: Siddharth Seth, debug, MethodDeclaration, LOG.debug("Using localizerTokenSecurityInfo");
41: Arun Murthy, debug, MethodDeclaration, LOG.debug("Using localizerTokenSelector.");
45: Varun Saxena, debug, IfStmt, LOG.debug("Token of kind " + token.getKind() + " is found");
51: Arun Murthy, debug, MethodDeclaration, LOG.debug("Returning null.");
173: Karthik Kambatla, warn, CatchClause, LOG.warn("Exception while uploading the file " + localPath.getName(), e);
120: Karthik Kambatla, warn, IfStmt, LOG.warn("User " + user + " is not authorized to upload file " + localPath.getName());
140: Karthik Kambatla, warn, IfStmt, LOG.warn("Could not copy the file to the shared cache at " + tempPath);
149: Karthik Kambatla, warn, IfStmt, LOG.warn("The file already exists under " + finalPath + ". Ignoring this attempt.");
169: Karthik Kambatla, info, TryStmt, LOG.info("File " + actualPath.getName() + " was uploaded to the shared cache at " + finalPath);
200: Mingliang Liu, debug, CatchClause, LOG.debug("Exception received while deleting temp files", ioe);
227: Karthik Kambatla, warn, IfStmt, LOG.warn("The remote file " + remotePath + " has changed since it's localized; will not consider it for upload");
83: Karthik Kambatla, error, CatchClause, LOG.error("Unexpected exception in getting the filesystem", e);
237: Xuan, warn, CatchClause, LOG.warn(this.appId + " specified invalid log aggregation policy " + className);
232: Xuan, warn, IfStmt, LOG.warn(this.appId + " specified invalid log aggregation policy " + className);
247: Xuan, info, IfStmt, LOG.info(this.appId + " specifies ContainerLogAggregationPolicy of " + policyClass);
309: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Cannot create writer for app " + this.applicationId + ". Skip log upload this time. ", e1);
371: Varun Vasudev, debug, IfStmt, LOG.debug("Adding new framework-token for " + appId + " for log-aggregation: " + systemCredentials.getAllTokens() + "; userUgi=" + userUgi);
423: Robert Kanter, Error, CatchClause, LOG.error("Error occurred while aggregating the log for the application " + appId, e);
428: Varun Saxena, warn, IfStmt, LOG.warn("Log aggregation did not complete for application " + appId);
453: Robert Joseph Evans, warn, CatchClause, LOG.warn("PendingContainers queue is interrupted");
484: Jason Lowe, warn, CatchClause, LOG.warn("Log dir " + rootLogDir + "is an unsupported file system", ue);
512: Xuan, info, IfStmt, LOG.info("Considering container " + logContext.getContainerId() + " for log-aggregation");
520: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Application just finished : " + this.applicationId);
527: Junping Du, info, MethodDeclaration, LOG.info("Aborting log aggregation for " + this.applicationId);
552: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Do OutOfBand log aggregation");
576: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Uploading logs for container " + containerId + ". Current good log dirs are " + StringUtils.join(",", dirsHandler.getLogDirsForRead()));
588: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Couldn't upload logs for " + containerId + ". Skipping this container.", e);
130: Junping Du, info, IfStmt, LOG.info("rollingMonitorInterval is set as " + rollingMonitorInterval + ". The logs will be aggregated every " + rollingMonitorInterval + " seconds");
126: Junping Du, info, IfStmt, LOG.info("rollingMonitorInterval is set as " + rollingMonitorInterval + ". The log rolling monitoring interval is disabled. " + "The logs will be aggregated after this application is finished.");
120: Junping Du, warn, IfStmt, LOG.warn("rollingMonitorIntervall should be more than or equal to " + MIN_LOG_ROLLING_INTERVAL + " seconds. Using " + MIN_LOG_ROLLING_INTERVAL + " seconds instead.");
117: Junping Du, info, IfStmt, LOG.info("Log aggregation debug mode enabled. rollingMonitorInterval = " + rollingMonitorInterval);
148: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(this.getName() + " waiting for pending aggregation during exit");
172: Robert Joseph Evans, info, ForeachStmt, LOG.info("Waiting for aggregation to complete for " + appId);
179: Robert Joseph Evans, warn, CatchClause, LOG.warn("Aggregation stop interrupted!");
184: Robert Joseph Evans, warn, ForeachStmt, LOG.warn("Some logs may not have been aggregated for " + appId);
200: Kihwal Lee, warn, CatchClause, LOG.warn("Application failed to init aggregation", e);
279: Jonathan Turner Eagles, warn, CatchClause, LOG.warn("Failed to close filesystems: ", e);
297: Daryn Sharp, warn, IfStmt, LOG.warn("Log aggregation is not initialized for " + containerId + ", did it fail to start?");
313: Daryn Sharp, warn, IfStmt, LOG.warn("Log aggregation is not initialized for " + appId + ", did it fail to start?");
371: Robert Kanter, warn, CatchClause, LOG.warn("Invalid thread pool size. Setting it to the default value " + "in YarnConfiguration");
377: Robert Kanter, warn, IfStmt, LOG.warn("Invalid thread pool size. Setting it to the default value " + "in YarnConfiguration");
97: Xuan, warn, CatchClause, LOG.warn("The format isn't valid. Min threshold falls back to the " + "default value " + DEFAULT_SAMPLE_MIN_THRESHOLD);
93: Xuan, warn, IfStmt, LOG.warn("The format isn't valid. Min threshold falls back to " + "the default value " + DEFAULT_SAMPLE_MIN_THRESHOLD);
84: Xuan, warn, CatchClause, LOG.warn("The format isn't valid. Sample rate falls back to the " + "default value " + DEFAULT_SAMPLE_RATE);
80: Xuan, warn, IfStmt, LOG.warn("The format isn't valid. Sample rate falls back to the " + "default value " + DEFAULT_SAMPLE_RATE);
132: Junping Du, debug, IfStmt, LOG.debug("Scheduling deletion of " + appId + " logs in " + deleteDelayMsec + " msec");
169: Vinod Kumar Vavilapalli, info, SwitchStmt, LOG.info("Scheduling Log Deletion for application: " + appId + ", with delay of " + this.deleteDelaySeconds + " seconds");
174: Junping Du, error, IfStmt, LOG.error("Unable to locate user for " + appId);
191: Junping Du, error, CatchClause, LOG.error("Unable to record log deleter state", e);
238: Jason Lowe, warn, CatchClause, LOG.warn("Unsupported file system used for log dir " + logDir, ue);
260: Junping Du, Error, CatchClause, LOG.error("Error removing log deletion state", e);
130: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(" Using ResourceCalculatorPlugin : " + this.resourceCalculatorPlugin);
135: Arun Murthy, info, MethodDeclaration, LOG.info(" Using ResourceCalculatorProcessTree : " + this.processTreeClass);
176: Hitesh Shah, info, MethodDeclaration, LOG.info("Physical memory check enabled: " + pmemCheckEnabled);
177: Hitesh Shah, info, MethodDeclaration, LOG.info("Virtual memory check enabled: " + vmemCheckEnabled);
181: Zhihai Xu, info, MethodDeclaration, LOG.info("ContainersMonitor enabled: " + containersMonitorEnabled);
193: Hitesh Shah, warn, IfStmt, LOG.warn("NodeManager's totalPmem could not be calculated. " + "Setting it to " + UNKNOWN_MEMORY_LIMIT);
201: Hitesh Shah, warn, IfStmt, LOG.warn("NodeManager configured with " + TraditionalBinaryPrefix.long2String(maxPmemAllottedForContainers, "", 1) + " physical memory allocated to containers, which is more than " + "80% of the total physical memory available (" + TraditionalBinaryPrefix.long2String(totalPhysicalMemoryOnNM, "", 1) + "). Thrashing might happen.");
232: Varun Vasudev, info, IfStmt, LOG.info("ResourceCalculatorPlugin is unavailable on this system. " + this.getClass().getName() + " is disabled.");
237: Varun Vasudev, info, IfStmt, LOG.info("ResourceCalculatorProcessTree is unavailable on this system. " + this.getClass().getName() + " is disabled.");
260: Robert Kanter, info, CatchClause, LOG.info("ContainersMonitorImpl monitoring thread interrupted");
388: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Process tree for container: " + containerId + " has processes older than 1 " + "iteration running over the configured limit. Limit=" + memLimit + ", current usage = " + curMemUsageOfAgedProcesses);
383: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Process tree for container: " + containerId + " running over twice " + "the configured limit. Limit=" + memLimit + ", current usage = " + currentMemUsage);
425: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Current ProcessTree list : " + tmp.substring(0, tmp.length()) + "]");
489: Zhijie Shen, warn, CatchClause, LOG.warn("Uncaught exception in ContainersMonitorImpl " + "while monitoring resource of " + containerId, e);
453: Varun Saxena, debug, IfStmt, LOG.debug("Constructing ProcessTree for : PID = " + pId + " ContainerId = " + containerId);
494: Devaraj K, debug, IfStmt, LOG.debug("Total Resource Usage stats in NM by all containers : " + "Virtual Memory= " + vmemUsageByAllContainers + ", Physical Memory= " + pmemByAllContainers + ", Total CPU usage(% per core)= " + cpuUsagePercentPerCoreByAllContainers);
519: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn(ContainersMonitorImpl.class.getName() + " is interrupted. Exiting.");
545: Varun Saxena, debug, IfStmt, LOG.debug("Tracking ProcessTree " + pId + " for the first time");
574: Daniel Templeton, info, IfStmt, LOG.info(containerId + " is missing. Not setting ip and hostname");
570: Daniel Templeton, info, IfStmt, LOG.info("Can not get both ip and hostname: " + Arrays.toString(ipAndHost));
567: Daniel Templeton, info, IfStmt, LOG.info(containerId + "'s ip = " + ipAndHost[0] + ", and hostname = " + ipAndHost[1]);
609: Jason Lowe, debug, IfStmt, AUDITLOG.debug(String.format("Resource usage of ProcessTree %s for container-id %s:" + " %s CPU:%f CPU/core:%f", pId, containerId.toString(), formatUsageString(currentVmemUsage, vmemLimit, currentPmemUsage, pmemLimit), cpuUsagePercentPerCore, cpuUsageTotalCoresPercentage));
705: Robert Kanter, error, IfStmt, LOG.error("Killed container process with PID " + pId + " but it is not a process group leader.");
713: Robert Kanter, info, IfStmt, LOG.info("Removed ProcessTree with root " + pId);
735: Daniel Templeton, info, IfStmt, LOG.info(containerId + " does not exist to report");
915: Daniel Templeton, warn, IfStmt, LOG.warn("Failed to track container " + containerId.toString() + ". It may have already completed.");
920: Daniel Templeton, info, IfStmt, LOG.info("Changing resource-monitoring for " + containerId);
932: Karthik Kambatla, info, MethodDeclaration, LOG.info("Stopping resource-monitoring for " + containerId);
941: Karthik Kambatla, info, MethodDeclaration, LOG.info("Starting resource-monitoring for " + containerId);
69: Sunil G, error, IfStmt, LOG.error(msg);
85: Wangda Tan, info, MethodDeclaration, LOG.info("Trying to diagnose FPGA information ...");
87: Wangda Tan, warn, IfStmt, LOG.warn("Failed to pass FPGA devices diagnose");
128: Wangda Tan, warn, IfStmt, LOG.warn("We continue although there're mistakes in user's configuration " + YarnConfiguration.NM_FPGA_ALLOWED_DEVICES + "user configured:" + allowed + ", while the real:" + list.toString());
46: Wangda Tan, info, MethodDeclaration, LOG.info("Initializing configured FPGA resources for the NodeManager.");
53: Wangda Tan, info, IfStmt, LOG.info("Didn't find any usable FPGAs on the NodeManager.");
50: Wangda Tan, info, MethodDeclaration, LOG.info("Using FPGA vendor plugin: " + vendorPluginClass);
114: Wangda Tan, warn, IfStmt, LOG.warn("Failed to find FPGA discoverer executable configured in " + YarnConfiguration.NM_FPGA_PATH_TO_EXEC + ", please check! Try default path");
130: Wangda Tan, warn, IfStmt, LOG.warn("Failed to find FPGA discoverer executable in " + pluginDefaultPreferredPath + ", file doesn't exists! Use default binary" + pathToExecutable);
121: Wangda Tan, warn, IfStmt, LOG.warn("Failed to find FPGA discoverer executable from system environment " + getDefaultPathEnvName() + ", please check your environment!");
137: Wangda Tan, warn, IfStmt, LOG.warn("Intel FPGA for OpenCL diagnose failed!");
174: Wangda Tan, warn, CatchClause, LOG.warn(msg);
175: Wangda Tan, debug, CatchClause, LOG.debug("Command output:" + shexec.getOutput() + ", exit code:" + shexec.getExitCode());
166: Wangda Tan, debug, TryStmt, LOG.debug("Get FPGA major-minor numbers from /dev/" + devName);
169: Wangda Tan, debug, TryStmt, LOG.debug("stat output:" + shexec.getOutput());
193: Wangda Tan, warn, CatchClause, LOG.warn(msg);
194: Wangda Tan, debug, CatchClause, LOG.debug(shexec.getOutput());
266: Wangda Tan, warn, IfStmt, LOG.warn("Unsupported diagnose output");
280: Wangda Tan, warn, IfStmt, LOG.warn("Couldn't find " + fieldRegexes[i] + " pattern");
332: Wangda Tan, info, MethodDeclaration, LOG.info("Got environment: " + id + ", search IP file in localized resources");
334: Wangda Tan, warn, IfStmt, LOG.warn("IP_ID environment is empty, skip downloading");
349: Wangda Tan, warn, IfStmt, LOG.warn("Localized resource is null!");
341: Wangda Tan, debug, ForeachStmt, LOG.debug("Check:" + path.toUri().toString());
344: Wangda Tan, debug, IfStmt, LOG.debug("Found: " + r);
380: Wangda Tan, error, CatchClause, LOG.error("Intel aocl program " + ipPath + " to " + aclName + " failed!");
374: Wangda Tan, debug, IfStmt, LOG.debug(shexec.getOutput());
375: Wangda Tan, info, IfStmt, LOG.info("Intel aocl program " + ipPath + " to " + aclName + " successfully");
107: Sunil G, error, IfStmt, LOG.error(msg);
125: Sunil G, debug, IfStmt, LOG.debug(msg);
132: Sunil G, warn, IfStmt, LOG.warn(msg, e);
191: Sunil G, info, IfStmt, LOG.info("Allowed GPU devices:" + gpuDevices);
165: Sunil G, error, IfStmt, LOG.error(msg);
230: Sunil G, warn, IfStmt, LOG.warn("Specified path is a directory, use " + DEFAULT_BINARY_NAME + " under the directory, updated path-to-executable:" + binaryPath.getAbsolutePath());
222: Sunil G, warn, IfStmt, LOG.warn("Failed to locate binary at:" + binaryPath.getAbsolutePath() + ", please double check [" + YarnConfiguration.NM_GPU_PATH_TO_EXEC + "] setting. Now use " + "default binary:" + DEFAULT_BINARY_NAME);
247: Sunil G, warn, CatchClause, LOG.warn(msg);
240: Sunil G, info, TryStmt, LOG.info("Trying to discover GPU information ...");
242: Sunil G, info, TryStmt, LOG.info(info.toString());
41: Sunil G, info, MethodDeclaration, LOG.info("Initializing configured GPU resources for the NodeManager.");
48: Sunil G, error, IfStmt, LOG.error(message);
94: Sunil G, info, IfStmt, LOG.info(YarnConfiguration.NVIDIA_DOCKER_PLUGIN_V1_ENDPOINT + " set to empty, skip init ..");
140: Sunil G, warn, CatchClause, LOG.warn("RuntimeException of " + this.getClass().getSimpleName() + " init:", e);
145: Sunil G, warn, CatchClause, LOG.warn("IOException of " + this.getClass().getSimpleName() + " init:", e);
109: Sunil G, info, TryStmt, LOG.info("Additional docker CLI options from plugin to run GPU " + "containers:" + cliOptions);
125: Sunil G, debug, IfStmt, LOG.debug("Found volume-driver:" + volumeDriver);
295: Sunil G, debug, IfStmt, LOG.debug("Failed to match " + mountSource + " to named-volume regex pattern");
290: Sunil G, debug, IfStmt, LOG.debug("Found volume name for GPU:" + newVolumeName);
93: Arun Suresh, debug, IfStmt, LOG.debug("pMemCheck [current={} + asked={} > allowed={}]", this.containersAllocation.getPhysicalMemory(), (pMemBytes >> 20), (getContainersMonitor().getPmemAllocatedForContainers() >> 20));
106: Arun Suresh, debug, IfStmt, LOG.debug("before vMemCheck" + "[isEnabled={}, current={} + asked={} > allowed={}]", getContainersMonitor().isVmemCheckEnabled(), this.containersAllocation.getVirtualMemory(), (vMemBytes >> 20), (getContainersMonitor().getVmemAllocatedForContainers() >> 20));
122: Arun Suresh, debug, IfStmt, LOG.debug("before cpuCheck [asked={} > allowed={}]", this.containersAllocation.getCPU(), getContainersMonitor().getVCoresAllocatedForContainers());
167: Arun Suresh, error, IfStmt, LOG.error("Unknown event type on UpdateCOntainer: " + event.getType());
176: Arun Suresh, error, SwitchStmt, LOG.error("Unknown event arrived at ContainerScheduler: " + event.toString());
243: Arun Suresh, error, IfStmt, LOG.error("UnKnown execution type received " + container.getContainerId() + ", execType " + execType);
412: Arun Suresh, info, IfStmt, LOG.info("Opportunistic container [{}] will not be queued at the NM" + "since max queue length [{}] has been reached", container.getContainerId(), maxOppQueueLength);
406: Arun Suresh, info, IfStmt, LOG.info("Opportunistic container {} will be queued at the NM.", container.getContainerId());
427: Arun Suresh, warn, CatchClause, LOG.warn("Could not store container [" + container.getContainerId() + "] state. The Container has been queued.", e);
484: Arun Suresh, info, ForeachStmt, LOG.info("Container {} will be {} to start the " + "execution of guaranteed container {}.", contToReclaim.getContainerId(), preemptionAction, container.getContainerId());
503: Arun Suresh, info, MethodDeclaration, LOG.info("Starting container [" + container.getContainerId() + "]");
548: Arun Suresh, warn, IfStmt, LOG.warn("There are no sufficient resources to start guaranteed [{}]" + "at the moment. Opportunistic containers are in the process of" + "being killed to make room.", containerToStartId);
623: Arun Suresh, info, IfStmt, LOG.info("Opportunistic container {} will be killed to meet NM queuing" + " limits.", container.getContainerId());
83: Wangda Tan, warn, IfStmt, LOG.warn("The configured log-aggregation-status.time-out.ms is " + configuredRollingInterval + " which should be larger than 0. " + "Using the default value:" + this.rollingInterval + " instead.");
89: Wangda Tan, info, ConstructorDeclaration, LOG.info("the rolling interval seconds for the NodeManager Cached Log " + "aggregation status is " + (rollingInterval / 1000));
96: Wangda Tan, warn, IfStmt, LOG.warn("Log Aggregation is disabled." + "So is the LogAggregationStatusTracker.");
113: Wangda Tan, warn, IfStmt, LOG.warn("The log aggregation is diabled. No need to update " + "the log aggregation status");
146: Wangda Tan, warn, IfStmt, LOG.warn("Ignore the log aggregation status update request " + "for the application:" + appId + ". The request log " + "aggregation status update is older than the cached " + "log aggregation status.");
141: Wangda Tan, warn, IfStmt, LOG.warn("Ignore the log aggregation status update request " + "for the application:" + appId + ". The cached log aggregation " + "status is " + tracker.getLogAggregationStatus() + ".");
127: Wangda Tan, warn, IfStmt, LOG.warn("The application:" + appId + " has already finished," + " and has been removed from NodeManager, we should not " + "receive the log aggregation status update for " + "this application.");
167: Wangda Tan, warn, IfStmt, LOG.warn("The log aggregation is diabled." + "There is no cached log aggregation status.");
206: Wangda Tan, info, TryStmt, LOG.info("Rolling over the cached log aggregation status.");
54: Wangda Tan, error, CatchClause, LOG.error("Failed to update node Labels from configuration.xml ", e);
159: Rohith Sharma K S, warn, IfStmt, LOG.warn("Execution of Node Labels script failed, Caught exception : " + e.getMessage(), e);
156: Rohith Sharma K S, warn, IfStmt, LOG.warn("Node Labels script timed out, Caught exception : " + e.getMessage(), e);
206: Miklos Szegedi, error, MethodDeclaration, LOG.error("Statestore exception: ", dbErr);
272: Jason Lowe, warn, ForeachStmt, LOG.warn("Remove container " + containerId + " with incomplete records");
278: Jason Lowe, error, CatchClause, LOG.error("Unable to remove container " + containerId + " in store", e);
367: Jason Lowe, warn, IfStmt, LOG.warn("the container " + containerId + " will be killed because of the unknown key " + key + " during recovery.");
382: Jason Lowe, debug, IfStmt, LOG.debug("storeContainer: containerId= " + idStr + ", startRequest= " + startRequest);
422: Arun Suresh, debug, IfStmt, LOG.debug("storeContainerQueued: containerId=" + containerId);
438: Arun Suresh, debug, IfStmt, LOG.debug("removeContainerQueued: containerId=" + containerId);
454: Arun Suresh, debug, IfStmt, LOG.debug("storeContainerPaused: containerId=" + containerId);
471: Arun Suresh, debug, IfStmt, LOG.debug("removeContainerPaused: containerId=" + containerId);
488: Varun Vasudev, debug, IfStmt, LOG.debug("storeContainerDiagnostics: containerId=" + containerId + ", diagnostics=" + diagnostics);
506: Varun Vasudev, debug, IfStmt, LOG.debug("storeContainerLaunched: containerId=" + containerId);
525: Arun Suresh, debug, IfStmt, LOG.debug("storeContainerUpdateToken: containerId=" + containerId);
555: Varun Vasudev, debug, IfStmt, LOG.debug("storeContainerKilled: containerId=" + containerId);
572: Varun Vasudev, debug, IfStmt, LOG.debug("storeContainerCompleted: containerId=" + containerId);
640: Varun Vasudev, debug, IfStmt, LOG.debug("removeContainer: containerId=" + containerId);
707: Varun Vasudev, debug, IfStmt, LOG.debug("storeApplication: appId=" + appId + ", proto=" + p);
724: Varun Vasudev, debug, IfStmt, LOG.debug("removeApplication: appId=" + appId);
823: Junping Du, debug, IfStmt, LOG.debug("Loading completed resource from " + key);
845: Junping Du, debug, IfStmt, LOG.debug("Loading in-progress resource at " + localPath);
906: Junping Du, debug, IfStmt, LOG.debug("Storing localized resource to " + completedKey);
930: Junping Du, debug, IfStmt, LOG.debug("Removing local resource at " + localPathStr);
1221: Junping Du, warn, CatchClause, LOG.warn("Skipping unknown log deleter key " + fullKey);
1266: Sunil G, debug, IfStmt, LOG.debug("storeAssignedResources: containerId=" + container.getContainerId() + ", assignedResources=" + StringUtils.join(",", assignedResources));
1301: Jason Lowe, warn, CatchClause, LOG.warn("cleanup keys with prefix " + FINISHED_APPS_KEY_PREFIX + " from leveldb failed", e);
1322: Jason Lowe, debug, IfStmt, LOG.debug("cleanup " + keyStr + " from leveldb");
1388: Arun Suresh, warn, CatchClause, LOG.warn("Unknown key " + key + ", remove and move on", e);
1398: Arun Suresh, info, IfStmt, LOG.info("Recovered for AMRMProxy: " + attemptId + ", map size " + appContext.size());
1371: Arun Suresh, info, IfStmt, LOG.info("Recovered for AMRMProxy: next master key id " + result.getNextMasterKey().getKeyId());
1365: Arun Suresh, info, IfStmt, LOG.info("Recovered for AMRMProxy: current master key id " + result.getCurrentMasterKey().getKeyId());
1534: Junping Du, info, MethodDeclaration, LOG.info("Using state database at " + storeRoot + " for recovery");
1540: Junping Du, info, IfStmt, LOG.info("Creating state database at " + dbfile);
1587: Jian He, info, MethodDeclaration, LOG.info("Starting full compaction cycle");
1591: Jian He, Error, CatchClause, LOG.error("Error compacting database", e);
1594: Jian He, info, MethodDeclaration, LOG.info("Full compaction cycle completed in " + duration + " msec");
1656: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Loaded NM state version info " + loadedVersion);
1661: Jason Darrell Lowe, info, IfStmt, LOG.info("Storing NM state version info " + getCurrentVersion());
211: Arun Suresh, info, MethodDeclaration, LOG.info("Forwarding registration request to the" + "Distributed Scheduler Service on YARN RM");
241: Arun Suresh, debug, IfStmt, LOG.debug("Forwarding allocate request to the" + "Distributed Scheduler Service on YARN RM");
113: Devarajulu K, error, CatchClause, LOG.error("Unable to update current master key in state store", e);
122: Devarajulu K, error, CatchClause, LOG.error("Unable to update previous master key in state store", e);
138: Devarajulu K, info, IfStmt, LOG.info("Rolling master-key for container-tokens, got key with id " + masterKeyRecord.getKeyId());
210: Devarajulu K, error, CatchClause, LOG.error("Unable to store token for container " + containerId, e);
226: Devarajulu K, error, CatchClause, LOG.error("Unable to remove token for container " + container, e);
260: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Updating node address : " + nodeHostAddr);
115: Junping Du, error, CatchClause, LOG.error("Unable to update current master key in state store", e);
124: Junping Du, error, CatchClause, LOG.error("Unable to update previous master key in state store", e);
138: Junping Du, info, IfStmt, LOG.info("Rolling master-key for container-tokens, got key with id " + masterKey.getKeyId());
183: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("NMToken password retrieved successfully!!");
203: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("No application Attempt for application : " + appId + " started on this NM.");
195: Varun Saxena, debug, IfStmt, LOG.debug("Removing application attempts NMToken keys for application " + appId);
232: Varun Saxena, debug, IfStmt, LOG.debug("NMToken key updated for application attempt : " + identifier.getApplicationAttemptId().toString());
251: Varun Saxena, debug, IfStmt, LOG.debug("updating nodeId : " + nodeId);
276: Junping Du, error, CatchClause, LOG.error("Unable to store master key for application " + attempt, e);
285: Junping Du, error, CatchClause, LOG.error("Unable to remove master key for application " + attempt, e);
106: Jian He, info, MethodDeclaration, LOG.info("Initialized NMTimelinePublisher UGI to " + nmLoginUGI);
145: Junping Du, error, SwitchStmt, LOG.error("Unknown NMTimelineEvent type: " + event.getType());
187: Sangjin Lee, error, CatchClause, LOG.error("Failed to publish Container metrics for container " + container.getContainerId(), e);
183: Sangjin Lee, error, IfStmt, LOG.error("Seems like client has been removed before the container" + " metric could be published for " + container.getContainerId());
281: Sangjin Lee, error, CatchClause, LOG.error("Failed to publish Container metrics for container " + container.getContainerId(), e);
277: Sangjin Lee, error, IfStmt, LOG.error("Seems like client has been removed before the event could be" + " published for " + container.getContainerId());
312: Junping Du, Error, CatchClause, LOG.error("Error when publishing entity " + entity, e);
301: Junping Du, debug, IfStmt, LOG.debug("Publishing the entity " + entity + ", JSON-style content: " + TimelineUtils.dumpTimelineRecordtoJSON(entity));
308: Sangjin Lee, error, IfStmt, LOG.error("Seems like client has been removed before the entity " + "could be published for " + entity);
335: Sangjin Lee, debug, IfStmt, LOG.debug(event.getType() + " is not a desired ApplicationEvent which" + " needs to be published by NMTimelinePublisher");
351: Junping Du, debug, IfStmt, LOG.debug(event.getType() + " is not a desired ContainerEvent which needs to be published by" + " NMTimelinePublisher");
372: Junping Du, debug, IfStmt, LOG.debug(event.getType() + " is not a desired LocalizationEvent which needs to be published" + " by NMTimelinePublisher");
431: Jian He, warn, CatchClause, LOG.warn("Unable to create timeline client for app " + appId, e);
182: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Removing CPU constraints for YARN containers.");
174: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("YARN containers restricted to " + yarnProcessors + " cores");
210: Alejandro Abdelnur, debug, IfStmt, LOG.debug("createCgroup: " + path);
224: Alejandro Abdelnur, debug, IfStmt, LOG.debug("updateCgroup: " + path + ": " + param + "=" + value);
265: Jason Lowe, warn, CatchClause, LOG.warn("Failed to read cgroup tasks file. ", e);
262: Jason Lowe, debug, IfStmt, LOG.debug("First line in cgroup tasks file: " + cgf + " " + str);
296: Jason Lowe, warn, CatchClause, LOG.warn("Failed to read cgroup tasks file. ", e);
290: Jason Lowe, warn, IfStmt, LOG.warn("Failed attempt to delete cgroup: " + cgf);
306: Sanford Ryza, debug, IfStmt, LOG.debug("deleteCgroup: " + cgroupPath);
321: Sanford Ryza, warn, IfStmt, LOG.warn("Unable to delete cgroup at: " + cgroupPath + ", tried to delete for " + deleteCgroupTimeout + "ms");
452: Haibo Chen, warn, IfStmt, LOG.warn(String.format("Skipping inaccessible cgroup mount point %s", e.getKey()));
325: Naganarasimha, error, IfStmt, LOG.error("Calculated memory for YARN containers is too low." + " Node memory is " + physicalMemoryMB + " MB, system reserved memory is " + reservedMemoryMB + " MB.");
356: Varun Vasudev, debug, ForeachStmt, LOG.debug("Setting key " + entry.getKey() + " to " + entry.getValue());
367: Wangda Tan, debug, IfStmt, LOG.debug("Set memory to " + ret.getMemorySize());
379: Varun Vasudev, debug, IfStmt, LOG.debug("Set vcores to " + ret.getVirtualCores());
382: Varun Vasudev, debug, MethodDeclaration, LOG.debug("Node resource information map is " + ret);
53: Varun Saxena, debug, IfStmt, LOG.debug("Accessing pid from pid file " + path);
103: Varun Saxena, debug, IfStmt, LOG.debug("Got pid " + (processId != null ? processId : "null") + " from path " + path);
155: Wangda Tan, debug, IfStmt, LOG.debug(ex.getMessage());
238: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Exception reading log file " + logFile.getAbsolutePath(), e);
111: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Failed to find log file", e);
174: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Exception reading log file " + logFile.getAbsolutePath(), e);
294: Junping Du, debug, IfStmt, LOG.debug(ex.getMessage());
399: Junping Du, debug, IfStmt, LOG.debug("Can not find the container:" + containerId + " in this node.");
481: Junping Du, debug, IfStmt, LOG.debug("Can not access the aggregated log for " + "the container:" + containerId);
483: Junping Du, debug, IfStmt, LOG.debug(ex.getMessage());
99: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Instantiating NMWebApp at " + bindAddress);
116: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(msg, e);
129: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Stopping webapp");
73: Sunil G, error, CatchClause, LOG.error("Exception while initialize parser", e);
83: Sunil G, error, CatchClause, LOG.error("Exception while parsing xml", e);
98: Vinod Kumar Vavilapalli, DEBUG, ForeachStmt, LOG.info("DEBUG: " + req + ":" + rsrcReqs.getContainer().getContainerId());
98: Thomas White, info, MethodDeclaration, LOG.info("Got heartbeat number " + heartBeatID);
188: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Setting " + YarnConfiguration.NM_LINUX_CONTAINER_EXECUTOR_PATH + "=" + exec_path);
277: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Not running test because container-executor.path is not set");
459: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Caught exception while running sleep", e);
471: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Sleeping for 200 ms before checking for pid ");
477: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Going to killing the process.");
483: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("sleeping for 100ms to let the sleep be killed");
301: Robert Joseph Evans, Error, CatchClause, LOG.error("Error:" + e.getMessage(), e);
129: Todd Lipcon, info, MethodDeclaration, LOG.info("Checking initial healthy condition");
141: Todd Lipcon, info, MethodDeclaration, LOG.info("Checking Healthy--->Unhealthy");
151: Todd Lipcon, info, MethodDeclaration, LOG.info("Checking UnHealthy--->healthy");
165: Todd Lipcon, info, MethodDeclaration, LOG.info("Checking Healthy--->timeout");
229: Jian He, info, MethodDeclaration, LOG.info("Sending out RESYNC event");
575: Jian He, info, MethodDeclaration, LOG.info("Start a container and wait until it is in RUNNING state");
626: Jian He, info, MethodDeclaration, LOG.info("Increase a container resource in a separate thread");
158: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Registering " + nodeId.toString());
194: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Got heartbeat number " + heartBeatID);
586: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Got heartBeatId: [" + heartBeatID + "]");
605: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Sending FINISH_APP for application: [" + appId + "]");
855: Bikas Saha, info, IfStmt, LOG.info("Registering " + nodeId.toString());
1145: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for NM to start..");
1147: Robert Joseph Evans, Error, IfStmt, LOG.error("Error during startup. ", nmStartError);
1217: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for NM to stop..");
1226: Rohith Sharma K S, info, WhileStmt, LOG.info("Waiting for NM shutdown..");
1250: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for NM to stop..");
1418: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("NM should have started successfully " + "after connecting to RM.", ex);
1495: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Number of Keep Alive Requests: [" + numKeepAliveRequests + "]");
1636: Jonathan Turner Eagles, info, WhileStmt, LOG.info("Waiting for NM to stop..");
1676: Xuan, info, WhileStmt, LOG.info("Waiting for NM to start..");
1678: Xuan, Error, IfStmt, LOG.error("Error during startup. ", nmStartError);
232: Jian He, info, MethodDeclaration, LOG.info("Sending requests to endpoints asynchronously. Number of test contexts=" + testContexts.size());
237: Jian He, info, ForStmt, LOG.info("Adding request to threadpool for test context: " + testContext.toString());
243: Jian He, info, MethodDeclaration, LOG.info("Sending request. Test context:" + testContext.toString());
252: Jian He, error, CatchClause, LOG.error("Failed to process request for context: " + testContext);
249: Jian He, info, TryStmt, LOG.info("Successfully sent request for context: " + testContext.toString());
263: Jian He, info, MethodDeclaration, LOG.info("Waiting for responses from endpoints. Number of contexts=" + testContexts.size());
271: Jian He, error, CatchClause, LOG.error("Failed to process request " + e.getMessage());
346: Jian He, error, CatchClause, LOG.error("Failed to register application master with test context: " + testContext);
342: Jian He, info, TryStmt, LOG.info("Sucessfully registered application master with test context: " + testContext);
429: Jian He, error, CatchClause, LOG.error("Failed to finish application master with test context: " + testContext);
425: Jian He, info, TryStmt, LOG.info("Sucessfully finished application master with test contexts: " + testContext);
171: Jian He, info, MethodDeclaration, LOG.info("Creating " + numberOfRequests + " contexts for testing");
174: Jian He, info, ForStmt, LOG.info("Created test context: " + testContexts.get(ep));
218: Jian He, info, CatchClause, LOG.info("Finish registration failed as expected because it was not registered");
231: Jian He, info, CatchClause, LOG.info("Finish registration failed as expected because it was not registered");
266: Jian He, info, CatchClause, LOG.info("Finish registration failed as expected because it was not registered");
276: Jian He, info, CatchClause, LOG.info("Finish registration failed as expected because it was not registered");
285: Jian He, info, MethodDeclaration, LOG.info("Creating " + numberOfRequests + " contexts for testing");
288: Jian He, info, ForStmt, LOG.info("Created test context: " + testContexts.get(i));
330: Jian He, info, CatchClause, LOG.info("AllocateRequest failed as expected because AM was not registered");
406: Jian He, error, CatchClause, LOG.error("Failed to register application master with appId: " + testAppId, ex);
403: Jian He, info, TryStmt, LOG.info("Sucessfully registered application master with appId: " + testAppId);
499: Jian He, info, WhileStmt, LOG.info("Number of allocated containers in this request: " + Integer.toString(allocateResponse.getAllocatedContainers().size()));
502: Jian He, info, WhileStmt, LOG.info("Total number of allocated containers: " + Integer.toString(containers.size()));
560: Jian He, info, WhileStmt, LOG.info("Number of containers received in this request: " + Integer.toString(allocateResponse.getAllocatedContainers().size()));
563: Jian He, info, WhileStmt, LOG.info("Total number of containers received: " + Integer.toString(containersForReleasedContainerIds.size()));
193: Subru Krishnan, info, MethodDeclaration, LOG.info("Number of allocated containers in the original request: " + Integer.toString(allocateResponse.getAllocatedContainers().size()));
208: Subru Krishnan, info, WhileStmt, LOG.info("Number of allocated containers in this request: " + Integer.toString(allocateResponse.getAllocatedContainers().size()));
210: Subru Krishnan, info, WhileStmt, LOG.info("Total number of allocated containers: " + Integer.toString(containers.size()));
243: Subru Krishnan, info, MethodDeclaration, LOG.info("Number of containers received in the original request: " + Integer.toString(newlyFinished.size()));
258: Subru Krishnan, info, WhileStmt, LOG.info("Number of containers received in this request: " + Integer.toString(newlyFinished.size()));
260: Subru Krishnan, info, WhileStmt, LOG.info("Total number of containers received: " + Integer.toString(containersForReleasedContainerIds.size()));
408: Subru Krishnan, info, CatchClause, LOG.info("Test main wait interrupted", e);
404: Subru Krishnan, info, TryStmt, LOG.info("Test main starts waiting for the first thread to block");
406: Subru Krishnan, info, TryStmt, LOG.info("Test main wait finished");
413: Subru Krishnan, info, MethodDeclaration, LOG.info("Starting second register thread");
417: Subru Krishnan, info, MethodDeclaration, LOG.info("Let first blocked register thread move on");
445: Subru Krishnan, info, CatchClause, LOG.info("Register thread exception", e);
202: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Created localDir in " + localDir.getAbsolutePath());
203: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Created tmpDir in " + tmpDir.getAbsolutePath());
287: Varun Vasudev, info, MethodDeclaration, LOG.info("Psuedo delete: user - " + user + ", type - " + deletionTask.getDeletionTaskType());
338: Arun Suresh, info, DoStmt, LOG.info("Waiting for container to get into one of states " + fStates + ". Current state is " + containerStatus.getState());
343: Karthik Kambatla, info, MethodDeclaration, LOG.info("Container state is " + containerStatus.getState());
358: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for app to reach " + finalState + ".. Current state is " + app.getApplicationState());
402: Arun Suresh, info, IfStmt, LOG.info("Waiting for NM container to get into one of the following " + "states: " + finalStates + ". Current state is " + currentState);
408: Jian He, info, MethodDeclaration, LOG.info("Container state is " + currentState);
416: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for process start-file to be created");
492: Arun Suresh, info, WhileStmt, LOG.info("Waiting for Original process to die.." + "and new process to start!!");
502: Arun Suresh, info, WhileStmt, LOG.info("Waiting for New process file to be created!!");
676: Arun Suresh, info, WhileStmt, LOG.info("Waiting for ReInitialization to complete..");
684: Arun Suresh, info, WhileStmt, LOG.info("Waiting for New process start-file to be created");
868: Arun Suresh, info, WhileStmt, LOG.info("Waiting for New process start-file to be created");
961: Arun Suresh, info, WhileStmt, LOG.info("Waiting for New process start-file to be created");
994: Arun Suresh, info, WhileStmt, LOG.info("Waiting for process start-file to be created");
2033: Xuan, info, WhileStmt, LOG.info("Waiting for process start-file to be created");
136: Jian He, info, MethodDeclaration, LOG.info("Created localDir in " + localDir.getAbsolutePath());
137: Jian He, info, MethodDeclaration, LOG.info("Created tmpDir in " + tmpDir.getAbsolutePath());
845: Gera Shegalov, info, IfStmt, LOG.info("Diagnostic Info : " + exitEvent.getDiagnosticInfo());
1218: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for process start-file to be created");
1558: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for process start-file to be created");
1579: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Manually killing pid " + pid + ", but not child pid " + child);
186: Junping Du, info, CatchClause, LOG.info("Caught expected exception : " + e);
198: Junping Du, info, CatchClause, LOG.info("Caught expected exception : " + e);
229: Junping Du, info, CatchClause, LOG.info("Caught unexpected exception : " + e);
232: Junping Du, error, CatchClause, LOG.error("Caught exception: " + e);
227: Junping Du, error, CatchClause, LOG.error("Caught exception: " + e);
256: Junping Du, error, CatchClause, LOG.error("Caught exception: " + e);
299: Junping Du, error, CatchClause, LOG.error("Caught exception: " + e);
350: Junping Du, error, CatchClause, LOG.error("Caught exception: " + e);
334: Junping Du, error, CatchClause, LOG.error("Caught exception: " + e);
101: Wangda Tan, error, CatchClause, LOG.error("Unexpected exception: " + e);
115: Wangda Tan, error, CatchClause, LOG.error("Unexpected exception: " + e);
110: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Unexpected exception: " + e);
128: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Unexpected exception: " + e);
219: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Caught exception: " + e);
165: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Unexpected exception: " + e);
217: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Unexpected exception: " + e);
243: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Unexpected exception: " + e);
318: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Unexpected exception: " + e);
207: Eric Yang, info, CatchClause, LOG.info("Could not run id -u command: " + e);
214: Eric Yang, info, CatchClause, LOG.info("Could not run id -g command: " + e);
220: Eric Yang, info, CatchClause, LOG.info("Could not run id -G command: " + e);
300: Eric Yang, info, CatchClause, LOG.info("LocalDirsHandler failed" + ioe);
503: Varun Vasudev, info, CatchClause, LOG.info("Caught expected exception : " + e);
537: Varun Vasudev, info, CatchClause, LOG.info("Caught expected exception: " + e);
782: Varun Vasudev, info, CatchClause, LOG.info("Caught expected exception : " + e);
829: Eric Yang, info, CatchClause, LOG.info("Caught expected exception : " + e);
933: Varun Vasudev, info, CatchClause, LOG.info("Caught expected exception : " + e);
958: Varun Vasudev, info, CatchClause, LOG.info("Caught expected exception : " + e);
984: Varun Vasudev, info, CatchClause, LOG.info("Caught expected exception : " + e);
1108: Varun Vasudev, info, CatchClause, LOG.info("Caught expected exception : " + e);
1181: Varun Vasudev, info, CatchClause, LOG.info("Caught expected exception : " + e);
1311: Eric Yang, info, CatchClause, LOG.info("Caught expected exception : " + e);
1329: Eric Yang, info, CatchClause, LOG.info("Caught expected exception : " + e);
1347: Eric Yang, info, CatchClause, LOG.info("Caught expected exception : " + e);
2027: Eric Yang, warn, CatchClause, LOG.warn("Signal docker container failed. Exception: ", e);
2039: Eric Yang, info, IfStmt, LOG.info("Delayed removal requested and allowed, skipping removal - " + containerId);
2103: Eric Yang, warn, CatchClause, LOG.warn("Relaunch container failed. Exception: ", e);
2104: Eric Yang, info, CatchClause, LOG.info("Docker command used: " + startCommand);
131: Eric Yang, info, CatchClause, LOG.info("LocalDirsHandler failed" + ioe);
303: Akira Ajisaka, warn, CatchClause, LOG.warn(e.toString());
313: Akira Ajisaka, warn, CatchClause, LOG.warn(e.toString());
239: Jason Lowe, info, IfStmt, LOG.info("Removed " + rem.getRequest().getPath() + " from localized cache");
224: Jonathan Turner Eagles, Info, MethodDeclaration, verify(logAggregationService).closeFileSystems(any(UserGroupInformation.class));
883: Zhihai Xu, Info, MethodDeclaration, verify(logAggregationService).closeFileSystems(any(UserGroupInformation.class));
896: Steve Loughran, info, MethodDeclaration, LOG.info("Created Dir:" + containerLogDir.getAbsolutePath() + " status :" + created);
984: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Found container " + key.toString());
1013: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("LogType:" + fileType);
1014: Zhijie Shen, info, TryStmt, LOG.info("LogLength:" + fileLength);
1015: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Log Contents:\n" + perContainerMap.get(fileType));
1039: Vinod Kumar Vavilapalli, info, ForeachStmt, LOG.info("Expected log-content : " + new String(expectedValue));
1467: Jason Lowe, Info, MethodDeclaration, verify(logAggregationService).closeFileSystems(any(UserGroupInformation.class));
2538: Steve Loughran, info, CatchClause, LOG.info("Context file not vailable: " + fnf);
2548: Steve Loughran, info, IfStmt, LOG.info("fileName :" + filename);
2549: Steve Loughran, info, IfStmt, LOG.info("lastLogFile :" + lastLogFile);
2554: Steve Loughran, info, IfStmt, LOG.info("Node list filename :" + filename);
2558: Steve Loughran, info, MethodDeclaration, LOG.info("File Count :" + count);
309: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for process start-file to be created");
311: Naganarasimha, info, WhileStmt, LOG.info("Monitor thread is waiting for resource utlization change.");
200: Arun Suresh, info, MethodDeclaration, LOG.info("Container was paused");
205: Arun Suresh, info, MethodDeclaration, LOG.info("Container was resumed");
692: Junping Du, Info, IfStmt, List<ContainerLogFileInfo> meta = logInfo.getContainerLogsInfo();
686: Junping Du, Info, IfStmt, List<ContainerLogFileInfo> meta = logInfo.getContainerLogsInfo();
157: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("RM could not transition to Standby", e);
183: Karthik Kambatla, warn, MethodDeclaration, LOG.warn("Lost contact with Zookeeper. Transitioning to standby in " + zkSessionTimeout + " ms if connection is not reestablished.");
217: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Request to fence old active being ignored, " + "as embedded leader election doesn't support fencing");
247: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Invalid data in ZK: " + StringUtils.byteToHexString(data));
253: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Mismatched cluster! The other RM seems " + "to be from a different cluster. Current cluster = " + clusterId + "Other RM's cluster = " + proto.getClusterId());
252: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Allowing manual failover from " + org.apache.hadoop.ipc.Server.getRemoteAddress() + " even though automatic failover is enabled, because the user " + "specified the force flag");
639: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Resource update get failed on all nodes due to change " + "resource on an unrecognized node: " + nodeId);
664: Jian He, info, IfStmt, LOG.info("Update resource on node(" + node.getNodeID() + ") with resource(" + newResourceOption.toString() + ")");
658: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Resource update get failed on an unrecognized node: " + nodeId);
910: Wangda Tan, warn, MethodDeclaration, LOG.warn("Exception " + msg, exception);
62: Arun Suresh, info, MethodDeclaration, LOG.info("Initializing AMS Processing chain. Root Processor=[" + this.head.getClass().getName() + "].");
75: Arun Suresh, info, MethodDeclaration, LOG.info("Adding [" + processor.getClass().getName() + "] tp top of" + " AMS Processing chain. ");
142: Konstantinos Karanasos, info, IfStmt, LOG.info(YarnConfiguration.SCHEDULER_RM_PLACEMENT_CONSTRAINTS_HANDLER + " placement handler will be used. Scheduling requests will be " + "handled by the main scheduler.");
136: Konstantinos Karanasos, info, IfStmt, LOG.info(YarnConfiguration.PROCESSOR_RM_PLACEMENT_CONSTRAINTS_HANDLER + " placement handler will be used. Scheduling requests will be " + "handled by the placement constraint processor");
130: Konstantinos Karanasos, info, IfStmt, LOG.info(YarnConfiguration.DISABLED_RM_PLACEMENT_CONSTRAINTS_HANDLER + " placement handler will be used, all scheduling requests will " + "be rejected.");
159: Konstantinos Karanasos, warn, IfStmt, LOG.warn("Found PlacementProcessor=" + p.getClass().getCanonicalName() + " defined in " + YarnConfiguration.RM_APPLICATION_MASTER_SERVICE_PROCESSORS + ", however PlacementProcessor handler should be configured " + "by using " + YarnConfiguration.RM_PLACEMENT_CONSTRAINTS_HANDLER + ", this processor will be ignored.");
268: Subru Krishnan, warn, IfStmt, LOG.warn(message);
313: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(rmApp.getApplicationId() + " unregistered successfully. ");
328: Jian He, error, IfStmt, LOG.error(message);
352: Bikas Saha, error, MethodDeclaration, LOG.error(message);
403: Zhijie Shen, error, IfStmt, LOG.error(message);
450: Jian He, info, IfStmt, LOG.info("The AMRMToken has been rolled-over. Send new AMRMToken back" + " to application: " + appAttemptId.getApplicationId());
479: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Registering app attempt : " + attemptId);
496: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Unregistering app attempt : " + attemptId);
337: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Allocated new applicationId: " + applicationId.getId());
370: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.info("Error getting UGI ", ie);
562: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to get the current user.", ie);
584: Li Lu, warn, CatchClause, LOG.warn("Invalid to flow run: " + value + ". Flow run should be a long integer", e);
596: Jian He, info, IfStmt, LOG.info("This is an earlier submitted application: " + applicationId);
606: Jason Lowe, info, IfStmt, LOG.info("Using app provided configurations for delegation token renewal," + " total size = " + tokenConf.capacity());
649: Jason Lowe, info, CatchClause, LOG.info("Exception in submitting " + applicationId, e);
644: Arun Murthy, info, TryStmt, LOG.info("Application with id " + applicationId.getId() + " submitted by user " + user);
713: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.info("Error getting UGI ", ie);
800: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.info("Error getting UGI ", ie);
975: Jian He, Error, CatchClause, LOG.info("Error getting UGI ", ie);
1018: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Failed to getQueueInfo for " + request.getQueueName(), ioe);
1478: subru, debug, IfStmt, LOG.debug(MessageFormat.format("Reservation {0} is within threshold so attempting to create synchronously.", reservationId));
1483: subru, info, IfStmt, LOG.info(MessageFormat.format("Created reservation {0} synchronously.", reservationId));
1558: Arun Suresh, error, IfStmt, LOG.error(error);
1648: Xuan, Error, CatchClause, LOG.info("Error getting UGI ", ie);
1767: Jian He, Error, CatchClause, LOG.info("Error getting UGI ", ie);
89: Jian He, info, CatchClause, LOG.info("Fail to re-join election.", e);
101: Xuan, info, MethodDeclaration, LOG.info(rmId + "is elected leader, transitioning to active");
108: Xuan, info, CatchClause, LOG.info(rmId + " failed to transition to active, giving up leadership", e);
123: Xuan, info, MethodDeclaration, LOG.info(rmId + " relinquish leadership");
130: Xuan, info, CatchClause, LOG.info(rmId + " did not transition to standby successfully.");
205: Junping Du, info, IfStmt, LOG.info("remove " + nodeId + " in " + context.nodeState);
303: Junping Du, debug, IfStmt, LOG.debug("remove " + rmNode.getState() + " " + d.nodeId);
295: Junping Du, debug, IfStmt, LOG.debug("remove " + d.nodeState + " " + d.nodeId);
311: Junping Du, debug, IfStmt, LOG.debug("Identified stale and timeout node " + d.nodeId);
323: Junping Du, info, IfStmt, LOG.info("DECOMMISSIONING " + nodeId + " timeout");
345: Junping Du, debug, IfStmt, LOG.debug("Consider non-existing app " + appId + " as completed");
352: Junping Du, debug, IfStmt, LOG.debug("Remove " + rmApp.getState() + " app " + appId);
410: Daniel Templeton, debug, ForeachStmt, LOG.debug("Decommissioning node: " + sb.toString());
127: Arun Suresh, info, MethodDeclaration, LOG.info("AM registration " + applicationAttemptId);
142: Arun Suresh, info, IfStmt, LOG.info("Setting client token master key");
180: Arun Suresh, info, IfStmt, LOG.info("Application " + app.getApplicationId() + " retrieved " + transferredContainers.size() + " containers from previous" + " attempts and " + nmTokens.size() + " NM tokens.");
234: Arun Suresh, warn, CatchClause, LOG.warn("Invalid resource ask by application " + appAttemptId, e);
241: Arun Suresh, warn, CatchClause, LOG.warn("Invalid blacklist request by application " + appAttemptId, e);
252: Arun Suresh, warn, CatchClause, LOG.warn("Invalid container release by application " + appAttemptId, e);
282: Arun Suresh, warn, CatchClause, LOG.warn("Exceptions caught when scheduler handling requests");
273: Arun Suresh, warn, IfStmt, LOG.warn(appAttemptId + " is in " + state + " state, ignore container allocate request.");
288: Arun Suresh, info, IfStmt, LOG.info("blacklist are updated in Scheduler." + "blacklistAdditions: " + blacklistAdditions + ", " + "blacklistRemovals: " + blacklistRemovals);
150: Jason Lowe, info, IfStmt, LOG.info("Removed " + result.getState().toString() + " node " + result.getHostName() + " from inactive nodes list");
180: Jason Lowe, debug, SwitchStmt, LOG.debug("Unexpected node state");
194: Junping Du, debug, MethodDeclaration, LOG.debug("hostsReader: in=" + conf.get(YarnConfiguration.RM_NODES_INCLUDE_FILE_PATH, YarnConfiguration.DEFAULT_RM_NODES_INCLUDE_FILE_PATH) + " out=" + conf.get(YarnConfiguration.RM_NODES_EXCLUDE_FILE_PATH, YarnConfiguration.DEFAULT_RM_NODES_EXCLUDE_FILE_PATH));
202: Vinod Kumar Vavilapalli, debug, ForeachStmt, LOG.debug("include: " + include);
205: Vinod Kumar Vavilapalli, debug, ForeachStmt, LOG.debug("exclude: " + exclude);
236: Junping Du, info, MethodDeclaration, LOG.info("refreshNodes excludesFile " + excludesFile);
240: Junping Du, info, MethodDeclaration, LOG.info("hostsReader include:{" + StringUtils.join(",", hostsReader.getHosts()) + "} exclude:{" + StringUtils.join(",", hostsReader.getExcludedHosts()) + "}");
310: Junping Du, info, IfStmt, LOG.info("Forcefully decommission " + nodeStr);
306: Junping Du, info, IfStmt, LOG.info("No action for " + nodeStr);
303: Junping Du, info, IfStmt, LOG.info("Update " + nodeStr + " timeout to be " + timeoutToUse);
298: Junping Du, info, IfStmt, LOG.info("Gracefully decommission " + nodeStr);
286: Junping Du, info, IfStmt, LOG.info("Recommission " + nodeStr);
452: Wangda Tan, debug, IfStmt, LOG.debug("[" + entry.getKey() + ":" + entry.getValue().ip + "] Expired after " + CachedResolver.this.expiryIntervalMs / 1000 + " secs");
495: Arun Murthy, debug, SwitchStmt, LOG.debug(eventNode + " reported unusable");
500: Junping Du, debug, SwitchStmt, LOG.debug(eventNode + " reported usable");
505: Arun Suresh, debug, SwitchStmt, LOG.debug(eventNode + " reported decommissioning");
511: Arun Murthy, error, SwitchStmt, LOG.error("Ignoring invalid eventtype " + event.getType());
521: Vinod Kumar Vavilapalli, warn, MethodDeclaration, LOG.warn("Failed to init hostsReader, disabling", ex);
645: Arun Suresh, Error, CatchClause, LOG.warn("Error readDecommissioningTimeout " + e.getMessage());
641: Arun Suresh, info, IfStmt, LOG.info("Use new decommissioningTimeoutSecs: " + defaultDecTimeoutSecs);
410: Arun Suresh, error, SwitchStmt, LOG.error("Unknown event arrived at" + "OpportunisticContainerAllocatorAMService: " + event.toString());
432: Arun Murthy, info, MethodDeclaration, LOG.info("Using Scheduler: " + schedulerClassName);
455: subru, info, MethodDeclaration, LOG.info("Using ReservationSystem: " + reservationClassName);
474: Wangda Tan, info, MethodDeclaration, LOG.info("Using SystemServiceManager: " + schedulerClassName);
550: Rohith Sharma K S, info, IfStmt, LOG.info("system metrics publisher with the timeline service V2 is " + "configured");
557: Sangjin Lee, info, IfStmt, LOG.info("TimelineServicePublisher is not configured");
755: subru, info, IfStmt, LOG.info("Initialized Reservation system");
791: Jian He, error, IfStmt, LOG.error(errMsg);
796: Jian He, info, IfStmt, LOG.info("Initialized Federation membership.");
838: Jian He, info, IfStmt, LOG.info("Epoch set for Federation: " + epoch);
819: Jian He, info, TryStmt, LOG.info("Recovery started");
826: Jian He, info, TryStmt, LOG.info("Recovery ended");
858: Bikas Saha, Error, CatchClause, LOG.error("Error closing store.", e);
869: Karthik Kambatla, error, MethodDeclaration, LOG.error("Received " + event);
881: Karthik Kambatla, fatal, SwitchStmt, LOG.fatal("State store fenced even though the resource manager " + "is not configured for high availability. Shutting down this " + "resource manager to protect the integrity of the state store.");
894: Karthik Kambatla, warn, IfStmt, LOG.warn("Ignoring state store operation failure because the " + "resource manager is not configured to fail fast. See the " + "yarn.fail-fast and yarn.resourcemanager.fail-fast " + "properties.");
888: Karthik Kambatla, fatal, IfStmt, LOG.fatal("Shutting down the resource manager because a state " + "store operation failed, and the resource manager is " + "configured to fail fast. See the yarn.fail-fast and " + "yarn.resourcemanager.fail-fast properties.");
901: Karthik Kambatla, fatal, SwitchStmt, LOG.fatal("Shutting down the resource manager.");
950: Karthik Kambatla, fatal, CatchClause, LOG.fatal("Failed to transition RM to Standby mode.", e);
943: Karthik Kambatla, info, TryStmt, LOG.info("Transitioning RM to Standby mode");
975: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error in handling event type " + event.getType() + " for application " + appID, t);
1030: Jian He, error, IfStmt, LOG.error("Event " + event.getType() + " not handled, because previousFailedAttempt is null");
1025: Jian He, Error, CatchClause, LOG.error("Error in handling event type " + event.getType() + " for applicationAttempt " + appAttemptId + " with " + previousFailedAttempt, t);
1021: Jian He, debug, TryStmt, LOG.debug("Event " + event.getType() + " handled by " + previousFailedAttempt);
1003: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error in handling event type " + event.getType() + " for applicationAttempt " + appAttemptId, t);
1056: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error in handling event type " + event.getType() + " for node " + nodeId, t);
1086: Wangda Tan, info, MethodDeclaration, LOG.info("Starting Web-server for " + name + " at: " + uri);
1165: Jian He, info, IfStmt, LOG.info("Using webapps at: " + onDiskPath);
1162: Jian He, info, IfStmt, LOG.info("Using war file at: " + onDiskPath);
1158: Jian He, error, IfStmt, LOG.error("No war file or webapps found for ui2 !");
1232: Karthik Kambatla, info, IfStmt, LOG.info("Already in active state");
1235: Karthik Kambatla, info, MethodDeclaration, LOG.info("Transitioning to active state");
1251: Karthik Kambatla, info, MethodDeclaration, LOG.info("Transitioned to active state");
1258: Karthik Kambatla, info, IfStmt, LOG.info("Already in standby state");
1262: Karthik Kambatla, info, MethodDeclaration, LOG.info("Transitioning to standby state");
1269: Karthik Kambatla, info, MethodDeclaration, LOG.info("Transitioned to standby state");
1482: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.fatal("Error starting ResourceManager", t);
1551: Karthik Kambatla, info, TryStmt, LOG.info("Deleting ResourceManager state store...");
1553: Karthik Kambatla, info, TryStmt, LOG.info("State store deleted");
1568: Wangda Tan, info, TryStmt, LOG.info("Deleting application " + removeAppId + " from state store");
1570: Wangda Tan, info, TryStmt, LOG.info("Application is deleted from state store");
280: Jian He, error, IfStmt, LOG.error("Received finished container : " + containerStatus.getContainerId() + " for unknown application " + appAttemptId.getApplicationId() + " Skipping.");
289: Xuan, debug, IfStmt, LOG.debug("Ignoring container completion status for unmanaged AM " + rmApp.getApplicationId());
297: Jian He, info, IfStmt, LOG.info("Ignoring not found attempt " + appAttemptId);
344: Jonathan Turner Eagles, info, IfStmt, LOG.info(message);
357: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(message);
369: Jian He, debug, IfStmt, LOG.debug("Resource for node: " + nid + " is adjusted from: " + capability + " to: " + dynamicLoadCapability + " due to settings in dynamic-resources.xml.");
386: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(message);
418: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Reconnect from the node at: " + host);
433: Jason Lowe, debug, SwitchStmt, LOG.debug("Unexpected Rmnode state");
408: Wangda Tan, debug, IfStmt, LOG.debug("Found the number of previous cached log aggregation " + "status from nodemanager:" + nodeId + " is :" + request.getLogAggregationReportsForApps().size());
460: Jian He, info, IfStmt, LOG.info("received container statuses on node manager register :" + request.getNMContainerStatuses());
495: Wangda Tan, info, MethodDeclaration, LOG.info(message.toString());
526: Karthik Kambatla, info, IfStmt, LOG.info(message);
536: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(message);
559: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(message);
550: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Received duplicate heartbeat from node " + rmNode.getNodeAddress() + " responseId=" + remoteNodeStatus.getResponseId());
573: Junping Du, info, IfStmt, LOG.info(message);
672: Rohith Sharma K S, debug, IfStmt, LOG.debug("Collector for applicaton: " + appId + " hasn't registered yet!");
701: Junping Du, warn, IfStmt, LOG.warn("Cannot update collector info because application ID: " + appId + " is not found in RMContext!");
748: Junping Du, info, IfStmt, LOG.info("Node not found, ignoring the unregister from node id : " + nodeId);
752: Junping Du, info, MethodDeclaration, LOG.info("Node with node id : " + nodeId + " has shutdown, hence unregistering the node.");
778: Wangda Tan, error, CatchClause, LOG.error(errorMessage, ex);
768: Wangda Tan, debug, IfStmt, LOG.debug("Node Labels {" + StringUtils.join(",", nodeLabels) + "} from Node " + nodeId + " were Accepted from RM");
460: Jian He, info, IfStmt, LOG.info("Skip allocating containers. Scheduler is waiting for recovery.");
464: Jian He, info, IfStmt, LOG.info("Scheduler recovery is done. Start allocating new containers.");
213: Arun Murthy, info, IfStmt, LOG.info(createAppSummary(app));
240: Arun Murthy, error, IfStmt, LOG.error("RMAppManager received completed appId of null, skipping");
293: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Max number of completed apps kept in state store met:" + " maxCompletedAppsInStateStore = " + maxCompletedAppsInStateStore + ", removing app " + removeApp.getApplicationId() + " from state store.");
304: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Application should be expired, max number of completed apps" + " kept in memory met: maxCompletedAppsInMemory = " + this.maxCompletedAppsInMemory + ", removing app " + removeId + " from memory: ");
339: Jason Lowe, warn, CatchClause, LOG.warn("Unable to parse credentials for " + applicationId, e);
376: Sunil G, error, CatchClause, LOG.error(msg, e);
458: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn(message);
551: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("RM app submission failed in validating AM resource request" + " for application " + submissionContext.getApplicationId(), e);
567: Arun Murthy, info, MethodDeclaration, LOG.info("Recovering " + appStates.size() + " applications");
577: Robert Kanter, info, TryStmt, LOG.info("Successfully recovered " + count + " out of " + appStates.size() + " applications");
585: Arun Murthy, debug, MethodDeclaration, LOG.debug("RMAppManager processing event for " + applicationId + " of type " + event.getType());
601: Rohith Sharma K S, warn, CatchClause, LOG.warn("Move Application has failed: " + e.getMessage());
605: Rohith Sharma K S, error, SwitchStmt, LOG.error("Invalid eventtype " + event.getType() + ". Ignoring!");
790: Rohith Sharma K S, error, CatchClause, LOG.error("Statestore update failed for move application '" + app.getApplicationId() + "' to queue '" + queue + "' with below exception:" + ex.getMessage());
809: Sunil G, error, IfStmt, LOG.error(msg);
824: Sunil G, info, IfStmt, LOG.info("Placed application=" + context.getApplicationId() + " to queue=" + placementContext.getQueue() + ", original queue=" + context.getQueue());
200: Arun Murthy, info, IfStmt, LOG.info(createSuccessLog(user, operation, target, appId, null, containerId, resource));
242: Eric Payne, info, IfStmt, LOG.info(createSuccessLog(user, operation, target, ip, args));
262: Arun Murthy, info, IfStmt, LOG.info(createSuccessLog(user, operation, target, appId, attemptId, null, null));
270: Jian He, info, IfStmt, LOG.info(createSuccessLog(user, operation, target, appId, null, null, null, callerContext, Server.getRemoteIp()));
298: Jason Lowe, info, IfStmt, LOG.info(createSuccessLog(user, operation, target, appId, null, null, null, null, ip));
318: Jason Lowe, info, IfStmt, LOG.info(createSuccessLog(user, operation, target, appId, null, null, null));
335: Jason Lowe, info, IfStmt, LOG.info(createSuccessLog(user, operation, target, null, null, null, null));
422: Arun Murthy, warn, IfStmt, LOG.warn(createFailureLog(user, operation, perm, target, description, appId, null, containerId, resource));
446: Arun Murthy, warn, IfStmt, LOG.warn(createFailureLog(user, operation, perm, target, description, appId, attemptId, null, null));
455: Jian He, warn, IfStmt, LOG.warn(createFailureLog(user, operation, perm, target, description, appId, null, null, null, callerContext));
478: Arun Murthy, warn, IfStmt, LOG.warn(createFailureLog(user, operation, perm, target, description, appId, null, null, null));
500: Arun Murthy, warn, IfStmt, LOG.warn(createFailureLog(user, operation, perm, target, description, null, null, null, null));
522: Eric Payne, warn, IfStmt, LOG.warn(createFailureLog(user, operation, perm, target, description, args));
612: Yufei Gu, warn, CatchClause, LOG.warn("Could not generate default proxy tracking URL for " + applicationId);
61: Mahadev Konar, Error, CatchClause, LOG.warn("Error registering RMNMInfo MBean", e);
63: Mahadev Konar, info, ConstructorDeclaration, LOG.info("Registered RMNMInfo MBean");
396: Bikas Saha, warn, CatchClause, LOG.warn("Couldn't get current user", ioe);
403: Bikas Saha, warn, IfStmt, LOG.warn("User " + user.getShortUserName() + " doesn't have permission" + " to call '" + method + "'");
414: Bikas Saha, trace, IfStmt, LOG.trace(method + " invoked by user " + user.getShortUserName());
135: Jian He, error, CatchClause, LOG.error(msg, e);
151: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when storing the start data of application " + wasEvent.getApplicationId());
148: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Stored the start data of application " + wasEvent.getApplicationId());
163: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when storing the finish data of application " + wafEvent.getApplicationId());
160: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Stored the finish data of application " + wafEvent.getApplicationId());
176: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when storing the start data of application attempt " + waasEvent.getApplicationAttemptId());
173: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Stored the start data of application attempt " + waasEvent.getApplicationAttemptId());
189: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when storing the finish data of application attempt " + waafEvent.getApplicationAttemptId());
186: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Stored the finish data of application attempt " + waafEvent.getApplicationAttemptId());
202: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when storing the start data of container " + wcsEvent.getContainerId());
199: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Stored the start data of container " + wcsEvent.getContainerId());
214: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error when storing the finish data of container " + wcfEvent.getContainerId());
211: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Stored the finish data of container " + wcfEvent.getContainerId());
219: Vinod Kumar Vavilapalli, error, SwitchStmt, LOG.error("Unknown WritingApplicationHistoryEvent type: " + event.getType());
109: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Setting up container " + masterContainer + " for AM " + application.getAppAttemptId());
130: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Done launching container " + masterContainer + " for AM " + application.getAppAttemptId());
307: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Launching master" + application.getAppAttemptId());
320: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.info("Error cleaning master ", ie);
327: Allen Wittenauer, Error, IfStmt, LOG.info("Error cleaning master ", e);
317: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Cleaning master " + application.getAppAttemptId());
332: Vinod Kumar Vavilapalli, warn, SwitchStmt, LOG.warn("Received unknown event-type " + eventType + ". Ignoring.");
352: Jason Lowe, info, MethodDeclaration, LOG.info(message);
103: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info(launcherHandlingThread.getName() + " interrupted during join ", ie);
122: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn(this.getClass().getName() + " interrupted. Returning.");
76: Varun Vasudev, warn, IfStmt, LOG.warn("Ignoring Blacklists, blacklist size " + currentBlacklistSize + " is more than failure threshold ratio " + blacklistDisableFailureThreshold + " out of total usable nodes " + numberOfNodeManagerHosts);
70: Karthik Kambatla, debug, IfStmt, LOG.debug("blacklist size " + currentBlacklistSize + " is less than " + "failure threshold ratio " + blacklistDisableFailureThreshold + " out of total usable nodes " + numberOfNodeManagerHosts);
73: Jian He, warn, CatchClause, LOG.warn("Exception while trying to initialize JAXB context.", e);
75: Jian He, info, ConstructorDeclaration, LOG.info("Initialized Federation membership for cluster with timestamp:  " + ResourceManager.getClusterTimeStamp());
91: Jian He, warn, CatchClause, LOG.warn("Exception while trying to generate cluster state," + " so reverting to last know state.", e);
105: Jian He, warn, CatchClause, LOG.warn("Exception when trying to heartbeat: ", e);
103: Jian He, debug, TryStmt, LOG.debug("Sending the heartbeat with capability: {}", capability);
93: Jian He, info, ConstructorDeclaration, LOG.info("FederationStateStoreService initialized");
111: Jian He, info, MethodDeclaration, LOG.info("Initialized state store client class");
123: Jian He, info, MethodDeclaration, LOG.info("Initialized federation membership service.");
146: Jian He, error, CatchClause, LOG.error("Failed to shutdown ScheduledExecutorService", e);
143: Jian He, info, IfStmt, LOG.info("Stopped federation membership heartbeat");
188: Jian He, info, TryStmt, LOG.info("Successfully registered for federation subcluster: {}", subClusterInfo);
200: Jian He, info, MethodDeclaration, LOG.info("Started federation membership heartbeat with interval: {}", heartbeatInterval);
372: Zhijie Shen, Error, CatchClause, LOG.error("Error when publishing entity [" + entity.getEntityType() + "," + entity.getEntityId() + "]", e);
366: Zhijie Shen, debug, IfStmt, LOG.debug("Publishing the entity " + entity.getEntityId() + ", JSON-style content: " + TimelineUtils.dumpTimelineRecordtoJSON(entity));
457: Zhijie Shen, Error, CatchClause, LOG.error("Error when publishing entity " + entity, e);
447: Zhijie Shen, debug, IfStmt, LOG.debug("Publishing the entity " + entity + ", JSON-style content: " + TimelineUtils.dumpTimelineRecordtoJSON(entity));
60: Wangda Tan, info, MethodDeclaration, LOG.info("Initializing SchedulingMonitor=" + getName());
68: Wangda Tan, info, MethodDeclaration, LOG.info("Starting SchedulingMonitor=" + getName());
90: Min Shen, info, IfStmt, LOG.info("Stop " + getName());
83: Wangda Tan, warn, CatchClause, LOG.warn(message);
101: Wangda Tan, warn, IfStmt, LOG.warn(message);
111: Wangda Tan, info, ForeachStmt, LOG.info("SchedulingEditPolicy=" + disabledPolicy + " removed, stopping it now ...");
146: Wangda Tan, warn, CatchClause, LOG.warn("Exception while stopping monitor=" + mon.getName(), e);
144: Wangda Tan, info, TryStmt, LOG.info("Sucessfully stopped monitor=" + mon.getName());
77: Jian He, debug, IfStmt, LOG.debug("skipping from queue=" + queueName + " because it's a non-preemptable queue");
109: Wangda Tan, debug, IfStmt, LOG.debug("Selected to preempt " + actualPreemptNeeded + " resource from partition:" + partition);
183: Wangda Tan, debug, IfStmt, LOG.debug("Queue Name:" + tq.queueName + ", partition:" + tq.partition);
185: Wangda Tan, debug, ForeachStmt, LOG.debug(tmpApp);
429: Wangda Tan, debug, IfStmt, LOG.debug("TempUser:" + tmpUser);
165: Wangda Tan, debug, IfStmt, LOG.debug("Rolling resource usage for user:" + user + " is : " + rollingResourceUsagePerUser.get(user));
184: Wangda Tan, debug, IfStmt, LOG.debug("totalPreemptedResourceAllowed for preemption at this round is :" + totalPreemptedResourceAllowed);
220: Wangda Tan, debug, IfStmt, LOG.debug("Skipping container: " + c.getContainerId() + " with resource:" + c.getAllocatedResource() + " as UserLimit for user:" + app.getUser() + " with resource usage: " + rollingUsedResourcePerUser + " is going under UL");
169: Jian He, debug, IfStmt, LOG.debug("skipping from queue=" + queueName + " because it's a non-preemptable queue");
208: Jian He, debug, IfStmt, LOG.debug("Queue=" + queueName + " partition=" + qT.partition + " resource-to-obtain=" + resToObtain);
218: Jian He, debug, IfStmt, LOG.debug(qT);
158: Christopher Douglas, info, MethodDeclaration, LOG.info("Preemption monitor:" + this.getClass().getCanonicalName());
262: Eric Payne, info, MethodDeclaration, LOG.info("Capacity Scheduler configuration changed, updated preemption " + "properties to:\n" + "max_ignored_over_capacity = " + maxIgnoredOverCapacity + "\n" + "natural_termination_factor = " + naturalTerminationFactor + "\n" + "max_wait_before_kill = " + maxWaitTime + "\n" + "monitoring_interval = " + monitoringInterval + "\n" + "total_preemption_per_round = " + percentageClusterPreemptionAllowed + "\n" + "observe_only = " + observeOnly + "\n" + "lazy-preemption-enabled = " + lazyPreempionEnabled + "\n" + "intra-queue-preemption.enabled = " + isIntraQueuePreemptionEnabled + "\n" + "intra-queue-preemption.max-allowable-limit = " + maxAllowableLimitForIntraQueuePreemption + "\n" + "intra-queue-preemption.minimum-threshold = " + minimumThresholdForIntraQueuePreemption + "\n" + "intra-queue-preemption.preemption-order-policy = " + intraQueuePreemptionOrderPolicy + "\n" + "priority-utilization.underutilized-preemption.enabled = " + isQueuePriorityPreemptionEnabled + "\n" + "select_based_on_reserved_containers = " + selectCandidatesForResevedContainers + "\n" + "additional_res_balance_based_on_reserved_containers = " + additionalPreemptionBasedOnReservedResource);
306: Jian He, debug, IfStmt, LOG.debug("Total time used=" + (clock.getTime() - startTs) + " ms.");
314: Wangda Tan, debug, IfStmt, LOG.debug("Starting to preempt containers for selectedCandidates and size:" + selectedCandidates.size());
324: Jian He, debug, IfStmt, LOG.debug("Send to scheduler: in app=" + appAttemptId + " #containers-to-be-preemptionCandidates=" + e.getValue().size());
445: Jian He, debug, IfStmt, LOG.debug(MessageFormat.format("Trying to use {0} to select preemption candidates", selector.getClass().getName()));
454: Wangda Tan, debug, IfStmt, LOG.debug(MessageFormat.format("{0} uses {1} millisecond to run", selector.getClass().getName(), clock.getTime() - startTime));
461: Wangda Tan, debug, IfStmt, LOG.debug(MessageFormat.format("So far, total {0} containers selected to be preempted", totalSelected));
607: Jian He, debug, MethodDeclaration, LOG.debug(sb.toString());
122: Sunil G, debug, IfStmt, LOG.debug("Initializing priority preemption directed graph:");
157: Sunil G, debug, IfStmt, LOG.debug("- Added priority ordering edge: " + q1 + " >> " + q2);
152: Sunil G, debug, IfStmt, LOG.debug("- Added priority ordering edge: " + q2 + " >> " + q1);
328: Wangda Tan, info, IfStmt, LOG.info("Successfully moved reserved container=" + reservedContainer.getContainerId() + " from targetNode=" + fromNode + " to targetNode=" + targetNode.getNodeID());
466: Wangda Tan, debug, IfStmt, LOG.debug("Trying to preempt following containers to make reserved " + "container=" + reservedContainer.getContainerId() + " on node=" + node.getNodeID() + " can be allocated:");
477: Wangda Tan, debug, IfStmt, LOG.debug(" --container=" + c.getContainerId() + " resource=" + c.getReservedResource());
113: Jian He, debug, IfStmt, LOG.debug(this.getClass().getName() + " Marked container=" + c.getContainerId() + " from queue=" + c.getQueueName() + " to be preemption candidates");
223: Jian He, debug, IfStmt, LOG.debug("Skip selecting AM container on host=" + node.getNodeID() + " AM container=" + c.getContainerId());
57: Chris Douglas, info, MethodDeclaration, LOG.info("Invariant checker " + this.getPolicyName() + " enabled. Monitoring every " + monitoringInterval + "ms, throwOnViolation=" + throwOnInvariantViolation);
76: Chris Douglas, warn, IfStmt, LOG.warn(message);
55: Devaraj K, error, IfStmt, LOG.error(msg);
147: Devaraj K, error, CatchClause, LOG.error("Failed to update node Labels", e);
183: Devaraj K, error, CatchClause, LOG.error("Failed to create RMNodeLabelsMappingProvider based on" + " Configuration", e);
195: Devaraj K, debug, IfStmt, LOG.debug("RM Node labels mapping provider class is : " + nodeLabelsMappingProvider.getClass().toString());
192: Devaraj K, error, IfStmt, LOG.error(msg);
181: Wangda Tan, info, IfStmt, LOG.info("No Modified Node label Mapping to replace");
243: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("This shouldn't happen, cannot get host in nodeCollection" + " associated to the node being activated");
68: Wangda Tan, info, MethodDeclaration, LOG.info("Initialized queue mappings, override: " + overrideWithQueueMappings);
183: Wangda Tan, info, IfStmt, LOG.info("Application " + applicationId + " mapping [" + queueName + "] to [" + mappedQueue + "] override " + overrideWithQueueMappings);
42: Xuan, info, MethodDeclaration, LOG.info("Using PlacementRule implementation - " + ruleClass);
78: Jian He, error, IfStmt, LOG.error(msg);
201: Jian He, info, IfStmt, LOG.info("Application " + applicationId + " user " + user + " mapping [" + queueName + "] to [" + mappedQueue + "] override " + overrideWithQueueMappings);
237: Wangda Tan, info, MethodDeclaration, LOG.info("Initialized queue mappings, override: " + overrideWithQueueMappings);
242: Arun Suresh, error, CatchClause, LOG.error("Failed to load state.", e);
288: Hitesh Shah, error, CatchClause, LOG.error("Failed to load state.", e);
286: Hitesh Shah, info, TryStmt, LOG.info("Done loading applications from FS state store");
321: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("incomplete rm state store entry found :" + record);
392: Tsuyoshi Ozawa, warn, IfStmt, LOG.warn("Unknown file for recovering RMDelegationTokenSecretManager");
388: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Loaded RMDelegationTokenIdentifier: " + identifier + " renewDate=" + renewDate);
376: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("Loaded delegation key: keyId=" + key.getKeyId() + ", expirationDate=" + key.getExpiryDate());
405: Hitesh Shah, info, MethodDeclaration, LOG.info("Storing info for app: " + appId + " at: " + nodeCreatePath);
412: Hitesh Shah, Error, CatchClause, LOG.info("Error storing info for app: " + appId, e);
423: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Updating info for app: " + appId + " at: " + nodeCreatePath);
430: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.info("Error updating info for app: " + appId, e);
443: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Storing info for attempt: " + appAttemptId + " at: " + nodeCreatePath);
451: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.info("Error storing info for attempt: " + appAttemptId, e);
464: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Updating info for attempt: " + appAttemptId + " at: " + nodeCreatePath);
472: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.info("Error updating info for attempt: " + appAttemptId, e);
484: Jian He, info, MethodDeclaration, LOG.info("Removing info for attempt: " + appAttemptId + " at: " + nodeRemovePath);
496: Hitesh Shah, info, MethodDeclaration, LOG.info("Removing info for app: " + appId + " at: " + nodeRemovePath);
512: Jian He, info, MethodDeclaration, LOG.info("Removing RMDelegationToken_" + identifier.getSequenceNumber());
535: Jian He, info, IfStmt, LOG.info("Storing RMDelegationToken_" + identifier.getSequenceNumber());
542: Zhijie Shen, info, IfStmt, LOG.info("Storing " + DELEGATION_TOKEN_SEQUENCE_NUMBER_PREFIX + identifier.getSequenceNumber());
532: Jian He, info, IfStmt, LOG.info("Updating RMDelegationToken_" + identifier.getSequenceNumber());
565: Tsuyoshi Ozawa, info, TryStmt, LOG.info("Storing RMDelegationKey_" + masterKey.getKeyId());
576: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Removing RMDelegationKey_" + masterKey.getKeyId());
741: Daniel Templeton, info, CatchClause, LOG.info("Exception while executing an FS operation.", e);
743: Tsuyoshi Ozawa, info, IfStmt, LOG.info("Maxed out FS retries. Giving up!");
746: Tsuyoshi Ozawa, info, CatchClause, LOG.info("Retrying operation on FS. Retry no. " + retry);
823: Zhijie Shen, info, IfStmt, LOG.info("File doesn't exist. Skip deleting the file " + dstPath);
867: Arun Suresh, info, MethodDeclaration, LOG.info("Storing state for reservation " + reservationIdName + " from " + "plan " + planName + " at path " + reservationPath);
878: Arun Suresh, info, MethodDeclaration, LOG.info("Removing state for reservation " + reservationIdName + " from " + "plan " + planName + " at path " + reservationPath);
962: Arun Suresh, info, IfStmt, LOG.info("Unknown child node with name: " + childNodeName);
954: Arun Suresh, debug, IfStmt, LOG.debug("Loading application attempt from node: " + childNodeName);
942: Arun Suresh, debug, IfStmt, LOG.debug("Loading application from node: " + childNodeName);
166: Jian He, info, MethodDeclaration, LOG.info("Using state database at " + storeRoot + " for recovery");
172: Jian He, info, IfStmt, LOG.info("Creating state database at " + dbfile);
297: Arun Suresh, warn, IfStmt, LOG.warn("Incorrect reservation state key " + key);
321: Arun Suresh, info, MethodDeclaration, LOG.info("Recovered " + numReservations + " reservations");
326: Jian He, info, MethodDeclaration, LOG.info("Recovered " + numKeys + " RM delegation token master keys");
328: Jian He, info, MethodDeclaration, LOG.info("Recovered " + numTokens + " RM delegation tokens");
348: Jian He, debug, IfStmt, LOG.debug("Loaded RM delegation key from " + key + ": keyId=" + masterKey.getKeyId() + ", expirationDate=" + masterKey.getExpiryDate());
394: Jian He, debug, IfStmt, LOG.debug("Loaded RM delegation token from " + key + ": tokenId=" + tokenId + ", renewDate=" + renewDate);
454: Jian He, warn, IfStmt, LOG.warn("Skipping extraneous data " + key);
468: Jian He, info, MethodDeclaration, LOG.info("Recovered " + numApps + " applications and " + numAppAttempts + " application attempts");
492: Jian He, warn, IfStmt, LOG.warn("Ignoring unknown application key: " + key);
498: Jian He, debug, IfStmt, LOG.debug("Loaded application " + appId + " with " + numAttempts + " attempts");
586: Jian He, debug, IfStmt, LOG.debug("Storing state for app " + appId + " at " + key);
607: Jian He, debug, IfStmt, LOG.debug("Storing state for attempt " + attemptId + " at " + key);
629: Jian He, debug, IfStmt, LOG.debug("Removing state for attempt " + attemptId + " at " + attemptKey);
654: Jian He, debug, IfStmt, LOG.debug("Removing state for app " + appId + " and " + appState.attempts.size() + " attempts" + " at " + appKey);
675: Arun Suresh, debug, IfStmt, LOG.debug("Storing state for reservation " + reservationIdName + " plan " + planName + " at " + key);
698: Arun Suresh, debug, IfStmt, LOG.debug("Removing state for reservation " + reservationIdName + " plan " + planName + " at " + reservationKey);
716: Jian He, debug, IfStmt, LOG.debug("Storing token to " + tokenKey);
728: Zhijie Shen, debug, IfStmt, LOG.debug("Storing " + tokenId.getSequenceNumber() + " to " + RM_DT_SEQUENCE_NUMBER_KEY);
761: Jian He, debug, IfStmt, LOG.debug("Removing token at " + tokenKey);
775: Jian He, debug, IfStmt, LOG.debug("Storing token master key to " + dbKey);
796: Jian He, debug, IfStmt, LOG.debug("Removing token master key at " + dbKey);
817: Jian He, info, MethodDeclaration, LOG.info("Deleting state database at " + root);
828: Wangda Tan, info, MethodDeclaration, LOG.info("Removing state for app " + removeAppId);
845: Jian He, info, WhileStmt, LOG.info("entry: " + asString(entry.getKey()));
862: Jian He, info, MethodDeclaration, LOG.info("Starting full compaction cycle");
866: Jian He, Error, CatchClause, LOG.error("Error compacting database", e);
869: Jian He, info, MethodDeclaration, LOG.info("Full compaction cycle completed in " + duration + " msec");
108: Jian He, info, MethodDeclaration, LOG.info("Updating final state " + appState.getState() + " for app: " + appId);
140: Jian He, info, MethodDeclaration, LOG.info("Updating final state " + attemptState.getState() + " for attempt: " + attemptState.getAttemptId());
152: Jian He, info, MethodDeclaration, LOG.info("Removing state for attempt: " + appAttemptId);
177: Vinod Kumar Vavilapalli, Error, IfStmt, LOG.info("Error storing info for RMDelegationToken: " + rmDTIdentifier, e);
185: Junping Du, info, MethodDeclaration, LOG.info("Store RMDT with sequence number " + rmDTIdentifier.getSequenceNumber());
202: Junping Du, info, MethodDeclaration, LOG.info("Remove RMDT with sequence number " + rmDTIdentifier.getSequenceNumber());
212: Junping Du, info, MethodDeclaration, LOG.info("Update RMDT with sequence number " + rmDTIdentifier.getSequenceNumber());
225: Vinod Kumar Vavilapalli, Error, IfStmt, LOG.info("Error storing info for RMDTMasterKey with keyID: " + delegationKey.getKeyId(), e);
230: Junping Du, info, MethodDeclaration, LOG.info("Store RMDT master key with key id: " + delegationKey.getKeyId() + ". Currently rmDTMasterKeyState size: " + rmDTMasterKeyState.size());
237: Junping Du, info, MethodDeclaration, LOG.info("Remove RMDT master key with key id: " + delegationKey.getKeyId());
247: Arun Suresh, info, MethodDeclaration, LOG.info("Storing reservationallocation for " + reservationIdName + " " + "for plan " + planName);
263: Arun Suresh, info, MethodDeclaration, LOG.info("Removing reservationallocation " + reservationIdName + " for plan " + planName);
215: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
223: Jian He, info, MethodDeclaration, LOG.info("Storing info for app: " + appId);
229: Jian He, Error, CatchClause, LOG.error("Error storing app: " + appId, e);
251: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
261: Jian He, info, MethodDeclaration, LOG.info("Updating info for app: " + appId);
278: Jian He, error, CatchClause, LOG.error(msg, e);
326: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
334: Jian He, info, MethodDeclaration, LOG.info("Removing info for app: " + appId);
338: Jian He, Error, CatchClause, LOG.error("Error removing app: " + appId, e);
353: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
369: Jian He, Error, CatchClause, LOG.error("Error storing appAttempt: " + attemptState.getAttemptId(), e);
361: Jian He, debug, IfStmt, LOG.debug("Storing info for attempt: " + attemptState.getAttemptId());
384: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
400: Jian He, Error, CatchClause, LOG.error("Error updating appAttempt: " + attemptState.getAttemptId(), e);
392: Jian He, debug, IfStmt, LOG.debug("Updating info for attempt: " + attemptState.getAttemptId());
415: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
425: Jian He, Error, CatchClause, LOG.error("Error While Storing RMDelegationToken and SequenceNumber ", e);
421: Jian He, info, TryStmt, LOG.info("Storing RMDelegationToken and SequenceNumber");
441: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
450: Jian He, Error, CatchClause, LOG.error("Error While Removing RMDelegationToken and SequenceNumber ", e);
447: Jian He, info, TryStmt, LOG.info("Removing RMDelegationToken and SequenceNumber");
466: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
476: Jian He, Error, CatchClause, LOG.error("Error While Updating RMDelegationToken and SequenceNumber ", e);
472: Jian He, info, TryStmt, LOG.info("Updating RMDelegationToken and SequenceNumber");
492: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
502: Jian He, Error, CatchClause, LOG.error("Error While Storing RMDTMasterKey.", e);
499: Jian He, info, TryStmt, LOG.info("Storing RMDTMasterKey.");
517: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
527: Jian He, Error, CatchClause, LOG.error("Error While Removing RMDTMasterKey.", e);
524: Jian He, info, TryStmt, LOG.info("Removing RMDTMasterKey.");
542: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
552: Jian He, Error, CatchClause, LOG.error("Error storing info for AMRMTokenSecretManager", e);
548: Jian He, info, TryStmt, LOG.info("Updating AMRMToken");
567: Arun Suresh, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
581: Arun Suresh, Error, CatchClause, LOG.error("Error while storing reservation allocation.", e);
574: Arun Suresh, info, TryStmt, LOG.info("Storing reservation allocation." + reservationEvent.getReservationIdName());
596: Arun Suresh, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
609: Arun Suresh, Error, CatchClause, LOG.error("Error while removing reservation allocation.", e);
603: Arun Suresh, info, TryStmt, LOG.info("Removing reservation allocation." + reservationEvent.getReservationIdName());
628: Jian He, error, IfStmt, LOG.error("Illegal event type: " + event.getClass());
635: Jian He, info, MethodDeclaration, LOG.info("Removing attempt " + attemptId + " from app: " + appId);
639: Jian He, Error, CatchClause, LOG.error("Error removing attempt: " + attemptId, e);
785: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Loaded RM state version info " + loadedVersion);
794: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Storing RM state version info " + getCurrentVersion());
1168: Jian He, error, CatchClause, LOG.error("Can't handle this event at current state", e);
1155: Jian He, debug, IfStmt, LOG.debug("Processing event of type " + event.getType());
1163: Jian He, info, IfStmt, LOG.info("RMStateStore state change from " + oldState + " to " + getRMStateStoreState());
1192: Junping Du, error, MethodDeclaration, LOG.error("State store operation failed ", failureCause);
33: Karthik Kambatla, info, MethodDeclaration, LOG.info("Using RMStateStore implementation - " + storeClass);
59: Robert Kanter, warn, CatchClause, LOG.warn("Recovering old formatted token");
317: Daniel Templeton, info, IfStmt, LOG.info("Invalid value " + appIdNodeSplitIndex + " for config " + YarnConfiguration.ZK_APPID_NODE_SPLIT_INDEX + " specified. " + "Resetting it to " + YarnConfiguration.DEFAULT_ZK_APPID_NODE_SPLIT_INDEX);
335: Robert Kanter, error, CatchClause, LOG.error("Invalid format for " + YarnConfiguration.ZK_RM_STATE_STORE_ROOT_NODE_ACL);
370: Robert Kanter, info, IfStmt, LOG.info("Invalid value " + delegationTokenNodeSplitIndex + " for config " + YarnConfiguration.ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX + " specified.  Resetting it to " + YarnConfiguration.DEFAULT_ZK_DELEGATION_TOKEN_NODE_SPLIT_INDEX);
419: Bikas Saha, debug, MethodDeclaration, LOG.debug(builder.toString());
529: Arun Suresh, debug, IfStmt, LOG.debug("Loading plan from znode: " + planName);
540: Arun Suresh, debug, IfStmt, LOG.debug("Loading reservation from znode: " + reservationNodePath);
564: Jian He, warn, IfStmt, LOG.warn("There is no data saved");
590: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Content of " + childNodePath + " is broken.");
603: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Loaded delegation key: keyId=" + key.getKeyId() + ", expirationDate=" + key.getExpiryDate());
648: Robert Kanter, debug, IfStmt, LOG.debug("Unknown child node with name " + childNodeName + " under" + tokenRoot);
678: Robert Kanter, debug, IfStmt, LOG.debug("Loaded RMDelegationTokenIdentifier: " + identifier + " renewDate=" + renewDate);
666: Robert Kanter, warn, IfStmt, LOG.warn("Content of " + path + " is broken.");
689: Daniel Templeton, debug, IfStmt, LOG.debug("Loading application from znode: " + appNodePath);
728: Robert Kanter, debug, IfStmt, LOG.debug("Unknown child node with name " + childNodeName + " under" + appRoot);
758: Hitesh Shah, debug, MethodDeclaration, LOG.debug("Done loading applications from ZK state store");
791: Robert Kanter, debug, IfStmt, LOG.debug("Unable to remove parent node " + parentZnode + " as it does not exist.");
808: Robert Kanter, debug, IfStmt, LOG.debug("Unable to remove app parent node " + parentZnode + " as it has children.");
801: Robert Kanter, debug, IfStmt, LOG.debug("No leaf znode exists. Removing parent node " + parentZnode);
822: Hitesh Shah, debug, IfStmt, LOG.debug("Storing info for app: " + appId + " at: " + nodeCreatePath);
831: Naganarasimha, debug, IfStmt, LOG.debug("Application state data size for " + appId + " is " + appStateData.length);
867: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Storing final state info for app: " + appId + " at: " + nodeUpdatePath);
880: Daniel Templeton, debug, IfStmt, LOG.debug("Path " + nodeUpdatePath + " for " + appId + " didn't " + "exist. Creating a new znode to update the application state.");
915: Daniel Templeton, debug, IfStmt, LOG.debug(operation + " info for attempt: " + appAttemptId + " at: " + path);
927: Daniel Templeton, debug, IfStmt, LOG.debug("Path " + path + " for " + appAttemptId + " didn't exist." + " Created a new znode to update the application attempt state.");
1008: Daniel Templeton, debug, IfStmt, LOG.debug("Removing info for app: " + removeAppId + " at: " + appIdRemovePath + " and its attempts.");
1035: Robert Kanter, debug, IfStmt, LOG.debug("Storing " + DELEGATION_TOKEN_PREFIX + rmDTIdentifier.getSequenceNumber());
1051: Robert Kanter, debug, IfStmt, LOG.debug("Storing " + dtSequenceNumberPath + ". SequenceNumber: " + rmDTIdentifier.getSequenceNumber());
1081: Jian He, debug, IfStmt, LOG.debug("Removing RMDelegationToken_" + rmDTIdentifier.getSequenceNumber());
1112: Robert Kanter, debug, IfStmt, LOG.debug("Updating " + DELEGATION_TOKEN_PREFIX + rmDTIdentifier.getSequenceNumber());
1130: Hitesh Shah, debug, IfStmt, LOG.debug("Storing RMDelegationKey_" + delegationKey.getKeyId());
1148: Hitesh Shah, debug, IfStmt, LOG.debug("Removing RMDelegationKey_" + delegationKey.getKeyId());
1189: Robert Kanter, debug, IfStmt, LOG.debug("Removing reservationallocation " + reservationIdName + " for" + " plan " + planName);
1224: Arun Suresh, debug, IfStmt, LOG.debug("Creating plan node: " + planName + " at: " + planCreatePath);
1238: Arun Suresh, debug, IfStmt, LOG.debug("Storing reservation: " + reservationIdName + " in plan:" + planName + " at: " + reservationPath);
1232: Arun Suresh, debug, IfStmt, LOG.debug("Updating reservation: " + reservationIdName + " in plan:" + planName + " at: " + reservationPath);
1295: Daniel Templeton, debug, IfStmt, LOG.debug("Unable to create app parent node " + rootNodePath + " as it already exists.");
1434: Robert Kanter, info, CatchClause, LOG.info(getName() + " thread interrupted! Exiting!");
383: Jian He, error, CatchClause, LOG.error("Failed to convert Credentials to ByteBuffer.");
404: Jian He, error, CatchClause, LOG.error("Failed to convert Credentials from ByteBuffer.");
144: subru, info, MethodDeclaration, LOG.info("Initializing Reservation system");
193: Anubhav Dhoot, info, MethodDeclaration, LOG.info("Recovered reservations for Plan: {}", planName);
198: Anubhav Dhoot, info, MethodDeclaration, LOG.info("Recovering Reservation system");
221: subru, info, MethodDeclaration, LOG.info("Refreshing Reservation system");
240: subru, warn, CatchClause, LOG.warn("Exception while trying to refresh reservable queues", e);
231: Anubhav Dhoot, warn, IfStmt, LOG.warn("Plan based on reservation queue {} already exists.", planQueueName);
253: subru, info, MethodDeclaration, LOG.info("Using PlanFollowerPolicy: " + planFollowerPolicyClassName);
384: subru, info, TryStmt, LOG.info("Allocated new reservationId: " + resId);
427: Naganarasimha, info, MethodDeclaration, LOG.info("Initialized plan {} based on reservable queue {}", plan.toString(), planQueueName);
436: Karthik Kambatla, info, MethodDeclaration, LOG.info("Using Replanner: " + plannerClassName + " for queue: " + planQueueName);
459: Karthik Kambatla, info, MethodDeclaration, LOG.info("Using Agent: " + agentClassName + " for queue: " + queueName);
483: Karthik Kambatla, info, MethodDeclaration, LOG.info("Using AdmissionPolicy: " + admissionPolicyClassName + " for queue: " + queueName);
77: Karthik Kambatla, debug, IfStmt, LOG.debug("Running plan follower edit policy for plan: " + planQueueName);
115: Anubhav Dhoot, warn, CatchClause, LOG.warn("Exception while trying to replan: {}", planQueueName, e);
147: Karthik Kambatla, warn, CatchClause, LOG.warn("Exception while trying to release default queue capacity for plan: {}", planQueueName, e);
175: Karthik Kambatla, debug, IfStmt, LOG.debug("Assigning capacity of {} to queue {} with target capacity {}", capToAssign, currResId, targetCapacity);
190: Karthik Kambatla, warn, CatchClause, LOG.warn("Exception while trying to size reservation for plan: {}", currResId, planQueueName, e);
199: Subru Krishnan, debug, IfStmt, LOG.debug("PlanFollowerEditPolicyTask: total Plan Capacity: {} " + "currReservation: {} default-queue capacity: {}", planResources, numRes, defQCap);
208: Karthik Kambatla, warn, CatchClause, LOG.warn("Exception while trying to reclaim default queue capacity for plan: {}", planQueueName, e);
216: Karthik Kambatla, error, CatchClause, LOG.error("Exception in archiving completed reservations: ", e);
218: Karthik Kambatla, info, MethodDeclaration, LOG.info("Finished iteration of plan follower edit policy for plan: " + planQueueName);
277: Karthik Kambatla, warn, CatchClause, LOG.warn("Exception while trying to expire reservation: {}", expiredReservationId, e);
274: Karthik Kambatla, info, IfStmt, LOG.info("Queue: " + expiredReservation + " removed");
271: Karthik Kambatla, info, IfStmt, LOG.info("Killing applications in queue: {}", expiredReservation);
299: Karthik Kambatla, warn, CatchClause, LOG.warn("Encountered unexpected error during migration of application: {}" + " from reservation: {}", app, expiredReservation, e);
66: subru, info, MethodDeclaration, LOG.info("Initializing Plan Follower Policy:" + this.getClass().getCanonicalName());
79: Karthik Kambatla, error, IfStmt, LOG.error("The Plan is not an PlanQueue!");
101: Karthik Kambatla, warn, CatchClause, LOG.warn("Exception while trying to activate reservation: {} for plan: {}", currResId, planQueueName, e);
105: Karthik Kambatla, warn, CatchClause, LOG.warn("Exception while trying to activate reservation: {} for plan: {}", currResId, planQueueName, e);
121: subru, warn, CatchClause, LOG.warn("Exception while trying to create default reservation queue for plan: {}", planQueueName, e);
125: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Exception while trying to create default reservation queue for " + "plan: {}", planQueueName, e);
47: Karthik Kambatla, info, MethodDeclaration, LOG.info("Initializing Plan Follower Policy:" + this.getClass().getCanonicalName());
55: Karthik Kambatla, error, IfStmt, LOG.error("The queue " + planQueueName + " cannot be found or is not a " + "ParentQueue");
334: subru, error, IfStmt, LOG.error(errMsg);
342: subru, error, IfStmt, LOG.error(errMsg);
365: subru, error, IfStmt, LOG.error("Unable to add reservation: {} to plan.", inMemReservation.getReservationId());
373: Robert Kanter, info, TryStmt, LOG.info("Successfully added reservation: {} to plan.", inMemReservation.getReservationId());
392: subru, error, IfStmt, LOG.error(errMsg);
399: subru, error, IfStmt, LOG.error("Unable to replace reservation: {} from plan.", reservation.getReservationId());
406: subru, error, CatchClause, LOG.error("Unable to update reservation: {} from plan due to {}.", reservation.getReservationId(), e.getMessage());
416: subru, info, IfStmt, LOG.info("Rollbacked update reservation: {} from plan.", reservation.getReservationId());
410: Robert Kanter, info, IfStmt, LOG.info("Successfully updated reservation: {} in plan.", reservation.getReservationId());
447: subru, error, IfStmt, LOG.error(errMsg);
437: subru, error, IfStmt, LOG.error("Unable to remove reservation: {} from plan.", reservation.getReservationId());
452: subru, info, MethodDeclaration, LOG.info("Sucessfully deleted reservation: {} in plan.", reservation.getReservationId());
465: subru, error, IfStmt, LOG.error(errMsg);
477: subru, debug, MethodDeclaration, LOG.debug("Running archival at time: {}", tick);
575: Subru Krishnan, warn, CatchClause, LOG.warn("Exception while trying to merge periodic" + " and non-periodic user allocations: {}", e.getMessage(), e);
140: Subru Krishnan, info, IfStmt, LOG.info("Cannot set capacity beyond end time: " + timePeriod + " was (" + interval.toString() + ")");
163: Subru Krishnan, info, IfStmt, LOG.info("Request to remove more resources than what is available");
169: Subru Krishnan, info, IfStmt, LOG.info("Interval extends beyond the end time " + timePeriod);
91: ccurino, info, MethodDeclaration, LOG.info("placing the following ReservationRequest: " + contract);
106: ccurino, info, CatchClause, LOG.info("OUTCOME: FAILURE, Reservation ID: " + reservationId.toString() + ", Contract: " + contract.toString());
101: ccurino, info, IfStmt, LOG.info("OUTCOME: FAILURE, Reservation ID: " + reservationId.toString() + ", Contract: " + contract.toString());
98: ccurino, info, IfStmt, LOG.info("OUTCOME: SUCCESS, Reservation ID: " + reservationId.toString() + ", Contract: " + contract.toString());
117: ccurino, info, MethodDeclaration, LOG.info("updating the following ReservationRequest: " + contract);
127: ccurino, info, MethodDeclaration, LOG.info("removing the following ReservationId: " + reservationId);
64: Arun Suresh, info, IfStmt, LOG.info("Initializing the GreedyReservationAgent to favor \"late\"" + " (right) allocations (controlled by parameter: " + FAVOR_EARLY_ALLOCATION + ")");
60: Arun Suresh, info, IfStmt, LOG.info("Initializing the GreedyReservationAgent to favor \"early\"" + " (left) allocations (controlled by parameter: " + FAVOR_EARLY_ALLOCATION + ")");
81: ccurino, info, MethodDeclaration, LOG.info("placing the following ReservationRequest: " + contract);
96: ccurino, info, CatchClause, LOG.info("OUTCOME: FAILURE, Reservation ID: " + reservationId.toString() + ", Contract: " + contract.toString());
91: ccurino, info, IfStmt, LOG.info("OUTCOME: FAILURE, Reservation ID: " + reservationId.toString() + ", Contract: " + contract.toString());
88: ccurino, info, IfStmt, LOG.info("OUTCOME: SUCCESS, Reservation ID: " + reservationId.toString() + ", Contract: " + contract.toString());
107: ccurino, info, MethodDeclaration, LOG.info("updating the following ReservationRequest: " + contract);
117: ccurino, info, MethodDeclaration, LOG.info("removing the following ReservationId: " + reservationId);
111: carlo curino, info, ForStmt, LOG.info("Removing reservation " + reservation.getReservationId() + " to repair physical-resource constraints in the plan: " + plan.getQueueName());
90: Junping Du, debug, MethodDeclaration, LOG.debug("DRConf - setVcoresPerNode: nodePrefix=" + getNodePrefix(node) + ", vcores=" + vcores);
103: Junping Du, debug, MethodDeclaration, LOG.debug("DRConf - setMemoryPerNode: nodePrefix=" + getNodePrefix(node) + ", memory=" + memory);
116: Junping Du, debug, MethodDeclaration, LOG.debug("DRConf - setOverCommitTimeoutPerNode: nodePrefix=" + getNodePrefix(node) + ", overCommitTimeout=" + overCommitTimeout);
136: Wangda Tan, info, IfStmt, LOG.info("Added profile '" + profileName + "' with resources: " + resource);
155: Wangda Tan, info, MethodDeclaration, LOG.info("Loaded profiles: " + profiles.keySet());
476: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("The specific max attempts: " + individualMaxAppAttempts + " for application: " + applicationId.getId() + " is invalid, because it is out of the range [1, " + globalMaxAppAttempts + "]. Use the global max attempts instead.");
487: Zhijie Shen, info, IfStmt, LOG.info("The attemptFailuresValidityInterval for the application: " + this.applicationId + " is " + this.attemptFailuresValidityInterval + ".");
909: Eli Collins, debug, TryStmt, LOG.debug("Processing event for " + appID + " of type " + event.getType());
916: Jason Lowe, error, CatchClause, LOG.error("App: " + appID + " can't handle this event at current state", e);
929: Robert Kanter, debug, IfStmt, LOG.debug(String.format(STATE_CHANGE_MESSAGE, appID, oldState, getState(), event.getType()));
926: Robert Kanter, info, IfStmt, LOG.info(String.format(STATE_CHANGE_MESSAGE, appID, oldState, getState(), event.getType()));
947: Robert Kanter, debug, IfStmt, LOG.debug(String.format(RECOVERY_MESSAGE, getApplicationId(), appState.getAttemptCount(), recoveredFinalState));
944: Robert Kanter, info, IfStmt, LOG.info(String.format(RECOVERY_MESSAGE, getApplicationId(), appState.getAttemptCount(), "NONE"));
1026: Arun Murthy, debug, MethodDeclaration, LOG.debug("Received node update event:" + type + " for node:" + node + " with state:" + nodeState);
1064: Haibo Chen, info, IfStmt, LOG.info("update the launch time for applicationId: " + app.getApplicationId() + ", attemptId: " + app.getCurrentAppAttempt().getAppAttemptId() + "launchTime: " + event.getTimestamp());
1134: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(msg, e);
1144: Jian He, debug, IfStmt, LOG.debug("Application " + app.applicationId + " is registered for timeout monitor, type=" + timeout.getKey() + " remaining timeout=" + (remainingTime > 0 ? remainingTime / 1000 : 0) + " seconds");
1227: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info(msg);
1279: Jian He, info, IfStmt, LOG.info("Application " + app.applicationId + " is registered for timeout monitor, type=" + ApplicationTimeoutType.LIFETIME + " value=" + applicationLifetime + " seconds");
1308: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Updating application " + this.applicationId + " with final state: " + this.targetedFinalState);
1540: Eric Payne, info, IfStmt, LOG.info("The number of failed attempts" + (app.attemptFailuresValidityInterval > 0 ? " in previous " + app.attemptFailuresValidityInterval + " milliseconds " : " ") + "is " + numberOfFailure + ". The max attempts is " + app.maxAppAttempts);
1600: Rohith Sharma K S, info, IfStmt, LOG.info("Remove attempt from state store : " + attemptId);
542: Daniel Templeton, debug, IfStmt, LOG.debug(YarnConfiguration.APP_ATTEMPT_DIAGNOSTICS_LIMIT_KC + " : " + diagnosticsLimitKC);
574: Daniel Templeton, error, CatchClause, LOG.error(message);
561: Daniel Templeton, error, IfStmt, LOG.error(message);
908: Eli Collins, debug, TryStmt, LOG.debug("Processing event for " + appAttemptID + " of type " + event.getType());
915: Jason Lowe, error, CatchClause, LOG.error("App attempt: " + appAttemptID + " can't handle this event at current state", e);
928: Robert Kanter, debug, IfStmt, LOG.debug(String.format(STATE_CHANGE_MESSAGE, appAttemptID, oldState, getAppAttemptState(), event.getType()));
925: Robert Kanter, info, IfStmt, LOG.info(String.format(STATE_CHANGE_MESSAGE, appAttemptID, oldState, getAppAttemptState(), event.getType()));
967: Robert Kanter, debug, IfStmt, LOG.debug(String.format(RECOVERY_MESSAGE, getAppAttemptId(), attemptState.getState()));
965: Robert Kanter, info, IfStmt, LOG.info(String.format(RECOVERY_MESSAGE, getAppAttemptId(), "NONE"));
1105: Robert Kanter, debug, IfStmt, LOG.debug("Setting node count for blacklist to " + numNodes);
1112: Karthik Kambatla, debug, IfStmt, LOG.debug("Using blacklist for AM: additions(" + amBlacklist.getBlacklistAdditions() + ") and removals(" + amBlacklist.getBlacklistRemovals() + ")");
1129: Sunil G, error, CatchClause, LOG.error("Could not find queue for application : ", e);
1149: Sunil G, debug, IfStmt, LOG.debug("Setting default node label expression : " + queueInfo.getDefaultNodeLabelExpression());
1234: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Interrupted while waiting to resend the" + " ContainerAllocated Event.");
1291: Wangda Tan, warn, IfStmt, LOG.warn(rmApp.getApplicationId() + " final state (" + appState + ") was recorded, but " + appAttempt.applicationAttemptId + " final state (" + appAttempt.recoveredFinalState + ") was not recorded.");
1412: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Updating application attempt " + applicationAttemptId + " with final state: " + targetedFinalState + ", and exit status: " + exitStatus);
1516: Vinod Kumar Vavilapalli, error, SwitchEntryStmt, LOG.error("Cannot get this state!! Error!!");
1980: Karthik Kambatla, warn, IfStmt, LOG.warn("No ContainerStatus in containerFinishedEvent");
2000: Zhihai Xu, info, IfStmt, LOG.info(nodeId + " is not added to AM blacklist for " + applicationAttemptId + ", because it has been removed");
91: Jian He, info, IfStmt, LOG.info(String.format("AM container preempted, " + "current appAttemptId=%s, containerId=%s, resource=%s", attemptId, container.getContainerId(), resource));
84: Jian He, info, IfStmt, LOG.info(String.format("Non-AM container preempted, current appAttemptId=%s, " + "containerId=%s, resource=%s", attemptId, container.getContainerId(), resource));
66: Jian He, info, MethodDeclaration, LOG.info("Application lifelime monitor interval set to " + monitorInterval + " ms.");
476: Karthik Kambatla, debug, IfStmt, LOG.debug("Processing " + event.getContainerId() + " of type " + event.getType());
485: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Can't handle this event at current state", e);
486: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Invalid event " + event.getType() + " on container " + this.getContainerId());
490: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(event.getContainerId() + " Container Transitioned from " + oldState + " to " + getState());
558: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("RMContainer received unexpected recover event with container" + " state " + report.getContainerState() + " while recovering.");
689: Jian He, warn, IfStmt, LOG.warn("Something wrong happened, container size reported by NM" + " is not expected, ContainerID=" + container.getContainerId() + " rm-size-resource:" + rmContainerResource + " nm-size-resource:" + nmContainerResource);
659: Eli Collins, debug, MethodDeclaration, LOG.debug("Processing " + event.getNodeId() + " of type " + event.getType());
666: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Can't handle this event at current state", e);
667: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Invalid event " + event.getType() + " on Node  " + this.nodeId + " oldState " + oldState);
671: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(nodeId + " Node Transitioned from " + oldState + " to " + getState());
705: Wangda Tan, debug, SwitchStmt, LOG.debug("Unexpected previous node state");
724: Robert Kanter, warn, SwitchStmt, LOG.warn("Unexpected initial state");
735: Junping Du, warn, SwitchStmt, LOG.warn("Unexpected final state");
759: Junping Du, warn, SwitchStmt, LOG.warn("Unexpected initial state");
779: Junping Du, warn, SwitchStmt, LOG.warn("Unexpected final state");
791: Junping Du, warn, IfStmt, LOG.warn("Cannot get RMApp by appId=" + appId + ", just added it to finishedApplications list for cleanup");
988: Jian He, warn, MethodDeclaration, LOG.warn("Try to update resource on a " + rmNode.getState().toString() + " node: " + rmNode.toString());
1077: Wangda Tan, info, MethodDeclaration, LOG.info("Deactivating Node " + rmNode.nodeId + " as it is now " + finalState);
1138: Junping Du, info, IfStmt, LOG.info(rmNode.getNodeID() + " is already DECOMMISSIONING");
1134: Junping Du, info, IfStmt, LOG.info("Update " + rmNode.getNodeID() + " DecommissioningTimeout to be " + timeout);
1142: Wangda Tan, info, MethodDeclaration, LOG.info("Put Node " + rmNode.nodeId + " in DECOMMISSIONING.");
1154: Junping Du, info, IfStmt, LOG.info("Preserve original total capability: " + rmNode.originalTotalCapability);
1175: Wangda Tan, info, MethodDeclaration, LOG.info("Node " + rmNode.nodeId + " in DECOMMISSIONING is " + "recommissioned back to RUNNING.");
1215: Wangda Tan, info, IfStmt, LOG.info("Node " + rmNode.nodeId + " reported UNHEALTHY with details: " + remoteNodeHealthStatus.getHealthReport());
1345: Jian He, info, IfStmt, LOG.info("Container " + containerId + " already scheduled for " + "cleanup, no further processing");
1354: Jian He, info, IfStmt, LOG.info("Container " + containerId + " belongs to an application that is already killed," + " no further processing");
1379: Jason Lowe, info, IfStmt, LOG.info("Container " + containerId + " already scheduled for " + "cleanup, no further processing");
1394: Ming Ma, debug, IfStmt, LOG.debug("Container " + containerId + " is the first container get launched for application " + containerAppId);
1388: Jason Lowe, info, IfStmt, LOG.info("Container " + containerId + " belongs to an application that is already killed," + " no further processing");
1461: Rohith Sharma K S, warn, IfStmt, LOG.warn(diag);
351: Jian He, info, IfStmt, LOG.info("Unknown application " + containerId.getApplicationAttemptId().getApplicationId() + " launched container " + containerId + " on node: " + node);
375: Jian He, info, IfStmt, LOG.info("Unknown application " + containerId.getApplicationAttemptId().getApplicationId() + " increased container " + containerId + " on node: " + node);
408: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Request for appInfo of unknown attempt " + appAttemptId);
421: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Request for appInfo of unknown attempt " + appAttemptId);
501: Jian He, error, IfStmt, LOG.error("Skip recovering container " + container + " for unknown application.");
509: Jian He, info, IfStmt, LOG.info("Skip recovering container  " + container + " for unknown SchedulerApplication. " + "Application current state is " + rmApp.getState());
516: Jian He, info, ForeachStmt, LOG.info("Recovering container " + container);
526: Jian He, info, IfStmt, LOG.info("Skip recovering container " + container + " for already stopped attempt.");
575: Zhijie Shen, info, IfStmt, LOG.info(container.getContainerId() + " is released by application.");
637: Devaraj K, info, MethodDeclaration, LOG.info("Release request cache is cleaned up");
667: Wangda Tan, info, IfStmt, LOG.info("Container " + containerStatus.getContainerId() + " completed with event " + event + ", but corresponding RMContainer doesn't exist.");
688: Arun Suresh, debug, IfStmt, LOG.debug("Completed container: " + rmContainer.getContainerId() + " in state: " + rmContainer.getState() + " event:" + event);
740: Zhijie Shen, info, IfStmt, LOG.info(containerId + " doesn't exist. Add the container" + " to the release request cache as it maybe on recovery.");
771: Jian He, warn, CatchClause, LOG.warn(e);
779: Jian He, warn, IfStmt, LOG.warn(errMsg);
802: Jian He, warn, IfStmt, LOG.warn(errMsg);
844: Jian He, warn, IfStmt, LOG.warn("Update resource on node: " + node.getNodeName() + " with the same resource: " + newResource);
833: Jian He, info, IfStmt, LOG.info("Update resource on node: " + node.getNodeName() + " from: " + oldResource + ", to: " + newResource);
916: Jian He, info, MethodDeclaration, LOG.info("Updated the cluste max priority to maxClusterLevelAppPriority = " + maxClusterLevelAppPriority);
959: Jian He, Error, CatchClause, LOG.warn("Error happens when checking increase request, Ignoring.." + " exception=", e);
1036: Karthik Kambatla, debug, ForeachStmt, LOG.debug("Container FINISHED: " + containerId);
1102: Karthik Kambatla, debug, IfStmt, LOG.debug("nodeUpdate: " + nm + " cluster capacity: " + getClusterResource());
1138: Sunil G, debug, IfStmt, LOG.debug("Node being looked for scheduling " + nm + " availableResource: " + schedulerNode.getUnallocatedResource());
1169: Wangda Tan, info, IfStmt, LOG.info("Promotion Update requests : " + promotionRequests);
1177: Wangda Tan, info, IfStmt, LOG.info("Resource increase requests : " + increaseRequests);
1183: Wangda Tan, info, IfStmt, LOG.info("Demotion Update requests : " + demotionRequests);
1191: Wangda Tan, info, IfStmt, LOG.info("Resource decrease requests : " + decreaseRequests);
1220: Wangda Tan, warn, IfStmt, LOG.warn("Cannot promote non-existent (or completed) Container [" + uReq.getContainerId() + "]");
1257: Wangda Tan, warn, IfStmt, LOG.warn("Cannot demote/decrease non-existent (or completed) " + "Container [" + uReq.getContainerId() + "]");
1314: Wangda Tan, info, IfStmt, LOG.info("Cannot rollback resource for container " + containerId + ". The container does not exist.");
1320: Wangda Tan, info, IfStmt, LOG.info("Cannot rollback resource for container " + containerId + ". The application that the container " + "belongs to does not exist.");
1328: Wangda Tan, info, IfStmt, LOG.info("Roll back resource for container " + containerId);
1360: Arun Suresh, info, MethodDeclaration, LOG.info("Minimum allocation = " + ret);
1372: Arun Suresh, info, MethodDeclaration, LOG.info("Maximum allocation = " + ret);
1423: Robert Kanter, warn, CatchClause, LOG.warn("Scheduler UpdateThread interrupted. Exiting.");
1426: Robert Kanter, error, CatchClause, LOG.error("Exception in scheduler UpdateThread", e);
1446: Wangda Tan, info, TryStmt, LOG.info("Reinitializing SchedulingMonitorManager ...");
70: Wangda Tan, debug, IfStmt, LOG.debug("User " + user + " added to activeUsers, currently: " + activeUsers);
99: Wangda Tan, debug, IfStmt, LOG.debug("User " + user + " removed from activeUsers, currently: " + activeUsers);
159: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Application " + applicationId + " requests cleared");
367: Wangda Tan, info, IfStmt, LOG.info("checking for deactivate of application :" + this.applicationId);
704: Sunil G, debug, IfStmt, LOG.debug("allocate: applicationId=" + applicationId + " container=" + containerAllocated.getId() + " host=" + containerAllocated.getNodeId().toString() + " user=" + user + " resource=" + containerAllocated.getResource() + " type=" + type);
160: Karthik Kambatla, warn, IfStmt, LOG.warn("Attempting to remove a non-existent node " + nodeId);
169: Arun Suresh, error, IfStmt, LOG.error("Attempting to remove node from an empty rack " + rackName);
246: Daniel Templeton, warn, IfStmt, LOG.warn(node.getNodeName() + " reported in with null resources, which " + "indicates a problem in the source code. Please file an issue at " + "https://issues.apache.org/jira/secure/CreateIssue!default.jspa");
391: Robert Kanter, info, IfStmt, LOG.info("Could not find a node matching given resourceName " + resourceName);
418: Arun Suresh, info, IfStmt, LOG.info("Could not find a node matching given resourceName " + resourceName);
45: Wangda Tan, info, MethodDeclaration, LOG.info("Using ConfigurationMutationACLPolicy implementation - " + policyClass);
91: Wangda Tan, info, IfStmt, LOG.info("The specified queue:" + queueName + " does not exist!");
97: Wangda Tan, info, MethodDeclaration, LOG.info("Need to stop the specific queue:" + queueName + " first.");
377: Jian He, info, IfStmt, LOG.info("recovered container " + id + " from previous attempt " + rmContainer.getApplicationAttemptId());
563: Zhijie Shen, debug, IfStmt, LOG.debug("Application attempt " + getApplicationAttemptId() + " reserved container " + rmContainer + " on node " + node + ". This attempt currently has " + reservedContainers.size() + " reserved containers at priority " + schedulerKey.getPriority() + "; currentReservation " + reservedResource);
659: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("showRequests:" + " application=" + getApplicationId() + " headRoom=" + getHeadroom() + " currentConsumption=" + attemptResourceUsage.getUsed().getMemorySize());
701: Jian He, Error, CatchClause, LOG.error("Error trying to assign container token and NM token to" + " an updated container " + container.getId(), e);
1219: Jian He, info, TryStmt, LOG.info("SchedulerAttempt " + getApplicationAttemptId() + " is recovering container " + rmContainer.getContainerId());
29: Wangda Tan, debug, IfStmt, log.debug("Skipping 'host' " + node.getNodeName() + " for " + application.getApplicationId() + " since it has been blacklisted");
38: Wangda Tan, debug, IfStmt, log.debug("Skipping 'rack' " + node.getRackName() + " for " + application.getApplicationId() + " since it has been blacklisted");
248: Karthik Kambatla, debug, IfStmt, LOG.debug("Released container " + container.getId() + " of capacity " + container.getResource() + " on host " + rmNode.getNodeAddress() + ", which currently has " + numContainers + " containers, " + getAllocatedResource() + " used and " + getUnallocatedResource() + " available" + ", release resources=" + true);
274: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Invalid resource addition of null resource for " + rmNode.getNodeAddress());
290: Vinod Kumar Vavilapalli, error, IfStmt, LOG.error("Invalid deduction of null resource for " + rmNode.getNodeAddress());
190: Sunil G, debug, IfStmt, LOG.debug("Requested Node Label Expression : " + labelExp);
191: Sunil G, debug, IfStmt, LOG.debug("Queue Info : " + queueInfo);
199: Sunil G, debug, IfStmt, LOG.debug("Setting default node label expression : " + queueInfo.getDefaultNodeLabelExpression());
239: Jian He, warn, IfStmt, LOG.warn(message);
96: Wangda Tan, debug, IfStmt, LOG.debug("successfully changed to " + capacity + " for queue " + this.getQueueName());
451: Wangda Tan, debug, IfStmt, LOG.debug("capacityConfigType is '" + capacityConfigType + "' for queue '" + getQueueName());
460: Wangda Tan, debug, IfStmt, LOG.debug("capacityConfigType is updated as '" + capacityConfigType + "' for queue '" + getQueueName());
500: Wangda Tan, debug, IfStmt, LOG.debug("Updating absolute resource configuration for queue:" + getQueueName() + " as minResource=" + minResource + " and maxResource=" + maxResource);
935: Sunil G, debug, IfStmt, LOG.debug("try to use reserved: " + getQueueName() + " usedResources: " + queueUsage.getUsed() + ", clusterResources: " + clusterResource + ", reservedResources: " + resourceCouldBeUnreserved + ", capacity-without-reserved: " + newTotalWithoutReservedResource + ", maxLimitCapacity: " + currentLimitResource);
949: Sunil G, debug, IfStmt, LOG.debug("Failed to assign to queue: " + getQueueName() + " nodePatrition: " + nodePartition + ", usedResources: " + queueUsage.getUsed(nodePartition) + ", clusterResources: " + clusterResource + ", reservedResources: " + resourceCouldBeUnreserved + ", maxLimitCapacity: " + currentLimitResource + ", currTotalUsed:" + usedExceptKillable);
960: Sunil G, debug, IfStmt, LOG.debug("Check assign to queue: " + getQueueName() + " nodePartition: " + nodePartition + ", usedResources: " + queueUsage.getUsed(nodePartition) + ", clusterResources: " + clusterResource + ", currentUsedCapacity: " + Resources.divide(resourceCalculator, clusterResource, queueUsage.getUsed(nodePartition), labelManager.getResourceByLabel(nodePartition, clusterResource)) + ", max-capacity: " + queueCapacities.getAbsoluteMaximumCapacity(nodePartition));
1167: Jian He, debug, IfStmt, LOG.debug("Used resource=" + queueUsage.getUsed(partition) + " exceeded maxResourceLimit of the queue =" + maxResourceLimit);
1205: Wangda Tan, info, IfStmt, LOG.info("The specified queue:" + queueName + " is already in the RUNNING state.");
83: Wangda Tan, debug, IfStmt, LOG.debug("updateChildQueues (action: add queue): " + added + " " + getChildQueuesToPrint());
110: Wangda Tan, debug, IfStmt, LOG.debug("Removed child queue: {}" + cs.getQueueName());
114: Wangda Tan, warn, IfStmt, LOG.warn("ACL configuration for '" + userPriorityACL.getMaxPriority() + "' is greater that cluster max priority. Resetting ACLs to " + clusterMaxPriority);
393: Jian He, info, TryStmt, LOG.info("Initialized CapacityScheduler with " + "calculator=" + getResourceCalculator().getClass() + ", " + "minimumAllocation=<" + getMinimumResourceCapability() + ">, " + "maximumAllocation=<" + getMaximumResourceCapability() + ">, " + "asynchronousScheduling=" + scheduleAsynchronously + ", " + "asyncScheduleInterval=" + asyncScheduleInterval + "ms");
469: Jian He, info, TryStmt, LOG.info("Re-initializing queues...");
507: Sunil G, debug, IfStmt, LOG.debug("Skip scheduling on node because it haven't heartbeated for " + timeElapsedFromLastHeartbeat / 1000.0f + " secs");
594: Wangda Tan, info, MethodDeclaration, LOG.info("AsyncScheduleThread[" + getName() + "] exited!");
632: Jian He, error, CatchClause, LOG.error(e);
636: Wangda Tan, info, MethodDeclaration, LOG.info("ResourceCommitterService exited!");
786: Jian He, Error, IfStmt, LOG.fatal(queueErrorMsg);
807: Jian He, Error, IfStmt, LOG.fatal(queueErrorMsg);
822: Jian He, info, TryStmt, LOG.info("Accepted application " + applicationId + " from user: " + user + ", in queue: " + queueName);
825: Jian He, debug, IfStmt, LOG.debug(applicationId + " is recovering. Skip notifying APP_ACCEPTED");
862: Sunil G, error, IfStmt, LOG.error("Could not auto-create leaf queue due to : ", e);
858: Sunil G, Error, IfStmt, LOG.fatal(queueErrorMsg, e);
847: Sunil G, error, IfStmt, LOG.error("Could not auto-create leaf queue " + queueName + " due to : ", e);
955: Jian He, info, CatchClause, LOG.info("Failed to submit application " + applicationId + " to queue " + queueName + " from user " + user, ace);
967: Jian He, info, TryStmt, LOG.info("Accepted application " + applicationId + " from user: " + user + ", in queue: " + queueName);
985: Jian He, warn, IfStmt, LOG.warn("Application " + applicationAttemptId.getApplicationId() + " cannot be found in scheduler.");
1013: Jian He, info, TryStmt, LOG.info("Added Application Attempt " + applicationAttemptId + " to scheduler from user " + application.getUser() + " in queue " + queue.getQueueName());
1018: Jian He, debug, IfStmt, LOG.debug(applicationAttemptId + " is recovering. Skipping notifying ATTEMPT_ADDED");
1045: Jian He, error, IfStmt, LOG.error("Cannot finish application " + "from non-leaf queue: " + queue.getQueueName());
1062: Jian He, info, TryStmt, LOG.info("Application Attempt " + applicationAttemptId + " is done." + " finalState=" + rmAppAttemptFinalState);
1070: Jian He, info, IfStmt, LOG.info("Unknown application " + applicationAttemptId + " has completed!");
1104: Jian He, error, IfStmt, LOG.error("Cannot finish application " + "from non-leaf queue: " + queueName);
1139: Jian He, error, IfStmt, LOG.error("Calling allocate on removed or non existent application " + applicationAttemptId.getApplicationId());
1150: Jian He, error, IfStmt, LOG.error("Calling allocate on previous or removed " + "or non existent application attempt " + applicationAttemptId);
1183: Jian He, debug, IfStmt, LOG.debug("allocate: pre-update " + applicationAttemptId + " ask size =" + ask.size());
1196: Wangda Tan, debug, IfStmt, LOG.debug("allocate: post-update");
1214: Sunil G, info, MethodDeclaration, LOG.info("Allocation for application " + applicationAttemptId + " : " + allocation + " with cluster resource : " + getClusterResource());
1322: Varun Saxena, warn, IfStmt, LOG.warn("There's something wrong, some RMContainers running on" + " a node, but we cannot find SchedulerApplicationAttempt " + "for it. Node=" + node.getNodeID() + " applicationAttemptId=" + rmContainer.getApplicationAttemptId());
1441: Jian He, debug, IfStmt, LOG.debug("Assigned maximum number of off-switch containers: " + offswitchCount + ", assignments so far: " + assignment);
1458: Jian He, error, IfStmt, LOG.error("Trying to schedule on a removed node, please double check.");
1472: Wangda Tan, error, IfStmt, LOG.error("Trying to schedule for a finished app, please double check.");
1477: Jian He, info, IfStmt, LOG.info("Trying to fulfill reservation for application " + reservedApplication.getApplicationId() + " on node: " + node.getNodeID());
1523: Jian He, debug, IfStmt, LOG.debug("Skipping scheduling since node " + node.getNodeID() + " is reserved by application " + node.getReservedContainer().getContainerId().getApplicationAttemptId());
1537: Jian He, debug, IfStmt, LOG.debug("This node or this node partition doesn't have available or" + "killable resource");
1544: Jian He, debug, IfStmt, LOG.debug("Trying to schedule on node: " + node.getNodeName() + ", available: " + node.getUnallocatedResource());
1587: Konstantinos Karanasos, warn, CatchClause, LOG.warn("Exception when trying to get exclusivity of node label=" + candidates.getPartition(), e);
1621: Jian He, debug, IfStmt, LOG.debug("This node or this node partition doesn't have available or" + "killable resource");
1805: Wangda Tan, error, CatchClause, LOG.error("Queue Management Change event cannot be applied for " + "parent queue : " + parentQueue.getQueueName(), sde);
1808: Wangda Tan, error, CatchClause, LOG.error("Queue Management Change event cannot be applied for " + "parent queue : " + parentQueue.getQueueName(), ioe);
1814: Vinod Kumar Vavilapalli, error, SwitchStmt, LOG.error("Invalid eventtype " + event.getType() + ". Ignoring!");
1856: Jian He, info, TryStmt, LOG.info("Added node " + nodeManager.getNodeAddress() + " clusterResource: " + clusterResource);
1881: Jian He, error, IfStmt, LOG.error("Attempting to remove non-existent node " + nodeId);
1914: Jian He, info, TryStmt, LOG.info("Removed node " + nodeInfo.getNodeAddress() + " clusterResource: " + getClusterResource());
1935: Jian He, info, IfStmt, LOG.info("Container " + container + " of" + " finished application " + appId + " completed with event " + event);
1944: Jian He, info, IfStmt, LOG.info("Container " + container + " of" + " removed node " + container.getNodeId() + " completed with event " + event);
1999: Wangda Tan, debug, IfStmt, LOG.debug(SchedulerEventType.KILL_RESERVED_CONTAINER + ":" + container.toString());
2015: Wangda Tan, debug, IfStmt, LOG.debug(SchedulerEventType.MARK_CONTAINER_FOR_PREEMPTION + ": appAttempt:" + aid.toString() + " container: " + cont.toString());
2036: Jian He, debug, IfStmt, LOG.debug(SchedulerEventType.MARK_CONTAINER_FOR_KILLABLE + ": container" + killableContainer.toString());
2072: Jian He, debug, IfStmt, LOG.debug(SchedulerEventType.MARK_CONTAINER_FOR_NONKILLABLE + ": container" + nonKillableContainer.toString());
2104: Jian He, debug, IfStmt, LOG.debug("ACL not found for queue access-type " + acl + " for queue " + queueName);
2191: Jian He, info, TryStmt, LOG.info("Removing queue: " + queueName);
2213: Wangda Tan, info, TryStmt, LOG.info("Removal of AutoCreatedLeafQueue " + queueName + " has succeeded");
2252: Wangda Tan, info, TryStmt, LOG.info("Creation of AutoCreatedLeafQueue " + newQueue + " succeeded");
2287: Wangda Tan, info, TryStmt, LOG.info("Set entitlement for AutoCreatedLeafQueue " + inQueue + "  to " + queue.getCapacity() + " request was (" + entitlement.getCapacity() + ")");
2339: Sunil G, info, TryStmt, LOG.info("App: " + appId + " successfully moved from " + sourceQueueName + " to: " + destQueueName);
2426: Jason Lowe, error, IfStmt, LOG.error("Unknown queue: " + queueName);
2430: Jason Lowe, error, IfStmt, LOG.error("queue " + queueName + " is not an leaf queue");
2480: Wangda Tan, info, IfStmt, LOG.info("Application '" + applicationId + "' is submitted without priority " + "hence considering default queue/cluster priority: " + appPriority.getPriority());
2501: Wangda Tan, info, TryStmt, LOG.info("Priority '" + appPriority.getPriority() + "' is acceptable in queue : " + queueName + " for application: " + applicationId);
2554: Wangda Tan, info, TryStmt, LOG.info("Priority '" + appPriority + "' is updated in queue :" + rmApp.getQueue() + " for application: " + applicationId + " for the user: " + rmApp.getUser());
2649: Arun Suresh, warn, IfStmt, LOG.warn("The SchedulingRequest has requested more than 1 allocation," + " but only 1 will be attempted !!");
2673: Arun Suresh, warn, CatchClause, LOG.warn("Unable to allocate container", e);
2665: Arun Suresh, debug, IfStmt, LOG.debug("Failed to allocate container for application " + appAttempt.getApplicationId() + " on node " + schedulerNode.getNodeName() + " because this allocation violates the" + " placement constraint.");
2828: Jian He, debug, IfStmt, LOG.debug("Try to commit allocation proposal=" + request);
2843: Jian He, info, IfStmt, LOG.info("Failed to accept allocation proposal");
2840: Jian He, info, IfStmt, LOG.info("Allocation proposal accepted");
2883: Wangda Tan, debug, IfStmt, LOG.debug("Trying to move container=" + toBeMovedContainer + " to node=" + targetNode.getNodeID());
2890: Wangda Tan, debug, IfStmt, LOG.debug("Failed to move reservation, cannot find source node=" + toBeMovedContainer.getNodeId());
2899: Wangda Tan, debug, IfStmt, LOG.debug("Failed to move reservation, node updated or removed, moving " + "cancelled.");
2909: Wangda Tan, debug, IfStmt, LOG.debug("Target node's reservation status changed, moving cancelled.");
2919: Wangda Tan, debug, IfStmt, LOG.debug("Cannot find to-be-moved container's application=" + toBeMovedContainer.getApplicationAttemptId());
2968: Sunil G, error, IfStmt, LOG.error("Unknown queue: " + queueName);
451: Wangda Tan, debug, MethodDeclaration, LOG.debug("CSConf - getCapacity: queuePrefix=" + getQueuePrefix(queue) + ", capacity=" + capacity);
462: Arun Murthy, debug, MethodDeclaration, LOG.debug("CSConf - setCapacity: queuePrefix=" + getQueuePrefix(queue) + ", capacity=" + capacity);
493: Arun Murthy, debug, MethodDeclaration, LOG.debug("CSConf - setMaxCapacity: queuePrefix=" + getQueuePrefix(queue) + ", maxCapacity=" + maxCapacity);
551: Arun Murthy, debug, MethodDeclaration, LOG.debug("here setUserLimit: queuePrefix=" + getQueuePrefix(queue) + ", userLimit=" + getUserLimit(queue));
608: Vinod Kumar Vavilapalli, warn, IfStmt, LOG.warn("Accessible node labels for root queue will be ignored," + " it will be automatically set to \"*\".");
655: Jian He, debug, IfStmt, LOG.debug("CSConf - getCapacityOfLabel: prefix=" + getNodeLabelPrefix(queue, label) + ", capacity=" + capacity);
817: Arun Murthy, debug, MethodDeclaration, LOG.debug("CSConf - getQueues called for: queuePrefix=" + getQueuePrefix(queue));
827: Arun Murthy, debug, MethodDeclaration, LOG.debug("CSConf - getQueues: queuePrefix=" + getQueuePrefix(queue) + ", queues=" + ((queues == null) ? "" : StringUtils.arrayToString(queues)));
834: Arun Murthy, debug, MethodDeclaration, LOG.debug("CSConf - setQueues: qPrefix=" + getQueuePrefix(queue) + ", queues=" + StringUtils.arrayToString(subQueues));
879: Jason Lowe, debug, IfStmt, LOG.debug("max alloc mb per queue for " + queue + " is " + maxAllocationMbPerQueue);
881: Jason Lowe, debug, IfStmt, LOG.debug("max alloc vcores per queue for " + queue + " is " + maxAllocationVcoresPerQueue);
886: Jason Lowe, info, IfStmt, LOG.info("max alloc mb per queue for " + queue + " is undefined");
890: Jason Lowe, info, IfStmt, LOG.info("max alloc vcore per queue for " + queue + " is undefined");
917: Jason Lowe, warn, IfStmt, LOG.warn(OFFSWITCH_PER_HEARTBEAT_LIMIT + "(" + limit + ") < 1. Using 1.");
1143: carlo curino, debug, MethodDeclaration, LOG.debug("here setReservableQueue: queuePrefix=" + getQueuePrefix(queue) + ", isReservableQueue=" + isReservable(queue));
1858: Wangda Tan, info, MethodDeclaration, LOG.info("Using Auto Created Queue Management Policy: " + queueManagementPolicyClassName + " for queue: " + queueName);
2066: Wangda Tan, debug, IfStmt, LOG.debug("CSConf - getAbsolueResourcePerQueue: prefix=" + getNodeLabelPrefix(queue, label) + ", capacity=" + resource);
163: Li Lu, info, MethodDeclaration, LOG.info("Initialized root queue " + root);
298: Li Lu, info, MethodDeclaration, LOG.info("Initialized queue: " + queue);
368: bibinchundatt, info, IfStmt, LOG.info("Converting the parent queue: " + oldQueue.getQueuePath() + " to leaf queue.");
357: Wangda Tan, info, IfStmt, LOG.info("Converting the leaf queue: " + oldQueue.getQueuePath() + " to parent queue.");
323: Wangda Tan, info, IfStmt, LOG.info("Deleting Queue " + queueName + ", as it is not" + " present in the modified capacity configuration xml");
158: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("LeafQueue:" + " name=" + queueName + ", fullname=" + getQueuePath());
289: Jian He, info, TryStmt, LOG.info("Initializing " + queueName + "\n" + "capacity = " + queueCapacities.getCapacity() + " [= (float) configuredCapacity / 100 ]" + "\n" + "absoluteCapacity = " + queueCapacities.getAbsoluteCapacity() + " [= parentAbsoluteCapacity * capacity ]" + "\n" + "maxCapacity = " + queueCapacities.getMaximumCapacity() + " [= configuredMaxCapacity ]" + "\n" + "absoluteMaxCapacity = " + queueCapacities.getAbsoluteMaximumCapacity() + " [= 1.0 maximumCapacity undefined, " + "(parentAbsoluteMaxCapacity * maximumCapacity) / 100 otherwise ]" + "\n" + "effectiveMinResource=" + getEffectiveCapacity(CommonNodeLabelsManager.NO_LABEL) + "\n" + " , effectiveMaxResource=" + getEffectiveMaxCapacity(CommonNodeLabelsManager.NO_LABEL) + "\n" + "userLimit = " + usersManager.getUserLimit() + " [= configuredUserLimit ]" + "\n" + "userLimitFactor = " + usersManager.getUserLimitFactor() + " [= configuredUserLimitFactor ]" + "\n" + "maxApplications = " + maxApplications + " [= configuredMaximumSystemApplicationsPerQueue or" + " (int)(configuredMaximumSystemApplications * absoluteCapacity)]" + "\n" + "maxApplicationsPerUser = " + maxApplicationsPerUser + " [= (int)(maxApplications * (userLimit / 100.0f) * " + "userLimitFactor) ]" + "\n" + "usedCapacity = " + queueCapacities.getUsedCapacity() + " [= usedResourcesMemory / " + "(clusterResourceMemory * absoluteCapacity)]" + "\n" + "absoluteUsedCapacity = " + absoluteUsedCapacity + " [= usedResourcesMemory / clusterResourceMemory]" + "\n" + "maxAMResourcePerQueuePercent = " + maxAMResourcePerQueuePercent + " [= configuredMaximumAMResourcePercent ]" + "\n" + "minimumAllocationFactor = " + minimumAllocationFactor + " [= (float)(maximumAllocationMemory - minimumAllocationMemory) / " + "maximumAllocationMemory ]" + "\n" + "maximumAllocation = " + maximumAllocation + " [= configuredMaxAllocation ]" + "\n" + "numContainers = " + numContainers + " [= currentNumContainers ]" + "\n" + "state = " + getState() + " [= configuredState ]" + "\n" + "acls = " + aclsString + " [= configuredAcls ]" + "\n" + "nodeLocalityDelay = " + nodeLocalityDelay + "\n" + "rackLocalityAdditionalDelay = " + rackLocalityAdditionalDelay + "\n" + "labels=" + labelStrBuilder.toString() + "\n" + "reservationsContinueLooking = " + reservationsContinueLooking + "\n" + "preemptionDisabled = " + getPreemptionDisabled() + "\n" + "defaultAppPriorityPerQueue = " + defaultAppPriorityPerQueue + "\npriority = " + priority + "\nmaxLifetime = " + maxApplicationLifetime + " seconds" + "\ndefaultLifetime = " + defaultApplicationLifetime + " seconds");
618: Rohith Sharma K S, info, CatchClause, LOG.info("Failed to submit application to parent-queue: " + getParent().getQueuePath(), ace);
634: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(msg);
644: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(msg);
654: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(msg);
664: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Failed to submit application to parent-queue: " + getParent().getQueuePath(), ace);
733: Sunil G, debug, IfStmt, LOG.debug("Effective user AM limit for \"" + userName + "\":" + preWeighteduserAMLimit + ". " + "Effective weighted user AM limit: " + userAMLimit + ". User weight: " + userWeight);
782: Sunil G, debug, IfStmt, LOG.debug("Queue: " + getQueueName() + ", node label : " + nodePartition + ", queue " + "partition " + "resource : " + queuePartitionResource + ',' + " queue current limit : " + queueCurrentLimit + "," + " queue partition usable resource : " + queuePartitionUsableResource + "," + " amResourceLimit : " + amResouceLimit);
833: Jian He, debug, IfStmt, LOG.debug("application " + application.getId() + " AMResource " + application.getAMResource(partitionName) + " maxAMResourcePerQueuePercent " + maxAMResourcePerQueuePercent + " amLimit " + amLimit + " lastClusterResource " + lastClusterResource + " amIfStarted " + amIfStarted + " AM node-partition name " + partitionName);
854: Varun Saxena, debug, IfStmt, LOG.debug("Not activating application " + applicationId + " as  amIfStarted: " + amIfStarted + " exceeds amLimit: " + amLimit);
846: Jian He, warn, IfStmt, LOG.warn("maximum-am-resource-percent is insufficient to start a" + " single application in queue, it is likely set too low." + " skipping enforcement to allow at least one application" + " to start");
890: Varun Saxena, debug, IfStmt, LOG.debug("Not activating application " + applicationId + " for user: " + user + " as userAmIfStarted: " + userAmIfStarted + " exceeds userAmLimit: " + userAMLimit);
882: Jian He, warn, IfStmt, LOG.warn("maximum-am-resource-percent is insufficient to start a" + " single application in queue for user, it is likely set too" + " low. skipping enforcement to allow at least one application" + " to start");
911: Jian He, info, ForStmt, LOG.info("Application " + applicationId + " from user: " + application.getUser() + " activated in queue: " + getQueueName());
936: Varun Saxena, info, IfStmt, LOG.info("Skipping activateApplications for " + application.getApplicationAttemptId() + " since cluster resource is " + Resources.none());
941: Jian He, info, TryStmt, LOG.info("Application added -" + " appId: " + application.getApplicationId() + " user: " + application.getUser() + "," + " leaf-queue: " + getQueueName() + " #user-pending-applications: " + user.getPendingApplications() + " #user-active-applications: " + user.getActiveApplications() + " #queue-pending-applications: " + getNumPendingApplications() + " #queue-active-applications: " + getNumActiveApplications());
1003: Jian He, info, TryStmt, LOG.info("Application removed -" + " appId: " + application.getApplicationId() + " user: " + application.getUser() + " queue: " + getQueueName() + " #user-pending-applications: " + user.getPendingApplications() + " #user-active-applications: " + user.getActiveApplications() + " #queue-pending-applications: " + getNumPendingApplications() + " #queue-active-applications: " + getNumActiveApplications());
1070: Konstantinos Karanasos, debug, IfStmt, LOG.debug("assignContainers: partition=" + candidates.getPartition() + " #applications=" + orderingPolicy.getNumSchedulableEntities());
1098: Jian He, debug, IfStmt, LOG.debug("Skip this queue=" + getQueuePath() + ", because it doesn't need more resource, schedulingMode=" + schedulingMode.name() + " node-partition=" + candidates.getPartition());
1178: Jian He, debug, IfStmt, LOG.debug("post-assignContainers for application " + application.getApplicationId());
1245: Wangda Tan, debug, IfStmt, LOG.debug("User " + username + " has been removed!");
1256: Jian He, debug, IfStmt, LOG.debug("Used resource=" + usedResource + " exceeded user-limit=" + userLimit);
1456: Wangda Tan, debug, IfStmt, LOG.debug("User " + user + " has been removed!");
1475: Wangda Tan, debug, IfStmt, LOG.debug("Headroom calculation for user " + user + ": " + " userLimit=" + userLimit + " queueMaxAvailRes=" + cachedResourceLimitsForHeadroom.getLimit() + " consumed=" + queueUser.getUsed() + " partition=" + nodePartition);
1556: Wangda Tan, debug, IfStmt, LOG.debug("User " + userName + " has been removed!");
1576: Jian He, debug, IfStmt, LOG.debug("User " + userName + " in queue " + getQueueName() + " will exceed limit based on reservations - " + " consumed: " + user.getUsed() + " reserved: " + application.getCurrentReservation() + " limit: " + limit);
1591: Jian He, debug, IfStmt, LOG.debug("User " + userName + " in queue " + getQueueName() + " will exceed limit - " + " consumed: " + user.getUsed(nodePartition) + " limit: " + limit);
1742: Wangda Tan, debug, IfStmt, LOG.debug(getQueueName() + " user=" + userName + " used=" + queueUsage.getUsed(nodePartition) + " numContainers=" + numContainers + " headroom = " + application.getHeadroom() + " user-resources=" + user.getUsed());
1782: Jian He, debug, IfStmt, LOG.debug(getQueueName() + " used=" + queueUsage.getUsed() + " numContainers=" + numContainers + " user=" + userName + " user-resources=" + user.getUsed());
2022: Jian He, info, IfStmt, LOG.info("movedContainer" + " container=" + rmContainer.getContainer() + " resource=" + rmContainer.getContainer().getResource() + " queueMoveIn=" + this + " usedCapacity=" + getUsedCapacity() + " absoluteUsedCapacity=" + getAbsoluteUsedCapacity() + " used=" + queueUsage.getUsed() + " cluster=" + clusterResource);
2041: Jian He, info, IfStmt, LOG.info("movedContainer" + " container=" + rmContainer.getContainer() + " resource=" + rmContainer.getContainer().getResource() + " queueMoveOut=" + this + " usedCapacity=" + getUsedCapacity() + " absoluteUsedCapacity=" + getAbsoluteUsedCapacity() + " used=" + queueUsage.getUsed() + " cluster=" + clusterResource);
70: Wangda Tan, Info, ConstructorDeclaration, LOG.info(queueInfo.toString());
127: Wangda Tan, error, CatchClause, LOG.error("Exception while computing policy changes for leaf queue : " + getQueueName(), ye);
125: Wangda Tan, Info, TryStmt, LOG.info(queueInfo.toString());
327: Wangda Tan, error, IfStmt, LOG.error("Queue " + getQueueName() + " is not an instance of PlanQueue or ManagedParentQueue." + " " + "Ignoring update " + queueManagementChanges);
112: Wangda Tan, info, ConstructorDeclaration, LOG.info("Initialized parent-queue " + queueName + " name=" + queueName + ", fullname=" + getQueuePath());
149: Jian He, info, TryStmt, LOG.info(queueName + ", capacity=" + this.queueCapacities.getCapacity() + ", absoluteCapacity=" + this.queueCapacities.getAbsoluteCapacity() + ", maxCapacity=" + this.queueCapacities.getMaximumCapacity() + ", absoluteMaxCapacity=" + this.queueCapacities.getAbsoluteMaximumCapacity() + ", state=" + getState() + ", acls=" + aclsString + ", labels=" + labelStrBuilder.toString() + "\n" + ", reservationsContinueLooking=" + reservationsContinueLooking + ", orderingPolicy=" + getQueueOrderingPolicyConfigName() + ", priority=" + priority);
247: Jian He, debug, IfStmt, LOG.debug("setChildQueues: " + getChildQueuesToPrint());
393: Jian He, info, IfStmt, LOG.info(getQueueName() + ": added new child queue: " + newChildQueue);
383: Jian He, info, IfStmt, LOG.info(getQueueName() + ": re-configured queue: " + childQueue);
446: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Failed to submit application to parent-queue: " + parent.getQueuePath(), ace);
492: Jian He, info, TryStmt, LOG.info("Application added -" + " appId: " + applicationId + " user: " + user + " leaf-queue of parent: " + getQueueName() + " #applications: " + getNumApplications());
520: Jian He, info, TryStmt, LOG.info("Application removed -" + " appId: " + applicationId + " user: " + user + " leaf-queue of parent: " + getQueueName() + " #applications: " + getNumApplications());
542: Jian He, debug, IfStmt, LOG.debug("Skip this queue=" + getQueuePath() + ", because it is not able to access partition=" + candidates.getPartition());
564: Jian He, debug, IfStmt, LOG.debug("Skip this queue=" + getQueuePath() + ", because it doesn't need more resource, schedulingMode=" + schedulingMode.name() + " node-partition=" + candidates.getPartition());
586: Jian He, debug, IfStmt, LOG.debug("Trying to assign containers to child-queue of " + getQueueName());
669: Jian He, info, IfStmt, LOG.info("assignedContainer" + " queue=" + getQueueName() + " usedCapacity=" + getUsedCapacity() + " absoluteUsedCapacity=" + getAbsoluteUsedCapacity() + " used=" + queueUsage.getUsed() + " cluster=" + clusterResource);
675: Jian He, debug, IfStmt, LOG.debug("ParentQ=" + getQueueName() + " assignedSoFarInThisIteration=" + assignment.getResource() + " usedCapacity=" + getUsedCapacity() + " absoluteUsedCapacity=" + getAbsoluteUsedCapacity());
775: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Trying to assign to queue: " + childQueue.getQueuePath() + " stats: " + childQueue);
787: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Assigned to queue: " + childQueue.getQueuePath() + " stats: " + childQueue + " --> " + childAssignment.getResource() + ", " + childAssignment.getType());
806: Jason Lowe, debug, IfStmt, LOG.debug("Decrease parentLimits " + parentLimits + " for " + this.getQueueName() + " by " + resourceToSubtract + " as childQueue=" + childQueue.getQueueName() + " is blocked");
833: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("printChildQueues - queue: " + getQueuePath() + " child-queues: " + getChildQueuesToPrint());
846: Jian He, debug, IfStmt, LOG.debug("completedContainer " + this + ", cluster=" + clusterResource);
1001: Wangda Tan, debug, IfStmt, LOG.debug("Updating effective min resource for queue:" + childQueue.getQueueName() + " as effMinResource=" + childQueue.getQueueResourceQuotas().getEffectiveMinResource(label) + "and Updating effective max resource as effMaxResource=" + childQueue.getQueueResourceQuotas().getEffectiveMaxResource(label));
1024: Wangda Tan, debug, IfStmt, LOG.debug("Updating min resource for Queue: " + name + " as " + ret.getResourceInformation(i) + ", Actual resource: " + nResourceInformation.getValue() + ", ratio: " + ratio.floatValue());
1106: Rohith Sharma K S, info, IfStmt, LOG.info("LeafQueue:" + leafQueue.getQueueName() + ", maxApplications=" + maxApplications + ", maxApplicationsPerUser=" + maxApplicationsPerUser + ", Abs Cap:" + childQueue.getQueueCapacities().getAbsoluteCapacity(label));
1178: Jian He, info, IfStmt, LOG.info("movedContainer" + " queueMoveIn=" + getQueueName() + " usedCapacity=" + getUsedCapacity() + " absoluteUsedCapacity=" + getAbsoluteUsedCapacity() + " used=" + queueUsage.getUsed() + " cluster=" + clusterResource);
1198: Jian He, info, IfStmt, LOG.info("movedContainer" + " queueMoveOut=" + getQueueName() + " usedCapacity=" + getUsedCapacity() + " absoluteUsedCapacity=" + getAbsoluteUsedCapacity() + " used=" + queueUsage.getUsed() + " cluster=" + clusterResource);
1292: Wangda Tan, info, IfStmt, LOG.info("Killed container=" + toKillContainer.getContainerId() + " from queue=" + lq.getQueueName() + " to make queue=" + this.getQueueName() + "'s max-capacity enforced");
1320: Jian He, info, TryStmt, LOG.info("assignedContainer" + " queue=" + getQueueName() + " usedCapacity=" + getUsedCapacity() + " absoluteUsedCapacity=" + getAbsoluteUsedCapacity() + " used=" + queueUsage.getUsed() + " cluster=" + cluster);
78: Wangda Tan, Info, ConstructorDeclaration, LOG.info(queueInfo.toString());
93: Wangda Tan, info, MethodDeclaration, LOG.info("Queue Management Policy monitor:" + this.getClass().getCanonicalName());
153: Wangda Tan, debug, IfStmt, LOG.debug("Total time used=" + (clock.getTime() - startTs) + " ms.");
231: Wangda Tan, debug, IfStmt, LOG.debug("Skipping queue management updates for parent queue " + parentQueue.getQueuePath() + " " + "since configuration for  auto creating queue's beyond " + "parent's " + "guaranteed capacity is disabled");
224: Wangda Tan, error, CatchClause, LOG.error("Could not compute child queue management updates for parent " + "queue " + parentQueue.getQueueName(), e);
193: Wangda Tan, debug, IfStmt, LOG.debug(MessageFormat.format("Trying to use {0} to compute preemption " + "candidates", policyClazz.getClass().getName()));
212: Wangda Tan, debug, IfStmt, LOG.debug(MessageFormat.format("{0} uses {1} millisecond" + " to run", policyClazz.getClass().getName(), clock.getTime() - startTime));
217: Wangda Tan, debug, IfStmt, LOG.debug(" Updated queue management updates for parent queue" + " [" + parentQueue.getQueueName() + ": [\n" + queueManagementChanges.toString() + "\n]");
523: Sunil G, debug, IfStmt, LOG.debug("userLimit is fetched. userLimit=" + userLimitResource + ", userSpecificUserLimit=" + userSpecificUserLimit + ", schedulingMode=" + schedulingMode + ", partition=" + nodePartition);
577: Sunil G, debug, IfStmt, LOG.debug("userLimit is fetched. userLimit=" + userLimitResource + ", userSpecificUserLimit=" + userSpecificUserLimit + ", schedulingMode=" + schedulingMode + ", partition=" + nodePartition);
779: Sunil G, debug, IfStmt, LOG.debug("User limit computation for " + userName + ",  in queue: " + lQueue.getQueueName() + ",  userLimitPercent=" + lQueue.getUserLimit() + ",  userLimitFactor=" + lQueue.getUserLimitFactor() + ",  required=" + required + ",  consumed=" + consumed + ",  user-limit-resource=" + userLimitResource + ",  queueCapacity=" + queueCapacity + ",  qconsumed=" + lQueue.getQueueResourceUsage().getUsed() + ",  currentCapacity=" + currentCapacity + ",  activeUsers=" + usersSummedByWeight + ",  clusterCapacity=" + clusterResource + ",  resourceByLabel=" + partitionResource + ",  usageratio=" + getUsageRatio(nodePartition) + ",  Partition=" + nodePartition + ",  resourceUsed=" + resourceUsed + ",  maxUserLimit=" + maxUserLimit + ",  userWeight=" + getUser(userName).getWeight());
852: Wangda Tan, debug, IfStmt, LOG.debug("User " + user + " added to activeUsers, currently: " + activeUsers);
883: Wangda Tan, debug, IfStmt, LOG.debug("User " + user + " removed from activeUsers, currently: " + activeUsers);
948: Wangda Tan, debug, IfStmt, LOG.debug("User '" + userName + "' has become active. Hence move user to active list." + "Active users size = " + activeUsersSet.size() + "Non-active users size = " + nonActiveUsersSet.size() + "Total Resource usage for active users=" + totalResUsageForActiveUsers.getAllUsed() + "." + "Total Resource usage for non-active users=" + totalResUsageForNonActiveUsers.getAllUsed());
988: Wangda Tan, debug, IfStmt, LOG.debug("User '" + userName + "' has become non-active.Hence move user to non-active list." + "Active users size = " + activeUsersSet.size() + "Non-active users size = " + nonActiveUsersSet.size() + "Total Resource usage for active users=" + totalResUsageForActiveUsers.getAllUsed() + "." + "Total Resource usage for non-active users=" + totalResUsageForNonActiveUsers.getAllUsed());
1010: Wangda Tan, warn, IfStmt, LOG.warn("User '" + userName + "' is not present in active/non-active. This is highly unlikely." + "We can consider this user in non-active list in this case.");
1071: Wangda Tan, debug, IfStmt, LOG.debug("User resource is updated." + "Total Resource usage for active users=" + totalResUsageForActiveUsers.getAllUsed() + "." + "Total Resource usage for non-active users=" + totalResUsageForNonActiveUsers.getAllUsed());
97: Jian He, info, IfStmt, LOG.info("Reserved container " + " application=" + application.getApplicationId() + " resource=" + allocatedResource + " queue=" + appInfo.getQueueName() + " cluster=" + clusterResource);
131: Jian He, debug, IfStmt, LOG.debug("Skip allocating AM container to app_attempt=" + application.getApplicationAttemptId() + ", don't allow to allocate AM container in non-exclusive mode");
157: Jian He, debug, IfStmt, LOG.debug("doesn't need containers based on reservation algo!");
169: Jian He, debug, IfStmt, LOG.debug("cannot allocate required resource=" + required + " because of headroom");
210: Jian He, debug, IfStmt, LOG.debug("Skip app_attempt=" + application.getApplicationAttemptId() + " priority=" + schedulerKey.getPriority() + " because missed-non-partitioned-resource-request" + " opportunity under required:" + " Now=" + missedNonPartitionedRequestSchedulingOpportunity + " required=" + rmContext.getScheduler().getNumClusterNodes());
510: Jian He, debug, IfStmt, LOG.debug("assignContainers: node=" + node.getNodeName() + " application=" + application.getApplicationId() + " priority=" + schedulerKey.getPriority() + " pendingAsk=" + pendingAsk + " type=" + type);
522: Jian He, warn, IfStmt, LOG.warn("Node : " + node.getNodeID() + " does not have sufficient resource for ask : " + pendingAsk + " node total capability : " + node.getTotalResource());
626: Jian He, debug, IfStmt, LOG.debug("we needed to unreserve to be able to allocate");
670: Jian He, debug, IfStmt, LOG.debug("needsContainers:" + " app.#re-reserve=" + application.getReReservations(schedulerKey) + " reserved=" + reservedContainers + " nodeFactor=" + nodeFactor + " minAllocFactor=" + application.getCSLeafQueue().getMinimumAllocationFactor() + " starvation=" + starvation);
739: Jian He, warn, IfStmt, LOG.warn("Couldn't get container for allocation!");
770: Jian He, debug, IfStmt, LOG.debug("Resetting scheduling opportunities");
861: Jian He, debug, IfStmt, LOG.debug("Skip app_attempt=" + application.getApplicationAttemptId() + ", because it doesn't need more resource, schedulingMode=" + schedulingMode.name() + " node-label=" + candidates.getPartition());
93: Weiwei Yang, info, MethodDeclaration, LOG.info("schedulerConfDir=" + schedulerConfPathStr);
94: Weiwei Yang, info, MethodDeclaration, LOG.info("capacity scheduler file max version = " + maxVersion);
118: Weiwei Yang, info, MethodDeclaration, LOG.info(new GsonBuilder().serializeNulls().create().toJson(logMutation));
139: Weiwei Yang, warn, IfStmt, LOG.warn("pendingMutation or tempConfigPath is null, do nothing");
155: Weiwei Yang, info, MethodDeclaration, LOG.info("finalize temp configuration file successfully, finalConfigPath=" + finalConfigPath);
162: Weiwei Yang, warn, IfStmt, LOG.warn(tempPath + " does not end with '" + TMP + "' return null");
174: Weiwei Yang, info, MethodDeclaration, LOG.info("delete temp configuration file: " + tempConfigPath);
192: Weiwei Yang, info, MethodDeclaration, LOG.info("upload conf from fileSystem took " + (Time.monotonicNow() - start) + " ms");
239: Weiwei Yang, info, CatchClause, LOG.info("write temp capacity configuration fail, schedulerConfigFile=" + tempSchedulerConfigPath, e);
235: Weiwei Yang, info, TryStmt, LOG.info("write temp capacity configuration successfully, schedulerConfigFile=" + tempSchedulerConfigPath);
243: Weiwei Yang, info, MethodDeclaration, LOG.info("write temp configuration to fileSystem took " + (Time.monotonicNow() - start) + " ms");
267: Weiwei Yang, info, ForStmt, LOG.info("delete config file " + fileStatuses[i].getPath());
138: Xuan, info, MethodDeclaration, LOG.info("Using conf database at " + storeRoot);
144: Xuan, info, IfStmt, LOG.info("Creating conf database at " + dbfile);
312: Xuan, info, MethodDeclaration, LOG.info("Starting full compaction cycle");
316: Xuan, Error, CatchClause, LOG.error("Error compacting database", e);
319: Xuan, info, MethodDeclaration, LOG.info("Full compaction cycle completed in " + duration + " msec");
159: Wangda Tan, info, MethodDeclaration, LOG.info("Loaded configuration store version info " + loadedVersion);
168: Wangda Tan, info, IfStmt, LOG.info("Storing configuration store version info " + getCurrentVersion());
43: Jonathan Hung, info, MethodDeclaration, LOG.info("Using YarnConfigurationStore implementation - " + storeClass);
193: Wangda Tan, error, CatchClause, LOG.error("Failed to retrieve configuration from zookeeper store", e);
205: Wangda Tan, error, CatchClause, LOG.error("Exception while deserializing scheduler configuration " + "from store", e);
310: Wangda Tan, info, MethodDeclaration, LOG.info("Initialized queue management policy for parent queue " + parentQueue.getQueueName() + " with leaf queue template capacities : [" + leafQueueTemplate.getQueueCapacities() + "]");
327: Sunil G, error, IfStmt, LOG.error("Invalid node label " + nodeLabel + " on configured leaf template on parent" + " queue " + parentQueue.getQueueName());
395: Sunil G, debug, IfStmt, LOG.debug("Parent queue : " + managedParentQueue.getQueueName() + ", nodeLabel = " + nodeLabel + ", absCapacity = " + parentAbsoluteCapacity + ", leafQueueAbsoluteCapacity = " + leafQueueTemplateAbsoluteCapacity + ", deactivatedCapacity = " + deactivatedCapacity + " , absChildActivatedCapacity = " + sumOfChildQueueActivatedCapacity + ", availableCapacity = " + availableCapacity);
412: Sunil G, debug, IfStmt, LOG.debug("Found " + maxLeafQueuesTobeActivated + " leaf queues" + " to be activated with " + pendingApps.size() + " apps ");
427: Sunil G, debug, IfStmt, LOG.debug("Activated leaf queues : [" + leafQueuesToBeActivated + "]");
505: Sunil G, info, IfStmt, LOG.info("Removed queue " + queue + " from leaf queue " + "state from partition " + partition);
495: Sunil G, info, IfStmt, LOG.info("Removed partition " + partition + " from leaf queue " + "state");
593: Sunil G, warn, IfStmt, LOG.warn("Could not find queue in scheduler while trying" + " to " + "deactivate for " + parentQueue);
587: Sunil G, debug, IfStmt, LOG.debug(" Leaf queue has pending applications or is " + "inactive" + " : " + leafQueue.getNumApplications() + ".Skipping deactivation for " + leafQueue);
670: Sunil G, debug, IfStmt, LOG.debug("Queue is already de-activated. Skipping " + "de-activation : " + leafQueue.getQueuePath());
661: Sunil G, debug, IfStmt, LOG.debug("Queue is already active." + " Skipping activation : " + queue.getQueuePath());
737: Wangda Tan, info, MethodDeclaration, LOG.info("Reinitialized queue management policy for parent queue " + parentQueue.getQueueName() + " with leaf queue template " + "capacities : [" + leafQueueTemplate.getQueueCapacities() + "]");
766: Sunil G, error, IfStmt, LOG.error(message);
233: Konstantinos Karanasos, warn, IfStmt, LOG.warn("Failed to get " + AppPlacementAllocator.class.getName() + " for application=" + getApplicationId() + " schedulerRequestKey=" + schedulerKey);
269: Jian He, debug, IfStmt, LOG.debug("To-release container=" + c.getRmContainer() + " is in final state");
282: Jian He, debug, IfStmt, LOG.debug("To-release container=" + r.getRmContainer() + ", for to a new allocated container, is in final state");
293: Jian He, debug, IfStmt, LOG.debug("Allocate from reserved container" + c.getAllocateFromReservedContainer().getRmContainer() + " is in final state");
308: Jian He, debug, IfStmt, LOG.debug("To-release container=" + r.getRmContainer() + ", for a reserved container, is in final state");
336: Jian He, debug, IfStmt, LOG.debug("Try to allocate from a non-existed reserved container");
346: Weiwei Yang, debug, IfStmt, LOG.debug("Try to allocate from reserved container " + allocation.getAllocateFromReservedContainer().getRmContainer().getContainerId() + ", but node is not reserved");
378: Jian He, debug, IfStmt, LOG.debug("Node doesn't have enough available resource, asked=" + allocation.getAllocatedOrReservedResource() + " available=" + availableResource);
471: Jian He, debug, IfStmt, LOG.debug("Try to reserve a container, but the node is " + "already reserved by another container=" + schedulerContainer.getSchedulerNode().getReservedContainer().getContainerId());
454: Sunil G, debug, IfStmt, LOG.debug("Try to re-reserve a container, but node " + schedulerContainer.getSchedulerNode() + " is already reserved by another container=" + schedulerContainer.getSchedulerNode().getReservedContainer());
429: Wangda Tan, debug, IfStmt, LOG.debug("No pending resource for: nodeType=" + allocation.getAllocationLocalityType() + ", node=" + schedulerContainer.getSchedulerNode() + ", requestKey=" + schedulerContainer.getSchedulerRequestKey() + ", application=" + getApplicationAttemptId());
594: Wangda Tan, debug, IfStmt, LOG.debug("allocate: applicationAttemptId=" + containerId.getApplicationAttemptId() + " container=" + containerId + " host=" + rmContainer.getAllocatedNode().getHost() + " type=" + allocation.getAllocationLocalityType());
668: Christopher Douglas, info, IfStmt, LOG.info("Application " + getApplicationId() + " unreserved " + " on node " + node + ", currently has " + reservedContainers.size() + " at priority " + schedulerKey.getPriority() + "; currentReservation " + this.attemptResourceUsage.getReserved() + " on node-label=" + node.getPartition());
791: Jian He, debug, IfStmt, LOG.debug("unreserving node with reservation size: " + reservedResource + " in order to allocate container with size: " + resourceNeedUnreserve);
865: Jian He, debug, IfStmt, LOG.debug("checked to see if could unreserve for app but nothing " + "reserved that matches for this app");
873: Jian He, error, IfStmt, LOG.error("node to unreserve doesn't exist, nodeid: " + idToUnreserve);
877: Jian He, debug, IfStmt, LOG.debug("unreserving for app: " + getApplicationId() + " on nodeId: " + idToUnreserve + " in order to replace reserved application and place it on node: " + node.getNodeID() + " needing: " + minimumUnreservedResource);
902: Jian He, debug, IfStmt, LOG.debug("pre-assignContainers for application " + getApplicationId());
1112: Wangda Tan, debug, IfStmt, LOG.debug("Failed to move reservation, two nodes are in different partition");
1123: Wangda Tan, debug, IfStmt, LOG.debug("Cannot find reserved container map.");
1131: Wangda Tan, debug, IfStmt, LOG.debug("To-be-moved container already updated.");
1141: Wangda Tan, debug, IfStmt, LOG.debug("Target node is already occupied before moving");
1150: Wangda Tan, debug, IfStmt, LOG.debug("Reserve on target node failed, e=", e);
92: Zhijie Shen, debug, IfStmt, LOG.debug("Reserved container " + container.getContainer().getId() + " on node " + this + " for application attempt " + application.getApplicationAttemptId());
85: Zhijie Shen, debug, IfStmt, LOG.debug("Updated reserved container " + container.getContainer().getId() + " on node " + this + " for application attempt " + application.getApplicationAttemptId());
169: Wangda Tan, info, MethodDeclaration, LOG.info("Assigned container " + container.getId() + " of capacity " + container.getResource() + " on host " + getRMNode().getNodeAddress() + ", which has " + getNumContainers() + " containers, " + getAllocatedResource() + " used and " + getUnallocatedResource() + " available after allocation");
122: Arun Suresh, warn, IfStmt, LOG.warn("Trying to remove tags from node/rack, however the count already" + " becomes 0 or less, it could be a potential bug.");
133: Arun Suresh, warn, IfStmt, LOG.warn("Failed to find node/rack=" + type + " while trying to remove tags, please double check.");
150: Arun Suresh, warn, IfStmt, LOG.warn("Failed to find node/rack=" + type + " while trying to remove tags, please double check.");
350: Konstantinos Karanasos, debug, IfStmt, LOG.debug("Added container=" + containerId + " with tags=[" + StringUtils.join(allocationTags, ",") + "]");
396: Konstantinos Karanasos, debug, IfStmt, LOG.debug("Removed container=" + containerId + " with tags=[" + StringUtils.join(allocationTags, ",") + "]");
89: Arun Suresh, warn, IfStmt, LOG.warn("Application {} has already been registered.", appId);
108: Arun Suresh, info, IfStmt, LOG.info("Application {} was registered, but no constraints were added.", appId);
128: Arun Suresh, info, IfStmt, LOG.info("Cannot add constraint to application {}, as it has not " + "been registered yet.", appId);
174: Arun Suresh, info, IfStmt, LOG.info("Constraint {} will not be added. There is already a " + "constraint associated with tag {}.", placementConstraint, sourceTag);
169: Arun Suresh, info, IfStmt, LOG.info("Replacing the constraint associated with tag {} with {}.", sourceTag, placementConstraint);
188: Wangda Tan, debug, IfStmt, LOG.debug("Application {} is not registered in the Placement " + "Constraint Manager.", appId);
219: Wangda Tan, debug, IfStmt, LOG.debug("Application {} is not registered in the Placement " + "Constraint Manager.", appId);
70: Arun Suresh, warn, IfStmt, LOG.warn("A placement constraint cannot be associated with an empty " + "set of tags.");
75: Arun Suresh, warn, IfStmt, LOG.warn("Only a single tag can be associated with a placement " + "constraint currently.");
141: Arun Suresh, warn, IfStmt, LOG.warn("No nodes available for placement at the moment !!");
179: Arun Suresh, warn, CatchClause, LOG.warn("Got exception from TagManager !", e);
261: Arun Suresh, warn, CatchClause, LOG.warn("Got exception from TagManager !", e);
65: Konstantinos Karanasos, debug, IfStmt, LOG.debug("Added TEMP container with tags=[" + StringUtils.join(allocationTags, ",") + "]");
113: Konstantinos Karanasos, debug, IfStmt, LOG.debug("Removed TEMP containers of app=" + applicationId);
80: Konstantinos Karanasos, info, IfStmt, LOG.info("Constraints added for application [{}] against tags [{}]", applicationId, appPlacementConstraints);
54: Konstantinos Karanasos, warn, IfStmt, LOG.warn(message);
72: Konstantinos Karanasos, warn, IfStmt, LOG.warn(message);
103: Arun Suresh, info, MethodDeclaration, LOG.info("Initializing Constraint Placement Processor:");
119: Arun Suresh, info, MethodDeclaration, LOG.info("Placement Algorithm [{}]", algorithm.getClass().getName());
124: Arun Suresh, info, MethodDeclaration, LOG.info("Placement Algorithm Iterator[{}]", iteratorName);
138: Arun Suresh, info, MethodDeclaration, LOG.info("Planning Algorithm pool size [{}]", algoPSize);
144: Arun Suresh, info, MethodDeclaration, LOG.info("Scheduler pool size [{}]", schedPSize);
152: Arun Suresh, info, MethodDeclaration, LOG.info("Num retry attempts [{}]", this.retryAttempts);
223: Arun Suresh, warn, IfStmt, LOG.warn("Unsuccessful allocation attempt [{}] for [{}]", placedReq.getPlacementAttempt(), sReqClone);
241: Arun Suresh, warn, IfStmt, LOG.warn("Following requests of [{}] were rejected by" + " the PlacementAlgorithmOutput Algorithm: {}", appAttemptId.getApplicationId(), rejectedAlgoRequests);
262: Arun Suresh, warn, SynchronizedStmt, LOG.warn("Following requests of [{}] exhausted all retry attempts " + "trying to schedule on placed node: {}", appAttemptId.getApplicationId(), rejectedRequests);
303: Arun Suresh, warn, IfStmt, LOG.warn("Not retrying request for application [{}] after [{}]" + " attempts: [{}]", schedulerResponse.getApplicationId(), placementAttempt, schedulerResponse.getSchedulingRequest());
298: Arun Suresh, warn, IfStmt, LOG.warn("Going to retry request for application [{}] after [{}]" + " attempts: [{}]", schedulerResponse.getApplicationId(), placementAttempt, schedulerResponse.getSchedulingRequest());
57: Arun Suresh, info, MethodDeclaration, LOG.info("Initializing Constraint Placement Planner:");
66: Arun Suresh, debug, LambdaExpr, LOG.debug("Got [{}] requests to place from application [{}].. " + "Attempt count [{}]", batchedRequests.getSchedulingRequests().size(), batchedRequests.getApplicationId(), batchedRequests.getPlacementAttempt());
122: Arun Suresh, debug, SynchronizedStmt, LOG.debug("Planning Algorithm has placed for application [{}]" + " the following [{}]", placement.getApplicationId(), placement.getPlacedRequests());
136: Arun Suresh, warn, IfStmt, LOG.warn("Planning Algorithm has rejected for application [{}]" + " the following [{}]", placement.getApplicationId(), placement.getRejectedRequests());
49: Konstantinos Karanasos, warn, IfStmt, LOG.warn(message);
133: Arun Suresh, warn, CatchClause, LOG.warn("Got Exception while sorting nodes..", ex);
186: Arun Suresh, debug, IfStmt, LOG.debug("Node added event from: " + rmNode.getNode().getName());
194: Arun Suresh, debug, MethodDeclaration, LOG.debug("Node delete event for: " + removedRMNode.getNode().getName());
207: Arun Suresh, debug, IfStmt, LOG.debug("Node not in list!");
205: Arun Suresh, debug, IfStmt, LOG.debug("Delete ClusterNode: " + removedRMNode.getNodeID());
214: Arun Suresh, debug, MethodDeclaration, LOG.debug("Node update event from: " + rmNode.getNodeID());
262: Arun Suresh, info, IfStmt, LOG.info("Deleting ClusterNode [" + rmNode.getNodeID() + "] " + "with queue wait time [" + currentNode.queueWaitTime + "] and " + "wait queue length [" + currentNode.queueLength + "]");
256: Arun Suresh, debug, IfStmt, LOG.debug("Updating ClusterNode [" + rmNode.getNodeID() + "] " + "with queue wait time [" + estimatedQueueWaitTime + "] and " + "wait queue length [" + waitQueueLength + "]");
244: Arun Suresh, warn, IfStmt, LOG.warn("IGNORING ClusterNode [" + rmNode.getNodeID() + "] " + "with queue wait time [" + estimatedQueueWaitTime + "] and " + "wait queue length [" + waitQueueLength + "]");
240: Arun Suresh, info, IfStmt, LOG.info("Inserting ClusterNode [" + rmNode.getNodeID() + "] " + "with queue wait time [" + estimatedQueueWaitTime + "] and " + "wait queue length [" + waitQueueLength + "]");
274: Arun Suresh, debug, MethodDeclaration, LOG.debug("Node resource update event from: " + rmNode.getNodeID());
140: Robert Kanter, info, CatchClause, LOG.info("Exception while loading allocation file: " + e);
133: Karthik Kambatla, warn, IfStmt, LOG.warn("Failed to reload fair scheduler config file because" + " last modified returned 0. File exists: " + fs.exists(allocFile));
126: Karthik Kambatla, error, IfStmt, LOG.error("Failed to reload fair scheduler config file - " + "will use existing allocations.", ex);
145: Robert Kanter, info, CatchClause, LOG.info("Interrupted while waiting to reload alloc configuration");
172: Karthik Kambatla, warn, CatchClause, LOG.warn("reloadThread fails to join.");
196: Sanford Ryza, warn, IfStmt, LOG.warn(allocFilePath + " not found on the classpath.");
230: Sanford Ryza, info, MethodDeclaration, LOG.info("Loading allocation file " + allocFile);
303: Karthik Kambatla, warn, CatchClause, LOG.warn("Continuous scheduling thread interrupted. Exiting.", e);
316: Haibo Chen, debug, MethodDeclaration, STATE_DUMP_LOG.debug("FairScheduler state: Cluster Capacity: " + clusterResource + "  Allocations: " + rootMetrics.getAllocatedResources() + "  Availability: " + Resource.newInstance(rootMetrics.getAvailableMB(), rootMetrics.getAvailableVirtualCores()) + "  Demand: " + rootQueue.getDemand());
324: Ray Chiang, debug, MethodDeclaration, STATE_DUMP_LOG.debug(rootQueue.dumpState());
452: Alejandro Abdelnur, info, IfStmt, LOG.info(message);
464: Sandy Ryza, info, IfStmt, LOG.info(message);
488: Jian He, info, IfStmt, LOG.info(msg);
499: Miklos Szegedi, info, TryStmt, LOG.info("Accepted application " + applicationId + " from user: " + user + ", in queue: " + queue.getName() + ", currently num of applications: " + applications.size());
504: Jian He, debug, IfStmt, LOG.debug(applicationId + " is recovering. Skip notifying APP_ACCEPTED");
555: Jian He, info, TryStmt, LOG.info("Added Application Attempt " + applicationAttemptId + " to scheduler from user: " + user);
560: Jian He, debug, IfStmt, LOG.debug(applicationAttemptId + " is recovering. Skipping notifying ATTEMPT_ADDED");
607: Karthik Kambatla, error, IfStmt, LOG.error(appRejectMsg);
617: Karthik Kambatla, error, IfStmt, LOG.error("Couldn't find RM app to set queue name on");
627: Jian He, warn, IfStmt, LOG.warn("Couldn't find application " + applicationId);
638: Daniel Templeton, info, TryStmt, LOG.info("Application " + applicationAttemptId + " is done. finalState=" + rmAppAttemptFinalState);
643: Jian He, info, IfStmt, LOG.info("Unknown application " + applicationAttemptId + " has completed!");
650: Daniel Templeton, info, IfStmt, LOG.info("Application " + applicationAttemptId + " has already been " + "stopped!");
713: Ray Chiang, info, IfStmt, LOG.info("Container " + container + " of finished application " + appId + " completed with event " + event);
734: Ray Chiang, debug, IfStmt, LOG.debug("Skipping container release on removed node: " + nodeID);
727: Ray Chiang, debug, IfStmt, LOG.debug("Skipping unreserve on removed node: " + nodeID);
740: Jian He, debug, IfStmt, LOG.debug("Application attempt " + application.getApplicationAttemptId() + " released container " + container.getId() + " on node: " + (node == null ? nodeID : node) + " with event: " + event);
762: Jian He, info, TryStmt, LOG.info("Added node " + node.getNodeAddress() + " cluster capacity: " + clusterResource);
778: Jian He, error, IfStmt, LOG.error("Attempting to remove non-existent node " + nodeId);
806: Jian He, info, TryStmt, LOG.info("Removed node " + rmNode.getNodeAddress() + " cluster capacity: " + clusterResource);
828: Haibo Chen, info, MethodDeclaration, LOG.info("Killing container " + container);
841: Jian He, error, IfStmt, LOG.error("Calling allocate on removed or non existent application " + appAttemptId.getApplicationId());
852: Jian He, error, IfStmt, LOG.error("Calling allocate on previous or removed " + "or non existent application attempt " + appAttemptId);
876: Jian He, debug, IfStmt, LOG.debug("allocate: pre-update" + " applicationAttemptId=" + appAttemptId + " application=" + application.getApplicationId());
895: Jian He, debug, IfStmt, LOG.debug("allocate: post-update" + " applicationAttemptId=" + appAttemptId + " #ask=" + ask.size() + " reservation= " + application.getCurrentReservation());
900: Karthik Kambatla, debug, IfStmt, LOG.debug("Preempting " + preemptionContainerIds.size() + " container(s)");
958: Karthik Kambatla, Error, CatchClause, LOG.error("Error while attempting scheduling for node " + node + ": " + ex.toString(), ex);
1230: Alejandro Abdelnur, error, SwitchStmt, LOG.error("Unknown event arrived at FairScheduler: " + event.toString());
1327: Karthik Kambatla, warn, IfStmt, LOG.warn(FairSchedulerConfiguration.UPDATE_INTERVAL_MS + " is invalid, so using default value " + FairSchedulerConfiguration.DEFAULT_UPDATE_INTERVAL_MS + " ms instead");
1348: Yufei Gu, warn, IfStmt, LOG.warn("Continuous scheduling is turned ON. It is deprecated " + "because it can cause scheduler slowness due to locking issues. " + "Schedulers should use assignmultiple as a replacement.");
1458: Karthik Kambatla, error, CatchClause, LOG.error("Failed to reload allocations file", e);
1497: Jian He, debug, IfStmt, LOG.debug("ACL not found for queue access-type " + acl + " for queue " + queueName);
1613: Daniel Templeton, info, IfStmt, LOG.info("Application " + appId + " is stopped and can't be moved!");
271: Robert Kanter, warn, IfStmt, LOG.warn("Configuration " + overridingKey + "=" + get(overridingKey) + " is overriding the " + RM_SCHEDULER_INCREMENT_ALLOCATION_MB + "=" + get(RM_SCHEDULER_INCREMENT_ALLOCATION_MB) + " property");
286: Robert Kanter, warn, IfStmt, LOG.warn("Configuration " + overridingKey + "=" + get(overridingKey) + " is overriding the " + RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES + "=" + get(RM_SCHEDULER_INCREMENT_ALLOCATION_VCORES) + " property");
141: Karthik Kambatla, info, IfStmt, LOG.info("Additional complete request on completed container " + rmContainer.getContainerId());
153: Jian He, debug, IfStmt, LOG.debug("Completed container: " + rmContainer.getContainerId() + " in state: " + rmContainer.getState() + " event:" + event);
199: Jian He, info, TryStmt, LOG.info("Application " + getApplicationId() + " unreserved " + " on node " + node + ", currently has " + reservedContainers.size() + " at priority " + schedulerKey.getPriority() + "; currentReservation " + this.attemptResourceUsage.getReserved());
249: Karthik Kambatla, debug, IfStmt, LOG.debug("Headroom calculation for " + this.getName() + ":" + "Min(" + "(queueFairShare=" + queueFairShare + " - queueUsage=" + queueUsage + ")," + " maxAvailableResource=" + maxAvailableResource + "Headroom=" + headroom);
322: Daniel Templeton, trace, IfStmt, LOG.trace("SchedulingOpportunities: " + schedulingOpportunities + ", rackLocalityThreshold: " + thresholdNum + ", change allowedLocality from RACK_LOCAL to OFF_SWITCH" + ", priority: " + schedulerKey.getPriority() + ", app attempt id: " + this.attemptId);
312: Daniel Templeton, trace, IfStmt, LOG.trace("SchedulingOpportunities: " + schedulingOpportunities + ", nodeLocalityThreshold: " + thresholdNum + ", change allowedLocality from NODE_LOCAL to RACK_LOCAL" + ", priority: " + schedulerKey.getPriority() + ", app attempt id: " + this.attemptId);
365: Jian He, debug, IfStmt, LOG.debug("Init the lastScheduledContainer time, priority: " + schedulerKey.getPriority() + ", time: " + currentTimeMs);
405: Daniel Templeton, trace, IfStmt, LOG.trace("Waiting time: " + waitTime + " ms, nodeLocalityDelay time: " + nodeLocalityDelayMs + " ms" + ", change allowedLocality from RACK_LOCAL to OFF_SWITCH" + ", priority: " + schedulerKey.getPriority() + ", app attempt id: " + this.attemptId);
395: Daniel Templeton, trace, IfStmt, LOG.trace("Waiting time: " + waitTime + " ms, nodeLocalityDelay time: " + nodeLocalityDelayMs + " ms" + ", change allowedLocality from NODE_LOCAL to RACK_LOCAL" + ", priority: " + schedulerKey.getPriority() + ", app attempt id: " + this.attemptId);
477: Jian He, debug, IfStmt, LOG.debug("allocate: applicationAttemptId=" + container.getId().getApplicationAttemptId() + " container=" + container.getId() + " host=" + container.getNodeId().getHost() + " type=" + type);
508: Jian He, info, MethodDeclaration, LOG.info("Raising locality level from " + old + " to " + level + " at " + " priority " + schedulerKey.getPriority());
601: Daniel Templeton, error, IfStmt, LOG.error("Looking to preempt container " + container + ". Container does not belong to app " + getApplicationId());
706: Arun Suresh, info, IfStmt, LOG.info("Making reservation: node=" + node.getNodeName() + " app_id=" + getApplicationId());
745: Arun Suresh, debug, IfStmt, LOG.debug("Reservation Exceeds Allowed number of nodes:" + " app_id=" + getApplicationId() + " existingReservations=" + existingReservations + " totalAvailableNodes=" + totalAvailNodes + " reservableNodesRatio=" + df.format(scheduler.getReservableNodesRatio()) + " numAllowedReservations=" + numAllowedReservations);
894: Ray Chiang, debug, IfStmt, LOG.debug("Resource request: " + capability + " exceeds the available" + " resources of the node.");
915: Ray Chiang, debug, IfStmt, LOG.debug("Couldn't create reservation for app:  " + getName() + ", at priority " + schedulerKey.getPriority());
908: Ray Chiang, debug, IfStmt, LOG.debug(getName() + "'s resource request is reserved.");
949: Daniel Templeton, trace, IfStmt, LOG.trace("Node offered to app: " + getName() + " reserved: " + reserved);
984: Karthik Kambatla, warn, IfStmt, LOG.warn("Relax locality off is not supported on local request: " + nodeLocalPendingAsk);
1004: Daniel Templeton, trace, IfStmt, LOG.trace("Assign container on " + node.getNodeName() + " node, assignType: NODE_LOCAL" + ", allowedLocality: " + allowedLocality + ", priority: " + schedulerKey.getPriority() + ", app attempt id: " + this.attemptId);
1021: Daniel Templeton, trace, IfStmt, LOG.trace("Assign container on " + node.getNodeName() + " node, assignType: RACK_LOCAL" + ", allowedLocality: " + allowedLocality + ", priority: " + schedulerKey.getPriority() + ", app attempt id: " + this.attemptId);
1040: Daniel Templeton, trace, IfStmt, LOG.trace("Assign container on " + node.getNodeName() + " node, assignType: OFF_SWITCH" + ", allowedLocality: " + allowedLocality + ", priority: " + schedulerKey.getPriority() + ", app attempt id: " + this.attemptId);
1052: Daniel Templeton, trace, IfStmt, LOG.trace("Can't assign container on " + node.getNodeName() + " node, allowedLocality: " + allowedLocality + ", priority: " + schedulerKey.getPriority() + ", app attempt id: " + this.attemptId);
1131: Karthik Kambatla, info, IfStmt, LOG.info("Releasing reservation that cannot be satisfied for " + "application " + getApplicationAttemptId() + " on node " + node);
1139: Karthik Kambatla, debug, IfStmt, LOG.debug("Trying to fulfill reservation for application " + getApplicationAttemptId() + " on node: " + node);
1375: Ray Chiang, debug, IfStmt, LOG.debug("AM resource request: " + amAsk.getPerAllocationResource() + " exceeds maximum AM resource allowed, " + getQueue().dumpState());
322: Thomas White, debug, IfStmt, LOG.debug("The updated demand for " + getName() + " is " + demand + "; the max is " + getMaxShare());
324: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("The updated fairshare for " + getName() + " is " + getFairShare());
333: Karthik Kambatla, debug, IfStmt, LOG.debug("Node " + node.getNodeName() + " offered to queue: " + getName() + " fairShare: " + getFairShare());
348: Karthik Kambatla, debug, IfStmt, LOG.debug("Assigned container in queue:" + getName() + " " + "container:" + assigned);
133: Karthik Kambatla, debug, IfStmt, LOG.debug("Counting resource from " + childQueue.getName() + " " + toAdd + "; Total resource demand for " + getName() + " now " + demand);
144: Thomas White, debug, IfStmt, LOG.debug("The updated demand for " + getName() + " is " + demand + "; the max is " + getMaxShare());
87: Daniel Templeton, info, CatchClause, LOG.info("Preemption thread interrupted! Exiting.");
143: Yufei Gu, info, ForeachStmt, LOG.info("Preempting container " + container + " from queue " + app.getQueueName());
256: Daniel Templeton, info, ForeachStmt, LOG.info("Killing container " + container);
173: Yufei Gu, warn, IfStmt, LOG.warn(String.format("Queue %s has max resources %s less than " + "min resources %s", getName(), maxResource, minShare));
293: Tsuyoshi Ozawa, debug, IfStmt, LOG.debug("The updated fairShare for " + getName() + " is " + fairShare);
430: Ray Chiang, debug, IfStmt, LOG.debug("Assigning container failed on node '" + node.getNodeName() + " because queue resource usage is larger than MaxShare: " + dumpState());
424: Ray Chiang, debug, IfStmt, LOG.debug("Assigning container failed on node '" + node.getNodeName() + " because it has reserved containers.");
527: Ray Chiang, debug, IfStmt, LOG.debug("Resource usage plus resource request: " + usagePlusAddition + " exceeds maximum resource allowed:" + getMaxShare() + " in queue " + getName());
117: Devaraj K, info, IfStmt, LOG.info("Reserved container " + container.getContainer().getId() + " on node " + this + " for application " + application.getApplicationId());
113: Devaraj K, info, IfStmt, LOG.info("Updated reserved container " + container.getContainer().getId() + " on node " + this + " for application " + application.getApplicationId());
245: Wangda Tan, debug, IfStmt, LOG.debug("Assigned container " + container.getId() + " of capacity " + container.getResource() + " on host " + getRMNode().getNodeAddress() + ", which has " + getNumContainers() + " containers, " + getAllocatedResource() + " used and " + getUnallocatedResource() + " available after allocation");
269: Karthik Kambatla, error, IfStmt, LOG.error("Allocated empty container" + rmContainer.getContainerId());
261: Sanford Ryza, error, IfStmt, LOG.error("Can't make app runnable that does not already exist in queue" + " as non-runnable: " + appSched + ". This should never happen.");
266: Sanford Ryza, error, IfStmt, LOG.error("Waiting app " + appSched + " expected to be in " + "usersNonRunnableApps, but was not. This should never happen.");
281: Karthik Kambatla, error, IfStmt, LOG.error("Can't create queue '" + queueName + "'.");
292: Karthik Kambatla, error, IfStmt, LOG.error("Can't create queue '" + queueName + "', since " + FifoPolicy.NAME + " is only for leaf queues.");
501: Karthik Kambatla, error, IfStmt, LOG.error("Setting scheduling policies for existing queues failed!");
359: Sandy Ryza, warn, IfStmt, LOG.warn("Name " + name + " is converted to " + converted + " when it is used as a queue name.");
128: Karthik Kambatla, error, IfStmt, LOG.error("Found ResourceRequest for a non-existent node/rack named " + resourceName);
119: Robert Kanter, warn, IfStmt, LOG.warn("Bad element in allocations file: " + tagName);
262: Robert Kanter, warn, IfStmt, LOG.warn(String.format("Queue %s has max resources %s less than " + "min resources %s", queueName, maxResource, minResource));
235: Karthik Kambatla, error, IfStmt, LOG.error("Queue policy can't be " + DominantResourceFairnessPolicy.NAME + " if the parent policy is " + getName() + ". Choose " + getName() + " or " + FifoPolicy.NAME + " for child queues instead." + " Please note that " + FifoPolicy.NAME + " is only for leaf queues.");
134: Karthik Kambatla, error, MethodDeclaration, LOG.error(getName() + " policy is only for leaf queues. Please choose " + DominantResourceFairnessPolicy.NAME + " or " + FairSharePolicy.NAME + " for parent queues.");
98: Jian He, debug, IfStmt, LOG.debug("allocate: applicationAttemptId=" + containerId.getApplicationAttemptId() + " container=" + containerId + " host=" + container.getNodeId().getHost() + " type=" + type);
329: Jian He, error, IfStmt, LOG.error("Calling allocate on removed or non existent application " + applicationAttemptId.getApplicationId());
340: Jian He, error, IfStmt, LOG.error("Calling allocate on previous or removed " + "or non existent application attempt " + applicationAttemptId);
356: Thomas Graves, info, IfStmt, LOG.info("Calling allocate on a stopped " + "application " + applicationAttemptId);
362: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("allocate: pre-update" + " applicationId=" + applicationAttemptId + " application=" + application);
370: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("allocate: post-update" + " applicationId=" + applicationAttemptId + " application=" + application);
375: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("allocate:" + " applicationId=" + applicationAttemptId + " #ask=" + ask.size());
396: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Accepted application " + applicationId + " from user: " + user + ", currently num of applications: " + applications.size());
400: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug(applicationId + " is recovering. Skip notifying APP_ACCEPTED");
428: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Added Application Attempt " + appAttemptId + " to scheduler from user " + application.getUser());
432: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug(appAttemptId + " is recovering. Skipping notifying ATTEMPT_ADDED");
447: Jian He, warn, IfStmt, LOG.warn("Couldn't find application " + applicationId);
495: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("assignContainers:" + " node=" + node.getRMNode().getNodeAddress() + " #applications=" + applications.size());
507: Vinod Kumar Vavilapalli, debug, ForeachStmt, LOG.debug("pre-assignContainers");
532: Vinod Kumar Vavilapalli, debug, ForeachStmt, LOG.debug("post-assignContainers");
605: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("assignContainersOnNode:" + " node=" + node.getRMNode().getNodeAddress() + " application=" + application.getApplicationId().getId() + " priority=" + schedulerKey.getPriority() + " #assigned=" + (nodeLocalContainers + rackLocalContainers + offSwitchContainers));
677: Vinod Kumar Vavilapalli, debug, MethodDeclaration, LOG.debug("assignContainers:" + " node=" + node.getRMNode().getNodeAddress() + " application=" + application.getApplicationId().getId() + " priority=" + schedulerKey.getPriority().getPriority() + " assignableContainers=" + assignableContainers + " capability=" + capability + " type=" + type);
803: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error("Unable to remove application " + appAttemptRemovedEvent.getApplicationAttemptID(), ie);
833: Vinod Kumar Vavilapalli, error, SwitchStmt, LOG.error("Invalid eventtype " + event.getType() + ". Ignoring!");
854: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Unknown application: " + appId + " released container " + container.getId() + " on node: " + node + " with event: " + event);
871: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Application attempt " + application.getApplicationAttemptId() + " released container " + container.getId() + " on node: " + node + " with event: " + event);
971: Karthik Kambatla, debug, IfStmt, LOG.debug("Node heartbeat " + nm.getNodeID() + " available resource = " + node.getUnallocatedResource());
976: Karthik Kambatla, debug, IfStmt, LOG.debug("Node after allocation " + nm.getNodeID() + " resource = " + node.getUnallocatedResource());
989: Haibo Chen, info, MethodDeclaration, LOG.info("Killing container " + container);
399: Arun Suresh, debug, IfStmt, LOG.debug("\tRequest=" + request);
183: Arun Suresh, info, IfStmt, LOG.info("Update numAllocation from old=" + existingNumAllocations + " to new=" + newNumAllocations);
358: Arun Suresh, info, MethodDeclaration, LOG.info("Successfully added SchedulingRequest to app=" + appSchedulingInfo.getApplicationAttemptId() + " targetAllocationTags=[" + StringUtils.join(",", targetAllocationTags) + "]. nodePartition=" + targetNodePartition);
434: Arun Suresh, warn, CatchClause, LOG.warn("Failed to query node cardinality:", e);
492: Arun Suresh, info, IfStmt, LOG.info(schedulingRequest.toString());
94: Xuan Gong, info, ConstructorDeclaration, LOG.info("AMRMTokenKeyRollingInterval: " + this.rollingInterval + "ms and AMRMTokenKeyActivationDelay: " + this.activationDelay + " ms");
124: Xuan Gong, info, TryStmt, LOG.info("Application finished, removing password for " + appAttemptId);
142: Xuan Gong, info, TryStmt, LOG.info("Rolling master-key for amrm-tokens");
166: Xuan Gong, info, TryStmt, LOG.info("Activating next master key with id: " + this.nextMasterKey.getMasterKey().getKeyId());
195: Xuan Gong, info, TryStmt, LOG.info("Create AMRMToken for ApplicationAttempt: " + appAttemptId);
228: Bikas Saha, debug, TryStmt, LOG.debug("Adding password for " + identifier.getApplicationAttemptId());
247: Xuan Gong, debug, IfStmt, LOG.debug("Trying to retrieve password for " + applicationAttemptId);
307: Xuan Gong, info, TryStmt, LOG.info("Creating password for " + applicationAttemptId);
131: Wangda Tan, debug, IfStmt, LOG.debug("Priority ACL group added: max-priority - " + priorityACLGroup.getMaxPriority() + "default-priority - " + priorityACLGroup.getDefaultPriority());
224: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Interrupted while joining on delayed removal thread.", e);
321: Arun Murthy, warn, WhileStmt, LOG.warn("Unable to add token " + token + " for cancellation. " + "Will retry..");
351: Arun Murthy, warn, CatchClause, LOG.warn("Failed to cancel token " + tokenWithConf.token + " " + StringUtils.stringifyException(e));
354: Robert Joseph Evans, warn, CatchClause, LOG.warn("Failed to cancel token " + tokenWithConf.token + " " + StringUtils.stringifyException(e));
359: Arun Murthy, warn, CatchClause, LOG.warn("Got exception " + StringUtils.stringifyException(t) + ". Exiting..");
338: Hitesh Shah, debug, IfStmt, LOG.debug("Cancelling token " + tokenWithConf.token.getService());
432: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Registering tokens for renewal for:" + " appId = " + applicationId);
450: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(applicationId + " found existing hdfs token " + token);
466: Jason Lowe, info, IfStmt, LOG.info("Using app provided token conf for renewal," + " number of configs = " + tokenConf.size());
472: Jason Lowe, info, ForStmt, LOG.info(entry.getKey() + " ===> " + entry.getValue());
487: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Failed to renew hdfs token " + dttr + " on recovery as it expired, requesting new hdfs token for " + applicationId + ", user=" + evt.getUser(), ioe);
557: Arun Murthy, error, CatchClause, LOG.error("Exception renewing token" + token + ". Not rescheduled", e);
554: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("The token was removed already. Token = [" + dttr + "]");
596: Robert Kanter, info, IfStmt, LOG.info("Will not renew token " + token);
605: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Renew " + token + " in " + expiresIn + " ms, appId = " + token.referringAppIds);
627: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Renewed delegation-token= [" + dttr + "]");
659: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Removed expiring token " + t);
664: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Token= (" + dttr + ") is expiring, request new token.");
675: Jason Lowe, info, IfStmt, LOG.info("RM proxy-user privilege is not enabled. Skip requesting hdfs tokens.");
683: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Received new tokens for " + referringAppIds + ". Received " + newTokens.length + " tokens.");
697: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Received new token " + token);
740: Mahadev Konar, info, IfStmt, LOG.info("Did not cancel " + t);
750: Vinod Kumar Vavilapalli, error, SynchronizedStmt, LOG.error("removing failed delegation token for appid=" + applicationIds + ";t=" + t.token.getService());
808: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Removing delegation token for appId=" + applicationId + "; token=" + dttr.token.getService());
868: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Delayed Deletion Thread Interrupted. Shutting it down");
927: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to add the application to the delegation token renewer.", t);
947: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("Unable to add the application to the delegation token" + " renewer on recovery.", t);
75: Vinod Kumar Vavilapalli, info, ConstructorDeclaration, LOG.info("NMTokenKeyRollingInterval: " + this.rollingInterval + "ms and NMTokenKeyActivationDelay: " + this.activationDelay + "ms");
95: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Rolling master-key for nm-tokens");
100: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Going to activate master-key with key-id " + this.nextMasterKey.getMasterKey().getKeyId() + " in " + this.activationDelay + "ms");
131: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("Activating next master key with id: " + this.nextMasterKey.getMasterKey().getKeyId());
146: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Clear node set for " + attemptId);
200: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Sending NMToken for nodeId : " + container.getNodeId() + " for container : " + container.getId());
134: Daniel Templeton, warn, IfStmt, LOG.warn("Target queue " + targetQueue + " does not exist while trying to move " + app.getApplicationId());
120: Daniel Templeton, warn, IfStmt, LOG.warn("Target queue " + targetQueue + " does not exist while trying to move " + app.getApplicationId());
81: Siddharth Seth, info, ConstructorDeclaration, LOG.info("ContainerTokenKeyRollingInterval: " + this.rollingInterval + "ms and ContainerTokenKeyActivationDelay: " + this.activationDelay + "ms");
109: Siddharth Seth, info, TryStmt, LOG.info("Rolling master-key for container-tokens");
114: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Going to activate master-key with key-id " + this.nextMasterKey.getMasterKey().getKeyId() + " in " + this.activationDelay + "ms");
145: Siddharth Seth, info, TryStmt, LOG.info("Activating next master key with id: " + this.nextMasterKey.getMasterKey().getKeyId());
96: Jason Lowe, Error, IfStmt, LOG.error("Error in storing master key with KeyID: " + newKey.getKeyId());
92: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("storing master key with keyID " + newKey.getKeyId());
110: Jason Lowe, Error, IfStmt, LOG.error("Error in removing master key with KeyID: " + key.getKeyId());
106: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("removing master key with keyID " + key.getKeyId());
126: Jason Lowe, Error, IfStmt, LOG.error("Error in storing RMDelegationToken with sequence number: " + identifier.getSequenceNumber());
120: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("storing RMDelegation token with sequence number: " + identifier.getSequenceNumber());
142: Jason Lowe, Error, IfStmt, LOG.error("Error in updating persisted RMDelegationToken" + " with sequence number: " + id.getSequenceNumber());
137: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("updating RMDelegation token with sequence number: " + id.getSequenceNumber());
158: Jason Lowe, Error, IfStmt, LOG.error("Error in removing RMDelegationToken with sequence number: " + ident.getSequenceNumber());
153: Vinod Kumar Vavilapalli, info, TryStmt, LOG.info("removing RMDelegation token with sequence number: " + ident.getSequenceNumber());
196: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("recovering RMDelegationTokenSecretManager.");
83: Varun Saxena, debug, IfStmt, LOG.debug("Setting the flow name: " + parts[1]);
89: Varun Saxena, debug, IfStmt, LOG.debug("Setting the flow version: " + parts[1]);
95: Varun Saxena, debug, IfStmt, LOG.debug("Setting the flow run id: " + parts[1]);
61: Sunil G, warn, IfStmt, LOG.warn("Invalid deSelects string " + literals.trim());
124: Zhijie Shen, debug, SwitchStmt, LOG.debug("Unexpected state filter for inactive RM node");
197: Jason Lowe, Error, CatchClause, LOG.debug("Error parsing {} as an ApplicationId", parts[3], e);
209: Jason Lowe, Error, CatchClause, LOG.debug("Error parsing {} as an ApplicationAttemptId", parts[3], e);
223: Jason Lowe, Error, CatchClause, LOG.debug("Error parsing {} as an ContainerId", parts[3], e);
149: Carlo Curino, info, IfStmt, LOG.info("Using RM authentication filter(kerberos/delegation-token)" + " for RM webapp authentication");
214: Subru Krishnan, Info, IfStmt, appContext.setLogAggregationContext(createLogAggregationContext(newApp.getLogAggregationContextInfo()));
590: Sanford Ryza, error, CatchClause, LOG.error("Unable to retrieve apps from ClientRMService", e);
1624: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Submit app request failed", ue);
1648: Vinod Kumar Vavilapalli, error, CatchClause, LOG.error(msg, e);
1747: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Create delegation token request failed", e);
1798: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Renew delegation token request failed", ue);
1801: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Renew delegation token request failed", ue);
1804: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Renew delegation token request failed", e);
1864: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Renew delegation token request failed", ue);
1867: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Renew delegation token request failed", ue);
1870: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Renew delegation token request failed", e);
1938: Carlo Curino, error, CatchClause, LOG.error(msg, e);
1983: =, info, CatchClause, LOG.info("Submit reservation request failed", ue);
2083: =, info, CatchClause, LOG.info("Update reservation request failed", ue);
2182: =, info, CatchClause, LOG.info("Update reservation request failed", ue);
2239: =, info, CatchClause, LOG.info("List reservation request failed", ue);
2520: Wangda Tan, error, CatchClause, LOG.error("Exception thrown when modifying configuration.", e);
90: Arun Suresh, info, WhileStmt, LOG.info("Waiting for RM to start...");
226: Arun Suresh, debug, IfStmt, LOG.debug("Added priority=" + schedulerKey.getPriority() + " application=" + applicationId);
241: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Added task " + task.getTaskId() + " to application " + applicationId + " at priority " + schedulerKey.getPriority());
245: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("addTask: application=" + applicationId + " #asks=" + ask.size());
284: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finished task " + task.getTaskId() + " of application " + applicationId + " on node " + nodeManager.getHostName() + ", currently using " + used + " resources");
313: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("addResourceRequest: applicationId=" + applicationId.getId() + " priority=" + schedulerKey.getPriority().getPriority() + " resourceName=" + resourceName + " capability=" + capability + " numContainers=" + request.getNumContainers() + " #asks=" + ask.size());
323: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("getResources begin:" + " application=" + applicationId + " #ask=" + ask.size());
327: Vinod Kumar Vavilapalli, debug, ForeachStmt, LOG.debug("getResources:" + " application=" + applicationId + " ask-request=" + request);
338: Varun Vasudev, info, IfStmt, LOG.info("-=======" + applicationAttemptId + System.lineSeparator() + "----------" + resourceManager.getRMContext().getRMApps().get(applicationId).getRMAppAttempt(applicationAttemptId));
349: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("getResources() for " + applicationId + ":" + " ask=" + ask.size() + " received=" + containers.size());
372: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Application " + applicationId + " assigned " + assignedContainers + "/" + numContainers);
402: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("Assigned container (" + container + ") of type " + type + " to task " + task.getTaskId() + " at priority " + schedulerKey.getPriority() + " on node " + nodeManager.getHostName() + ", currently using " + used + " resources");
433: Arun Suresh, debug, IfStmt, LOG.debug("updateResourceDemands:" + " application=" + applicationId + " type=" + type + " host=" + host + " request=" + ((requests == null) ? "null" : requests.get(host)));
444: Arun Suresh, debug, IfStmt, LOG.debug("updateResourceDemands:" + " application=" + applicationId + " type=" + type + " rack=" + rack + " request=" + ((requests == null) ? "null" : requests.get(rack)));
455: Arun Suresh, debug, IfStmt, LOG.debug("updateResourceDemands:" + " application=" + applicationId + " #asks=" + ask.size());
470: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("updateResourceRequest:" + " application=" + applicationId + " request=" + request);
225: Robert Kanter, info, MethodDeclaration, Log.getLog().info("ContainerStatus: " + containerStatus);
249: Jian He, info, WhileStmt, LOG.info("App : " + appId + " State is : " + app.getState() + " Waiting for state : " + finalStates);
255: Jian He, info, MethodDeclaration, LOG.info("App State is : " + app.getState());
280: Wangda Tan, info, WhileStmt, LOG.info("App : " + appId + " State is : " + app.getState() + " Waiting for state : " + finalState);
286: Karthik Kambatla, info, MethodDeclaration, LOG.info("App State is : " + app.getState());
354: Karthik Kambatla, info, WhileStmt, LOG.info("AppAttempt : " + attempt.getAppAttemptId() + " State is : " + attempt.getAppAttemptState() + " Waiting for state : " + finalState);
360: Karthik Kambatla, info, MethodDeclaration, LOG.info("Attempt State is : " + attempt.getAppAttemptState());
371: Daniel Templeton, info, WhileStmt, LOG.info("Received completed containers " + containers);
392: Daniel Templeton, info, WhileStmt, LOG.info("Application " + appId + " is waiting for AM to restart. Current has " + app.getAppAttempts().size() + " attempts.");
480: Daniel Templeton, info, WhileStmt, LOG.info("Waiting for container " + containerId + " to be " + containerState + ", container is null right now.");
491: Daniel Templeton, info, WhileStmt, LOG.info("Container : " + containerId + " State is : " + container.getState() + " Waiting for state : " + containerState);
501: Daniel Templeton, info, MethodDeclaration, LOG.info("Container State is : " + container.getState());
918: Daniel Templeton, info, WhileStmt, LOG.info("Node State is : " + node.getState() + " Waiting for state : " + finalState);
924: Daniel Templeton, info, MethodDeclaration, LOG.info("Node " + nodeId + " State is : " + node.getState());
1162: Daniel Templeton, info, IfStmt, LOG.info("waiting for SchedulerApplicationAttempt=" + attemptId + " added.");
1200: Daniel Templeton, info, MethodDeclaration, LOG.info("Launch AM " + attempt.getAppAttemptId());
1217: Daniel Templeton, info, MethodDeclaration, LOG.info("Launch AM " + attempt.getAppAttemptId());
1313: Varun Saxena, info, WhileStmt, LOG.info("wait for app removed, " + appId);
1319: Varun Saxena, info, MethodDeclaration, LOG.info("app is removed from scheduler, " + appId);
213: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("startContainer:" + " node=" + containerManagerAddress + " application=" + applicationId + " container=" + container + " available=" + available + " used=" + used);
225: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Checking resource usage for " + containerManagerAddress);
280: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("stopContainer:" + " node=" + containerManagerAddress + " application=" + applicationId + " container=" + containerID + " available=" + available + " used=" + used);
114: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Got exception while killing app as the enemy", e);
452: Arun Suresh, info, MethodDeclaration, LOG.info("Got exception while killing app as the enemy", e);
466: Arun Suresh, info, DoStmt, LOG.info("Waiting for node capacity to be added to plan");
72: Vinod Kumar Vavilapalli, info, ConstructorDeclaration, LOG.info("Task " + taskId + " added to application " + this.applicationId + " with " + this.hosts.size() + " hosts, " + racks.size() + " racks");
269: Arun Murthy, info, WhileStmt, LOG.info("Waiting for AM Launch to happen..");
327: Arun Murthy, info, WhileStmt, LOG.info("Waiting for AM Launch to happen..");
424: Arun Murthy, info, WhileStmt, LOG.info("Waiting for AppAttempt to reach LAUNCHED state. " + "Current state is " + attempt.getAppAttemptState());
154: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for RM to start...");
399: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Got exception while killing app as the enemy", e);
108: Jonathan Turner Eagles, info, WhileStmt, LOG.info("Got " + contReceived + " containers. Waiting to get " + request);
133: Siddharth Seth, info, WhileStmt, LOG.info("Waiting to get cleanup events.. cleanedConts: " + numCleanedContainers + " cleanedApps: " + numCleanedApps);
188: Jonathan Turner Eagles, info, WhileStmt, LOG.info("Got " + contReceived + " containers. Waiting to get " + request);
257: Karthik Kambatla, info, IfStmt, LOG.info("Got cleanup for " + contsToClean.get(0));
255: Karthik Kambatla, error, IfStmt, LOG.error("Failed to get any containers to cleanup");
272: Jian He, info, WhileStmt, LOG.info("Haven't got application=" + appId.toString() + " in cleanup list from node heartbeat response, " + "sleep for a while before next heartbeat");
117: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Container started by MyContainerManager: " + request);
147: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Container cleaned up by MyContainerManager");
223: Arun Suresh, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
274: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
349: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
408: Jonathan Turner Eagles, info, WhileStmt, LOG.info("Waiting for allocate event to be handled ...");
415: Jonathan Turner Eagles, info, WhileStmt, LOG.info("Waiting for allocate event to be handled ...");
422: Jonathan Turner Eagles, info, WhileStmt, LOG.info("Waiting for allocate event to be handled ...");
429: Jonathan Turner Eagles, info, WhileStmt, LOG.info("Waiting for allocate event to be handled ...");
436: Jonathan Turner Eagles, info, WhileStmt, LOG.info("Waiting for allocate event to be handled ...");
443: Jonathan Turner Eagles, info, WhileStmt, LOG.info("Waiting for allocate event to be handled ...");
525: Vinod Kumar Vavilapalli, info, ForeachStmt, LOG.info("types = " + types.toString());
1015: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("summary: " + msg);
208: Arun Suresh, info, MethodDeclaration, LOG.info("Connecting to ResourceManager at " + rmAddress);
259: Mahadev Konar, info, MethodDeclaration, LOG.info("Connecting to ResourceManager at " + rmAddress);
1254: Daryn Sharp, warn, CatchClause, LOG.warn("Broken Barrier", e);
1256: Daryn Sharp, warn, CatchClause, LOG.warn("Interrupted while awaiting barriers", e);
1894: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Connecting to ResourceManager at " + rmAddress);
1957: Wangda Tan, info, MethodDeclaration, LOG.info("Connecting to ResourceManager at " + rmAddress);
2120: Jason Lowe, info, MethodDeclaration, LOG.info("Connecting to ResourceManager at " + rmAddress);
2151: Wangda Tan, info, MethodDeclaration, LOG.info("Connecting to ResourceManager at " + rmAddress);
131: Thomas Graves, info, MethodDeclaration, LOG.info("Creating DelegationTokenSecretManager with initialInterval: " + initialInterval + ", maxLifetime: " + maxLifetime + ", renewInterval: " + renewInterval);
154: Thomas Graves, info, TryStmt, LOG.info("Got delegation token at: " + tokenFetchTime);
176: Thomas Graves, info, TryStmt, LOG.info("Renewed token at: " + renewalTime + ", NextExpiryTime: " + nextExpTime);
200: Thomas Graves, info, TryStmt, LOG.info("At time: " + System.currentTimeMillis() + ", token should be invalid");
219: Thomas Graves, info, TryStmt, LOG.info("Got delegation token at: " + tokenFetchTime);
243: Thomas Graves, info, TryStmt, LOG.info("Cancelled delegation token at: " + System.currentTimeMillis());
82: Arun Suresh, info, MethodDeclaration, LOG.info("Submit reservation response: " + reservationID);
118: Arun Suresh, info, MethodDeclaration, LOG.info("Submit reservation response: " + reservationID);
196: Arun Suresh, info, DoStmt, LOG.info("Waiting for node capacity to be added to plan");
249: Anubhav Dhoot, info, MethodDeclaration, LOG.info("Submit reservation response: " + reservationID);
303: Anubhav Dhoot, info, MethodDeclaration, LOG.info("Submit reservation response: " + reservationID);
335: Anubhav Dhoot, info, MethodDeclaration, LOG.info("Submit reservation response: " + reservationID);
387: Anubhav Dhoot, info, MethodDeclaration, LOG.info("Submit reservation response: " + reservationID);
458: Anubhav Dhoot, info, MethodDeclaration, LOG.info("Submit reservation response: " + resID1);
470: Anubhav Dhoot, info, MethodDeclaration, LOG.info("Submit reservation response: " + resID2);
482: Anubhav Dhoot, info, MethodDeclaration, LOG.info("Submit reservation response: " + resID3);
535: Anubhav Dhoot, info, DoStmt, LOG.info("Waiting for reservation to be active");
91: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testResourceAllocation ---");
141: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Adding new tasks...");
160: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Trying to allocate...");
166: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finishing up tasks...");
179: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- END: testResourceAllocation ---");
176: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Got " + contReceived + " containers. Waiting to get " + 3);
190: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Got " + contReceived + " containers. Waiting to get " + 10);
333: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("waiting for nmToken to be cleared for : " + nm2.getNodeId());
420: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("requesting containers..");
433: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Got " + containersReceived.size() + " containers. Waiting to get " + totalContainerRequested);
99: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Waiting for callback");
101: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Stopping RM");
103: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Stopped RM");
327: Jian He, info, TryStmt, TestRMEmbeddedElector.LOG.info("Callback called. Sleeping now");
329: Jian He, info, TryStmt, TestRMEmbeddedElector.LOG.info("Sleep done");
145: Bikas Saha, error, CatchClause, LOG.error("ActiveRM check failed", e);
691: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info(appId + " final state is not saved.");
2459: Rohith Sharma K S, debug, CatchClause, LOG.debug("Exception on start", e);
2602: Sunil G, debug, CatchClause, LOG.debug("Exception on start", e);
80: Varun Saxena, info, WhileStmt, LOG.info("Got " + conts.size() + " containers. Waiting to get " + request);
103: Xuan, info, WhileStmt, LOG.info("Waiting to get signalcontainer events.. signaledConts: " + signaledConts);
282: Wangda Tan, debug, ForStmt, LOG.debug("add container to app=" + attemptId + " res=" + res + " node=" + host + " nodeLabelExpression=" + label + " partition=" + partition);
352: Wangda Tan, debug, ForeachStmt, LOG.debug("Application mock: queue: " + queueName + ", appId:" + appId);
421: Wangda Tan, debug, ForeachStmt, LOG.debug("Updating user-limit from mock: totResoucePerPartition=" + totResoucePerPartition + ", capacity=" + capacity + ", users.size()=" + users.size() + ", userlimit= " + userLimit + ",label= " + label + ",queueName= " + queueName);
494: Jian He, debug, ForeachStmt, LOG.debug("add scheduler node, id=" + nodeId + ", partition=" + partition);
521: Jian He, debug, ForeachStmt, LOG.debug("add partition=" + partitionName + " totalRes=" + res + " exclusivity=" + exclusivity);
636: Jian He, debug, MethodDeclaration, LOG.debug("*** Setup queue, source=" + q);
668: Jian He, debug, MethodDeclaration, LOG.debug("Setup queue, name=" + queue.getQueueName() + " path=" + queue.getQueuePath());
670: Jian He, debug, MethodDeclaration, LOG.debug("Parent=" + (parentQueue == null ? "null" : parentQueue.getQueueName()));
727: Jian He, debug, ForeachStmt, LOG.debug("Setup queue=" + queueName + " partition=" + partitionName + " [abs_guaranteed=" + absGuaranteed + ",abs_max=" + absMax + ",abs_used" + absUsed + ",pending_resource=" + pending + ", reserved_resource=" + reserved + "]");
291: Vinod Kumar Vavilapalli, warn, TryStmt, LOG.warn("\n\n ##Testing path [" + p + "]\n\n");
122: Jian He, info, MethodDeclaration, LOG.info("Starting ZKRMStateStorePerf ver." + version);
228: Jian He, info, MethodDeclaration, LOG.info(resultMsg);
157: Hitesh Shah, error, CatchClause, LOG.error(error, e);
45: Subru Krishnan, info, MethodDeclaration, LOG.info(periodicVector.toString());
64: Subru Krishnan, info, MethodDeclaration, LOG.info(periodicVector.toString());
127: subru, info, CatchClause, LOG.info(message);
148: subru, info, CatchClause, LOG.info(message);
168: subru, info, CatchClause, LOG.info(message);
187: subru, info, CatchClause, LOG.info(message);
206: subru, info, CatchClause, LOG.info(message);
225: subru, info, CatchClause, LOG.info(message);
246: subru, info, CatchClause, LOG.info(message);
269: subru, info, CatchClause, LOG.info(message);
303: Subru Krishnan, info, CatchClause, LOG.info(message);
323: Subru Krishnan, info, CatchClause, LOG.info(message);
343: Subru Krishnan, info, CatchClause, LOG.info(message);
360: Carlo Curino, info, CatchClause, LOG.info(message);
390: subru, info, CatchClause, LOG.info(message);
412: subru, info, CatchClause, LOG.info(message);
431: subru, info, CatchClause, LOG.info(message);
449: subru, info, CatchClause, LOG.info(message);
466: subru, info, CatchClause, LOG.info(message);
483: subru, info, CatchClause, LOG.info(message);
500: subru, info, CatchClause, LOG.info(message);
518: subru, info, CatchClause, LOG.info(message);
539: subru, info, CatchClause, LOG.info(message);
571: Carlo Curino, info, CatchClause, LOG.info(message);
590: Carlo Curino, info, CatchClause, LOG.info(message);
606: Carlo Curino, info, CatchClause, LOG.info(message);
640: subru, info, CatchClause, LOG.info(message);
662: subru, info, CatchClause, LOG.info(message);
683: subru, info, CatchClause, LOG.info(message);
740: Wangda Tan, info, CatchClause, LOG.info(message);
758: Wangda Tan, info, CatchClause, LOG.info(message);
780: Wangda Tan, info, CatchClause, LOG.info(message);
324: subru, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
339: subru, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
369: Arun Suresh, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
372: Arun Suresh, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
390: Arun Suresh, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
416: subru, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
432: subru, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
453: subru, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
469: subru, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
484: subru, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
542: Subru Krishnan, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
567: Subru Krishnan, info, MethodDeclaration, LOG.info(rleSparseVector.toString());
1069: Subru Krishnan, info, MethodDeclaration, LOG.info("Running with seed: " + seed);
105: Subru Krishnan, info, MethodDeclaration, LOG.info("Running with seed: " + seed);
113: Subru Krishnan, info, MethodDeclaration, LOG.info("Running with seed: " + seed);
121: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("failed to heartbeat ", e);
149: Mahadev Konar, Error, CatchClause, LOG.error("Error in handling event type " + event.getType() + " for application " + appId, t);
173: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error in handling event type " + event.getType() + " for application " + appID, t);
635: Arun Murthy, info, MethodDeclaration, LOG.info("--- START: testUnmanagedAppSuccessPath ---");
646: Arun Murthy, info, MethodDeclaration, LOG.info("--- START: testUnmanagedAppFailPath ---");
663: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppSuccessPath ---");
673: Bikas Saha, info, MethodDeclaration, LOG.info("--- START: testAppRecoverPath ---");
682: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppNewKill ---");
704: Arun Murthy, info, MethodDeclaration, LOG.info("--- START: testAppNewReject ---");
722: XUAN, info, MethodDeclaration, LOG.info("--- START: testAppNewRejectAddToStore ---");
741: Bikas Saha, info, MethodDeclaration, LOG.info("--- START: testAppNewSavingKill ---");
763: Bikas Saha, info, MethodDeclaration, LOG.info("--- START: testAppNewSavingReject ---");
781: Rohith Sharma K S, info, MethodDeclaration, LOG.info("--- START: testAppNewSavingSaveReject ---");
798: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppSubmittedRejected ---");
816: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppSubmittedKill---");
839: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppAcceptedFailed ---");
874: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppAcceptedKill ---");
904: Jian He, info, MethodDeclaration, LOG.info("--- START: testAppAcceptedAttemptKilled ---");
926: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppRunningKill ---");
951: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppRunningFailed ---");
1009: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppAtFinishingIgnoreKill ---");
1027: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppFinalSavingToFinished ---");
1051: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppFinishedFinished ---");
1071: Bikas Saha, info, MethodDeclaration, LOG.info("--- START: testAppFailedFailed ---");
1101: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testAppKilledKilled ---");
1156: Jason Lowe, info, MethodDeclaration, LOG.info("--- START: testAppStartAfterKilled ---");
180: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error in handling event type " + event.getType() + " for application " + appID, t);
200: Vinod Kumar Vavilapalli, Error, CatchClause, LOG.error("Error in handling event type " + event.getType() + " for application " + application.getApplicationId(), t);
144: Jian He, info, MethodDeclaration, LOG.info("Test - " + suffix);
700: Bikas Saha, info, WhileStmt, LOG.info("Waiting for AppAttempt to reach LAUNCHED state. " + "Current state is " + attempt.getAppAttemptState());
236: Robert Kanter, info, WhileStmt, LOG.info("Waiting for containers to be created for app...");
166: Arun Murthy, info, MethodDeclaration, LOG.info("Setup top-level queues a and b");
304: Arun Murthy, info, MethodDeclaration, LOG.info("Queue 'A' -" + " aMResourceLimit=" + queue.getAMResourceLimit() + " UserAMResourceLimit=" + queue.getUserAMResourceLimit());
279: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testCapacityScheduler ---");
336: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Kick!");
354: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Adding new tasks...");
369: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Sending hb from " + nm_0.getHostName());
373: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Sending hb from " + nm_1.getHostName());
378: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Trying to allocate...");
391: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- END: testCapacityScheduler ---");
396: Wangda Tan, info, MethodDeclaration, LOG.info("--- START: testNotAssignMultiple ---");
471: Wangda Tan, info, MethodDeclaration, LOG.info("Kick!");
491: Wangda Tan, info, MethodDeclaration, LOG.info("--- START: testNotAssignMultiple ---");
496: Wangda Tan, info, MethodDeclaration, LOG.info("--- START: testAssignMultiple ---");
573: Wangda Tan, info, MethodDeclaration, LOG.info("Kick!");
593: Wangda Tan, info, MethodDeclaration, LOG.info("--- START: testAssignMultiple ---");
644: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Setup top-level queues a and b");
674: bibinchundatt, info, MethodDeclaration, LOG.info("Setup top-level queues a and b (without children)");
710: Wangda Tan, info, MethodDeclaration, LOG.info("Setup top-level queues a and b (without b3)");
780: Wangda Tan, info, MethodDeclaration, LOG.info("Setup top-level queues a");
798: Jason Lowe, info, MethodDeclaration, LOG.info("Setup top-level queues a and b");
1262: Jian He, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
1297: Eric Payne, info, WhileStmt, LOG.info("Waiting for RMNodeResourceUpdateEvent to be handled... Tried " + waitCount + " times already..");
1313: Jian He, info, WhileStmt, LOG.info("Waiting for containers to be finished for app 1... Tried " + waitCount + " times already..");
1333: Jian He, info, WhileStmt, LOG.info("Waiting for containers to be allocated for app 1... Tried " + times + " times already..");
1469: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for AppAttempt to reach LAUNCHED state. " + "Current state is " + attempt.getAppAttemptState());
4499: bibinchundatt, error, CatchClause, LOG.error("Expected to NOT throw exception when refresh queue tries to delete" + " a queue WITHOUT running apps", e);
375: Wangda Tan, info, MethodDeclaration, LOG.info("Setup " + C + " as an auto leaf creation enabled parent queue");
407: Wangda Tan, info, MethodDeclaration, LOG.info("Setup " + D + " as an auto leaf creation enabled parent queue");
724: Sunil G, info, ForeachStmt, LOG.info("Validating label " + label);
291: carlo curino, info, MethodDeclaration, LOG.info("Setup a as a plan queue");
134: Arun Murthy, info, CatchClause, LOG.info("FOOBAR q.assignContainers q=" + queue.getQueueName() + " alloc=" + allocation + " node=" + node.getNodeName());
329: Arun Murthy, info, MethodDeclaration, LOG.info("status child-queues: " + ((ParentQueue) root).getChildQueuesToPrint());
345: Arun Murthy, info, MethodDeclaration, LOG.info("status child-queues: " + ((ParentQueue) root).getChildQueuesToPrint());
363: Arun Murthy, info, MethodDeclaration, LOG.info("status child-queues: " + ((ParentQueue) root).getChildQueuesToPrint());
376: Arun Murthy, info, MethodDeclaration, LOG.info("status child-queues: " + ((ParentQueue) root).getChildQueuesToPrint());
390: Arun Murthy, info, MethodDeclaration, LOG.info("status child-queues: " + ((ParentQueue) root).getChildQueuesToPrint());
403: Arun Murthy, info, MethodDeclaration, LOG.info("status child-queues: " + ((ParentQueue) root).getChildQueuesToPrint());
417: Arun Murthy, info, MethodDeclaration, LOG.info("status child-queues: " + ((ParentQueue) root).getChildQueuesToPrint());
439: Arun Murthy, info, MethodDeclaration, LOG.info("status child-queues: " + ((ParentQueue) root).getChildQueuesToPrint());
106: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for node managers to register : " + size);
119: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("sending container requests ");
126: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("heartbeating nm1");
129: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
133: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("received container : " + alloc1Response.getAllocatedContainers().size());
140: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("heartbeating nm2");
145: Vinod Kumar Vavilapalli, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
149: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("received container : " + alloc1Response.getAllocatedContainers().size());
96: Jian He, debug, CatchClause, LOG.debug("Thread interrupted.");
832: Wangda Tan, info, DoStmt, LOG.info(assign.toString());
123: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Setup top-level queues a and b");
140: Wangda Tan, info, MethodDeclaration, LOG.info("Setup top-level queues a and b with absolute resource");
189: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("FOOBAR q.assignContainers q=" + queue.getQueueName() + " alloc=" + allocation + " node=" + node.getNodeName());
126: Jian He, info, MethodDeclaration, LOG.info("Test - " + suffix);
70: Jian He, info, MethodDeclaration, LOG.info("Setup top-level queues q1 and q2");
159: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Setup top-level queues");
195: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Setup 2nd-level queues");
209: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Setup 3rd-level queues");
287: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Setup top-level queues");
323: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Setup top-level queues");
385: Wangda Tan, info, MethodDeclaration, LOG.info("Setup top-level queues");
225: Karthik Kambatla, info, MethodDeclaration, LOG.info("node = " + host + " avail=" + node.getUnallocatedResource());
431: Arun Suresh, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
502: Arun Suresh, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
593: Arun Suresh, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
661: Arun Suresh, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
816: Arun Suresh, info, IfStmt, LOG.info("nm_" + nm.getNodeId() + ": " + sb.toString());
830: Arun Suresh, info, WhileStmt, LOG.info("Waiting for containers to be created for " + am.getApplicationAttemptId().getApplicationId() + "...");
205: Karthik Kambatla, fatal, IfStmt, LOG.fatal("Failure data: " + copy[0] + " " + copy[1] + " " + copy[2]);
404: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- START: testFifoScheduler ---");
461: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Send resource requests to the scheduler");
466: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Send a heartbeat to kick the tires on the Scheduler... " + "nm0 -> task_0_0 and task_1_0 allocated, used=4G " + "nm1 -> nothing allocated");
485: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Adding new tasks...");
516: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Sending hb from " + nm_0.getHostName());
519: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Sending hb from " + nm_1.getHostName());
523: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Trying to allocate...");
534: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finishing up task_0_0");
545: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finishing up task_1_0");
556: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finishing up task_0_3");
567: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finishing up task_0_1");
576: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finishing up task_0_2");
585: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finishing up task_1_3");
594: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Finishing up task_1_1");
603: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("--- END: testFifoScheduler ---");
727: Devaraj K, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
732: Devaraj K, info, WhileStmt, LOG.info("Waiting for containers to be created for app 2...");
765: Devaraj K, info, WhileStmt, LOG.info("Waiting for containers to be finished for app 1... Tried " + waitCount + " times already..");
1131: Devaraj K, info, WhileStmt, LOG.info("Waiting for containers to be created for app 1...");
1166: Eric Payne, info, WhileStmt, LOG.info("Waiting for RMNodeResourceUpdateEvent to be handled... Tried " + waitCount + " times already..");
1184: Devaraj K, info, WhileStmt, LOG.info("Waiting for containers to be finished for app 1... Tried " + waitCount + " times already..");
137: Siddharth Seth, info, WhileStmt, LOG.info("Waiting for AM Launch to happen..");
206: Siddharth Seth, info, CatchClause, LOG.info("Exception found is ", t);
258: Siddharth Seth, info, WhileStmt, LOG.info("Waiting for AM Launch to happen..");
158: Arun Murthy, info, MethodDeclaration, LOG.info("Called MYDFS.renewdelegationtoken " + token + ";this dfs=" + this.hashCode() + ";c=" + counter);
162: Arun Murthy, info, IfStmt, LOG.info("RENEW in 2 seconds");
175: Jason Lowe, info, IfStmt, LOG.info("Cancel token " + token);
195: Arun Murthy, info, MethodDeclaration, LOG.info("filesystem uri = " + FileSystem.getDefaultUri(conf).toString());
313: Arun Murthy, info, MethodDeclaration, LOG.info("Called MYDFS.getdelegationtoken " + result);
369: Arun Murthy, info, MethodDeclaration, LOG.info("dfs=" + (Object) dfs.hashCode() + ";conf=" + conf.hashCode());
380: Arun Murthy, info, MethodDeclaration, LOG.info("token=" + token1 + " should be renewed for 2 secs");
415: Arun Murthy, info, MethodDeclaration, LOG.info("dfs=" + dfs.hashCode() + ";Counter = " + Renewer.counter + ";t=" + Renewer.lastRenewed);
431: Arun Murthy, info, MethodDeclaration, LOG.info("token=" + token4 + " should be renewed for 2 secs");
447: Arun Murthy, info, MethodDeclaration, LOG.info("Counter = " + Renewer.counter + ";t=" + Renewer.lastRenewed);
465: Thomas Graves, info, MethodDeclaration, LOG.info("dfs=" + (Object) dfs.hashCode() + ";conf=" + conf.hashCode());
498: Jian He, info, MethodDeclaration, LOG.info("dfs=" + (Object) dfs.hashCode() + ";conf=" + conf.hashCode());
525: Mahadev Konar, info, MethodDeclaration, LOG.info("dfs=" + (Object) dfs.hashCode() + ";conf=" + conf.hashCode());
532: Mahadev Konar, info, MethodDeclaration, LOG.info("token=" + token1 + " should be renewed for 2 secs");
548: Mahadev Konar, info, MethodDeclaration, LOG.info("Counter = " + Renewer.counter + ";t=" + Renewer.lastRenewed);
598: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("dfs=" + (Object) dfs.hashCode() + ";conf=" + lconf.hashCode());
678: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("dfs=" + (Object) dfs.hashCode() + ";conf=" + lconf.hashCode());
187: Zhijie Shen, info, MethodDeclaration, LOG.info("posted node nodelabel");
200: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("posted node nodelabel");
213: Tsuyoshi Ozawa, info, MethodDeclaration, LOG.info("posted node nodelabel");
270: Zhijie Shen, info, MethodDeclaration, LOG.info("posted node nodelabel");
322: Zhijie Shen, info, MethodDeclaration, LOG.info("posted node nodelabel");
345: Zhijie Shen, info, MethodDeclaration, LOG.info("posted node nodelabel");
466: Wangda Tan, info, MethodDeclaration, LOG.info("posted node nodelabel");
507: Wangda Tan, info, MethodDeclaration, LOG.info("posted node nodelabel");
181: Subru Krishnan, Error, CatchClause, LOG.error("Error starting Router", t);
58: Subru Krishnan, error, IfStmt, LOG.error(errMsg);
55: Subru Krishnan, error, IfStmt, LOG.error(errMsg, t);
122: Subru Krishnan, info, CatchClause, LOG.info(message);
158: Subru Krishnan, error, CatchClause, LOG.error(e.getMessage());
242: Subru Krishnan, debug, ForStmt, LOG.debug("getNewApplication try #" + i + " on SubCluster " + subClusterId);
250: Subru Krishnan, warn, CatchClause, LOG.warn("Unable to create a new ApplicationId in SubCluster " + subClusterId.getId(), e);
269: Subru Krishnan, error, MethodDeclaration, LOG.error(errMsg);
362: Subru Krishnan, info, ForStmt, LOG.info("submitApplication appId" + applicationId + " try #" + i + " on SubCluster " + subClusterId);
391: Subru Krishnan, info, IfStmt, LOG.info("Application " + applicationId + " already submitted on SubCluster " + subClusterId);
407: Subru Krishnan, warn, CatchClause, LOG.warn("Unable to submit the application " + applicationId + "to SubCluster " + subClusterId.getId(), e);
412: Subru Krishnan, info, IfStmt, LOG.info("Application " + request.getApplicationSubmissionContext().getApplicationName() + " with appId " + applicationId + " submitted on " + subClusterId);
429: Subru Krishnan, error, MethodDeclaration, LOG.error(errMsg);
482: Subru Krishnan, error, CatchClause, LOG.error("Unable to kill the application report for " + request.getApplicationId() + "to SubCluster " + subClusterId.getId(), e);
477: Subru Krishnan, info, TryStmt, LOG.info("forceKillApplication " + applicationId + " on SubCluster " + subClusterId);
489: Subru Krishnan, error, IfStmt, LOG.error("No response when attempting to kill the application " + applicationId + " to SubCluster " + subClusterId.getId());
547: Subru Krishnan, error, CatchClause, LOG.error("Unable to get the application report for " + request.getApplicationId() + "to SubCluster " + subClusterId.getId(), e);
554: Subru Krishnan, error, IfStmt, LOG.error("No response when attempting to retrieve the report of " + "the application " + request.getApplicationId() + " to SubCluster " + subClusterId.getId());
141: Subru Krishnan, info, MethodDeclaration, LOG.info("Starting Router ClientRMService");
169: Subru Krishnan, info, MethodDeclaration, LOG.info("Router ClientRMService listening on address: " + this.server.getListenerAddress());
176: Subru Krishnan, info, MethodDeclaration, LOG.info("Stopping Router ClientRMService");
510: Subru Krishnan, info, IfStmt, LOG.info("Request to start an already existing user: {}" + " was received, so ignoring.", user);
106: Subru Krishnan, info, CatchClause, LOG.info(message);
104: Subru Krishnan, info, MethodDeclaration, LOG.info("Starting Router RMAdmin Service");
132: Subru Krishnan, info, MethodDeclaration, LOG.info("Router RMAdminService listening on address: " + this.server.getListenerAddress());
139: Subru Krishnan, info, MethodDeclaration, LOG.info("Stopping Router RMAdminService");
246: Subru Krishnan, info, IfStmt, LOG.info("Request to start an already existing user: {}" + " was received, so ignoring.", user);
112: Carlo Curino, info, CatchClause, LOG.info("Cannot add application {}: {}", app.getAppId(), e.getMessage());
152: Carlo Curino, error, CatchClause, LOG.error("Cannot render ResourceManager", e);
172: Carlo Curino, error, CatchClause, LOG.error("Cannot parse SubCluster info", e);
189: Inigo Goiri, error, IfStmt, LOG.error("The interceptor for SubCluster {} does not exist in the cache.", subClusterId);
286: Inigo Goiri, debug, ForStmt, LOG.debug("getNewApplication try #{} on SubCluster {}", i, subClusterId);
295: Inigo Goiri, warn, CatchClause, LOG.warn("Unable to create a new ApplicationId in SubCluster {}", subClusterId.getId(), e);
314: Carlo Curino, error, MethodDeclaration, LOG.error(errMsg);
432: Inigo Goiri, info, ForStmt, LOG.info("submitApplication appId {} try #{} on SubCluster {}", applicationId, i, subClusterId);
473: Inigo Goiri, info, IfStmt, LOG.info("Application {} already submitted on SubCluster {}", applicationId, subClusterId);
502: Inigo Goiri, warn, CatchClause, LOG.warn("Unable to submit the application {} to SubCluster {}", applicationId, subClusterId.getId(), e);
508: Inigo Goiri, info, IfStmt, LOG.info("Application {} with appId {} submitted on {}", context.getApplicationName(), applicationId, subClusterId);
525: Carlo Curino, error, MethodDeclaration, LOG.error(errMsg);
703: Inigo Goiri, error, IfStmt, LOG.error("Subcluster {} failed to return appReport.", info.getSubClusterId());
726: Inigo Goiri, warn, CatchClause, LOG.warn("Failed to get application report", e);
825: Inigo Goiri, error, CatchClause, LOG.error("Subcluster {} failed to return nodeInfo.", info.getSubClusterId());
850: Subru Krishnan, warn, CatchClause, LOG.warn("Failed to get node report ", e);
887: Inigo Goiri, error, CatchClause, LOG.error("Cannot get nodes: {}", e.getMessage());
906: Inigo Goiri, error, CatchClause, LOG.error("Subcluster {} failed to return nodesInfo.", info.getSubClusterId());
925: Subru Krishnan, warn, CatchClause, LOG.warn("Failed to get nodes report ", e);
945: Subru Krishnan, error, CatchClause, LOG.error(e.getLocalizedMessage());
964: Inigo Goiri, error, CatchClause, LOG.error("Subcluster {} failed to return Cluster Metrics.", info.getSubClusterId());
983: Subru Krishnan, warn, CatchClause, LOG.warn("Failed to get nodes report ", e);
174: Inigo Goiri, error, CatchClause, LOG.error("Cannot get user: {}", e.getMessage());
249: Carlo Curino, info, IfStmt, LOG.info("Request to start an already existing user: {}" + " was received, so ignoring.", user);
109: Carlo Curino, error, IfStmt, LOG.error("Unable to obtain user name, user not authenticated");
143: Inigo Goiri, error, CatchClause, LOG.error("Cannot create empty entity for {}", returnType, e);
44: Arun Suresh, info, MethodDeclaration, LOG.info("Test: aggregate metrics are initialized correctly");
56: Arun Suresh, info, MethodDeclaration, LOG.info("Test: aggregate metrics are updated correctly");
241: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: failed getNewApplication call");
246: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: failed submitApplication call");
251: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: failed forceKillApplication call");
256: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: failed getApplicationReport call");
261: Carlo Curino, info, MethodDeclaration, LOG.info("Mocked: failed getApplicationsReport call");
269: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: successful getNewApplication call with duration {}", duration);
275: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: successful submitApplication call with duration {}", duration);
281: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: successful forceKillApplication call with duration {}", duration);
287: Arun Suresh, info, MethodDeclaration, LOG.info("Mocked: successful getApplicationReport call with duration {}", duration);
293: Carlo Curino, info, MethodDeclaration, LOG.info("Mocked: successful getApplicationsReport call with duration {}", duration);
90: Subru Krishnan, error, CatchClause, LOG.error(e.getMessage());
121: Subru Krishnan, error, CatchClause, LOG.error(e.getMessage());
97: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Get New Application");
102: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Submit Application");
108: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Kill Application");
114: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Get Cluster Metrics");
120: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Get Cluster Nodes");
125: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Get Queue Info");
130: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Get Queue User");
135: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Get Cluster Node");
141: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Move Application Across Queues");
147: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Get New Reservation");
152: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Submit Reservation");
158: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Update Reservation");
164: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterClientRMServiceE2E - Delete Reservation");
98: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Refresh Queues");
103: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Refresh Nodes");
108: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Refresh Super User");
114: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Refresh User to Group");
120: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Refresh Admin Acls");
125: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Refresh Service Acls");
131: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Update Node Resource");
137: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Refresh Nodes Resource");
143: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Add To Cluster NodeLabels");
149: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Remove To Cluster NodeLabels");
155: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Replace Labels On Node");
161: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Check For Decommissioning Nodes");
167: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Refresh Cluster Max Priority");
173: Subru Krishnan, info, MethodDeclaration, LOG.info("testRouterRMAdminServiceE2E - Get Groups For User");
92: Carlo Curino, info, MethodDeclaration, LOG.info("Application submitted: " + appId);
150: Carlo Curino, info, MethodDeclaration, LOG.info("Force killing application: " + appId);
90: Carlo Curino, error, CatchClause, LOG.error(e.getMessage());
126: Carlo Curino, error, CatchClause, LOG.error(e.getMessage());
550: Haibo Chen, info, MethodDeclaration, LOG.info("Using seed: " + seed);
105: Karthik Kambatla, info, MethodDeclaration, LOG.info("Scheduled the shared cache cleaner task to run every " + periodInMinutes + " minutes.");
111: Karthik Kambatla, info, MethodDeclaration, LOG.info("Shutting down the background thread.");
120: Karthik Kambatla, warn, CatchClause, LOG.warn("The cleaner service was interrupted while shutting down the task.", e);
117: Karthik Kambatla, warn, IfStmt, LOG.warn("Gave up waiting for the cleaner task to shutdown.");
115: Karthik Kambatla, info, IfStmt, LOG.info("The background thread stopped.");
171: Karthik Kambatla, info, MethodDeclaration, LOG.info("Created the global cleaner pid file at " + pidPath.toString());
188: Karthik Kambatla, error, CatchClause, LOG.error("Unable to remove the global cleaner pid file! The file may need " + "to be removed manually.", e);
186: Karthik Kambatla, info, TryStmt, LOG.info("Removed the global cleaner pid file at " + pidPath.toString());
87: Karthik Kambatla, error, CatchClause, LOG.error("Unable to obtain the filesystem for the cleaner service", e);
112: Karthik Kambatla, warn, IfStmt, LOG.warn("A cleaner task is already running. " + "This scheduled cleaner task will do nothing.");
127: Karthik Kambatla, error, CatchClause, LOG.error("Unexpected exception while initializing the cleaner task. " + "This task will do nothing,", e);
119: Karthik Kambatla, error, IfStmt, LOG.error("The shared cache root " + location + " was not found. " + "The cleaner task will do nothing.");
180: Karthik Kambatla, error, CatchClause, LOG.error("Unable to complete the cleaner task", e1);
151: Karthik Kambatla, info, TryStmt, LOG.info("Processing " + numResources + " resources in the shared cache");
158: Karthik Kambatla, warn, IfStmt, LOG.warn("The cleaner task was interrupted. Aborting.");
165: Karthik Kambatla, warn, IfStmt, LOG.warn("Invalid file at path " + resource.getPath().toString() + " when a directory was expected");
177: Karthik Kambatla, info, TryStmt, LOG.info("Processed " + numResources + " resource(s) in " + durationMs + " ms.");
222: Karthik Kambatla, error, CatchClause, LOG.error("Exception thrown while removing dead appIds.", e);
251: Karthik Kambatla, error, CatchClause, LOG.error("Failed to remove path from the file system. Skipping this resource: " + path, e);
241: Karthik Kambatla, error, IfStmt, LOG.error("Failed to remove path from the file system." + " Skipping this resource: " + path);
205: Karthik Kambatla, info, IfStmt, LOG.info("Found a renamed directory that was left undeleted at " + path.toString() + ". Deleting.");
212: Karthik Kambatla, Error, CatchClause, LOG.error("Error while processing a shared cache resource: " + path, e);
273: Karthik Kambatla, error, SwitchStmt, LOG.error("Cleaner encountered an invalid status (" + resourceStatus + ") while processing resource: " + path.getName());
139: Karthik Kambatla, Error, CatchClause, LOG.info("Error getting UGI ", ie);
172: Karthik Kambatla, Error, CatchClause, LOG.info("Error getting UGI ", ie);
116: Karthik Kambatla, warn, CatchClause, LOG.warn("Couldn't get current user", ioe);
121: Karthik Kambatla, warn, IfStmt, LOG.warn("User " + user.getShortUserName() + " doesn't have permission" + " to call '" + method + "'");
128: Karthik Kambatla, info, MethodDeclaration, LOG.info("SCM Admin: " + method + " invoked by user " + user.getShortUserName());
160: Akira Ajisaka, Error, CatchClause, LOG.error("Error starting SharedCacheManager", t);
47: Karthik Kambatla, debug, ConstructorDeclaration, LOG.debug("Initialized " + registry);
47: Karthik Kambatla, debug, ConstructorDeclaration, LOG.debug("Initialized " + registry);
132: Karthik Kambatla, info, MethodDeclaration, LOG.info("Getting the active app list to initialize the in-memory scm store");
136: Karthik Kambatla, info, MethodDeclaration, LOG.info(initialApps.size() + " apps recorded as active at this time");
141: Karthik Kambatla, info, MethodDeclaration, LOG.info("Scheduled the in-memory scm store app check task to run every " + checkPeriodMin + " minutes.");
147: Karthik Kambatla, info, MethodDeclaration, LOG.info("Stopping the " + InMemorySCMStore.class.getSimpleName() + " service.");
150: Karthik Kambatla, info, IfStmt, LOG.info("Shutting down the background thread.");
157: Karthik Kambatla, warn, CatchClause, LOG.warn("The InMemorySCMStore was interrupted while shutting down the " + "app check task.", e);
154: Karthik Kambatla, warn, IfStmt, LOG.warn("Gave up waiting for the app check task to shutdown.");
161: Karthik Kambatla, info, IfStmt, LOG.info("The background thread stopped.");
169: Karthik Kambatla, info, MethodDeclaration, LOG.info("Bootstrapping from " + initialCachedResources.size() + " cache resources located in the file system");
183: Karthik Kambatla, info, MethodDeclaration, LOG.info("Bootstrapping complete");
199: Karthik Kambatla, error, CatchClause, LOG.error(message);
210: Karthik Kambatla, info, MethodDeclaration, LOG.info("Querying for all individual cached resource files");
213: Karthik Kambatla, info, MethodDeclaration, LOG.info("Found " + numEntries + " files: processing for one resource per " + "key");
230: Karthik Kambatla, warn, IfStmt, LOG.warn("Key " + key + " is already mapped to file " + initialCachedEntries.get(key) + "; file " + fileName + " will not be added");
240: Karthik Kambatla, info, MethodDeclaration, LOG.info("A total of " + initialCachedEntries.size() + " files are now mapped");
518: Karthik Kambatla, error, CatchClause, LOG.error("Unexpected exception thrown during in-memory store app check task." + " Rescheduling task.", e);
491: Karthik Kambatla, info, TryStmt, LOG.info("Checking the initial app list for finished applications.");
497: Karthik Kambatla, info, IfStmt, LOG.info("Looking into " + initialApps.size() + " apps to see if they are still active");
508: Karthik Kambatla, warn, CatchClause, LOG.warn("Exception while checking the app status;" + " will leave the entry in the list", e);
514: Karthik Kambatla, info, SynchronizedStmt, LOG.info("There are now " + initialApps.size() + " entries in the list");
67: Karthik Kambatla, info, MethodDeclaration, LOG.info("Instantiated " + SCMWebApp.class.getName() + " at " + bindAddress);
175: Jian He, debug, MethodDeclaration, LOG.debug("Writing ContainerTokenIdentifierForTest to RPC layer: " + this);
181: Vinod Kumar Vavilapalli, warn, CatchClause, LOG.warn("COULD NOT CLEANUP", e);
376: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("MiniYARN ResourceManager address: " + conf.get(YarnConfiguration.RM_ADDRESS));
378: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("MiniYARN ResourceManager web address: " + WebAppUtils.getRMWebAppURLWithoutScheme(conf));
510: Xuan, info, MethodDeclaration, LOG.info("Starting resourcemanager " + index);
511: Alejandro Abdelnur, info, MethodDeclaration, LOG.info("MiniYARN ResourceManager address: " + conf.get(YarnConfiguration.RM_ADDRESS));
513: Xuan, info, MethodDeclaration, LOG.info("MiniYARN ResourceManager web address: " + WebAppUtils.getRMWebAppURLWithoutScheme(conf));
526: Jonathan Turner Eagles, warn, IfStmt, LOG.warn("Stopping RM while some app masters are still alive");
545: Suresh Srinivas, warn, CatchClause, LOG.warn("could not cleanup symlink: " + testWorkDir.getAbsolutePath());
597: Sanford Ryza, info, MethodDeclaration, LOG.info("Starting NM: " + index);
615: Mahadev Konar, info, ForStmt, LOG.info("Created " + dirType + "Dir in " + dirs[i].getAbsolutePath());
717: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Exception in heartbeat from node " + request.getNodeStatus().getNodeId(), e);
732: Vinod Kumar Vavilapalli, info, CatchClause, LOG.info("Exception in node registration from " + request.getNodeId().toString(), e);
791: Eric Payne, info, IfStmt, LOG.info("All Node Managers connected in MiniYARNCluster");
796: Eric Payne, info, MethodDeclaration, LOG.info("Node Managers did not connect within 5000ms");
834: Zhijie Shen, info, MethodDeclaration, LOG.info("MiniYARN ApplicationHistoryServer address: " + getConfig().get(YarnConfiguration.TIMELINE_SERVICE_ADDRESS));
836: Zhijie Shen, info, MethodDeclaration, LOG.info("MiniYARN ApplicationHistoryServer web address: " + getConfig().get(YarnConfiguration.TIMELINE_SERVICE_WEBAPP_ADDRESS));
891: Arun Suresh, info, IfStmt, LOG.info("CustomAMRMProxyService is disabled");
883: Arun Suresh, info, IfStmt, LOG.info("CustomAMRMProxyService is enabled. " + "All the AM->RM requests will be intercepted by the proxy");
923: Jian He, info, IfStmt, LOG.info("CustomAMRMProxyService is disabled");
915: Jian He, info, IfStmt, LOG.info("CustomAMRMProxyService is enabled. " + "All the AM->RM requests will be intercepted by the proxy");
71: Jian He, debug, MethodDeclaration, LOG.debug("Writing NMTokenIdentifierNewForTest to RPC layer: " + this);
159: Akira Ajisaka, info, ConstructorDeclaration, LOG.info("RUNNING TEST " + name);
425: Robert Kanter, error, CatchClause, LOG.error("TimeoutException", te);
419: Daniel Templeton, info, TryStmt, LOG.info("Waiting for " + containerId + " to get to state " + ContainerState.COMPLETE);
437: Akira Ajisaka, info, MethodDeclaration, LOG.info("Removing container from NMContext, containerID = " + containerId);
636: Vinod Kumar Vavilapalli, info, MethodDeclaration, LOG.info("Running test for malice user");
738: Jian He, info, MethodDeclaration, LOG.info("Running test for serializing/deserializing containerIds");
162: Mahadev Konar, info, MethodDeclaration, LOG.info("Starting up YARN cluster");
169: Mahadev Konar, info, MethodDeclaration, LOG.info("Configured nm-" + dirType + "-dirs=" + nm.getConfig().get(dirsProperty));
215: Mahadev Konar, error, CatchClause, LOG.error("Interrupted while waiting for NodeManager's disk health check.");
237: Mahadev Konar, info, MethodDeclaration, LOG.info("ExpectedDirs=" + expectedDirs);
238: Mahadev Konar, info, MethodDeclaration, LOG.info("SeenDirs=" + seenDirs);
256: Mahadev Konar, error, CatchClause, LOG.error("Interrupted while waiting for NM->RM heartbeat.");
277: Mahadev Konar, info, MethodDeclaration, LOG.info("Prepared " + dir + " to fail.");
122: Junping Du, debug, IfStmt, LOG.debug("Cache new enough, skip refreshing");
138: Junping Du, Error, CatchClause, LOG.warn("Error closing timeline store", e);
147: Junping Du, debug, MethodDeclaration, LOG.debug("Cache for group {} released. ", groupId);
160: Junping Du, info, MethodDeclaration, LOG.info("Cleaner set to delete logs older than {} seconds", logRetainSecs);
168: Junping Du, info, MethodDeclaration, LOG.info("Unknown apps will be treated as complete after {} seconds", unknownActiveSecs);
174: Junping Du, info, MethodDeclaration, LOG.info("Application cache size is {}", appCacheMaxSize);
183: Junping Du, debug, IfStmt, LOG.debug("Evicting {} due to space limitations", groupId);
185: Junping Du, debug, IfStmt, LOG.debug("Force release cache {}.", groupId);
233: Jian He, Error, CatchClause, LOG.warn("Error loading classloader", ioe);
237: Junping Du, debug, ForeachStmt, LOG.debug("Trying to load plugin class {}", name);
255: Junping Du, Error, CatchClause, LOG.warn("Error loading plugin " + name, e);
248: Jian He, debug, IfStmt, LOG.debug("Load plugin class with system classpath");
242: Jian He, debug, IfStmt, LOG.debug("Load plugin {} with classpath: {}", name, pluginClasspath);
259: Junping Du, info, ForeachStmt, LOG.info("Load plugin class {}", cacheIdPlugin.getClass().getName());
275: Junping Du, info, MethodDeclaration, LOG.info("Starting {}", getName());
316: Li Lu, info, MethodDeclaration, LOG.info("Scanning active directory {} every {} seconds", activeRootPath, scanIntervalSecs);
318: Junping Du, info, MethodDeclaration, LOG.info("Cleaning logs every {} seconds", cleanerIntervalSecs);
331: Junping Du, info, MethodDeclaration, LOG.info("Stopping {}", getName());
336: Junping Du, info, IfStmt, LOG.info("Waiting for executor to terminate");
341: Junping Du, warn, IfStmt, LOG.warn("Executor did not terminate");
339: Junping Du, info, IfStmt, LOG.info("Executor terminated");
372: Junping Du, debug, IfStmt, LOG.debug("scan logs for {} in {}", appId, stat.getPath());
415: Junping Du, debug, MethodDeclaration, LOG.debug("Looking for app logs mapped for app id {}", applicationId);
441: Junping Du, debug, IfStmt, LOG.debug("Create and try to add new appLogs to appIdLogMap for {}", applicationId);
486: Junping Du, error, CatchClause, LOG.error("Unable to remove " + dirpath, e);
480: Junping Du, info, TryStmt, LOG.info("Deleting {}", dirpath);
482: Junping Du, error, IfStmt, LOG.error("Unable to remove " + dirpath);
684: Junping Du, debug, IfStmt, LOG.debug("Try to parse summary log for log {} in {}", appId, appDirPath);
690: Junping Du, info, IfStmt, LOG.info("{} state is UNKNOWN and logs are stale, assuming COMPLETED", appId);
707: Junping Du, info, IfStmt, LOG.info("File {} no longer exists, remove it from log list", log.getPath(appDirPath));
720: Junping Du, debug, MethodDeclaration, LOG.debug("scanForLogs on {}", appDirPath);
725: Junping Du, debug, WhileStmt, LOG.debug("scanForLogs on {}", statAttempt.getPath().getName());
729: Junping Du, debug, IfStmt, LOG.debug("Scanner skips for unknown dir/file {}", statAttempt.getPath());
743: Junping Du, debug, WhileStmt, LOG.debug("scan for log file: {}", filename);
778: Junping Du, debug, MethodDeclaration, LOG.debug("Incoming log {} not present in my summaryLogs list, add it", filename);
804: Vinod Kumar Vavilapalli, debug, ForeachStmt, LOG.debug("Try refresh logs for {}", log.getFilename());
815: Vinod Kumar Vavilapalli, info, IfStmt, LOG.info("File {} no longer exists, removing it from log list", log.getPath(dirPath));
809: Vinod Kumar Vavilapalli, debug, IfStmt, LOG.debug("Refresh logs for cache id {}", groupId);
831: Junping Du, debug, IfStmt, LOG.debug("Application {} is done, trying to move to done dir {}", appId, doneAppPath);
837: Junping Du, info, IfStmt, LOG.info("Moved {} to {}", appDirPath, doneAppPath);
861: Junping Du, debug, MethodDeclaration, LOG.debug("Active scan starting");
870: Li Lu, Error, IfStmt, LOG.error("Error scanning active files", t);
868: Li Lu, info, IfStmt, LOG.info("File scanner interrupted");
864: Li Lu, debug, TryStmt, LOG.debug("Scanned {} active applications", scanned);
873: Junping Du, debug, MethodDeclaration, LOG.debug("Active scan complete");
899: Li Lu, Error, IfStmt, LOG.error("Error processing logs for " + appLogs.getAppId(), t);
897: Li Lu, info, IfStmt, LOG.info("Log parser interrupted");
887: Junping Du, debug, TryStmt, LOG.debug("Begin parsing summary logs. ");
893: Junping Du, debug, TryStmt, LOG.debug("End parsing summary logs. ");
908: Junping Du, debug, MethodDeclaration, LOG.debug("Cleaner starting");
917: Li Lu, Error, IfStmt, LOG.error("Error cleaning files", e);
915: Li Lu, info, IfStmt, LOG.info("Cleaner interrupted");
922: Junping Du, debug, MethodDeclaration, LOG.debug("Cleaner finished");
948: Junping Du, debug, IfStmt, LOG.debug("Adding {} as a store for the query", storeForId.getName());
954: Junping Du, debug, IfStmt, LOG.debug("Using summary store for {}", entityType);
966: Junping Du, debug, ForeachStmt, LOG.debug("Trying plugin {} for id {} and type {}", cacheIdPlugin.getClass().getName(), entityId, entityType);
973: Junping Du, debug, IfStmt, LOG.debug("Plugin returned ids: " + idsFromPlugin);
971: Junping Du, debug, IfStmt, LOG.debug("Plugin returned null " + cacheIdPlugin.getClass().getName());
978: Junping Du, debug, IfStmt, LOG.debug("plugin {} returns a non-null value on query", cacheIdPlugin.getClass().getName());
994: Junping Du, debug, IfStmt, LOG.debug("plugin {} returns a non-null value on query {}", cacheIdPlugin.getClass().getName(), idsFromPlugin);
1010: Junping Du, debug, IfStmt, LOG.debug("Set up new cache item for id {}", groupId);
1018: Junping Du, warn, IfStmt, LOG.warn("AppLogs for groupId {} is set to null!", groupId);
1014: Junping Du, debug, IfStmt, LOG.debug("Set applogs {} for group id {}", appLogs, groupId);
1029: Junping Du, warn, IfStmt, LOG.warn("AppLogs for group id {} is null", groupId);
1025: Junping Du, debug, IfStmt, LOG.debug("try refresh cache {} {}", groupId, appLogs.getAppId());
1039: Junping Du, debug, MethodDeclaration, LOG.debug("getEntities type={} primary={}", entityType, primaryFilter);
1045: Junping Du, debug, ForeachStmt, LOG.debug("Try timeline store {} for the request", store.getName());
1059: Junping Du, debug, MethodDeclaration, LOG.debug("getEntity type={} id={}", entityType, entityId);
1064: Junping Du, debug, ForeachStmt, LOG.debug("Try timeline store {}:{} for the request", store.getName(), store.toString());
1072: Junping Du, debug, MethodDeclaration, LOG.debug("getEntity: Found nothing");
1080: Junping Du, debug, MethodDeclaration, LOG.debug("getEntityTimelines type={} ids={}", entityType, entityIds);
1084: Junping Du, debug, ForeachStmt, LOG.debug("getEntityTimeline type={} id={}", entityType, entityId);
1088: Junping Du, debug, ForeachStmt, LOG.debug("Try timeline store {}:{} for the request", store.getName(), store.toString());
107: Xuan, info, MethodDeclaration, LOG.info("Using leveldb path " + dbPath);
163: Xuan, error, CatchClause, LOG.error("GenericObjectMapper cannot read key from key " + entityId.toString() + " into an object. Read aborted! ");
166: Xuan, error, CatchClause, LOG.error(e.getMessage());
185: Xuan, error, CatchClause, LOG.error("GenericObjectMapper cannot write " + entity.getClass().getName() + " into a byte array. Write aborted! ");
188: Xuan, error, CatchClause, LOG.error(e.getMessage());
272: Xuan, error, CatchClause, LOG.error("GenericObjectMapper cannot read key from key " + nextRaw.getKey() + " into an object. Read aborted! ");
275: Xuan, error, CatchClause, LOG.error(e.getMessage());
284: Xuan, error, MethodDeclaration, LOG.error("LevelDB map adapter does not support iterate-and-remove" + " use cases. ");
105: Junping Du, debug, MethodDeclaration, LOG.debug("Parsing for log dir {} on attempt {}", appDirPath, attemptDirName);
129: Junping Du, warn, IfStmt, LOG.warn("{} no longer exists. Skip for scanning. ", logPath);
113: Junping Du, debug, TryStmt, LOG.debug("Parsing {} at offset {}", logPath, offset);
116: Junping Du, info, TryStmt, LOG.info("Parsed {} entities from {} in {} msec", count, logPath, Time.monotonicNow() - startTime);
152: Junping Du, debug, IfStmt, LOG.debug("Exception in parse path: {}", e.getMessage());
196: Junping Du, trace, WhileStmt, LOG.trace("Read entity {}", etype);
199: Junping Du, trace, WhileStmt, LOG.trace("Parser now at offset {}", bytesParsed);
202: Junping Du, debug, TryStmt, LOG.debug("Adding {}({}) to store", eid, etype);
208: Junping Du, Error, ForeachStmt, LOG.warn("Error putting entity: {} ({}): {}", e.getEntityId(), e.getEntityType(), e.getErrorCode());
260: Junping Du, trace, WhileStmt, LOG.trace("Read domain {}", domain.getId());
263: Junping Du, trace, WhileStmt, LOG.trace("Parser now at offset {}", bytesParsed);
99: Rohith Sharma K S, info, IfStmt, LOG.info("App-level aggregator shutdown timed out, shutdown now. ");
115: bibinchundatt, debug, MethodDeclaration, LOG.debug("App-level real-time aggregating");
117: Rohith Sharma K S, warn, IfStmt, LOG.warn("App-level collector is not ready, skip aggregation. ");
136: Rohith Sharma K S, Error, CatchClause, LOG.error("Error aggregating timeline metrics", e);
126: Rohith Sharma K S, debug, IfStmt, LOG.debug("App-level collector is empty, skip aggregation. ");
138: bibinchundatt, debug, MethodDeclaration, LOG.debug("App-level real-time aggregation complete");
183: Rohith Sharma K S, info, IfStmt, LOG.info("Delegation token not available for renewal for app " + appCollector.getTimelineEntityContext().getAppId());
228: Jian He, info, MethodDeclaration, LOG.info("Generated a new token " + timelineToken + " for app " + appId);
251: Sangjin Lee, error, CatchClause, LOG.error("Failed to communicate with NM Collector Service for " + appId);
262: Rohith Sharma K S, warn, CatchClause, LOG.warn("Failed to cancel token for app collector with appId " + appId, e);
314: Sangjin Lee, error, CatchClause, LOG.error(msg, e);
320: Sangjin Lee, info, MethodDeclaration, LOG.info("Instantiated the per-node collector webapp at " + timelineRestServerBindAddress);
330: Sangjin Lee, info, MethodDeclaration, LOG.info("Report a new collector for application: " + appId + " to the NM Collector Service.");
340: Sangjin Lee, info, MethodDeclaration, LOG.info("Get timeline collector context for " + appId);
346: Varun Saxena, debug, IfStmt, LOG.debug("Setting the user in the context: " + userId);
353: Varun Saxena, debug, IfStmt, LOG.debug("Setting the flow name: " + flowName);
360: Varun Saxena, debug, IfStmt, LOG.debug("Setting the flow version: " + flowVersion);
367: Varun Saxena, debug, IfStmt, LOG.debug("Setting the flow run id: " + flowRunId);
384: Junping Du, info, IfStmt, LOG.info("nmCollectorServiceAddress: " + nmCollectorServiceAddress);
418: Jian He, info, IfStmt, LOG.info("Renewed token for " + appId + " with new expiration " + "timestamp = " + newExpirationTime);
442: Jian He, warn, CatchClause, LOG.warn("Unable to report regenerated token to NM for " + appId);
450: Jian He, info, IfStmt, LOG.info("Cannot find active collector while " + (timerForRenewal ? "renewing" : "regenerating") + " token for " + appId);
466: Jian He, warn, CatchClause, LOG.warn("Unable to " + (timerForRenewal ? "renew" : "regenerate") + " token for " + appId, e);
110: Sangjin Lee, warn, IfStmt, LOG.warn("Scheduler terminated before removing the application collectors");
195: Haibo Chen, info, IfStmt, LOG.info("Stop container for " + containerId + " is called before initializing container.");
249: Akira Ajisaka, Error, CatchClause, LOG.error("Error starting PerNodeTimelineCollectorServer", t);
140: Junping Du, debug, IfStmt, LOG.debug("putEntities(entities=" + entities + ", callerUgi=" + callerUgi + ")");
192: Junping Du, debug, IfStmt, LOG.debug("putEntitiesAsync(entities=" + entities + ", callerUgi=" + callerUgi + ")");
78: Sangjin Lee, info, MethodDeclaration, LOG.info("Using TimelineWriter: " + timelineWriterClassName);
149: Sangjin Lee, info, IfStmt, LOG.info("the collector for " + appId + " already exists!");
142: Sangjin Lee, info, TryStmt, LOG.info("the collector for " + appId + " was added");
192: Sangjin Lee, info, IfStmt, LOG.info("The collector service for " + appId + " was removed");
185: Sangjin Lee, error, IfStmt, LOG.error("the collector for " + appId + " does not exist!");
153: Zhijie Shen, error, IfStmt, LOG.error(msg);
182: Zhijie Shen, Error, CatchClause, LOG.error("Error putting entities", e);
167: Zhijie Shen, error, IfStmt, LOG.error("Application: " + appId + " is not found");
196: Junping Du, error, CatchClause, LOG.error("Invalid application ID: " + appId);
103: Sangjin Lee, info, MethodDeclaration, LOG.info("Using store: " + timelineReaderClassName);
187: Jian He, info, MethodDeclaration, LOG.info("Instantiating TimelineReaderWebApp at " + bindAddress);
204: Sangjin Lee, error, CatchClause, LOG.error(msg, e);
229: Akira Ajisaka, Error, CatchClause, LOG.error("Error starting TimelineReaderWebServer", t);
173: Vrushali Channapattan, info, MethodDeclaration, LOG.info("Processed URL " + url + " but encountered exception (Took " + (endTime - startTime) + " ms.)");
188: Vrushali Channapattan, Error, IfStmt, LOG.error("Error while processing REST request", e);
316: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
346: Li Lu, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
595: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
621: Vrushali Channapattan, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
687: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
708: Li Lu, info, IfStmt, LOG.info("Processed URL " + url + " but entity not found" + " (Took " + (endTime - startTime) + " ms.)");
713: Li Lu, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
878: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
897: Vrushali Channapattan, info, IfStmt, LOG.info("Processed URL " + url + " but entity not found" + " (Took " + (endTime - startTime) + " ms.)");
902: Vrushali Channapattan, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
943: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
964: Li Lu, info, IfStmt, LOG.info("Processed URL " + url + " but flowrun not found (Took " + (endTime - startTime) + " ms.)");
968: Li Lu, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
1055: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
1073: Vrushali Channapattan, info, IfStmt, LOG.info("Processed URL " + url + " but flowrun not found (Took " + (endTime - startTime) + " ms.)");
1080: Vrushali Channapattan, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
1143: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
1170: Li Lu, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
1296: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
1320: Li Lu, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
1429: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
1454: Vrushali Channapattan, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
1520: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
1542: Li Lu, info, IfStmt, LOG.info("Processed URL " + url + " but app not found" + " (Took " + (endTime - startTime) + " ms.)");
1546: Li Lu, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
1693: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
1712: Sangjin Lee, info, IfStmt, LOG.info("Processed URL " + url + " but app not found" + " (Took " + (endTime - startTime) + " ms.)");
1716: Sangjin Lee, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
1825: Li Lu, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
1854: Li Lu, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
3229: Sangjin Lee, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
3244: Sangjin Lee, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
3310: Varun Saxena, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
3336: Varun Saxena, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
3380: Varun Saxena, info, MethodDeclaration, LOG.info("Received URL " + url + " from user " + TimelineReaderWebServicesUtils.getUserName(callerUGI));
3402: Varun Saxena, info, MethodDeclaration, LOG.info("Processed URL " + url + " (Took " + (endTime - startTime) + " ms.)");
108: Jason Lowe, info, IfStmt, LOG.info("listAllowedUsers=" + listAllowedUsers);
110: Jason Lowe, info, IfStmt, LOG.info("allowedUsersAclList=" + allowedUsersAclList.getUsers());
117: Jason Lowe, info, IfStmt, LOG.info("adminAclList not set, hence setting it to \"\"");
120: Jason Lowe, info, IfStmt, LOG.info("adminAclList=" + adminAclList.getUsers());
123: Jian He, info, MethodDeclaration, LOG.info("Token " + ident + " expired.");
392: Sangjin Lee, info, CatchClause, LOG.info("Cannot find entity {id:" + context.getEntityId() + " , type:" + context.getEntityType() + "}. Will send HTTP 404 in response.");
252: Sangjin Lee, info, SwitchStmt, LOG.info("Unexpected filter type " + filter.getFilterType());
307: Sangjin Lee, info, SwitchStmt, LOG.info("Unexpected filter type " + filter.getFilterType());
65: Sangjin Lee, info, IfStmt, LOG.info("closing the hbase Connection");
146: Jian He, info, MethodDeclaration, LOG.info("Initialized HBaseTimelineWriterImpl UGI to " + ugi);
170: Sangjin Lee, warn, IfStmt, LOG.warn("Found null for one of: flowName=" + flowName + " appId=" + appId + " userId=" + userId + " clusterId=" + clusterId + " . Not proceeding with writing to hbase");
439: Varun Saxena, info, SwitchStmt, LOG.info("Invalid table name provided.");
512: Zhijie Shen, warn, IfStmt, LOG.warn("timestamp is not set for event " + eventId + "! Using the current timestamp");
580: Junping Du, info, IfStmt, LOG.info("closing the entity table");
585: Junping Du, info, IfStmt, LOG.info("closing the app_flow table");
590: Junping Du, info, IfStmt, LOG.info("closing the application table");
594: Sangjin Lee, info, IfStmt, LOG.info("closing the flow run table");
599: Sangjin Lee, info, IfStmt, LOG.info("closing the flowActivityTable table");
607: Sangjin Lee, info, IfStmt, LOG.info("closing the hbase Connection");
79: Varun Saxena, info, MethodDeclaration, LOG.info("Starting the schema creation");
229: Sangjin Lee, ERROR, CatchClause, LOG.error("ERROR: " + e.getMessage() + "\n");
281: Haibo Chen, Error, CatchClause, LOG.error("Error in creating hbase tables: ", e);
275: vrushali, info, IfStmt, LOG.info("Will skip existing tables and continue on htable creation " + "exceptions!");
279: vrushali, info, TryStmt, LOG.info("Successfully created HBase schema. ");
292: vrushali, info, IfStmt, LOG.info("Schema creation finished successfully");
286: vrushali, warn, IfStmt, LOG.warn("Schema creation finished with the following exceptions");
288: vrushali, warn, ForeachStmt, LOG.warn(e.getMessage());
311: Sangjin Lee, warn, IfStmt, LOG.warn("Skip and continue on: " + e.getMessage());
320: Sangjin Lee, warn, IfStmt, LOG.warn("Skip and continue on: " + e.getMessage());
329: Sangjin Lee, warn, IfStmt, LOG.warn("Skip and continue on: " + e.getMessage());
338: Sangjin Lee, warn, IfStmt, LOG.warn("Skip and continue on: " + e.getMessage());
347: Sangjin Lee, warn, IfStmt, LOG.warn("Skip and continue on: " + e.getMessage());
356: Rohith Sharma K S, warn, IfStmt, LOG.warn("Skip and continue on: " + e.getMessage());
365: Haibo Chen, warn, IfStmt, LOG.warn("Skip and continue on: " + e.getMessage());
124: Junping Du, info, MethodDeclaration, LOG.info("Status of table creation for " + table.getNameAsString() + "=" + admin.tableExists(table));
89: Sangjin Lee, info, MethodDeclaration, LOG.info("Status of table creation for " + table.getNameAsString() + "=" + admin.tableExists(table));
320: Sangjin Lee, error, CatchClause, LOG.error("Illegal column found, skipping this column.", iae);
300: Varun Saxena, debug, IfStmt, LOG.debug("null prefix was specified; returning all columns");
305: Sangjin Lee, error, CatchClause, LOG.error("Illegal column found, skipping this column.", iae);
395: Sangjin Lee, error, CatchClause, LOG.error("Illegal column found, skipping this column.", iae);
380: Sangjin Lee, error, CatchClause, LOG.error("Illegal column found, skipping this column.", iae);
65: Rohith Sharma K S, info, IfStmt, LOG.info("Using hbase configuration at " + timelineServiceHBaseConfFileURL);
89: Haibo Chen, info, MethodDeclaration, LOG.info("Status of table creation for " + table.getNameAsString() + "=" + admin.tableExists(table));
123: Sangjin Lee, info, MethodDeclaration, LOG.info("Status of table creation for " + table.getNameAsString() + "=" + admin.tableExists(table));
88: Sangjin Lee, info, MethodDeclaration, LOG.info("Status of table creation for " + table.getNameAsString() + "=" + admin.tableExists(table));
93: Rohith Sharma K S, info, MethodDeclaration, LOG.info("CoprocessorJarPath=" + coprocessorJarPath.toString());
99: Sangjin Lee, info, MethodDeclaration, LOG.info("Status of table creation for " + table.getNameAsString() + "=" + admin.tableExists(table));
89: bibinchundatt, debug, MethodDeclaration, LOG.debug("FilterList created for scan is - {}", typeFilterList);
101: Sangjin Lee, warn, IfStmt, LOG.warn("Failed to add type " + entity.getType() + " to the result set because there is a duplicated copy. ");
106: Sangjin Lee, debug, IfStmt, LOG.debug("Current row key: " + Arrays.toString(currRowKey));
107: Sangjin Lee, debug, IfStmt, LOG.debug("New entity type discovered: " + currType);
112: bibinchundatt, debug, MethodDeclaration, LOG.debug("Scanned {} records for {} types", counter, types.size());
249: Sangjin Lee, debug, IfStmt, LOG.debug("FilterList created for get is - " + filterList);
254: Sangjin Lee, info, IfStmt, LOG.info("Cannot find matching entity of type " + getContext().getEntityType());
279: Sangjin Lee, debug, IfStmt, LOG.debug("FilterList created for scan is - " + filterList);
124: Rohith Sharma K S, info, MethodDeclaration, LOG.info("Status of table creation for " + table.getNameAsString() + "=" + admin.tableExists(table));
229: Sangjin Lee, debug, IfStmt, LOG.debug("preFlush store = " + store.getColumnFamilyName() + " flushableSize=" + store.getFlushableSize() + " flushedCellsCount=" + store.getFlushedCellsCount() + " compactedCellsCount=" + store.getCompactedCellsCount() + " majorCompactedCellsCount=" + store.getMajorCompactedCellsCount() + " memstoreFlushSize=" + store.getMemstoreFlushSize() + " memstoreSize=" + store.getMemStoreSize() + " size=" + store.getSize() + " storeFilesCount=" + store.getStorefilesCount());
249: Sangjin Lee, debug, IfStmt, LOG.debug("postFlush store = " + store.getColumnFamilyName() + " flushableSize=" + store.getFlushableSize() + " flushedCellsCount=" + store.getFlushedCellsCount() + " compactedCellsCount=" + store.getCompactedCellsCount() + " majorCompactedCellsCount=" + store.getMajorCompactedCellsCount() + " memstoreFlushSize=" + store.getMemstoreFlushSize() + " memstoreSize=" + store.getMemStoreSize() + " size=" + store.getSize() + " storeFilesCount=" + store.getStorefilesCount());
272: Sangjin Lee, info, IfStmt, LOG.info("Compactionrequest= " + request.toString() + " " + requestOp.toString() + " RegionName=" + e.getEnvironment().getRegion().getRegionInfo().getRegionNameAsString());
111: Sangjin Lee, debug, IfStmt, LOG.debug(" batch size=" + batchSize);
242: Sangjin Lee, debug, IfStmt, LOG.debug("emitted no cells for " + this.action);
238: Sangjin Lee, debug, IfStmt, LOG.debug("emitted cells. " + addedCnt + " for " + this.action + " rowKey=" + FlowRunRowKey.parseRowKey(CellUtil.cloneRow(cells.get(0))));
305: Sangjin Lee, trace, IfStmt, LOG.trace("In collect cells " + " FlowSannerOperation=" + this.action + " currentAggOp=" + currentAggOp + " cell qualifier=" + Bytes.toString(CellUtil.cloneQualifier(cell)) + " cell value= " + converter.decodeValue(CellUtil.cloneValue(cell)) + " timestamp=" + cell.getTimestamp());
354: Sangjin Lee, trace, IfStmt, LOG.trace("In emitCells " + this.action + " currentColumnCells size= " + currentColumnCells.size() + " currentAggOp" + currentAggOp);
447: Sangjin Lee, debug, IfStmt, LOG.debug("In processSummationMajorCompaction," + " will drop cells older than " + currentTimestamp + " CurrentColumnCells size=" + currentColumnCells.size());
475: Sangjin Lee, trace, IfStmt, LOG.trace("MAJOR COMPACTION loop sum= " + sum + " discarding now: " + " qualifier=" + Bytes.toString(CellUtil.cloneQualifier(cell)) + " value=" + converter.decodeValue(CellUtil.cloneValue(cell)) + " timestamp=" + cell.getTimestamp() + " " + this.action);
462: Sangjin Lee, trace, IfStmt, LOG.trace("reading flow app id sum=" + sum);
523: Sangjin Lee, info, IfStmt, LOG.info("After major compaction for qualifier=" + qualifier + " with currentColumnCells.size=" + currentColumnCells.size() + " returning finalCells.size=" + finalCells.size() + " with zero sum=" + sum.longValue());
510: Sangjin Lee, trace, IfStmt, LOG.trace("MAJOR COMPACTION final sum= " + sum + " for " + Bytes.toString(CellUtil.cloneQualifier(sumCell)) + " " + this.action);
514: Sangjin Lee, info, IfStmt, LOG.info("After major compaction for qualifier=" + Bytes.toString(CellUtil.cloneQualifier(sumCell)) + " with currentColumnCells.size=" + currentColumnCells.size() + " returning finalCells.size=" + finalCells.size() + " with sum=" + sum.longValue() + " with cell timestamp " + sumCell.getTimestamp());
577: Sangjin Lee, error, CatchClause, LOG.error("caught iae during conversion to long ", iae);
587: Sangjin Lee, warn, IfStmt, LOG.warn("scanner close called but scanner is null");
237: Sangjin Lee, debug, IfStmt, LOG.debug("preFlush store = " + store.getColumnFamilyName() + " flushableSize=" + store.getFlushableSize() + " flushedCellsCount=" + store.getFlushedCellsCount() + " compactedCellsCount=" + store.getCompactedCellsCount() + " majorCompactedCellsCount=" + store.getMajorCompactedCellsCount() + " memstoreSize=" + store.getMemStoreSize() + " size=" + store.getSize() + " storeFilesCount=" + store.getStorefilesCount());
256: Sangjin Lee, debug, IfStmt, LOG.debug("postFlush store = " + store.getColumnFamilyName() + " flushableSize=" + store.getFlushableSize() + " flushedCellsCount=" + store.getFlushedCellsCount() + " compactedCellsCount=" + store.getCompactedCellsCount() + " majorCompactedCellsCount=" + store.getMajorCompactedCellsCount() + " memstoreSize=" + store.getMemStoreSize() + " size=" + store.getSize() + " storeFilesCount=" + store.getStorefilesCount());
279: Sangjin Lee, info, IfStmt, LOG.info("Compactionrequest= " + request.toString() + " " + requestOp.toString() + " RegionName=" + e.getEnvironment().getRegion().getRegionInfo().getRegionNameAsString());
111: Sangjin Lee, debug, IfStmt, LOG.debug(" batch size=" + batchSize);
242: Sangjin Lee, debug, IfStmt, LOG.debug("emitted no cells for " + this.action);
238: Sangjin Lee, debug, IfStmt, LOG.debug("emitted cells. " + addedCnt + " for " + this.action + " rowKey=" + FlowRunRowKey.parseRowKey(CellUtil.cloneRow(cells.get(0))));
305: Sangjin Lee, trace, IfStmt, LOG.trace("In collect cells " + " FlowSannerOperation=" + this.action + " currentAggOp=" + currentAggOp + " cell qualifier=" + Bytes.toString(CellUtil.cloneQualifier(cell)) + " cell value= " + converter.decodeValue(CellUtil.cloneValue(cell)) + " timestamp=" + cell.getTimestamp());
354: Sangjin Lee, trace, IfStmt, LOG.trace("In emitCells " + this.action + " currentColumnCells size= " + currentColumnCells.size() + " currentAggOp" + currentAggOp);
447: Sangjin Lee, debug, IfStmt, LOG.debug("In processSummationMajorCompaction," + " will drop cells older than " + currentTimestamp + " CurrentColumnCells size=" + currentColumnCells.size());
475: Sangjin Lee, trace, IfStmt, LOG.trace("MAJOR COMPACTION loop sum= " + sum + " discarding now: " + " qualifier=" + Bytes.toString(CellUtil.cloneQualifier(cell)) + " value=" + converter.decodeValue(CellUtil.cloneValue(cell)) + " timestamp=" + cell.getTimestamp() + " " + this.action);
462: Sangjin Lee, trace, IfStmt, LOG.trace("reading flow app id sum=" + sum);
523: Sangjin Lee, info, IfStmt, LOG.info("After major compaction for qualifier=" + qualifier + " with currentColumnCells.size=" + currentColumnCells.size() + " returning finalCells.size=" + finalCells.size() + " with zero sum=" + sum.longValue());
510: Sangjin Lee, trace, IfStmt, LOG.trace("MAJOR COMPACTION final sum= " + sum + " for " + Bytes.toString(CellUtil.cloneQualifier(sumCell)) + " " + this.action);
514: Sangjin Lee, info, IfStmt, LOG.info("After major compaction for qualifier=" + Bytes.toString(CellUtil.cloneQualifier(sumCell)) + " with currentColumnCells.size=" + currentColumnCells.size() + " returning finalCells.size=" + finalCells.size() + " with sum=" + sum.longValue() + " with cell timestamp " + sumCell.getTimestamp());
577: Sangjin Lee, error, CatchClause, LOG.error("caught iae during conversion to long ", iae);
587: Sangjin Lee, warn, IfStmt, LOG.warn("scanner close called but scanner is null");
77: Xuan, debug, IfStmt, LOG.debug("Redirecting {} {} to {}", request.getMethod(), request.getRequestURI(), target);
65: Robert Kanter, warn, IfStmt, LOG.warn("Unrecognized attribute value for " + CommonConfigurationKeys.HADOOP_SECURITY_AUTHENTICATION + " of " + auth);
79: Arun Murthy, info, MethodDeclaration, LOG.info("Instantiating Proxy at " + bindAddress);
113: Xuan, error, CatchClause, LOG.error("Could not start proxy web server", e);
125: Xuan, Error, CatchClause, LOG.error("Error stopping proxy web server", e);
205: Xuan, debug, IfStmt, LOG.debug("local InetAddress for proxy host: {}", localAddress);
238: Xuan, debug, IfStmt, LOG.debug("REQ HEADER: {} : {}", name, value);
343: Xuan, warn, IfStmt, LOG.warn("{} gave an invalid proxy path {}", remoteUser, pathInfo);
354: Xuan, warn, IfStmt, LOG.warn("{} attempting to access {} that is invalid", remoteUser, appId);
398: Xuan, warn, IfStmt, LOG.warn("{} attempting to access {} that was not found", remoteUser, id);
426: Xuan, info, IfStmt, LOG.info("Asking {} if they want to connect to the " + "app master GUI of {} owned by {}", remoteUser, appId, runningUser);
439: Xuan, info, TryStmt, LOG.info("{} is accessing unchecked {}" + " which is the app master GUI of {} owned by {}", remoteUser, toFetch, appId, runningUser);
594: Karthik Kambatla, error, IfStmt, LOG.error("The AM's web app redirected the RM web proxy's request back " + "to the web proxy. The typical cause is that the AM is resolving " + "the RM's address as something other than what it expects. Check " + "your network configuration and the value of the " + "yarn.web-proxy.address property. Once the host resolution issue " + "has been resolved, you will likely need to delete the " + "misbehaving application, " + id);
602: Karthik Kambatla, error, IfStmt, LOG.error("REDIRECT: sending redirect to " + redirect);
93: Xuan, warn, CatchClause, LOG.warn("{} does not appear to be a valid URL", proxyUriBase, e);
118: Xuan, warn, CatchClause, LOG.warn("Could not locate {} - skipping", proxyHost, e);
112: Xuan, debug, IfStmt, LOG.debug("proxy address is: {}", add.getHostAddress());
143: Xuan, debug, IfStmt, LOG.debug("Remote address for request is: {}", httpReq.getRemoteAddr());
180: Karthik Kambatla, debug, IfStmt, LOG.debug("Could not find " + WebAppProxyServlet.PROXY_USER_COOKIE_NAME + " cookie, so user will not be set");
227: Yufei Gu, debug, CatchClause, LOG.debug("Failed to connect to " + url + ": " + e.toString());
99: Jason Darrell Lowe, info, MethodDeclaration, LOG.info("Running embedded servlet container at: http://localhost:" + originalPort);
245: Jason Lowe, info, TryStmt, LOG.info("" + proxyConn.getURL());
246: Jason Lowe, info, TryStmt, LOG.info("ProxyConn.getHeaderField(): " + proxyConn.getHeaderField(ProxyUtils.LOCATION));
477: Xuan, info, MethodDeclaration, LOG.info("Proxy server is started at port {}", proxyServer.getConnectorAddress(0).getPort());
